<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Bass.Net</name>
    </assembly>
    <members>
        <member name="T:Un4seen.Bass.AddOn.Spx.BassSpx">
            <summary>
            BASS.NET API wrapper for BASS_SPX.DLL
            <para>Requires: bass_spx.dll - Speex Audio Codec (SPX) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_SPX is an extension to the BASS audio library, enabling the playback of Speex files.</para>
            <para>Speex is an open source and patent-free audio compression format designed for speech. The Speex Project aims to lower the barrier of entry for voice applications by providing a free alternative to expensive proprietary speech codecs. 
            Moreover, Speex is well-adapted to Internet applications and provides useful features that are not present in most other codecs.</para>
            <para>The Speex format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/URL/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> /URL/User functions.</para>
            <para>More information can be found on <a href="http://www.speex.org">www.speex.org</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Speex Audio file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Speex Audio memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a Speex Audio file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from a Speex Audio file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
             <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="proc">Callback function to receive the file as it is downloaded... NULL = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Spx.BassSpx.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_spx.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Spx.BassSpx.SupportedStreamName">
            <summary>
            Supported file format name of the bass_spx.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Spx.BassSpx.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Spx.BassSpx.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Ofr.BassOfr">
            <summary>
            BASS.NET API wrapper for BASS_OFR.DLL
            <para>Requires: bass_ofr.dll and OptimFROG.dll - OptimFROG and OptimFROG DualStream Audio Codec (OFR) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_OFR is an extension to the BASS audio library, enabling the playback of OptimFROG and OptimFROG DualStream files.</para>
            <para>OptimFROG is a lossless audio compression program. Its main goal is to reduce the size of audio files, while permitting bit identical restoration of all input.
            OptimFROG DualStream is aimed at filling the big gap between perceptual coding and lossless coding. The goal is to offer real transparent audio coding at half or less the bitrate generally used by lossless coding,
            and also to permit progressive consistent increase of the quality level, until lossless coding is reached.</para>
            <para>The OptimFROG format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Ofr.BassOfr.BASS_OFR_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> /User functions.</para>
            <para>More information can be found on <a href="http://www.losslessaudio.org">www.losslessaudio.org</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ofr.BassOfr.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ofr.BassOfr.BASS_OFR_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ofr.BassOfr.BASS_OFR_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a OptimFROG or OptimFROG DualStream file.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ofr.BassOfr.BASS_OFR_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ofr.BassOfr.BASS_OFR_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a OptimFROG or OptimFROG DualStream memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ofr.BassOfr.BASS_OFR_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a OptimFROG or OptimFROG DualStream file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Ofr.BassOfr.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_ofr.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Ofr.BassOfr.SupportedStreamName">
            <summary>
            Supported file format name of the bass_ofr.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ofr.BassOfr.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ofr.BassOfr.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ofr.BassOfr.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Ofr.BassOfr.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Ofr.BassOfr.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BassVideo">
            <summary>
            BASS.NET API wrapper for BASSVIDEO.DLL
            <para>Requires: BassVideo.dll - Video Playback Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BassVideo is an extension to the BASS audio library, enabling the playback of video files. It uses DirectShow to render the video and BASS to output the audio.</para>
            <para>It requires DirectX (at best v9 or above) and supports WMV, MPEG, AVI videos and VMR9, VMR9 windowless, Overlay, EVR and default rendering (Aspect Ratio Support : 4:3 , 16:9, Source, Free, Custom).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BassVideo.BASSVIDEOVERSION">
            <summary>
            Current BassVideo version (without minor revision).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode">
            <summary>
            Retrieves the error code for the most recent BASS_Video function call in the current thread.
            </summary>
            <returns>If no error occured during the last BASS_Video function call then 0 is returned. 
            See the function description for an explanation of what the error code means.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFileUnicode(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="file"></param>
            <param name="flags"></param>
            <param name="bassFlags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)">
            <summary>
            Creates a video stream from a MPG, MPEG, WMV, AVI or DirectShow supported file.
            </summary>
            <param name="file">Filename for which a video stream should be created.</param>
            <param name="flags">One of the following (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOFlag"/>):
            <list type="table">
            <item><term>BASSVIDEO_AUTO_PAINT</term><description>Auto paint.</description></item>
            <item><term>BASSVIDEO_AUTO_RESIZE</term><description>Auto resize.</description></item>
            <item><term>BASSVIDEO_AUTO_MOVE</term><description>Auto move.</description></item>
            </list>
            </param>
            <param name="bassFlags">Any combination of these flags <see cref="T:Un4seen.Bass.BASSFlag"/>:
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a> (will have no effect if the video stream is more than stereo).</description></item>
            <item><term>BASS_UNICODE</term><description>file is a Unicode (16-bit characters) filename (automatically set with this overload).</description></item>
            </list>
            </param>
            <param name="proc">The user defined video action state function (see <see cref="T:Un4seen.Bass.AddOn.Video.VIDEOPROC"/>) - or NULL.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new video stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            If you don't specify a video callback you must have created and specified a default video window (see <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetVideoWindow(System.Int32,System.IntPtr,System.Drawing.Rectangle@,System.Int32)"/>). 
            However, the DirectShow video filter need to know it's parent when it connects and before playing (e.g. in case you want to create a dynamic video windows you need to specify a callback).
            <para>DirectShow supports the following formats by default: WMA, WMV, ASF, MPEG, AVI, QuickTime (version 2 and lower), WAV, AIFF, AU, SND. You might install more video codecs to support additional formats.</para>
            </remarks>
            <example>
            <code>
            int chan1 = BassVideo.BASS_Video_StreamCreateFile("test1.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, null, IntPtr.Zero);
            int chan2 = BassVideo.BASS_Video_AddFile(chan1, "test2.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, null, IntPtr.Zero);
            BassVideo.BASS_Video_Play(chan2, false);
            </code>
            <code lang="vbnet">
            Dim chan1 As Integer = BassVideo.BASS_Video_StreamCreateFile("test1.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, Nothing, IntPtr.Zero)
            Dim chan2 As Integer = BassVideo.BASS_Video_AddFile(chan1, "test2.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, Nothing, IntPtr.Zero)
            BassVideo.BASS_Video_Play(chan2, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFileUser(Un4seen.Bass.BASS_FILEPROCS,Un4seen.Bass.AddOn.Video.BASSVIDEOType,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from a MPG, MPEG, WMV, AVI, MP3, WMA, WAV or DirectShow supported file.
            </summary>
            <param name="procs">The user defined file function (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="mediatype">One of the following (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOType"/>):
            <list type="table">
            <item><term>BASSVIDEO_MEDIA_AVI</term><description>The source is an AVI format..</description></item>
            <item><term>BASSVIDEO_MEDIA_UNKNOWN</term><description>The source is unknown (other then AVI).</description></item>
            </list>
            </param>
            <param name="flags">One of the following (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOFlag"/>):
            <list type="table">
            <item><term>BASSVIDEO_AUTO_PAINT</term><description>Auto paint.</description></item>
            <item><term>BASSVIDEO_AUTO_RESIZE</term><description>Auto resize.</description></item>
            <item><term>BASSVIDEO_AUTO_MOVE</term><description>Auto move.</description></item>
            </list>
            </param>
            <param name="bassFlags">Any combination of these flags <see cref="T:Un4seen.Bass.BASSFlag"/>:
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a> (will have no effect if the video stream is more than stereo).</description></item>
            <item><term>BASS_UNICODE</term><description>file is a Unicode (16-bit characters) filename (automatically set with this overload).</description></item>
            </list>
            </param>
            <param name="proc">The user defined video action state function (see <see cref="T:Un4seen.Bass.AddOn.Video.VIDEOPROC"/>) - or NULL.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new video stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            If you don't specify a video callback you must have created and specified a default video window (see <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetVideoWindow(System.Int32,System.IntPtr,System.Drawing.Rectangle@,System.Int32)"/>). 
            However, the DirectShow video filter need to know it's parent when it connects and before playing (e.g. in case you want to create a dynamic video windows you need to specify a callback).
            <para>DirectShow supports the following formats by default: WMA, WMV, ASF, MPEG, AVI, QuickTime (version 2 and lower), WAV, AIFF, AU, SND. You might install more video codecs to support additional formats.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BassVideo_StreamCreateFileMemory(System.IntPtr,System.Int64,Un4seen.Bass.AddOn.Video.BASSVIDEOType,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from a MPG, MPEG, WMV, AVI, MP3, WMA, WAV or DirectShow supported file.
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="length">Data length (needs to be set to the length of the memory stream in bytes which should be played).</param>
            <param name="mediatype">One of the following (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOType"/>):
            <list type="table">
            <item><term>BASSVIDEO_MEDIA_AVI</term><description>The source is an AVI format..</description></item>
            <item><term>BASSVIDEO_MEDIA_UNKNOWN</term><description>The source is unknown (other then AVI).</description></item>
            </list>
            </param>
            <param name="flags">One of the following (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOFlag"/>):
            <list type="table">
            <item><term>BASSVIDEO_AUTO_PAINT</term><description>Auto paint.</description></item>
            <item><term>BASSVIDEO_AUTO_RESIZE</term><description>Auto resize.</description></item>
            <item><term>BASSVIDEO_AUTO_MOVE</term><description>Auto move.</description></item>
            </list>
            </param>
            <param name="bassFlags">Any combination of these flags <see cref="T:Un4seen.Bass.BASSFlag"/>:
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a> (will have no effect if the video stream is more than stereo).</description></item>
            <item><term>BASS_UNICODE</term><description>file is a Unicode (16-bit characters) filename (automatically set with this overload).</description></item>
            </list>
            </param>
            <param name="proc">The user defined video action state function (see <see cref="T:Un4seen.Bass.AddOn.Video.VIDEOPROC"/>) - or NULL.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new video stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            If you don't specify a video callback you must have created and specified a default video window (see <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetVideoWindow(System.Int32,System.IntPtr,System.Drawing.Rectangle@,System.Int32)"/>). 
            However, the DirectShow video filter need to know it's parent when it connects and before playing (e.g. in case you want to create a dynamic video windows you need to specify a callback).
            <para>DirectShow supports the following formats by default: WMA, WMV, ASF, MPEG, AVI, QuickTime (version 2 and lower), WAV, AIFF, AU, SND. You might install more video codecs to support additional formats.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetConfig(Un4seen.Bass.AddOn.Video.BASSVIDEOConfig,System.Int32)">
            <summary>
            Sets the value of a video config option.
            </summary>
            <param name="option">The option to set the value of... one of the following (<see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOConfig"/>):
            <list type="table">
            <item><term>BassVideo_Config_Renderer</term><description>Configure the video renderer.</description></item>
            </list>
            </param>
            <param name="newvalue">The new option value (one of <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOOption"/>). See the option's documentation for details on the possible values.</param>
            <remarks>
            <para>On Microsoft Windows XP, the default video renderer is the Video Mixing Renderer (VMR). The VMR and the Video Renderer both have the friendly name 'Video Renderer'.
            On all other platforms, the Video Renderer is the default renderer, although applications can use the VMR-9 for advanced rendering capabilities.</para>
            <para>Video Mixing Render 9 is available in DirectX 9 or above. The enhanced Video Render is available in Windows Vista. On other operating system you might use this render by installing the latest .Net framework package.</para>
            <para>Windowed Mode: in all windowed modes the video renderer creates it's own video window and paints the video itself. 
            In BassVideo you will need to set your video window and thus the video will be a child of your window.
            Windowed Modes are: Default, VMR9, Overlay and EVR.</para>
            <para>WindowLess Mode: It is no longer necessary to make the video playback window a child of the application's window in order to contain video playback. 
            The VMR's new windowless rendering mode allows applications to easily host video playback within any window without having to forward window messages to the renderer for renderer-specific processing. 
            WindowLess Modes are: VMR9_WindowLess.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetConfig(Un4seen.Bass.AddOn.Video.BASSVIDEOConfig)">
            <summary>
            Gets the value of a video config option.
            </summary>
            <param name="option">The option to get the value of... one of the following (<see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOConfig"/>).</param>
            <returns>If successful, the value of the requested config option is returned (BASSVIDEOOption), else -1 is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_Play(System.Int32,System.Boolean)">
            <summary>
            Play a video stream(s).
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="restart">Restart playback from the beginning?</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            In BassVideo the <paramref name="restart"/> parameter is ignored, so it it here to be compatible with the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> function. 
            When calling this method, BassVideo will check if the handle is created by BassVideo, if not, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> will be invoked for any audio channel.
            The same applies to <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_Stop(System.Int32)"/>, <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_Pause(System.Int32)"/>, <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetPosition(System.Int32,System.Int64)"/>, <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetPosition(System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetLength(System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_Stop(System.Int32)">
            <summary>
            Stops a video stream.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_Pause(System.Int32)">
            <summary>
            Pauses a video stream.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetPosition(System.Int32,System.Int64)">
            <summary>
            Set the playback position of a video stream.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="pos">The new position in bytes to set the video playback to.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetPosition(System.Int32)">
            <summary>
            Gets the current playback position in bytes of a video stream.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>If successful, the playback position is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetLength(System.Int32)">
            <summary>
            Gets the total length in bytes of a video stream.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>If successful, the length in bytes is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamFree(System.Int32)">
            <summary>
            Frees a video stream.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_Init">
            <summary>
            Initializes BASS_Video.
            </summary>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Call this method before any other BASS_Video methods.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_Free">
            <summary>
            Frees all resources used by BASS_Video.
            </summary>
            <remarks>This function should be called before your program exits.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetCurrentBuffering(System.Int32)">
            <summary>
            Gets the current buffering rate (use with streaming URL).
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>If successful, the current buffering rate is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetEventNotify(System.Int32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sets the window handle to received DirectShow event messages.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="hwnd">The window handle which should receive DirectShow event messages (use IntPtr.Zero to stop receiving event messages).</param>
            <param name="msg">The message Id to be passed as the notification (e.g. use any WM_USER + N value).</param>
            <param name="data">Value to be passed as a lParam parameter for the <paramref name="msg"/> message.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This method designates a window that will process event notifications. 
            Whenever the filter graph manager puts an event in the event queue, it will also post a message to the designated window. 
            The <paramref name="hwnd"/> parameter specifies the window, and the <paramref name="msg"/> parameter specifies the message is. 
            The application should define a private window message for this purpose. The message's lParam parameter is set to the value of <paramref name="data"/>, and the wParam parameter is set to zero.
            <para>When the window receives the message, it should call the <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetEvent(System.Int32,Un4seen.Bass.AddOn.Video.BASSVIDEOEvent@,System.Int32@,System.Int32@,System.Int32)"/> method to retrieve the event. 
            Events are asynchronous, so the queue might contain several events (or none).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetEvent(System.Int32,Un4seen.Bass.AddOn.Video.BASSVIDEOEvent@,System.Int32@,System.Int32@,System.Int32)">
            <summary>
            Gets a DirectShow event.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="eventCode">Returns the event code received (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent"/>).</param>
            <param name="param1">Returns the first event parameter value.</param>
            <param name="param2">Returns the second event parameter value.</param>
            <param name="timeout">Specifies a timeout in milliseconds when receiving DirectShow events (use -1 to block until there is an event).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            If no event is currently queued, this method waits up to <paramref name="timeout"/> milliseconds for an event to arrive. 
            Avoid using a time-out interval of infinite (-1), because threads cannot process any messages while waiting in this method. 
            If you call this method from the same thread that processes windows messages (i.e. the UI thread), specify only small timeout values, in order to remain responsive to user input.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetVideoWindow(System.Int32,System.IntPtr,System.Drawing.Rectangle@,System.Int32)">
            <summary>
            Set the video window for the channels or set the default video window.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/> - or 0 to set a default video window.</param>
            <param name="videoWindowHandle">The handle of the window where to display the video.</param>
            <param name="videoRect">The size (rectangle) of the window to display the video.</param>
            <param name="videoNum">The zero based index of the video stream number (see <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_AddVideo(System.Int32,System.IntPtr,System.Drawing.Rectangle@,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag)"/> for details, in case the channel doesn't have multi video output enabled set this value to 0).</param>
            <remarks>
            Note : VMR9_WindowLess requires to set a default video window before creating any video streams.
            <para>If the <paramref name="handle"/> is not a BassVideo handle, BassVideo will use that as the default VideoWindow Handle,
            else, it sets the video window for the given video channel handle.</para>
            <para>This method should be called inside a <see cref="T:Un4seen.Bass.AddOn.Video.VIDEOPROC"/> callback when the event <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOAction">BassVideo_FoundVideo</see> occures.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_Repaint(System.Int32,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Manually repaints the video window.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="windowHandle">The handle of the window you want to repaint.</param>
            <param name="hDC">The device context handle to use.</param>
            <param name="videoNum">The zero based index of the video stream number (see <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_AddVideo(System.Int32,System.IntPtr,System.Drawing.Rectangle@,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag)"/> for details).</param>
            <remarks>
            This method might need to be called when using VMR9_WindowLess or EVR renderer and if you want to implement you own painting overload of a user control.
            </remarks>
            <example>
            <code>
            protected override void OnPaint(PaintEventArgs e)
            {
              base.OnPaint(e);
              // Perform custom drawing
              BassVideo.BASS_Video_Repaint(video, this, e.Graphics, 0);
            }
            </code>
            <code lang="vbnet">
            Protected Overrides Sub OnPaint(e As PaintEventArgs)
              MyBase.OnPaint(e)
              ' Perform custom drawing
              BassVideo.BASS_Video_Repaint(video, Me, e.Graphics, 0)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_WindowResize(System.Int32,System.Drawing.Rectangle@,System.Int32)">
            <summary>
            Notify BassVideo when a video window was resized.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="videoRect">The new size (rectangle) of the window to display the video.</param>
            <param name="videoNum">The zero based index of the video stream number (see <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_AddVideo(System.Int32,System.IntPtr,System.Drawing.Rectangle@,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag)"/> for details).</param>
            <remarks>Call this, e.g. when the video window size was changed.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_WindowMove(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Call this when the video window position was changed.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="msg">WM_MOVE (0x0003).</param>
            <param name="wParam">This parameter is not used.</param>
            <param name="lParam">Specifies the x and y coordinates of the upper-left corner of the client area of the window. The low-order word contains the x-coordinate while the high-order word contains the y coordinate.</param>
            <param name="videoNum">The zero based index of the video stream number (see <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_AddVideo(System.Int32,System.IntPtr,System.Drawing.Rectangle@,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag)"/> for details).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetRatio(System.Int32,Un4seen.Bass.AddOn.Video.BASSVIDEORatio,System.Double,System.Int32)">
            <summary>
            Sets the video acpect ratio.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="ratio">The ratio to set (one of <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEORatio"/>).</param>
            <param name="custom">When RCustom is used as a <paramref name="ratio"/> this value defines your custom aspect ratio.</param>
            <param name="videoNum">The zero based index of the video stream number (see <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_AddVideo(System.Int32,System.IntPtr,System.Drawing.Rectangle@,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag)"/> for details, in case the channel doesn't have multi video output enabled set this value to 0).</param>
            <returns>If successful, 0 is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetChannel(System.Int32,System.Int32)">
            <summary>
            Sets a video channel to be used with <see cref="N:Un4seen.Bass.AddOn.Mix">BASSmix</see>.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="mixer">The mixer channel.</param>
            <returns>The old video handle but changed to a decoding channel (use this with <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>).</returns>
            <remarks>If you want to use a video channel with BASSmix, you'll need a decoding channel. 
            This function is used to change a video stream to a decoding channel. You must add the return value via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> to a mixer afterwards manually.</remarks>
            <example>
            <code>
            int chan1 = BassVideo.BASS_Video_StreamCreateFile("test1.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, null, IntPtr.Zero);
            int mixer = BassMix.BASS_Mixer_StreamCreate(96000, 2, BASSFlag.BASS_DEFAULT);
            int chan2 = BassVideo.BASS_Video_SetChannel(chan1, mixer);
            BassMix.BASS_Mixer_StreamAddChannel(mixer, chan2, BASSFlag.BASS_MIXER_DOWNMIX);
            ...
            BassVideo.BASS_Video_Play(mixer, false);
            </code>
            <code lang="vbnet">
            Dim chan1 As Integer = BassVideo.BASS_Video_StreamCreateFile("test1.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, Nothing, IntPtr.Zero)
            Dim mixer As Integer = BassMix.BASS_Mixer_StreamCreate(96000, 2, BASSFlag.BASS_DEFAULT)
            Dim chan2 As Integer = BassVideo.BASS_Video_SetChannel(chan1, mixer)
            BassMix.BASS_Mixer_StreamAddChannel(mixer, chan2, BASSFlag.BASS_MIXER_DOWNMIX)
            ...
            BassVideo.BASS_Video_Play(mixer, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_AddFileUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="file"></param>
            <param name="flags"></param>
            <param name="bassFlags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_AddFile(System.Int32,System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)">
            <summary>
            Adds a file to an existing video stream (graph).
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="file">Filename for which a video stream should be added.</param>
            <param name="flags">One of the following (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOFlag"/>).</param>
            <param name="bassFlags">Any combination of these flags <see cref="T:Un4seen.Bass.BASSFlag"/>:
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a> (will have no effect if the video stream is more than stereo).</description></item>
            <item><term>BASS_UNICODE</term><description>file is a Unicode (16-bit characters) filename (automatically set with this overload).</description></item>
            </list>
            </param>
            <param name="proc">The user defined video action state function (see <see cref="T:Un4seen.Bass.AddOn.Video.VIDEOPROC"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new video stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>You can add an unlimited number of files to an existing video stream.
            Using this method allows you to play multiple video files with one <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_Play(System.Int32,System.Boolean)"/> command.</remarks>
            <example>
            <code>
            int chan1 = BassVideo.BASS_Video_StreamCreateFile("test1.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, null, IntPtr.Zero);
            int chan2 = BassVideo.BASS_Video_AddFile(chan1, "test2.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, null, IntPtr.Zero);
            BassVideo.BASS_Video_Play(chan2, false);
            </code>
            <code lang="vbnet">
            Dim chan1 As Integer = BassVideo.BASS_Video_StreamCreateFile("test1.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, Nothing, IntPtr.Zero)
            Dim chan2 As Integer = BassVideo.BASS_Video_AddFile(chan1, "test2.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, Nothing, IntPtr.Zero)
            BassVideo.BASS_Video_Play(chan2, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetVersion">
            <summary>
            Retrieves the version number of the BassVideo.DLL that is loaded.
            </summary>
            <returns>The BassVideo version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BassVideo supports all the BASSenc functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.AddOn.Video.BassVideo.BASSVIDEOVERSION"/> to check the major revision.</para>
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(BassVideo.BASS_Video_GetVersion()) != BassVideo.BASSVIDEOVERSION )
            {
              MessageBox.Show(this, "Wrong BassVideo Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(BassVideo.BASS_Video_GetVersion()) &lt;&gt; BassVideo.BASSVIDEOVERSION Then
              MessageBox.Show(Me, "Wrong BassVideo Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (BassVideo.BASS_Video_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong BassVideo Version!");
            }
            </code>
            <code lang="vbnet">
            If BassVideo.BASS_Video_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong BassVideo Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BassVideo.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BassVideo version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BassVideo supports all the BassVideo functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (BassVideo.BASS_Video_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong BassVideo Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If BassVideo.BASS_Video_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong BassVideo Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_AddVideo(System.Int32,System.IntPtr,System.Drawing.Rectangle@,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag)">
            <summary>
            Adds a new video window to a video stream.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="videoWindowHandle">The handle of the window to display the video.</param>
            <param name="videoRect">The size (rectangle) of the window to display the video.</param>
            <param name="flags">One of the following (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOFlag"/>):
            <list type="table">
            <item><term>BASSVIDEO_AUTO_PAINT</term><description>Auto paint.</description></item>
            <item><term>BASSVIDEO_AUTO_RESIZE</term><description>Auto resize.</description></item>
            <item><term>BASSVIDEO_AUTO_MOVE</term><description>Auto move.</description></item>
            </list>
            </param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <example>
            <code>
            int chan = BassVideo.BASS_Video_StreamCreateFile("test1.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, null, IntPtr.Zero);
            Rectangle rect = pictureBox1.ClientRectangle;
            BassVideo.BASS_Video_AddVideo(chan, pictureBox1.Handle, ref rect, BASSVIDEOFlag.BASSVIDEO_DEFAULT);
            </code>
            <code lang="vbnet">
            Dim chan As Integer = BassVideo.BASS_Video_StreamCreateFile("test1.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, Nothing, IntPtr.Zero)
            Dim rect As Rectangle = pictureBox1.ClientRectangle
            BassVideo.BASS_Video_AddVideo(chan, pictureBox1.Handle, rect, BASSVIDEOFlag.BASSVIDEO_DEFAULT)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_AddVideo(System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag)">
            <summary>
            Adds a new video window to a video stream.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="videoWindowHandle">The handle of the window to display the video.</param>
            <param name="left">The left position to display the video.</param>
            <param name="top">The top position to display the video.</param>
            <param name="right">The right positionto display the video.</param>
            <param name="bottom">The bottom positionto display the video.</param>
            <param name="flags">One of the following (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOFlag"/>):
            <list type="table">
            <item><term>BASSVIDEO_AUTO_PAINT</term><description>Auto paint.</description></item>
            <item><term>BASSVIDEO_AUTO_RESIZE</term><description>Auto resize.</description></item>
            <item><term>BASSVIDEO_AUTO_MOVE</term><description>Auto move.</description></item>
            </list>
            </param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works like the other overload but takes the position instead of the rectangle as a parameter.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetGraph(System.Int32)">
            <summary>
            Gets the pointer to the filter graph of a channel.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>If successful, the pointer to the graph is returned, else IntPtr.Zero is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_FrameStep(System.Int32)">
            <summary>
            Steps to the next video frame.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Not all video formats support stepping to the next frame. The video should be paused to step to the next frame.</remarks>
            <example>
            <code>
            int chan = BassVideo.BASS_Video_StreamCreateFile("test1.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, null, IntPtr.Zero);
            ...
            BassVideo.BASS_Video_Pause(chan);
            BassVideo.BASS_Video_FrameStep(chan);
            </code>
            <code lang="vbnet">
            Dim chan As Integer = BassVideo.BASS_Video_StreamCreateFile("test1.avi", BASSVIDEOFlag.BASSVIDEO_DEFAULT, BASSFlag.BASS_DEFAULT, Nothing, IntPtr.Zero)
            ...
            BassVideo.BASS_Video_Pause(chan)
            BassVideo.BASS_Video_FrameStep(chan)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_CaptureBitmapUnicode(System.String,System.Double,System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="sourceFile"></param>
            <param name="captureTime"></param>
            <param name="outputFile"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_CaptureBitmap(System.String,System.Double,System.String)">
            <summary>
            Captures a video frame to a bitmap file.
            </summary>
            <param name="sourceFile">The video input file name.</param>
            <param name="captureTime">The position to capture.</param>
            <param name="outputFile">The output file name of the bitmap.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetVideoInfo(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Gets the video height and width.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="height">Returns the video height.</param>
            <param name="width">Returns the video width.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_EnumFilter(System.Int32,Un4seen.Bass.AddOn.Video.FILTERPROC,System.IntPtr)">
            <summary>
            Enumerates all directshow filters in the filter graph.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="proc">The user defined directshow filter enum callback (see <see cref="T:Un4seen.Bass.AddOn.Video.FILTERPROC"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>TRUE on success - else FALSE. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <example>
            <code>
            private FILTERPROC _myFilterProc; // make it global, so that the GC can not remove it
            ...
            _myFilterProc = new FILTERPROC(MyFilter);
            BassVideo.BASS_Video_EnumFilter(chan, _myFilterProc, IntPtr.Zero);
            ...
            private bool MyFilter(int handle, IntPtr filterName, IntPtr filter, IntPtr user)
            {
              string name = Utils.IntPtrAsStringAnsi(filterName);
              bool hasProperty = BassVideo.BASS_Video_HasFilterPropertyPage(handle, filter, BASSVIDEOFilter.BassVideo_Filter);
              ...
            }
            </code>
            <code lang="vbnet">
            Private _myFilterProc As FILTERPROC ' make it global, so that the GC can not remove it
            ...
            _myFilterProc = New FILTERPROC(AddressOf MyFilter)
            BassVideo.BASS_Video_EnumFilter(chan, _myFilterProc, IntPtr.Zero)
            ...
            Private Function MyFilter(handle As Integer, filterName As IntPtr, filter As IntPtr, user As IntPtr) As Boolean
              Dim name As String = Utils.IntPtrAsStringAnsi(filterName)
              Dim hasProperty As Boolean = BassVideo.BASS_Video_HasFilterPropertyPage(handle, filter, BASSVIDEOFilter.BassVideo_Filter)
              ...
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_HasFilterPropertyPage(System.Int32,System.IntPtr,Un4seen.Bass.AddOn.Video.BASSVIDEOFilter)">
            <summary>
            Checks if the directshow filter has a property page.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="filter">Either a pointer to the filter name or to the filter itself.</param>
            <param name="flags">If the <paramref name="filter"/> represents a pointer to a filter name you need to specify <see cref="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFilter.BassVideo_FilterName"/>, else the pointer represents the filter itself, which need <see cref="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFilter.BassVideo_Filter"/>.</param>
            <returns>TRUE, if the directshow filter has a property dialog - else FALSE. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ShowFilterPropertyPage(System.Int32,System.IntPtr,System.IntPtr,Un4seen.Bass.AddOn.Video.BASSVIDEOFilter)">
            <summary>
            Shows a directshow filter property page.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="filter">Either a pointer to the filter name or to the filter itself.</param>
            <param name="parentWnd">The parent window handle to be used when showing the property dialog.</param>
            <param name="flags">If the <paramref name="filter"/> represents a pointer to a filter name you need to specify <see cref="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFilter.BassVideo_FilterName"/>, else the pointer represents the filter itself, which need <see cref="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFilter.BassVideo_Filter"/>.</param>
            <returns>TRUE, if the directshow filter property dialog was shown - else FALSE. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Please make sure to not enter any incorrect values in the filter property page.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SaveGraphFileUnicode(System.Int32,System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="fileName"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SaveGraphFile(System.Int32,System.String)">
            <summary>
            Saves the current filter graph to a graph file.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="fileName">The file name to save the graph to.</param>
            <returns>TRUE on success - else FALSE. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            You can use GraphEdit to view the graph and how it work, but you can't run it, because the filter is provided for viewing only - 
            So it can't work outsize BassVideo. Please register the filter before using it with GraphEdit: use 'regsvr32 bassvideo.ax' or run 'reg.bat'
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_CloseWindow(System.Int32,System.Int32)">
            <summary>
            Closes the video window.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="videoNum">The zero based index of the video stream number (see <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_AddVideo(System.Int32,System.IntPtr,System.Drawing.Rectangle@,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag)"/> for details).</param>
            <remarks>Use this method to make sure that the video windows is closed. You should use this method before any call to <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamFree(System.Int32)"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetVideoWindow(System.Int32,System.Int32)">
            <summary>
            Gets the video window handle (of the active movie window).
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="videoNum">The zero based index of the video stream number (see <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_AddVideo(System.Int32,System.IntPtr,System.Drawing.Rectangle@,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag)"/> for details).</param>
            <returns>The active movie window on success - else IntPtr.Zero will be returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetTempoValue(System.Int32,System.Int32)">
            <summary>
            Sets the playback tempo.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="tempo">The tempo value (from 50 to 8000, use 1000 for normal speed).</param>
            <returns>TRUE on success - else FALSE. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetTempoEnable(System.Int32,System.Boolean)">
            <summary>
            Enables/Disables tempo changes.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="enable">TRUE to enable tempo changes, FALSE to disable tempo changes.</param>
            <returns>TRUE on success - else FALSE. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetTempoValue(System.Int32)">
            <summary>
            Gets the current tempo value.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>The tempo value (from 50 to 8000, 1000 for normal speed).</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetTempoEnable(System.Int32)">
            <summary>
            Gets the current tempo status.
            </summary>
            <param name="handle">The video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>TRUE, if tempo changes are currently enabled and FALSE if disabled.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetColor(System.Int32,Un4seen.Bass.AddOn.Video.BASSVIDEOColor,System.Single,System.Int32,System.Int32)">
            <summary>
            Sets the color settings for a video.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="colorSetting">One of the following (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOColor"/>):
            <list type="table">
            <item><term>COLOR_Brightness</term><description>Controls the brightness of the video.</description></item>
            <item><term>COLOR_Contrast</term><description>Controls the contrast of the video.</description></item>
            <item><term>COLOR_Hue</term><description>Controls the hue of the video.</description></item>
            <item><term>COLOR_Saturation</term><description>Controls the saturation of the video.</description></item>
            </list>
            </param>
            <param name="colorValue">The color value to apply.</param>
            <param name="videoNum">The number of the video stream.</param>
            <param name="flags">reserved</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetColorRange(System.Int32,Un4seen.Bass.AddOn.Video.BASSVIDEOColor,System.Int32,System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>
            Gets the available color setting range.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="colorSetting">One of the following (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOColor"/>):
            <list type="table">
            <item><term>COLOR_Brightness</term><description>Controls the brightness of the video.</description></item>
            <item><term>COLOR_Contrast</term><description>Controls the contrast of the video.</description></item>
            <item><term>COLOR_Hue</term><description>Controls the hue of the video.</description></item>
            <item><term>COLOR_Saturation</term><description>Controls the saturation of the video.</description></item>
            </list>
            </param>
            <param name="videoNum">The number of the video stream.</param>
            <param name="flags">reserved</param>
            <param name="cMax">The maximum color value which can be applied.</param>
            <param name="cMin">The minimum color value which can be applied.</param>
            <param name="cDef">The default color value.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This method only works with VMR9 and is for testing only. With some hardware it will not work.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetPitchValue(System.Int32,System.Int32)">
            <summary>
            Sets the pitch (speed) of the video.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="pitch">The pitch value between 500 (slow) to 2000 (fast) - default is 1000 (normal).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>You need to enable pitching via <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetPitchEnable(System.Int32,System.Boolean)"/> to use this method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetPitchValue(System.Int32)">
            <summary>
            Gets the current pitch value.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>The current pitch value between 500 (slow) to 2000 (fast) - default is 1000 (normal).</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetPitchEnable(System.Int32,System.Boolean)">
            <summary>
            Disables or Enables the pitch effect.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="enable">TRUR to enable pitching - FALSE to disable it.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetPitchEnable(System.Int32)">
            <summary>
            Gets if the pitch effect is currently enabled.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>If pitching is enabled TRUE is returned, else FALSE is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetInfo(System.Int32,Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO)">
            <summary>
            Gets information about a video.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO"/> class to store the information at.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetInfo(System.Int32)">
            <summary>
            Gets information about a video.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>An instance of the <see cref="T:Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO"/> class on success - or NULL on error.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetFrameInfo(System.Int32,Un4seen.Bass.AddOn.Video.BASS_VIDEO_FRAMEINFO)">
            <summary>
            Gets the current frame information of a video.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.AddOn.Video.BASS_VIDEO_FRAMEINFO"/> class to store the information at.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetFrameInfo(System.Int32)">
            <summary>
            Gets the current frame information of a video.
            </summary>
            <param name="handle">The existing video stream handle as returned by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.</param>
            <returns>An instance of the <see cref="T:Un4seen.Bass.AddOn.Video.BASS_VIDEO_FRAMEINFO"/> class on success - or NULL on error.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_EncodeAudioUnicode(System.String,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,Un4seen.Bass.AddOn.Video.AUDIOENCODEPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="file"></param>
            <param name="bassFlags"></param>
            <param name="videoProc"></param>
            <param name="audioProc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_EncodeAudio(System.String,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,Un4seen.Bass.AddOn.Video.AUDIOENCODEPROC,System.IntPtr)">
            <summary>
            Extracts raw sample data from a video stream (via DirectShow).
            </summary>
            <param name="file">Filename of the video for which the audio data should be extracted.</param>
            <param name="bassFlags">Any combination of these flags <see cref="T:Un4seen.Bass.BASSFlag"/>:
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a> (will have no effect if the video stream is more than stereo).</description></item>
            <item><term>BASS_UNICODE</term><description>file is a Unicode (16-bit characters) filename (automatically set with this overload).</description></item>
            </list>
            </param>
            <param name="videoProc">The user defined video action state function (see <see cref="T:Un4seen.Bass.AddOn.Video.VIDEOPROC"/>) - or NULL.</param>
            <param name="audioProc">The user defined audio extraction function which will be called whenever new sample data is available (see <see cref="T:Un4seen.Bass.AddOn.Video.AUDIOENCODEPROC"/>) - or NULL.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new video stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            If you don't specify a video callback you must have created and specified a default video window (see <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetVideoWindow(System.Int32,System.IntPtr,System.Drawing.Rectangle@,System.Int32)"/>). 
            However, the DirectShow video filter need to know it's parent when it connects and before playing (e.g. in case you want to create a dynamic video windows you need to specify a callback).
            <para>DirectShow supports the following formats by default: WMA, WMV, ASF, MPEG, AVI, QuickTime (version 2 and lower), WAV, AIFF, AU, SND. You might install more video codecs to support additional formats.</para>
            <para>The audio callback receives the number of bytes placed in the audio buffer, use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve the audio sample data from the video stream.</para>
            </remarks>
            <example>
            <code>
            private AUDIOENCODEPROC _myAudioProc; // make it global, so that the GC can not remove it
            
            _myAudioProc = new AUDIOENCODEPROC(MyAudioCallback);
            int chan = BassVideo.BASS_Video_EncodeAudio("demo.asf", BASSFlag.BASS_DEFAULT, null, _myAudioProc, IntPtr.Zero);
            
            private bool MyAudioCallback(int handle, int length, IntPtr user)
            {
              if (length &gt; 0)
              {
                byte[] buffer = new byte[length];
                int len = Bass.BASS_ChannelGetData(handle, buffer, length);
                // do whatever you need to do with the sample data in the buffer
                ...
              }
            }
            </code>
            <code lang="vbnet">
            Private _myAudioProc As AUDIOENCODEPROC ' make it global, so that the GC can not remove it
            
            _myAudioProc = New AUDIOENCODEPROC(AddressOf MyAudioCallback)
            Dim chan As Integer = BassVideo.BASS_Video_EncodeAudio("demo.asf", BASSFlag.BASS_DEFAULT, Nothing, _myAudioProc, IntPtr.Zero)
            
            Private Sub MyAudioCallback(handle As Integer, length As Integer, user As IntPtr)
              If length &gt; 0 Then
                Dim buffer(length) As Byte
                Dim len As Integer = Bass.BASS_ChannelGetData(handle, buffer, length)
                ' do whatever you need to do with the sample data in the buffer
                ...
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BassVideo.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the BassVideo.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BassVideo.SupportedStreamName">
            <summary>
            Supported file format name of the BassVideo.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BassVideo.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASSVIDEOError">
            <summary>
            BASS error codes as returned e.g. by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_ErrorGetCode"/> (int)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOError.BASSVIDEO_ERROR_UNKNOW">
            <summary>
            Unknown Error.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOError.BASSVIDEO_ERROR_SUCCESS">
            <summary>
            All is OK.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOError.BASSVIDEO_ERROR_INVALID_HANDLE">
            <summary>
            An invalid handle was used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOError.BASSVIDEO_ERROR_INVALID_COLOR_MODE">
            <summary>
            An invalid color mode was used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOError.BASSVIDEO_ERROR_NULL_CALLBACK">
            <summary>
            No callback delegate was specified.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOError.BASSVIDEO_ERROR_DOESNT_HAVE_PROPERTY_PAGE">
            <summary>
            The directshow filter has no property page.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOError.BASSVIDEO_ERROR_NULL_FILTER">
            <summary>
            No directshow filter exists.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent">
            <summary>
            BASS event codes as returned e.g. by <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetEvent(System.Int32,Un4seen.Bass.AddOn.Video.BASSVIDEOEvent@,System.Int32@,System.Int32@,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_OK">
            <summary>
            OK (no error).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_COMPLETE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_USERABORT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_ERRORABORT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_TIME">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_REPAINT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_STREAM_ERROR_STOPPED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_STREAM_ERROR_STILLPLAYING">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_ERROR_STILLPLAYING">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_PALETTE_CHANGED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_VIDEO_SIZE_CHANGED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_QUALITY_CHANGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_SHUTTING_DOWN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_CLOCK_CHANGED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_PAUSED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_OPENING_FILE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_BUFFERING_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_FULLSCREEN_LOST">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_ACTIVATE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_NEED_RESTART">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_WINDOW_DESTROYED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_DISPLAY_CHANGED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_STARVATION">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_OLE_EVENT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_NOTIFY_WINDOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_STREAM_CONTROL_STOPPED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_STREAM_CONTROL_STARTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_END_OF_SEGMENT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_SEGMENT_STARTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_LENGTH_CHANGED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_DEVICE_LOST">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_STEP_COMPLETE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_SKIP_FRAMES">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_TIMECODE_AVAILABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_EXTDEVICE_MODE_CHANGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_STATE_CHANGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_GRAPH_CHANGED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_CLOCK_UNSET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_VMR_RENDERDEVICE_SET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.VMR_RENDER_DEVICE_OVERLAY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.VMR_RENDER_DEVICE_VIDMEM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.VMR_RENDER_DEVICE_SYSMEM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_VMR_SURFACE_FLIPPED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_VMR_RECONNECTION_FAILED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_PREPROCESS_COMPLETE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent.EC_CODECAPI_EVENT">
            <summary>
            
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASSVIDEOAction">
            <summary>
            Used in the <see cref="T:Un4seen.Bass.AddOn.Video.VIDEOPROC"/> to retrieve the current video action state.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOAction.BassVideo_OpenDone">
            <summary>
            The video stream is opened.
            </summary>
            <remarks>
            handle : HStream = 0 if failed, != 0 if success
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOAction.BassVideo_Buffering">
            <summary>
            The video stream is currently buffering.
            </summary>
            <remarks>
            param1 : 0 if buffering done, != 0 if buffering in progress , param2 = buffer percent
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOAction.BassVideo_FoundVideo">
            <summary>
            The video stream was found.
            </summary>
            <remarks>
            handle : HSTREAM; notify the app to prepare the video windows and handle.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOAction.BassVideo_EndStream">
            <summary>
            The video stream has ended.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOAction.BassVideo_DShow_Event">
            <summary>
            DirectShow Event.
            </summary>
            <remarks>param1 : the event (and can directly be casted into a <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOEvent"/> value).</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASSVIDEOFlag">
            <summary>
            Video Stream create flags to be used with <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_AddFile(System.Int32,System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFlag.BASSVIDEO_DEFAULT">
            <summary>
            0 = default video create stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFlag.BASSVIDEO_AUTO_PAINT">
            <summary>
            Auto Paint.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFlag.BASSVIDEO_AUTO_RESIZE">
            <summary>
            Auto Resize.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFlag.BASSVIDEO_AUTO_MOVE">
            <summary>
            Auto Move.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASSVIDEOType">
            <summary>
            Video Stream create flags to be used with <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOType.BASSVIDEO_MEDIA_UNKNOWN">
            <summary>
            Source is unknown (can be used with any other format then AVI).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOType.BASSVIDEO_MEDIA_AVI">
            <summary>
            Source is an AVI format.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASSVIDEOOption">
            <summary>
            Video Stream rendering options to be used with <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetConfig(Un4seen.Bass.AddOn.Video.BASSVIDEOConfig,System.Int32)"/>, <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetConfig(Un4seen.Bass.AddOn.Video.BASSVIDEOConfig)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOOption.BassVideo_Default">
            <summary>
            Use system default video renderer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOOption.BassVideo_VMR9">
            <summary>
            Use VMR9 (requires DirectX-9).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOOption.BassVideo_VMR9_Windowless">
            <summary>
            Use VMR9-WindowLess Mode (requires DirectX-9).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOOption.BassVideo_EVR">
            <summary>
            Use EVR (Enhance Video Renderer).
            </summary>
            <remarks>Please Note : EVR is avaiable on Vista only to use EVR on XP (or other systems) you should install the lastest .NET package.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOOption.BassVideo_Overlay">
            <summary>
            Use Overlay Renderer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOOption.BassVideo_NoVideo">
            <summary>
            Don't display video (audio only).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOOption.BassVideo_Use_Thread_Streaming">
            <summary>
            Use a dedicated thread when opening a Url.
            </summary>
            <remarks>
            Use a <see cref="T:Un4seen.Bass.AddOn.Video.VIDEOPROC"/> to catch the action notification.
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASSVIDEOConfig">
            <summary>
            Video Stream rendering options to be used with <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetConfig(Un4seen.Bass.AddOn.Video.BASSVIDEOConfig,System.Int32)"/>, <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetConfig(Un4seen.Bass.AddOn.Video.BASSVIDEOConfig)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOConfig.BassVideo_Config_Renderer">
            <summary>
            BASS_Video rendering option.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOConfig.BassVideo_Config_WMASF_READER">
            <summary>
            0 = use WM_ASFReader else use Windows Media Source Filter
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASSVIDEOFilter">
            <summary>
            Video Stream rendering options to be used with <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetConfig(Un4seen.Bass.AddOn.Video.BASSVIDEOConfig,System.Int32)"/>, <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetConfig(Un4seen.Bass.AddOn.Video.BASSVIDEOConfig)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFilter.BassVideo_Filter">
            <summary>
            The filter represents a pointer to the filter itself.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFilter.BassVideo_FilterName">
            <summary>
            The filter represents a pointer to the filter name.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASSVIDEORatio">
            <summary>
            Video Stream resize/aspect ration options to be used with <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetRatio(System.Int32,Un4seen.Bass.AddOn.Video.BASSVIDEORatio,System.Double,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEORatio.R43">
            <summary>
            4:3 ratio.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEORatio.R169">
            <summary>
            16:9 ratio.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEORatio.RSource">
            <summary>
            Use source ratio.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEORatio.RFree">
            <summary>
            No ratio (use full video window).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEORatio.RCustom">
            <summary>
            Use custom as ratio ( width / heigh).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASSVIDEOColor">
            <summary>
            Video Color flags to be used with <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetColorRange(System.Int32,Un4seen.Bass.AddOn.Video.BASSVIDEOColor,System.Int32,System.Int32,System.Single@,System.Single@,System.Single@)"/> and <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_SetColor(System.Int32,Un4seen.Bass.AddOn.Video.BASSVIDEOColor,System.Single,System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOColor.COLOR_Brightness">
            <summary>
            Controls the Brightness.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOColor.COLOR_Contrast">
            <summary>
            Controls the Contrast.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOColor.COLOR_Hue">
            <summary>
            Controls the Hue.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOColor.COLOR_Saturation">
            <summary>
            Controls the Saturation.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat">
            <summary>
            Video format type to be used with <see cref="T:Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_UNKNOW">
            <summary>
            Unknown video type.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_RGB1">
            <summary>
            Uncompressed RGB Video type: RGB, 1 bit per pixel (bpp), palettized.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_RGB4">
            <summary>
            Uncompressed RGB Video type: RGB, 4 bpp, palettized.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_RGB8">
            <summary>
            Uncompressed RGB Video type: RGB, 8 bpp.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_RGB555">
            <summary>
            Uncompressed RGB Video type: RGB 555, 16 bpp.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_RGB565">
            <summary>
            Uncompressed RGB Video type: RGB 565, 16 bpp.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_RGB24">
            <summary>
            Uncompressed RGB Video type: RGB, 24 bpp.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_RGB32">
            <summary>
            Uncompressed RGB Video type: RGB, 32 bpp.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_ARGB1555">
            <summary>
            Uncompressed RGB Video type: RGB 555 with alpha channel.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_ARGB32">
            <summary>
            Uncompressed RGB Video type: RGB 32 with alpha channel.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_ARGB4444">
            <summary>
            Uncompressed RGB Video type: 16-bit RGB with alpha channel; 4 bits per channel.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_A2R10G10B10">
            <summary>
            Uncompressed RGB Video type: 32-bit RGB with alpha channel; 10 bits per RGB channel plus 2 bits for alpha.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_A2B10G10R10">
            <summary>
            Uncompressed RGB Video type: 32-bit RGB with alpha channel; 10 bits per RGB channel plus 2 bits for alpha.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AYUV">
            <summary>
            Uncompressed YUV Video type: AYUV - 4:4:4 - packed - 8bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_YUY2">
            <summary>
            Uncompressed YUV Video type: YUY2 - 4:2:2 - packed - 8bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_UYVY">
            <summary>
            Uncompressed YUV Video type: UYVY - 4:2:2 - packed - 8bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_IMC1">
            <summary>
            Uncompressed YUV Video type: IMC1 - 4:2:0 - planar - 8bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_IMC3">
            <summary>
            Uncompressed YUV Video type: IMC3 - 4:2:0 - planar - 8bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_IMC2">
            <summary>
            Uncompressed YUV Video type: IMC2 - 4:2:0 - planar - 8bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_IMC4">
            <summary>
            Uncompressed YUV Video type: IMC4 - 4:2:0 - planar - 8bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_YV12">
            <summary>
            Uncompressed YUV Video type: YV12 - 4:2:0 - planar - 8bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_NV12">
            <summary>
            Uncompressed YUV Video type: NV12 - 4:2:0 - planar - 8bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_Y411">
            <summary>
            Uncompressed YUV Video type: Y411 - 4:1:1 - packed - 8bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_Y41P">
            <summary>
            Uncompressed YUV Video type: Y41P - 4:1:1 - packed - 8bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_Y211">
            <summary>
            Uncompressed YUV Video type: Y211 - packed - 8bits.
            </summary>
            <remarks>Y211 is a packed format, in which Y is sampled every 2 pixels horizontally, and U and V are sampled every 4 pixels horizontally. Each macropixel is 4 bytes and contains 4 pixels. It uses the following byte order: Y0 U0 Y2 V0  Y4 U4 Y6 V4  Y8 U8 Y10 V8).</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_YVYU">
            <summary>
            Uncompressed YUV Video type: YVYU - 4:2:2 - packed - 8bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_YVU9">
            <summary>
            Uncompressed YUV Video type: YVU9 - planar - 8bits.
            </summary>
            <remarks>YVU9 is a planar format, in which U and V are sampled every 4 pixels horizontally and vertically (sometimes referred to as 16:1:1). The V plane appears before the U plane.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_IF09">
            <summary>
            Uncompressed YUV Video type: Indeo YVU9 - planar - 8bits.
            </summary>
            <remarks>The Indeo YVU9 format is a variation of YVU9 with additional delta-frame information after the U plane.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_NTSC_M">
            <summary>
            Analog Video type: (M) NSTC.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_PAL_B">
            <summary>
            Analog Video type: (B) PAL.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_PAL_D">
            <summary>
            Analog Video type: (D) PAL.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_PAL_G">
            <summary>
            Analog Video type: (G) PAL.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_PAL_H">
            <summary>
            Analog Video type: (H) PAL.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_PAL_I">
            <summary>
            Analog Video type: (I) PAL.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_PAL_M">
            <summary>
            Analog Video type: (M) PAL.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_PAL_N">
            <summary>
            Analog Video type: (N) PAL.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_SECAM_B">
            <summary>
            Analog Video type: (B) SECAM.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_SECAM_D">
            <summary>
            Analog Video type: (D) SECAM.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_SECAM_G">
            <summary>
            Analog Video type: (G) SECAM.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_SECAM_H">
            <summary>
            Analog Video type: (H) SECAM.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_SECAM_K">
            <summary>
            Analog Video type: (K) SECAM.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_SECAM_K1">
            <summary>
            Analog Video type: (K1) SECAM.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AnalogVideo_SECAM_L">
            <summary>
            Analog Video type: (L) SECAM.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_AI44">
            <summary>
            DirectX Video acceleration type: For subpicture and text overlays.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_IA44">
            <summary>
            DirectX Video Acceleration type: For subpicture and text overlays.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_dvsl">
            <summary>
            DV Video type: SD-DVCR (525/60 or 625/50).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_dvsd">
            <summary>
            DV Video type: SDL-DVCR (525/60 or 625/50).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_dvhd">
            <summary>
            DV Video type: HD-DVCR (1125/60 or 1250/50).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_dv25">
            <summary>
            Professional Video Format type: DVCPRO 25 (525/60 or 625/50). 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_dv50">
            <summary>
            Professional Video Format type: DVCPRO 50 (525/60 or 625/50)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_dvh1">
            <summary>
            Professional Video Format type: DVCPRO 100 (1080i/60, 1080i/50, or 720p/60).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_DVCS">
            <summary>
            Professional Video Format type.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_RGB32_D3D_DX7_RT">
            <summary>
            Video Mixing Renderer VMR-7 Video type: 32-bit RGB render target.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_RGB16_D3D_DX7_RT">
            <summary>
            Video Mixing Renderer VMR-7 Video type: 16-bit RGB render target.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_ARGB32_D3D_DX7_RT">
            <summary>
            Video Mixing Renderer VMR-7 Video type: 32-bit ARGB render target.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_ARGB4444_D3D_DX7_RT">
            <summary>
            Video Mixing Renderer VMR-7 Video type: ARGB4444 render target. For subpicture graphics.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_ARGB1555_D3D_DX7_RT">
            <summary>
            Video Mixing Renderer VMR-7 Video type: ARGB1555 render target. For subpicture graphics.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_RGB32_D3D_DX9_RT">
            <summary>
            Video Mixing Renderer VMR-9 Video type: 32-bit RGB render target.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_RGB16_D3D_DX9_RT">
            <summary>
            Video Mixing Renderer VMR-9 Video type: 16-bit RGB render target.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_ARGB32_D3D_DX9_RT">
            <summary>
            Video Mixing Renderer VMR-9 Video type: 32-bit ARGB render target.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_ARGB4444_D3D_DX9_RT">
            <summary>
            Video Mixing Renderer VMR-9 Video type: ARGB4444 render target. For subpicture graphics.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_ARGB1555_D3D_DX9_RT">
            <summary>
            Video Mixing Renderer VMR-9 Video type: ARGB1555 render target. For subpicture graphics.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_CFCC">
            <summary>
            Miscellaneous Video type: MJPG format produced by some cards.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_CLJR">
            <summary>
            Miscellaneous Video type: Cirrus Logic CLJR format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_CPLA">
            <summary>
            Miscellaneous Video type: Cinepak UYVY format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_CLPL">
            <summary>
            Miscellaneous Video type: A YUV format supported by some Cirrus Logic drivers.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_IJPG">
            <summary>
            Miscellaneous Video type: Intergraph JPEG format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_MDVF">
            <summary>
            Miscellaneous Video type: A DV encoding format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_MJPG">
            <summary>
            Miscellaneous Video type: Motion JPEG (MJPG) compressed video.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_MPEG1Packet">
            <summary>
            Miscellaneous Video type: MPEG1 Video Packet.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_MPEG1Payload">
            <summary>
            Miscellaneous Video type: MPEG1 Video Payload.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_Overlay">
            <summary>
            Miscellaneous Video type: Video delivered using hardware overlay.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_Plum">
            <summary>
            Miscellaneous Video type: Plum MJPG format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_QTJpeg">
            <summary>
            Miscellaneous Video type: QuickTime JPEG compressed data.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_QTMovie">
            <summary>
            Miscellaneous Video type: Apple® QuickTime® compression.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_QTRle">
            <summary>
            Miscellaneous Video type: QuickTime RLE compressed data.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_QTRpza">
            <summary>
            Miscellaneous Video type: QuickTime RPZA compressed data.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_QTSmc">
            <summary>
            Miscellaneous Video type: QuickTime SMC compressed data.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_TVMJ">
            <summary>
            Miscellaneous Video type: TrueVision MJPG format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_VPVBI">
            <summary>
            Miscellaneous Video type: Video port vertical blanking interval (VBI) data.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_VPVideo">
            <summary>
            Miscellaneous Video type: Video port video data.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat.VIDEOTYPE_WAKE">
            <summary>
            Miscellaneous Video type: MJPG format produced by some cards. 
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetInfo(System.Int32,Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO)"/> to retrieve information on a video.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO.AvgTimePerFrame">
            <summary>
            The average frame time in seconds.
            </summary>
            <remarks>This value is typically set by the source filter, which obtains it from the information in the video stream itself. 
            This value is not necessarily equal to the actual time per frame at which the video is rendered.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO.Height">
            <summary>
            The video height.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO.Width">
            <summary>
            The video width.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO.FormatType">
            <summary>
            The video info format (either FORMAT_VideoInfo_1 or FORMAT_VideoInfo_2).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO.VideoFormat">
            <summary>
            The input format of the video renderer (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOFormat"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO.VideoFormat_GUID">
            <summary>
            The format Guid.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BASS_VIDEO_INFO.ToString">
            <summary>
            A description of the video info object (WidthxHeight: VideoFormat).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.BASS_VIDEO_FRAMEINFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_GetFrameInfo(System.Int32,Un4seen.Bass.AddOn.Video.BASS_VIDEO_FRAMEINFO)"/> to retrieve frame information on a video.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASS_VIDEO_FRAMEINFO.AvgFrameRate">
            <summary>
            The actual number of frames per second, multiplied by 100. For example, an average frame rate of 30 frames per second will be represented as 3000.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASS_VIDEO_FRAMEINFO.FrameDraw">
            <summary>
            Number of frames drawn since streaming started.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Video.BASS_VIDEO_FRAMEINFO.FrameDrop">
            <summary>
            Number of frames dropped by the renderer.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BASS_VIDEO_FRAMEINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Video.BASS_VIDEO_FRAMEINFO.ToString">
            <summary>
            A description of the frame info object (FrameDraw, AvgFrameRate).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.VIDEOPROC">
            <summary>
            User defined callback function to process video action states.
            </summary>
            <param name="handle">The video handle that the data is from.</param>
            <param name="action">One of the <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOAction"/> values to indicate the current video state.</param>
            <param name="param1">The first action parameter (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOAction"/> for details).</param>
            <param name="param2">The second action parameter (see <see cref="T:Un4seen.Bass.AddOn.Video.BASSVIDEOAction"/> for details).</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_StreamCreateFile(System.String,Un4seen.Bass.AddOn.Video.BASSVIDEOFlag,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.FILTERPROC">
            <summary>
            Directshow filter enum callback.
            </summary>
            <param name="handle">The video handle that the data is from.</param>
            <param name="filterName">The pointer to the name of the directshow filter (use <see cref="M:Un4seen.Bass.Utils.IntPtrAsStringAnsi(System.IntPtr)"/> to get the real filtername string).</param>
            <param name="filter">The pointer of the directshow filter.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_EnumFilter(System.Int32,Un4seen.Bass.AddOn.Video.FILTERPROC,System.IntPtr)"/> was called.</param>
            <returns>Return TRUE to continue the enumeration - else FALSE.</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Video.AUDIOENCODEPROC">
            <summary>
            Audio data callback to extract the sample data from a video stream.
            </summary>
            <param name="handle">The video handle that the data is from.</param>
            <param name="length">The number of bytes which had been feed to the channel, use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve the audio sample data from the video stream.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_EncodeAudio(System.String,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,Un4seen.Bass.AddOn.Video.AUDIOENCODEPROC,System.IntPtr)"/> was called.</param>
            <remarks>See <see cref="M:Un4seen.Bass.AddOn.Video.BassVideo.BASS_Video_EncodeAudio(System.String,Un4seen.Bass.BASSFlag,Un4seen.Bass.AddOn.Video.VIDEOPROC,Un4seen.Bass.AddOn.Video.AUDIOENCODEPROC,System.IntPtr)"/> for details.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BassMidi">
            <summary>
            BASS .NET API wrapper for BASSMIDI.
            <para>Requires: bassmidi.dll - BASSMIDI Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSMIDI is an extension to the BASS audio library, enabling the playing of MIDI files (Musical Instrument Digital Interface), using SF2 soundfonts to provide the sounds.</para>
            <para>The MIDI format is used in very much the same way as any of the built-in BASS	stream formats - simply call the MIDI stream creation function instead of the BASS built-in functions. 
            The BASS plugin system (see BASS_PluginLoad) is also supported.</para>
            <para>SF2 soundfonts are used to provide the sounds. There are several soundfonts available on the internet. 
            One example (Chorium) is available from the BASS webpage. On Win32, the Creative 4MB/2MB soundfont (CT4MGM.SF2/CT2MGM.SF2) will be used by default when it's present (in the Windows system directory).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Creates a sample stream to render real-time MIDI events.
            </summary>
            <param name="channels">The number of MIDI channels: 1 (min) - 128 (max).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate (in Hz) to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function creates a stream solely for real-time MIDI events. As it's not based on any file, the stream has no predetermined length and is never-ending. Seeking isn't possible, but it is possible to reset everything, including playback buffer, 
            by calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> (restart = TRUE) or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> (pos = 0).</para>
            <para>MIDI events are applied using the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> function. If the stream is being played (it's not a decoding channel), then there will be some delay in the effect of the events being heard. 
            This latency can be reduced by making use of the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> and <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD"/> options.</para>
            <para>Unlike MIDI files, streams created for rendering real-time events are not limited to 16 channels. By default, all the MIDI channels are melodic, but they can be switched to percussion/drums using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> and the MIDI_EVENT_DRUMS event.</para>
            <para>Soundfonts provide the sounds that are used to render a MIDI stream. A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overriden using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>.</para>
            <para>To play a MIDI file, use <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="channels"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Creates a sample stream from a MIDI sound file.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_DECAYEND</term><description>Let the ending decay naturally (including reverb), instead of stopping abruptly at the end of the file. This doesn't apply when looping. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>BASSMIDI supports format 0 and 1 MIDI files, as well as the first track of format 2 files. RIFF MIDI (RMID) files are also supported. The General MIDI standard events are supported, as are several Roland GS and Yamaha XG NRPN and SysEx events. A full list of supported MIDI events can be found in the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> documentation.
            <para>Soundfonts provide the sounds that are used to render a MIDI stream. A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overriden using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>. 
            By default, with the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIDI_AUTOFONT</see> config option enabled, BASSMIDI will also look for a soundfont of the same name as the MIDI file. For example, if the MIDI is "afile.mid", then it will look for a "afile.sf2" (or "afile.mid.sf2"). Note that a MIDI stream can have multiple soundfonts stacked, each providing different presets, for example.</para>
            <para>As well as the standard byte/time-based positioning, MIDI tick-based positioning is also supported. The BASS_POS_MIDI_TICK "mode" can be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> to deal in ticks.</para>
            <para>Marker, cue and lyric events can be retrieved via the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> function. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">Syncs</see> (BASS_SYNC_MIDI_MARKER, BASS_SYNC_MIDI_CUE, BASS_SYNC_MIDI_LYRIC, BASS_SYNC_MIDI_EVENT, BASS_SYNC_MIDI_TICK) 
            can also be used to be notified of their occurrence.</para>
            <para>The texts of each track in the MIDI file are available via the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_MIDI_TRACK"/> + track tag, where track=0 is the first track. A pointer to a series of null-terminated strings is given, the final string ending with a double null. 
            The first text in the first track is generally the title of the MIDI file. RIFF MIDI tags are also available via the standard <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_INFO"/> tag.
            In addition you might also use the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMidiTrackText(System.Int32,System.Int32)"/> method to retrieve the track text.</para>
            <para>Unlike with most stream formats, the entire MIDI file is loaded to memory. This means the file can be deleted or moved after calling this function.</para>
            <para>As well as providing dedicated stream creation functions, BASSMIDI supports the BASS plugin system, adding MIDI file support to the standard BASS stream creation functions - <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>. 
            This is enabled using the BASS_PluginLoad function.</para>
            <para>MIDI streams created via the plugin system use the sample rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="url"/> is not a valid URL.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Creates a sample stream from a MIDI memory IntPtr.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_DECAYEND</term><description>Let the ending decay naturally (including reverb), instead of stopping abruptly at the end of the file. This doesn't apply when looping. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>BASSMIDI supports format 0 and 1 MIDI files, as well as the first track of format 2 files. RIFF MIDI (RMID) files are also supported. The General MIDI standard events are supported, as are several Roland GS and Yamaha XG NRPN and SysEx events. A full list of supported MIDI events can be found in the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> documentation.
            <para>Soundfonts provide the sounds that are used to render a MIDI stream. A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overriden using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>. 
            By default, with the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIDI_AUTOFONT</see> config option enabled, BASSMIDI will also look for a soundfont of the same name as the MIDI file. For example, if the MIDI is "afile.mid", then it will look for a "afile.sf2" (or "afile.mid.sf2"). Note that a MIDI stream can have multiple soundfonts stacked, each providing different presets, for example.</para>
            <para>As well as the standard byte/time-based positioning, MIDI tick-based positioning is also supported. The BASS_POS_MIDI_TICK "mode" can be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> to deal in ticks.</para>
            <para>Marker, cue and lyric events can be retrieved via the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> function. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">Syncs</see> (BASS_SYNC_MIDI_MARKER, BASS_SYNC_MIDI_CUE, BASS_SYNC_MIDI_LYRIC, BASS_SYNC_MIDI_EVENT, BASS_SYNC_MIDI_TICK) 
            can also be used to be notified of their occurrence.</para>
            <para>The texts of each track in the MIDI file are available via the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_MIDI_TRACK"/> + track tag, where track=0 is the first track. A pointer to a series of null-terminated strings is given, the final string ending with a double null. 
            The first text in the first track is generally the title of the MIDI file. RIFF MIDI tags are also available via the standard <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_INFO"/> tag.
            In addition you might also use the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMidiTrackText(System.Int32,System.Int32)"/> method to retrieve the track text.</para>
            <para>Unlike with most stream formats, the entire MIDI file is loaded to memory. This means the file can be deleted or moved after calling this function.</para>
            <para>As well as providing dedicated stream creation functions, BASSMIDI supports the BASS plugin system, adding MIDI file support to the standard BASS stream creation functions - <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>. 
            This is enabled using the BASS_PluginLoad function.</para>
            <para>MIDI streams created via the plugin system use the sample rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="url"/> is not a valid URL.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFileMemory(System.Boolean,System.Byte[],System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFile(System.Byte[],System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Creates a sample stream from a MIDI memory byte[].
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="memory">A managed memory location as a byte[].</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_DECAYEND</term><description>Let the ending decay naturally (including reverb), instead of stopping abruptly at the end of the file. This doesn't apply when looping. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>BASSMIDI supports format 0 and 1 MIDI files, as well as the first track of format 2 files. RIFF MIDI (RMID) files are also supported. The General MIDI standard events are supported, as are several Roland GS and Yamaha XG NRPN and SysEx events. A full list of supported MIDI events can be found in the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> documentation.
            <para>Soundfonts provide the sounds that are used to render a MIDI stream. A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overriden using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>. 
            By default, with the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIDI_AUTOFONT</see> config option enabled, BASSMIDI will also look for a soundfont of the same name as the MIDI file. For example, if the MIDI is "afile.mid", then it will look for a "afile.sf2" (or "afile.mid.sf2"). Note that a MIDI stream can have multiple soundfonts stacked, each providing different presets, for example.</para>
            <para>As well as the standard byte/time-based positioning, MIDI tick-based positioning is also supported. The BASS_POS_MIDI_TICK "mode" can be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> to deal in ticks.</para>
            <para>Marker, cue and lyric events can be retrieved via the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> function. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">Syncs</see> (BASS_SYNC_MIDI_MARKER, BASS_SYNC_MIDI_CUE, BASS_SYNC_MIDI_LYRIC, BASS_SYNC_MIDI_EVENT, BASS_SYNC_MIDI_TICK) 
            can also be used to be notified of their occurrence.</para>
            <para>The texts of each track in the MIDI file are available via the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_MIDI_TRACK"/> + track tag, where track=0 is the first track. A pointer to a series of null-terminated strings is given, the final string ending with a double null. 
            The first text in the first track is generally the title of the MIDI file. RIFF MIDI tags are also available via the standard <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_INFO"/> tag.
            In addition you might also use the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMidiTrackText(System.Int32,System.Int32)"/> method to retrieve the track text.</para>
            <para>Unlike with most stream formats, the entire MIDI file is loaded to memory. This means the file can be deleted or moved after calling this function.</para>
            <para>As well as providing dedicated stream creation functions, BASSMIDI supports the BASS plugin system, adding MIDI file support to the standard BASS stream creation functions - <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>. 
            This is enabled using the BASS_PluginLoad function.</para>
            <para>MIDI streams created via the plugin system use the sample rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="url"/> is not a valid URL.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr,System.Int32)">
            <summary>
            Creates a sample stream from a MIDI file via a user callback function.
            </summary>
            <param name="system">File system to use, which must be <see cref="F:Un4seen.Bass.BASSStreamSystem.STREAMFILE_NOBUFFER"/>, as the entire MIDI file is preloaded.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_DECAYEND</term><description>Let the ending decay naturally (including reverb), instead of stopping abruptly at the end of the file. This doesn't apply when looping. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            </list>
            </param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <param name="freq">Sample rate to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.
            <para>As there is no file associated with a user file stream, it's not possible for BASSMIDI to look for a soundfont with the same name as the MIDI file. If there is a matching soundfont, it can be applied using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="system"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported (ie. no WDM drivers).</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr,System.Int32)">
            <summary>
            Creates a sample stream from an MIDI file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
            <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_STATUS</term><description>Pass status info (HTTP/ICY tags) from the server to the <see cref="T:Un4seen.Bass.DOWNLOADPROC"/> callback during connection. This can be useful to determine the reason for a failure.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_DECAYEND</term><description>Let the ending decay naturally (including reverb), instead of stopping abruptly at the end of the file. This doesn't apply when looping. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            </list>
            </param>
            <param name="proc">Callback function to receive the file as it is downloaded... NULL = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="freq">Sample rate to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.
            <para>The entire MIDI file is preloaded, so the standard BASS_STREAM_BLOCK and BASS_STREAM_RESTRATE flags have no effect here.</para>
            <para>Regardless of the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIDI_AUTOFONT"/> setting, a matching soundfont is not looked for when opening a MIDI file from a URL.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_NONET</term><description>No internet connection could be opened. Can be caused by a bad <see cref="T:Un4seen.Bass.BASSConfig">proxy setting</see>.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="url"/> is not a valid URL.</description></item>
            <item><term>BASS_ERROR_TIMEOUT</term><description>The server did not respond to the request within the timeout period, as set with the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_NET_TIMEOUT</see> config option.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMarkInternal(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.MIDI_MARK_INTERNAL@)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="type"></param>
            <param name="index"></param>
            <param name="mark"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)">
            <summary>
            Retrieves a marker from a MIDI stream.
            </summary>
            <param name="handle">The MIDI stream to retrieve the marker from.</param>
            <param name="type">The type of marker to retrieve, one of the following (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker"/>):
            <list type="table">
            <item><term>BASS_MIDI_MARK_CUE</term><description>Cue events (MIDI meta event 07).</description></item>
            <item><term>BASS_MIDI_MARK_LYRIC</term><description>Lyric events (MIDI meta event 05).</description></item>
            <item><term>BASS_MIDI_MARK_MARKER</term><description>Marker events (MIDI meta event 06).</description></item>
            <item><term>BASS_MIDI_MARK_TEXT</term><description>Text events (MIDI meta event 01).</description></item>
            </list>
            </param>
            <param name="index">The marker to retrieve... 0 = the first.</param>
            <param name="mark">Instance of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK"/> class to receive the marker details.</param>
            <returns>TRUE on success, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The markers are ordered chronologically.
            <para><see cref="T:Un4seen.Bass.BASSSync">BASS_SYNC_MIDI_xxx Syncs</see> can be used to be informed of when markers are encountered during playback.</para>
            <para>If a lyric marker text begins with a '/' (slash) character, that means a new line should be started. If the text begins with a '\' (backslash) character, the display should be cleared. 
            Lyrics can sometimes be found in BASS_MIDI_MARK_TEXT instead of BASS_MIDI_MARK_LYRIC markers.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/>type in not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="index"/>type in not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List a MIDI stream's markers:
            <code>
            BASS_MIDI_MARK mark = new BASS_MIDI_MARK();
            int idx = 0;
            while (BassMidi.BASS_MIDI_StreamGetMark(handle, BASSMIDIMarker.BASS_MIDI_MARK_MARKER, idx, mark))
            {
              idx++;
              Console.WriteLine("{0}.Marker: {1}", idx, mark);
            }
            </code>
            <code lang="vbnet">
            Dim mark As New BASS_MIDI_MARK()
            Dim idx As Integer = 0
            While BassMidi.BASS_MIDI_StreamGetMark(handle, BASSMIDIMarker.BASS_MIDI_MARK_MARKER, idx, mark)
              idx += 1
              Console.WriteLine("{0}.Marker: {1}", idx, mark)
            End While
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32)">
            <summary>
            Retrieves a marker from a MIDI stream.
            </summary>
            <param name="handle">The MIDI stream to retrieve the marker from.</param>
            <param name="type">The type of marker to retrieve, one of the following (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker"/>):
            <list type="table">
            <item><term>BASS_MIDI_MARK_CUE</term><description>Cue events (MIDI meta event 07).</description></item>
            <item><term>BASS_MIDI_MARK_LYRIC</term><description>Lyric events (MIDI meta event 05).</description></item>
            <item><term>BASS_MIDI_MARK_MARKER</term><description>Marker events (MIDI meta event 06).</description></item>
            <item><term>BASS_MIDI_MARK_TEXT</term><description>Text events (MIDI meta event 01).</description></item>
            </list>
            </param>
            <param name="index">The marker to retrieve... 0 = the first.</param>
            <returns>On success, an instance of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK"/> class is returned, else NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The markers are ordered chronologically.
            <para><see cref="T:Un4seen.Bass.BASSSync">BASS_SYNC_MIDI_xxx Syncs</see> can be used to be informed of when markers are encountered during playback.</para>
            <para>If a lyric marker text begins with a '/' (slash) character, that means a new line should be started. If the text begins with a '\' (backslash) character, the display should be cleared. 
            Lyrics can sometimes be found in BASS_MIDI_MARK_TEXT instead of BASS_MIDI_MARK_LYRIC markers.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/>type in not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="index"/>type in not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List a MIDI stream's markers:
            <code>
            int idx = 0;
            BASS_MIDI_MARK mark;
            while ((mark = BassMidi.BASS_MIDI_StreamGetMark(handle, BASSMIDIMarker.BASS_MIDI_MARK_MARKER, idx)) != null)
            {
              idx++;
              Console.WriteLine("{0}.Marker: {1}", idx, mark);
            }
            </code>
            <code lang="vbnet">
            Dim idx As Integer = 0
            Dim mark As BASS_MIDI_MARK
            While True
              mark = BassMidi.BASS_MIDI_StreamGetMark(stream, BASSMIDIMarker.BASS_MIDI_MARK_MARKER, idx)
              If mark Is Nothing Then
                Exit While
              End If
              idx += 1
              Console.WriteLine("{0}.Marker: {1}", idx, mark)
            End While
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)">
            <summary>
            Applies an event to a MIDI stream.
            </summary>
            <param name="handle">The MIDI stream to apply the event to (as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>).</param>
            <param name="chan">The MIDI channel to apply the event in... 0 (channel 1) - 15 (channel 16).</param>
            <param name="eventtype">The event to apply (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details).</param>
            <param name="param">The event parameter (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Apart from the "global" events, all events apply only to the specified MIDI channel.</para>
            <para>Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping. This applies to all events apart from the "non-MIDI" events.</para>
            <para>If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_BUFFER</see> and <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_UPDATEPERIOD</see> config options when creating the stream.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One of the other parameters is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play the middle C note (key 60) with a velocity of 100, on channel 1 for 2 seconds:
            <code>
            // press the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60, 100);
            // wait 2 seconds
            Thread.Sleep(2000);
            // release the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60);
            </code>
            <code lang="vbnet">
            ' press the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60, 100)
            ' wait 2 seconds
            Thread.Sleep(2000)
            ' release the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Byte,System.Byte)">
            <summary>
            Applies an event to a MIDI stream.
            </summary>
            <param name="handle">The MIDI stream to apply the event to (as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>).</param>
            <param name="chan">The MIDI channel to apply the event in... 0 (channel 1) - 15 (channel 16).</param>
            <param name="eventtype">The event to apply (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details).</param>
            <param name="loParam">The event parameter (LOBYTE), (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details).</param>
            <param name="hiParam">The event parameter (HIBYTE), (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Apart from the "global" events, all events apply only to the specified MIDI channel.</para>
            <para>Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping. This applies to all events apart from the "non-MIDI" events.</para>
            <para>If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_BUFFER</see> and <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_UPDATEPERIOD</see> config options when creating the stream.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One of the other parameters is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play the middle C note (key 60) with a velocity of 100, on channel 1 for 2 seconds:
            <code>
            // press the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60, 100);
            // wait 2 seconds
            Thread.Sleep(2000);
            // release the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60);
            </code>
            <code lang="vbnet">
            ' press the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60, 100)
            ' wait 2 seconds
            Thread.Sleep(2000)
            ' release the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent)">
            <summary>
            Retrieves the current value of an event in a MIDI stream channel.
            </summary>
            <param name="handle">The MIDI stream to retrieve the event from (as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>).</param>
            <param name="chan">The MIDI channel to retrieve the event from... 0 (channel 1) - 15 (channel 16).</param>
            <param name="eventtype">The event to retrieve (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details).</param>
            <returns>The event parameter (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details) if successful - else -1 (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One of the other parameters is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)">
            <summary>
            Applies a soundfont configuration to a MIDI stream, or sets the default soundfont configuration.
            </summary>
            <param name="handle">The MIDI stream to apply the soundfonts to... 0 = set default soundfont configuration.</param>
            <param name="fonts">The pointer to an array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT"/> soundfonts to apply.</param>
            <param name="count">The number of elements in the fonts array.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Multiple soundfonts can be stacked, to provide different presets and banks, for example. When a preset is present in multiple soundfonts, the earlier soundfont in the array has priority. 
            When a soundfont matching the MIDI file is loaded, that remains loaded when calling this function, and has priority over all other soundfonts.
            <para>Changing the default configuration only affects subsequently created MIDI streams. Existing streams that are using the previous default configuration will continue to use that previous configuration.</para>
            <para>On Windows, the default default configuration will be to use the Creative 4MB (CT4MGM.SF2) or 2MB (CT2MGM.SF2) soundfont when present in the Windows system directory.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>Something in the <paramref name="fonts"/> array is invalid, check the soundfont handles.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // first initialize the fonts
            int font1 = BassMidi.BASS_MIDI_FontInit("afont.sf2");
            int font2 = BassMidi.BASS_MIDI_FontInit("bfont.sf2");
            BASS_MIDI_FONT[] newfonts = { new BASS_MIDI_FONT(font1, -1, 0), new BASS_MIDI_FONT(font2, -1, 0) };
            // now set them
            BassMidi.BASS_MIDI_StreamSetFonts(_stream, newfonts, newfonts.Length);
            </code>
            <code lang="vbnet">
            ' first initialize the fonts
            Dim font1 As Integer =  BassMidi.BASS_MIDI_FontInit("afont.sf2") 
            Dim font2 As Integer =  BassMidi.BASS_MIDI_FontInit("bfont.sf2") 
            Dim newFonts() As BASS_MIDI_FONT = {New BASS_MIDI_FONT(font1, -1, 0), New BASS_MIDI_FONT(font2, -1, 0)}
            ' now set them
            BassMidi.BASS_MIDI_StreamSetFonts(_stream, newFonts, newFonts.Length)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <param name="fonts">An array to retrieve the soundfont configuration.</param>
            <param name="count">The maximum number of elements to retrieve in the fonts array. This and fonts can be 0, to get the number of elements in the soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration (which can be higher than count) is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>When a soundfont matching the MIDI file is loaded, it will be the first element in the returned configuration.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int fontCount = BassMidi.BASS_MIDI_StreamGetFontsCount(_stream);
            BASS_MIDI_FONT[] fonts = new BASS_MIDI_FONT[fontCount];
            int count = BassMidi.BASS_MIDI_StreamGetFonts(_stream, fonts, fontCount);
            </code>
            <code lang="vbnet">
            Dim fontCount As Integer = BassMidi.BASS_MIDI_StreamGetFontsCount(_stream)
            Dim fonts(fontCount) As BASS_MIDI_FONT
            Dim count As Integer = BassMidi.BASS_MIDI_StreamGetFonts(_stream, fonts, fontCount)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetFonts(System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <returns>An array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT"/> configuration entries if successfull - or NULL on error.</returns>
            <remarks>This overload will always return all used soundfont configuration objects.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_MIDI_FONT[] fonts = BassMidi.BASS_MIDI_StreamGetFonts(_stream);
            </code>
            <code lang="vbnet">
            Dim fonts As BASS_MIDI_FONT() = BassMidi.BASS_MIDI_StreamGetFonts(_stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetFontsCount(System.Int32)">
            <summary>
            Retrieves the number of elements in the soundfont configuration.
            </summary>
            <param name="handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetTrackCount(System.Int32)">
            <summary>
            Returns the total number of tracks contained in the MIDI stream.
            </summary>
            <param name="handle">The MIDI stream to retrieve the track count from.</param>
            <returns>The number of tracks contained in the MIDI stream.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamLoadSamples(System.Int32)">
            <summary>
            Preloads the samples required by a MIDI file stream.
            </summary>
            <param name="handle">The MIDI stream handle.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Samples are normally loaded as they are needed while rendering a MIDI stream, which can result in CPU spikes, particularly with packed soundfonts. That generally won't cause any problems, but when smooth/constant performance is critical this function can be used to preload the samples before rendering, so avoiding the need to load them while rendering.</para>
            <para>Preloaded samples can be compacted/unloaded just like any other samples, so it is probably wise to disable the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIDI_COMPACT</see> option when preloading samples, to avoid any chance of the samples subsequently being automatically unloaded.</para>
            <para>This function should not be used while the MIDI stream is being rendered, as that could interrupt the rendering.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is for real-time events only, so it's not possible to know what presets are going to be used. Use <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontLoad(System.Int32,System.Int32,System.Int32)"/> instead.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInitUnicode(System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="file"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String)">
            <summary>
            Initializes a soundfont from a file (unicode).
            </summary>
            <param name="file">The file name of the sound font (e.g. an .sf2 file).</param>
            <returns>If successful, the soundfont's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The BASS_UNICODE flag is applied automatically here.
            <para>BASSMIDI uses SF2 soundfonts to provide the sounds to use in the rendering of MIDI files. Several SF2 soundfonts can be found on the internet, including one (Chorium) on the BASS website.</para>
            <para>A soundfont needs to be initialized before it can be used to render MIDI streams. Once initialized, a soundfont can be assigned to MIDI streams using the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/> function. A single soundfont can be shared by multiple MIDI streams.</para>
            <para>Information on the initialized soundfont can be retrieved using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO)"/>.</para>
            <para>If the specified soundfont has already been initialized, the existing handle will be returned.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The <paramref name="file"/> could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // first initialize the fonts
            int font1 = BassMidi.BASS_MIDI_FontInit("afont.sf2");
            int font2 = BassMidi.BASS_MIDI_FontInit("bfont.sf2");
            BASS_MIDI_FONT[] newfonts = new BASS_MIDI_FONT[2];
            newfonts[0] = new BASS_MIDI_FONT(font1, 10, 0);
            newfonts[1] = new BASS_MIDI_FONT(font2, -1, 0);
            // now set them
            BassMidi.BASS_MIDI_StreamSetFonts(_stream, newfonts, 2);
            </code>
            <code lang="vbnet">
            ' first initialize the fonts
            Dim font1 As Integer = BassMidi.BASS_MIDI_FontInit("afont.sf2")
            Dim font2 As Integer = BassMidi.BASS_MIDI_FontInit("bfont.sf2")
            Dim newfonts(2) As BASS_MIDI_FONT
            newfonts(0) = New BASS_MIDI_FONT(font1, 10, 0)
            newfonts(1) = New BASS_MIDI_FONT(font2, -1, 0)
            BassMidi.BASS_MIDI_StreamSetFonts(_stream, newfonts, 2)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO)">
            <summary>
            Retrieves information on a soundfont.
            </summary>
            <param name="handle">The soundfont to get info on (e.g. as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String)"/>).</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO"/> class to store the information at.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int font1 = BassMidi.BASS_MIDI_FontInit("afont.sf2");
            BASS_MIDI_FONTINFO fontInfo = new BASS_MIDI_FONTINFO();
            BassMidi.BASS_MIDI_FontGetInfo(font1, fontInfo);
            Console.WriteLine( fontInfo.ToString() );
            </code>
            <code lang="vbnet">
            Dim font1 As Integer = BassMidi.BASS_MIDI_FontInit("afont.sf2")
            Dim fontInfo As New BASS_MIDI_FONTINFO()
            BassMidi.BASS_MIDI_FontGetInfo(font1, fontInfo)
            Console.WriteLine(fontInfo.ToString())
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetInfo(System.Int32)">
            <summary>
            Retrieves information on a soundfont.
            </summary>
            <param name="handle">The soundfont to get info on (e.g. as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String)"/>).</param>
            <returns>An instance of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO"/> class on success - else NULL.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontCompact(System.Int32)">
            <summary>
            Compact a soundfont's memory usage.
            </summary>
            <param name="handle">The soundfont to get info on (e.g. as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String)"/>).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Compacting involves freeing any samples that are currently loaded but unused. The amount of sample data currently loaded can be retrieved using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontFree(System.Int32)">
            <summary>
            Frees a soundfont.
            </summary>
            <param name="handle">The soundfont to get info on (e.g. as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String)"/>).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>When a soundfont is freed, it is automatically removed from any MIDI streams that are using it.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontPack(System.Int32,System.String,System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="outfile"></param>
            <param name="encoder"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontPack(System.Int32,System.String,System.String)">
            <summary>
            Produces a compressed version of a soundfont.
            <para>Unicode version only here (BASS_UNICODE will be used automatically).</para>
            </summary>
            <param name="handle">The soundfont to pack.</param>
            <param name="outfile">Filename for the packed soundfont.</param>
            <param name="encoder">Encoder command-line (e.g. as returned by <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/>).</param>
            <returns>If successful, the TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Standard soundfonts use PCM samples, so they can be quite large, which can be a problem if they're to be distributed. 
            To reduce the size, BASSMIDI can compress the samples using any command-line encoder with STDIN and STDOUT support. 
            Packed soundfonts can be used for rendering by BASSMIDI just like normal soundfonts. 
            They can also be unpacked using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontUnpack(System.Int32,System.String,Un4seen.Bass.BASSFlag)"/>.
            <para>Although any command-line encoder can be used, it is best to use a lossless format like FLAC or WavPack, rather than a lossy one like OGG or MP3. 
            Using a lossless encoder, the packed soundfont will produce exactly the same results as the original soundfont, and will be identical to the original when unpacked. 
            As a compromise between quality and size, the WavPack hybrid/lossy mode also produces good sounding results.</para>
            <para>The encoder must be told (via the command-line) to expect input from STDIN and to send it's output to STDOUT.</para>
            <para>To use a packed soundfont, the appropriate BASS add-on needs to be loaded (via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>) to decode the samples. 
            For example, if the samples are FLAC encoded, BASSFLAC would need to be loaded. During rendering, the samples are unpacked as they're needed, which could result in CPU spikes. 
            Where smooth performance is critical, it may be wise to preload the samples using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontLoad(System.Int32,System.Int32,System.Int32)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>Couldn't start the encoder. Check that the executable exists.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>Couldn't create the output file, <paramref name="outfile"/>.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Create a FLAC encoded version of a soundfont:
            <code>
            // open original soundfont
            int handle = BassMidi.BASS_MIDI_FontInit( "afile.sf2");
            // produce packed version
            BassMidi.BASS_MIDI_FontPack(handle, "afile.sf2pack", "flac --best -");
            </code>
            <code lang="vbnet">
            ' open original soundfont
            Dim handle As Integer = BassMidi.BASS_MIDI_FontInit("afile.sf2")
            ' produce packed version
            BassMidi.BASS_MIDI_FontPack(handle, "afile.sf2pack", "flac --best -")
            </code>
            Using the build-in encoder framework:
            <code>
            EncoderFLAC flac = new EncoderFLAC(0);
            flac.InputFile = null;	// use STDIN 
            flac.OutputFile = null; // use STDOUT
            // produce packed version
            BassMidi.BASS_MIDI_FontPack(handle, "afile.sf2pack", flac.EncoderCommandLine);
            </code>
            <code lang="vbnet">
            Dim flac As New EncoderFLAC(0)
            flac.InputFile = Nothing ' use STDIN 
            flac.OutputFile = Nothing ' use STDOUT
            ' produce packed version
            BassMidi.BASS_MIDI_FontPack(handle, "afile.sf2pack", flac.EncoderCommandLine)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontUnpack(System.Int32,System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="outfile"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontUnpack(System.Int32,System.String)">
            <summary>
            Produces a decompressed version of a packed soundfont.
            <para>Unicode version only here (BASS_UNICODE will be used automatically).</para>
            </summary>
            <param name="handle">The soundfont to unpack.</param>
            <param name="outfile">Filename for the unpacked soundfont.</param>
            <returns>If successful, the TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>To unpack a soundfont, the appropriate BASS add-on needs to be loaded (via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>) to decode the samples. 
            For example, if the samples are FLAC encoded, BASSFLAC would need to be loaded. 
            BASS also needs to have been initialized, using <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 
            For just unpacking a soundfont, the "no sound" device could be used.
            <para><see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO)"/> can be used to check if a soundfont is packed.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The soundfont is not packed.</description></item>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called - it needs to be to decode the samples.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The appropriate add-on to decode the samples is not loaded.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>Couldn't create the output file, <paramref name="outfile"/>.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Unpack a FLAC encoded soundfont:
            <code>
            // load FLAC plugin
            Bass.BASS_PluginLoad("bassflac.dll");
            // open soundfont
            int handle = BassMidi.BASS_MIDI_FontInit("afile.sf2pack");
            // produce unpacked version
            BassMidi.BASS_MIDI_FontUnpack(handle, "afile.sf2");
            </code>
            <code lang="vbnet">
            ' load FLAC plugin
            Bass.BASS_PluginLoad("bassflac.dll")
            ' open soundfont
            Dim handle As Integer = BassMidi.BASS_MIDI_FontInit("afile.sf2pack")
            ' produce unpacked version
            BassMidi.BASS_MIDI_FontUnpack(handle, "afile.sf2")
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontLoad(System.Int32,System.Int32,System.Int32)">
            <summary>
            Preloads presets from a soundfont.
            </summary>
            <param name="handle">The soundfont handle... 0 = all soundfonts.</param>
            <param name="preset">Preset number to load... -1 = all presets.</param>
            <param name="bank">Bank number to load... -1 = all banks.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Samples are normally loaded as they are needed while rendering a MIDI stream, which can result in CPU spikes, particularly with packed soundfonts. That generally won't cause any problems, but when smooth/constant performance is critical this function can be used to preload the samples before rendering, so avoiding the need to load them while rendering.</para>
            <para>When preloading samples to render a particular MIDI stream, it is more efficient to use <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamLoadSamples(System.Int32)"/> to preload the specific samples that the MIDI stream will use, rather than preloading the entire soundfont.</para>
            <para>Preloaded samples can be compacted/unloaded just like any other samples, so it is probably wise to disable the BASS_CONFIG_MIDI_COMPACT option when preloading samples, to avoid any chance of the samples subsequently being automatically unloaded.</para>
            <para>A soundfont should not be preloaded while it's being used to render any MIDI streams, as that could delay the rendering.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The appropriate add-on to decode the samples is not loaded.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The soundfont does not contain the requested preset.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetPresetPtr(System.Int32,System.Int32,System.Int32)">
            <summary>
            Retrieves the name of a preset in a soundfont.
            </summary>
            <param name="handle"></param>
            <param name="preset"></param>
            <param name="bank"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetPreset(System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="handle">The soundfont handle to get the preset name from.</param>
            <param name="preset">Preset number to load... -1 = all presets (the first encountered).</param>
            <param name="bank">Bank number to load... -1 = all banks (the first encountered).</param>
            <returns>If successful, the requested preset name is returned, else NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The soundfont does not contain the requested preset.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontSetVolume(System.Int32,System.Single)">
            <summary>
            Sets a soundfont's volume level.
            </summary>
            <param name="handle">The soundfont to set the volume of.</param>
            <param name="volume">The volume level... 0=silent, 1.0=normal/default.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            By default, some soundfonts may be louder than others, which could be a problem when mixing multiple soundfonts. 
            This function can be used to compensate for any differences, by raising the level of the quieter soundfonts or lowering the louder ones.
            <para>Changes take immediate effect in any MIDI streams that are using the soundfont.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetVolume(System.Int32)">
            <summary>
            Retrieves a soundfont's volume level.
            </summary>
            <param name="handle">The soundfont to get the volume of.</param>
            <returns>If successful, the soundfont's volume level is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BassMidi.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bassmidi.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BassMidi.SupportedStreamName">
            <summary>
            Supported file format name of the bassmidi.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
            <example>
            Load BASS and BASSMIDI from the application's startup path:
            <code>
            Bass.LoadMe();
            BassMidi.LoadMe();
            ...
            // when not used anymore...
            BassMidi.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSMIDI from a different directory:
            <code>
            Bass.LoadMe( @"C:\Development\BASS\_libs" );
            BassMidi.LoadMe( @"C:\Development\BASS\_libs" );
            ...
            // when not used anymore...
            BassMidi.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker">
            <summary>
            The Marker type, to be used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_MARKER">
            <summary>
            Marker events.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_CUE">
            <summary>
            Cue events.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_LYRIC">
            <summary>
            Lyric events.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_TEXT">
            <summary>
            Text events.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent">
            <summary>
            The MIDI event type, to be used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> resp. <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_NOTE">
            <summary>
            Press a key.
            <para>param : LOBYTE = key number (0-127), HIBYTE = velocity (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PROGRAM">
            <summary>
            Select the preset/instrument to use. Standard soundfont presets follow the General MIDI standard, and generally also include Roland GS variations in other banks (accessible via the MIDI_EVENT_BANK event).
            <para>param : preset number (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHANPRES">
            <summary>
            Set the channel pressure.
            <para>param : pressure level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PITCH">
            <summary>
            Set the pitch wheel.
            <para>param : pitch wheel position (0-16383, 8192=normal/middle).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PITCHRANGE">
            <summary>
            Set pitch wheel range (MIDI RPN 0).
            <para>param : range in semitones.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUMS">
            <summary>
            Set the percussion/drums channel switch.
            <para>param : use drums? (0=no, 1=yes).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_FINETUNE">
            <summary>
            Set the fine tuning (MIDI RPN 1).
            <para>param : finetune in cents (0-16383, 0=-100, 8192=normal, 16383=+100).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_COARSETUNE">
            <summary>
            Set the coarse tuning (MIDI RPN 2).
            <para>param : finetune in semitones (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MASTERVOL">
            <summary>
            Set the master volume.
            <para>param : volume level (0-16383, 0=silent, 16363=normal/full).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_BANK">
            <summary>
            Select the bank to use (MIDI controller 0).
            <para>param : bank number (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MODULATION">
            <summary>
            Set the modulation (MIDI controller 1).
            <para>param : modulation level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_VOLUME">
            <summary>
            Set the volume (MIDI controller 7).
            <para>param : volume level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PAN">
            <summary>
            Set the pan position (MIDI controller 10).
            <para>param : pan position (0-127, 64=middle).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_EXPRESSION">
            <summary>
            Set the expression (MIDI controller 11).
            <para>param : expression level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_SUSTAIN">
            <summary>
            Set the sustain switch (MIDI controller 64).
            <para>param : enable sustain? (0-63=no, 64-127=yes).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_SOUNDOFF">
            <summary>
            Stop all sounds (MIDI controller 120).
            <para>param : not used.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_RESET">
            <summary>
            Reset controllers (MIDI controller 121), that is modulation=0, expression=127, sustain=0, pitch wheel=8192, channel pressure=0.
            <para>param : not used.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_NOTESOFF">
            <summary>
            Release all keys (MIDI controller 123).
            <para>param : not used.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PORTAMENTO">
            <summary>
            Set the portamento switch (MIDI controller 65).
            <para>param : enable portamento? (0-63=no, 64-127=yes).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PORTATIME">
            <summary>
            Set the portamento time (MIDI controller 5).
            <para>param : portamento time (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PORTANOTE">
            <summary>
            Set the portamento start key - the next note starts at this key (MIDI controller 84).
            <para>param : key number (1-127, 60=middle C).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MODE">
            <summary>
            Set poly/mono mode (MIDI controllers 126 &amp; 127).
            <para>param : mode (0=poly, 1=mono).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB">
            <summary>
            Set the reverb send level (MIDI controller 91).
            <para>param : reverb level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS">
            <summary>
            Set the chorus send level (MIDI controller 93).
            <para>param : chorus level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CUTOFF">
            <summary>
            Set the low-pass filter cutoff (MIDI controller 74, NRPN 120h).
            <para>param : cutoff level (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_RESONANCE">
            <summary>
            Set the low-pass filter resonance (MIDI controller 71, NRPN 121h).
            <para>param : resonance level (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB_MACRO">
            <summary>
            To be defined.
            <para>param : to be defined.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_MACRO">
            <summary>
            To be defined.
            <para>param : to be defined.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB_TIME">
            <summary>
            Set the reverb time.
            <para>param : reverb time in milliseconds.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB_DELAY">
            <summary>
            Set the reverb delay.
            <para>param : reverb delay in millisecond 10ths.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB_LOCUTOFF">
            <summary>
            Set the reverb low-pass cutoff.
            <para>param :  reverb low-pass cutoff in hertz (0=off).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB_HICUTOFF">
            <summary>
            Set the reverb high-pass cutoff.
            <para>param : reverb high-pass cutoff in hertz (0=off).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB_LEVEL">
            <summary>
            Set the reverb level.
            <para>param : reverb level (0=off, 100=0dB, 200=+6dB).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_DELAY">
            <summary>
            Set the chorus delay.
            <para>param : chorus delay in millisecond 10ths.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_DEPTH">
            <summary>
            Set the chorus depth.
            <para>param : chorus depth in millisecond 10ths.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_RATE">
            <summary>
            Set the chorus rate.
            <para>param : chorus rate in hertz 100ths.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_FEEDBACK">
            <summary>
            Set the chorus feedback level.
            <para>param : chorus feedback level (0=-100%, 100=off, 200=+100%).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_LEVEL">
            <summary>
            Set the chorus level.
            <para>param : chorus level (0=off, 100=0dB, 200=+6dB).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_REVERB">
            <summary>
            Set the chorus send to reverb level.
            <para>param : chorus send to reverb level (0=off, 100=0dB, 200=+6dB).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_FINETUNE">
            <summary>
            Set the fine tuning of a drum key (MIDI NRPN 19knh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = finetune in cents (0-127, 0=-100, 64=normal, 127=+100).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_COARSETUNE">
            <summary>
            Set the coarse tuning of a drum key (MIDI NRPN 18knh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = finetune in semitones (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_PAN">
            <summary>
            Set the pan position of a drum key (MIDI NRPN 1Cknh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = pan position (0-127, 0=random, 64=middle).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_REVERB">
            <summary>
            Set the reverb send level of a drum key (MIDI NRPN 1Dknh).
            <para>param :  LOBYTE = key number (0-127), HIBYTE = reverb level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_CHORUS">
            <summary>
            Set the chorus send level of a drum key (MIDI NRPN 1Eknh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = chorus level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_CUTOFF">
            <summary>
            Set the low-pass filter cutoff of a drum key (MIDI NRPN 14knh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = cutoff level (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_RESONANCE">
            <summary>
            Set the low-pass filter resonance of a drum key (MIDI NRPN 15knh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = resonance level (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_TEMPO">
            <summary>
            Set the tempo (MIDI meta event 81). Changing the tempo affects the stream length, and the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> value will no longer be valid.
            <para>param : tempo in microseconds per quarter note.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MIXLEVEL">
            <summary>
            Set the level.
            <para>param : the level (0=silent, 100=0dB, 200=+6dB).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_TRANSPOSE">
            <summary>
            Transpose all notes. Changes take effect from the next note played, and affect melodic channels only (not drum channels).
            <para>param : transposition amount in semitones (0=-100, 100=normal, 200=+100).</para>
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO)"/> to retrieve information on a soundfont.
            </summary>
            <remarks>
            The name, copyright and comment members can be NULL if the soundfont file does not include that information.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.name">
            <summary>
            Name of the soundfont.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.copyright">
            <summary>
            Copyright notice.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.comment">
            <summary>
            Any comments.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.presets">
            <summary>
            The number of presets/instruments in the soundfont.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.samsize">
            <summary>
            The total size (in bytes) of the sample data in the soundfont.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.samload">
            <summary>
            The amount of sample data currently loaded.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.samtype">
            <summary>
            The BASS_CTYPE_STREAM_xxx format of the sample data if it's packed... -1 = unknown format (appropriate BASS add-on not loaded), 0 = not packed.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.ToString">
            <summary>
            A description of the soundfont info object (name, copyright, comment, size etc.)
            </summary>
            <returns>The string description of the soundfont info object.</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/> to set and retrieve soundfont configurations.
            </summary>
            <remarks>When using an individual preset from a soundfont, BASSMIDI will first look for the exact preset and bank match, but if that's not present, the first preset from the soundfont will be used. This is useful for single preset soundfonts.
            <para>When using all presets in a soundfont, the bank member is a base number that's added to the soundfont's banks. For example, if bank=1 then the soundfont's bank 0 becomes bank 1, etc... Negative base numbers are allowed.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT.font">
            <summary>
            Soundfont handle, previously inititialized with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT.preset">
            <summary>
            Preset number... -1 = use all presets in the soundfont.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT.bank">
            <summary>
            Base bank number, or the bank number of the individual preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Font">The soundfont handle to use.</param>
            <param name="Preset">The preset number to use (-1=use all presets).</param>
            <param name="Bank">The bank number to use.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT.ToString">
            <summary>
            A description of the soundfont configuration object (font, preset, bank)
            </summary>
            <returns>The description string of the soundfont configuration object.</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/>, <see cref="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_LYRIC"/>, <see cref="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_CUE"/> and <see cref="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_MARKER"/> to retrieve markers.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK.track">
            <summary>
            The MIDI track (number) containing marker (0=first).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK.pos">
            <summary>
            The position (in bytes) of the marker.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK.text">
            <summary>
            The marker, cue or lyric text.
            </summary>
            <remarks>If the lyric text begins with a '/' (slash) character, a new line should be started. 
            If it begins with a '\' (backslash) character, the display should be cleared.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Track">The track (number) containing marker.</param>
            <param name="Pos">The position (in bytes) of the marker.</param>
            <param name="Text">The marker text.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK.ToString">
            <summary>
            A description of the marker object (the text).
            </summary>
            <returns>The marker description text.</returns>
        </member>
        <member name="T:Un4seen.Bass.SplashScreen">
            <summary>
            BASS.NET Splash Screen.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.SplashScreen.#ctor(System.Boolean,System.Int32)">
            <summary>
            BASS.NET Splash Screen constructor.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Ape.BassApe">
            <summary>
            BASS.NET API wrapper for BASS_APE.DLL
            <para>Requires: bass_ape.dll - Monkey's Audio Codec (APE) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_APE is an extension to the BASS audio library, enabling the playback of Monkey's Audio files.</para>
            <para>Monkey's Audio is a fast and powerful way to compress digital music. Unlike traditional methods, such as MP3, Vorbis or WMA which permanently discard quality to save space, Monkey's Audio makes perfect, lossless copies of your music, while still being able to save a lot of space.</para>
            <para>The Monkey's Audio format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/URL/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Ape.BassApe.BASS_APE_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> /URL/User functions.</para>
            <para>More information can be found on <a href="http://www.monkeysaudio.com">www.monkeysaudio.com</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.BASS_APE_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.BASS_APE_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Monkey's Audio file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.BASS_APE_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.BASS_APE_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Monkey's Audio memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.BASS_APE_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a Monkey's Audio file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Ape.BassApe.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_ape.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Ape.BassApe.SupportedStreamName">
            <summary>
            Supported file format name of the bass_ape.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Ape.BassApe.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Ape.BassApe.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.BassVst">
            <summary>
            BASS.NET API wrapper for BASS_VST.DLL
            <para>Requires: bass_vst.dll - VST plugin support Add-On.</para>
            </summary>
            <remarks>
            <para>BASS_VST allows the usage of VST effect plugins as well as VST instruments (VSTi plugins) with BASS.</para>
            <para>VST PlugIn Technology by Steinberg Media Technologies GmbH.</para>
            <para>(C) Bjoern Petersen Software Design'n'Development, Hamburg, Germany.
            Contact: drsilver@silverjuke.net - <a href="http://www.silverjuke.net">www.silverjuke.net</a>.</para>
            <para>Redistribution of this package is allowed if all files stay intact.
            However, there is no guarantee, that all VST plugins might really work - just try them out.</para>
            <para>BASS_VST is VST host compatible up to the new VST 2.4 implementation and (hopefully) implements all needed features - 
            incl. the new double precision processing.</para>
            <para>Note that BASS_VST only loads realtime VST effects with at least 1 Input and 1 Output (stereo effects will typically have at least 2 In and 2 Out).</para>
            <para>While the normal usage is very easy (only one function - <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/> - is really needed), 
            BASS_VST also allowed advanced usage of the VST features - incl. embedding an editor or subclassing the whole library.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSPUnicode(System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="dllFile"></param>
            <param name="flags"></param>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)">
            <summary>
            Assigns a VST effects (defined by a DLL file name) to any BASS channels.
            <para>This overload implements the Unicode overload for the dllFile name, so the BASS_UNICODE flag will automatically be added if not already set.</para>
            </summary>
            <param name="chan">The channel handle... a HSTREAM, HMUSIC, or HRECORD. Or 0, if you want to test, if the dll is a valid VST plugin.</param>
            <param name="dllFile">The fully qualified path and file name to the VST effect plugin (a DLL file name).</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Vst.BASSVSTDsp"/>):
            <list type="table">
            <item><term>BASS_VST_KEEP_CHANS</term><description>By default, mono effects assigned to stereo channels are mixed down before processing and converted back to stereo afterwards. Set this flag to avoid this behaviour in which case only the first channel is affected by processing.</description></item>
            <item><term>BASS_UNICODE</term><description>dllFile is Unicode (16-bit characters) (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="priority">Same meaning as for <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/> - DSPs with higher priority are called before those with lower.</param>
            <returns>On success, the method returns the new vstHandle that must be given to all the other functions, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The VST plugin is implemented via a DSP callback on the channel. That means when you play the channel (or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> if it's a decoding channel), the sample data will be sent to the VST effect at the same time.
            If the channel is freed all DSPs are removed automatically, also all VST DSPs are removed as well. If you want or need to free the VST DSP manually you can call <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelRemoveDSP(System.Int32,System.Int32)"/>.
            <para>For testing if a DLL is a valid VST effect, you can set chan to 0 - however, do not forget to call <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelRemoveDSP(System.Int32,System.Int32)"/> even in this case.</para>
            <para>You may safely assign the same DLL to different channels at the same time - the library makes sure, every channel is processed indepeningly. But take care to use the correct vstHandles in this case.</para>
            <para>Finally, you can use any number of VST effects on a channel. They are processed alongside with all other BASS DSPs in the order of it's priority.</para>
            <para>To set or get the parameters of a VST effect you might use <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamCount(System.Int32)"/> alongside with <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParam(System.Int32,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetParam(System.Int32,System.Int32,System.Single)"/> to enumerate over the total number of effect parameters.
            To retrieve details about an individual parameter you might use <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamInfo(System.Int32,System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO)"/>.
            If the VST effect supports an embedded editor you might also invoke this one with <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_EmbedEditor(System.Int32,System.IntPtr)"/>. If the embedded editor also supports localization you might set the language in advance with <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetLanguage(System.String)"/>.</para>
            <para>If you need to temporarily bypass the VST effect you might call <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetBypass(System.Int32,System.Boolean)"/> - <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetBypass(System.Int32)"/> will tell you the current bypass status though.</para>
            <para>Use <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/> to get even more details about a loaded VST plugin.</para>
            </remarks>
            <example>
            <code>
            // create any stream 
            int stream = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_SAMPLE_FLOAT);
            // and assign a VST effect
            int vstHandle = BassVst.BASS_VST_ChannelSetDSP(stream, 
                                    "C:\\VstPlugins\\DelayEditGUI.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1);
            // and play the stream
            Bass.BASS_ChannelPlay(stream, false);
            ...
            // if the VST effect is not needed anymore...
            BassVst.BASS_VST_ChannelRemoveDSP(stream, vstHandle);
            </code>
            <code lang="vbnet">
            ' create any stream 
            Dim stream As Integer = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_SAMPLE_FLOAT)
            ' and assign a VST effect
            Dim vstHandle As Integer = BassVst.BASS_VST_ChannelSetDSP(stream, 
                                               "C:\VstPlugins\DelayEditGUI.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1)
            ' and play the stream
            Bass.BASS_ChannelPlay(stream, False)
            ...
            ' if the VST effect is not needed anymore...
            BassVst.BASS_VST_ChannelRemoveDSP(stream, vstHandle)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelRemoveDSP(System.Int32,System.Int32)">
            <summary>
            Removes a VST effect from a channel and destroys the VST instance.
            </summary>
            <param name="chan">The channel handle from which to remove the VST effect... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If you do not call <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelRemoveDSP(System.Int32,System.Int32)"/> explicitly and you have assigned a channel to the effect, the effect is removed automatically when the channel handle is deleted by BASS (like for any other DSP as well).</para>
            <para>For various reasons, the underlying DLL is unloaded from memory with a little delay, however, this has also the advantage that subsequent adding/removing of DLLs to channels has no bad performance impact.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelCreateUnicode(System.Int32,System.Int32,System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="freq"></param>
            <param name="chans"></param>
            <param name="dllFile"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelCreate(System.Int32,System.Int32,System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a new BASS stream based on any VST instrument plugin (VSTi).
            <para>This overload implements the Unicode overload for the dllFile name, so the BASS_UNICODE flag will automatically be added if not already set.</para>
            </summary>
            <param name="freq">The sample rate of the VSTi output (e.g. 44100).</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1.</param>
            <param name="dllFile">The fully qualified path and file name to the VSTi plugin (a DLL file name).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Produce 32-bit floating-point output. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See Floating-point channels for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing. Note this only applies to playback of the mixer's output - the mixing of the source channels is always performed by BASSmix.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the DX8 effect implementations section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description>Speaker assignment flags.</description></item>
            </list>
            </param>
            <returns>If successful, the new vst handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>On success, the function returns the new vstHandle that must be given to
            the other functions.  The returned VST handle can also be given to the typical BASS_Channel* functions.
            Use <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelFree(System.Int32)"/> to deletes and free a VST instrument channel.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelFree(System.Int32)">
            <summary>
            Deletes and frees a VST instrument channel.
            </summary>
            <param name="vstHandle">The VSTi channel to delete (as created by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelCreate(System.Int32,System.Int32,System.String,Un4seen.Bass.BASSFlag)"/>).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Note, that you cannot delete VST effects assigned to this channels this way; for this purpose, please call <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelRemoveDSP(System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ProcessEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)">
            <summary>
            Sends a MIDI message/event to the VSTi plugin.
            </summary>
            <param name="vstHandle">The VSTi channel to send a MIDI message to (as created by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelCreate(System.Int32,System.Int32,System.String,Un4seen.Bass.BASSFlag)"/>).</param>
            <param name="midiCh">The Midi channel number to use (0 to 15).</param>
            <param name="eventtype">The Midi event/status value to use (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details).</param>
            <param name="param">The data bytes to send with the message (use <see cref="M:Un4seen.Bass.Utils.MakeWord(System.Byte,System.Byte)"/> to compose a data byte 1 and 2).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Use one of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> commands similar to <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/>.
            <para>Set <paramref name="midiCh"/> to 0xFFFF and <paramref name="eventtype"/> to the raw command to send. 
            The raw command must be encoded as 0x00xxyyzz with xx=MIDI command, yy=MIDI databyte #1, zz=MIDI databyte #2. <paramref name="param"/> should be set to 0 in this case.
            </para>
            <para>Send SysEx commands by setting <paramref name="midiCh"/> to 0xEEEE. 
            <paramref name="event"/> must be set to a pointer to the bytes to send and <paramref name="param"/> must be set to the number of bytes to send.
            </para>
            </remarks>
            <example>
            <code>
            using Un4seen.Bass.AddOn.Vst;
            using Un4seen.Bass.AddOn.Midi;
            
            int vstHandle = BassVst.BASS_VST_ChannelCreate(44100, 2, "yourVSTi.dll", BASSFlag.BASS_DEFAULT);
            BassVst.BASS_VST_ProcessEvent(vstHandle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, Utils.MakeWord(60, 100));
            </code>
            <code lang="vbnet">
            Imports Un4seen.Bass.AddOn.Vst
            Imports Un4seen.Bass.AddOn.Midi
            
            Dim vstHandle As Integer = BassVst.BASS_VST_ChannelCreate(44100, 2, "yourVSTi.dll", BASSFlag.BASS_DEFAULT)
            BassVst.BASS_VST_ProcessEvent(vstHandle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, Utils.MakeWord(60, 100))
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ProcessEventRaw(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sends a SysEx or MIDI (short)message/event to the VSTi plugin.
            </summary>
            <param name="vstHandle">The VSTi channel to send a MIDI message to (as created by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelCreate(System.Int32,System.Int32,System.String,Un4seen.Bass.BASSFlag)"/>).</param>
            <param name="msg">The pointer to your Midi message data to send (byte[]).</param>
            <param name="length">The length of a SysEx message or 0 in case of a normal Midi (short)message.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>To send a Midi (short)message : 
            The raw message must be encoded as 0x00xxyyzz with xx=MIDI command, yy=MIDI databyte #1, zz=MIDI databyte #2. <paramref name="length"/> should be set to 0 in this case.
            </para>
            <para>To send a SysEx message:
            <paramref name="msg"/> must be set to a pointer to the bytes to send and <paramref name="length"/> must be set to the number of bytes to send.
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ProcessEventRaw(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Sends a SysEx or MIDI (short)message/event to the VSTi plugin.
            </summary>
            <param name="vstHandle">The VSTi channel to send a MIDI message to (as created by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelCreate(System.Int32,System.Int32,System.String,Un4seen.Bass.BASSFlag)"/>).</param>
            <param name="msg">The byte array containing your Midi message data to send.</param>
            <param name="length">The length of a SysEx message or 0 in case of a normal Midi (short)message.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>To send a Midi (short)message : 
            The raw message must be encoded as 0x00xxyyzz with xx=MIDI command, yy=MIDI databyte #1, zz=MIDI databyte #2. <paramref name="length"/> should be set to 0 in this case.
            </para>
            <para>To send a SysEx message:
            <paramref name="msg"/> must be set to a pointer to the bytes to send and <paramref name="length"/> must be set to the number of bytes to send.
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ProcessEventRaw(System.Int32,Ten53.Multimedia.Midi.MidiShortMessage)">
            <summary>
            Sends a MIDI (short)message to the VSTi plugin.
            </summary>
            <param name="vstHandle">The VSTi channel to send a MIDI message to (as created by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelCreate(System.Int32,System.Int32,System.String,Un4seen.Bass.BASSFlag)"/>).</param>
            <param name="msg">The already constructed MIDI short message to send.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ProcessEventRaw(System.Int32,Ten53.Multimedia.Midi.MidiSysExMessage)">
            <summary>
            Sends a MIDI system exclusive message to the VSTi plugin.
            </summary>
            <param name="vstHandle">The VSTi channel to send a MIDI message to (as created by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelCreate(System.Int32,System.Int32,System.String,Un4seen.Bass.BASSFlag)"/>).</param>
            <param name="msg">The already constructed MIDI system exclusive message to send.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Do NOT prepare the message with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>!</remarks>
            <example>
            <code>
            using Un4seen.Bass.AddOn.Vst;
            using Un4seen.Bass.AddOn.Midi;
            
            int vstHandle = BassVst.BASS_VST_ChannelCreate(44100, 2, "yourVSTi.dll", BASSFlag.BASS_DEFAULT);
            
            // create a new system-exclusive message
            MidiSysExMessage sysex = new MidiSysExMessage(false, IntPtr.Zero);
            // message will be 8 byte (incl. SoX and EoX)
            sysex.CreateBuffer(8);
            // write start-of-system-exclusive
            sysex.MessageWriteSoX();
            int offset = 1;
            // write 6 more bytes...
            sysex.MessageWrite8(ref offset, 65);
            sysex.MessageWrite16(ref offset, 1023);
            sysex.MessageWrite16(ref offset, 13);
            sysex.MessageWrite8(ref offset, 1);
            // write end-of-system-exusive
            sysex.MessageWriteEoX();
            
            BassVst.BASS_VST_ProcessEvent(vstHandle, sysex);
            </code>
            <code lang="vbnet">
            Imports Un4seen.Bass.AddOn.Vst
            Imports Un4seen.Bass.AddOn.Midi
            
            Dim vstHandle As Integer = BassVst.BASS_VST_ChannelCreate(44100, 2, "yourVSTi.dll", BASSFlag.BASS_DEFAULT)
            
            ' create a new system-exclusive message
            Dim sysex As New MidiSysExMessage(False, IntPtr.Zero)
            ' message will be 8 byte (incl. SoX and EoX)
            sysex.CreateBuffer(8)
            ' write start-of-system-exclusive
            sysex.MessageWriteSoX()
            Dim offset As Integer = 1
            ' write 6 more bytes...
            sysex.MessageWrite8(offset, 65)
            sysex.MessageWrite16(offset, 1023)
            sysex.MessageWrite16(offset, 13)
            sysex.MessageWrite8(offset, 1)
            ' write end-of-system-exusive
            sysex.MessageWriteEoX()
            
            BassVst.BASS_VST_ProcessEvent(vstHandle, sysex)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamCount(System.Int32)">
            <summary>
            Returns the number of editable parameters for the VST effect.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <returns>The number of editable parameters or if the effect has no editable parameters, 0 is returned.</returns>
            <remarks>
            <para>To set or get the individual parameters of a VST effect you might use <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamCount(System.Int32)"/> alongside with <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParam(System.Int32,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetParam(System.Int32,System.Int32,System.Single)"/> to enumerate over the total number of effect parameters.
            To retrieve details about an individual parameter you might use <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamInfo(System.Int32,System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO)"/>.
            If the VST effect supports an embedded editor you might also invoke this one with <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_EmbedEditor(System.Int32,System.IntPtr)"/>. If the embedded editor also supports localization you might set the language in advance with <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetLanguage(System.String)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParam(System.Int32,System.Int32)">
            <summary>
            Get the value of a single VST effect parameter.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="paramIndex">The index of the parameter (must be smaller than <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamCount(System.Int32)"/>).</param>
            <returns>TRUE on success.</returns>
            <remarks>
            <para>All VST effect parameters are in the range from 0.0 to 1.0 (float), however, from the view of a VST effect, they may represent completely different values.
            E.g. some might represent a multiplier to some internal constants and will result in number of samples or some might represent a value in dB etc.</para>
            <para>You can use <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamInfo(System.Int32,System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO)"/> to get further information about a single parameter, which will also present you with the current value in a readable format.</para>
            </remarks>
            <example>
            List all parameters and values of a loaded VST effect:
            <code>
            // assign and load the VST effect
            vstHandle = BassVst.BASS_VST_ChannelSetDSP(_stream, 
                                "C:\\VstPlugins\\DelayEditGUI.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1);
            // get the total number of parameters
            int vstParams = BassVst.BASS_VST_GetParamCount(vstHandle);
            // create a paramInfo object
            BASS_VST_PARAM_INFO paramInfo = new BASS_VST_PARAM_INFO();
            for (int i=0; i&lt;vstParams; i++)
            {
              // get the info about the parameter
              float paramValue = BassVst.BASS_VST_GetParam(vstHandle, i);
              Console.WriteLine( paramValue.ToString() );
            
              // and get further info about the parameter
              BassVst.BASS_VST_GetParamInfo(vstHandle, i, paramInfo);
              Console.WriteLine( paramInfo.ToString() );
            }
            </code>
            <code lang="vbnet">
            ' assign and load the VST effect
            vstHandle = BassVst.BASS_VST_ChannelSetDSP(_stream, 
                                "C:\VstPlugins\DelayEditGUI.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1)
            ' get the total number of parameters
            Dim vstParams As Integer = BassVst.BASS_VST_GetParamCount(vstHandle)
            ' create a paramInfo object
            Dim paramInfo As New BASS_VST_PARAM_INFO()
            Dim i As Integer
            For i = 0 To vstParams - 1
              ' get the info about the parameter
              Dim paramValue As Single = BassVst.BASS_VST_GetParam(vstHandle, i)
              Console.WriteLine(paramValue.ToString())
            
              ' and get further info about the parameter
              BassVst.BASS_VST_GetParamInfo(vstHandle, i, paramInfo)
              Console.WriteLine(paramInfo.ToString())
            Next i
            </code>
            The output from the above might look like this:
            <code lang="none">
            0,5
            Delay =   22049 samples
            0,5
            FeedBack = 0.500000 amount
            0,75
            Volume = -2.49877 dB
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetParam(System.Int32,System.Int32,System.Single)">
            <summary>
            Set a value of a single VST effect parameter.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="paramIndex">The index of the parameter (must be smaller than <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamCount(System.Int32)"/>).</param>
            <param name="newValue"></param>
            <returns>TRUE on success.</returns>
            <remarks>
            <para>All VST effect parameters are in the range from 0.0 to 1.0 (float), however, from the view of a VST effect, they may represent completely different values.
            E.g. some might represent a multiplier to some internal constants and will result in number of samples or some might represent a value in dB etc.</para>
            <para>So it is a good idea to call <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamInfo(System.Int32,System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO)"/> after you modified a parameter, in order to to get further information about the parameter in question, which will also present you with the current value in a readable format.</para>
            </remarks>
            <example>
            <code>
            // assign and load the VST effect
            vstHandle = BassVst.BASS_VST_ChannelSetDSP(_stream, 
                                "C:\\VstPlugins\\DelayEditGUI.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1);
            
            // create a paramInfo object
            BASS_VST_PARAM_INFO paramInfo = new BASS_VST_PARAM_INFO();
            // set a parameter with index number 1 to 0.7
            BassVst.BASS_VST_SetParam(vstHandle, 1, 0.75);
            // and get the info about the parameter back, so that we know how is looks like in a readable format
            BassVst.BASS_VST_GetParamInfo(vstHandle, i, paramInfo);
            Console.WriteLine(String.Format( "{0} = {1} {2}", paramInfo.name, paramInfo.display, paramInfo.unit));
            // this might look like this: "Volume = -2.49877 dB"
            </code>
            <code lang="vbnet">
            ' assign and load the VST effect
            vstHandle = BassVst.BASS_VST_ChannelSetDSP(_stream, 
                                "C:\VstPlugins\DelayEditGUI.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1)
            
            ' create a paramInfo object
            Dim paramInfo As New BASS_VST_PARAM_INFO()
            ' set a parameter with index number 1 to 0.7
            BassVst.BASS_VST_SetParam(vstHandle, 1, 0.75)
            ' and get the info about the parameter back, so that we know how is looks like in a readable format
            BassVst.BASS_VST_GetParamInfo(vstHandle, i, paramInfo)
            Console.WriteLine([String].Format("{0} = {1} {2}", paramInfo.name, paramInfo.display, paramInfo.unit))
            ' this might look like this: "Volume = -2.49877 dB"
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamInfo(System.Int32,System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO)">
            <summary>
            Get some common information about an editable parameter to a <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO"/> class.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="paramIndex">The index of the parameter (must be smaller than <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamCount(System.Int32)"/>).</param>
            <param name="ret">An instance of the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO"/> where to store the parameter information at.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamInfo(System.Int32,System.Int32)">
            <summary>
            Get some common information about an editable parameter to a <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO"/> class.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="paramIndex">The index of the parameter (must be smaller than <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamCount(System.Int32)"/>).</param>
            <returns>If successful, an instance of the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO"/> is returned, else NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramCount(System.Int32)">
            <summary>
            Returns the number of editable programs for the VST effect.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <returns>The number of available programs or 0 if no program is available.</returns>
            <remarks>Many (not all!) effects have more than one "program" that
            can hold a complete set of parameters each.  Moreover, some of these 
            programs may be initialized to some useful "factory defaults".
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgram(System.Int32)">
            <summary>
            Returns the currently selected program for the VST effect.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <returns>The currect selected program number. Valid program numbers are between 0 and <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramCount(System.Int32)"/> minus 1.</returns>
            <remarks>After construction (<see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>), always the first program (0) is selected.
            <para>With <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetProgram(System.Int32,System.Int32)"/> you can change the selected program. Functions as <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetParam(System.Int32,System.Int32,System.Single)"/> will always change the selected program's settings.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetProgram(System.Int32,System.Int32)">
            <summary>
            Sets (changes) the selected program for the VST effect.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="programIndex">The program number to set (between 0 and <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramCount(System.Int32)"/> minus 1.).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>You might call <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramCount(System.Int32)"/> to check, if the VST effect has any editable programs available.
            <para>With <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgram(System.Int32)"/> you can check, which is the current selected program. Functions as as <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetParam(System.Int32,System.Int32,System.Single)"/> will always change the selected program's settings.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramParamPtr(System.Int32,System.Int32)">
            <summary>
            Returns a list parameter values of any program of a VST effect.
            </summary>
            <param name="vstHandle"></param>
            <param name="programIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramParam(System.Int32,System.Int32)">
            <summary>
            Returns the parameters of a given program.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="programIndex">The program number for which to query the parameter values, must be smaller than <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramCount(System.Int32)"/>.</param>
            <returns>An array of float values representing the parameter values of the given program or NULL if the program (VST effect) has no parameters or an error occurred.</returns>
            <remarks>
            <para>The parameters of the currently selected program can also be queried by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParam(System.Int32,System.Int32)"/>.</para>
            <para>The function returns the parameters as an array of floats. The number of elements in the returned array is equal to <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamCount(System.Int32)"/>.</para>
            <para>If you set programIndex to -1, you can retrieve the effect's default values (these are the same values as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamInfo(System.Int32,System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO)"/>).</para>
            <para>This function does not change the selected program!</para>
            </remarks>
            <example>
            List all parameter values of a certain program:
            <code>
            vstHandle = BassVst.BASS_VST_ChannelSetDSP(_stream, 
                                "C:\\VstPlugins\\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1 );
            // get the number of available programs
            int vstProgCount = BassVst.BASS_VST_GetProgramCount(vstHandle);
            if (vstProgCount &gt; 1)
            {
              // as an example get the parameters of program #1 (selected should be #0 in this case)
              float[] progParams = BassVst.BASS_VST_GetProgramParam(vstHandle, 1);
              if (progParams != null)
              {
                BASS_VST_PARAM_INFO paramInfo = new BASS_VST_PARAM_INFO();
                // loop over all paramter
                for (int i=0; i&lt;progParams.Length; i++)
                {
                  // get the program's value
                  float paramValue = progParams[i];
                  // qurey the info to get the parameter name
                  BassVst.BASS_VST_GetParamInfo(vstHandle, i, paramInfo);
            
                  Console.WriteLine( String.Format( "{0} = {1}", paramInfo.name, paramValue ) );
                }
              }
            }
            </code>
            <code lang="vbnet">
            vstHandle = BassVst.BASS_VST_ChannelSetDSP(_stream, 
                                "C:\VstPlugins\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1)
            ' get the number of available programs
            Dim vstProgCount As Integer = BassVst.BASS_VST_GetProgramCount(vstHandle)
            If vstProgCount &gt; 1 Then
              ' as an example get the parameters of program #1 (selected should be #0 in this case)
              Dim progParams As Single() = BassVst.BASS_VST_GetProgramParam(vstHandle, 1)
              If Not (progParams Is Nothing) Then
                Dim paramInfo As New BASS_VST_PARAM_INFO()
                ' loop over all paramter
                Dim i As Integer
                For i = 0 To progParams.Length - 1
                  ' get the program's value
                  Dim paramValue As Single = progParams(i)
                  ' qurey the info to get the parameter name
                  BassVst.BASS_VST_GetParamInfo(vstHandle, i, paramInfo)
            
                  Console.WriteLine([String].Format("{0} = {1}", paramInfo.name, paramValue))
                Next i
              End If
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetProgramParam(System.Int32,System.Int32,System.Single[])">
            <summary>
            Set all parameters of any program in a VST effect.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="programIndex">The program number for which to set the parameter values, must be smaller than <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramCount(System.Int32)"/>.</param>
            <param name="param">An array with the parameter values to set. The array needs to have as many elements as defined by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamCount(System.Int32)"/> or as returned be <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramParam(System.Int32,System.Int32)"/>.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function does not change the selected program!
            <para>If you use <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetCallback(System.Int32,Un4seen.Bass.AddOn.Vst.VSTPROC,System.IntPtr)"/>, the BASS_VST_PARAM_CHANGED event is only posted if you select a program with parameters different from the prior.</para>
            </remarks>
            <example>
            Copy all parameters from the current program to program #3:
            <code>
            // get the current program number
            int vstCurrProg = BassVst.BASS_VST_GetProgram(vstHandle);
            // query all parameter values of the current program
            float[] prog0Params = BassVst.BASS_VST_GetProgramParam(vstHandle, vstCurrProg);
            // query all parameter values of the program #3
            float[] prog1aParams = BassVst.BASS_VST_GetProgramParam(vstHandle, 3);
            // copy all parameters from the current program to #3
            bool ok = BassVst.BASS_VST_SetProgramParam(vstHandle, 3, prog0Params);
            // and query all parameter values of the program #3 again...
            float[] prog1bParams = BassVst.BASS_VST_GetProgramParam(vstHandle, 3);
            </code>
            <code lang="vbnet">
            ' get the current program number
            Dim vstCurrProg As Integer = BassVst.BASS_VST_GetProgram(vstHandle)
            ' query all parameter values of the current program
            Dim prog0Params As Single() = BassVst.BASS_VST_GetProgramParam(vstHandle, vstCurrProg)
            ' query all parameter values of the program #3
            Dim prog1aParams As Single() = BassVst.BASS_VST_GetProgramParam(vstHandle, 3)
            ' copy all parameters from the current program to #3
            Dim ok As Boolean = BassVst.BASS_VST_SetProgramParam(vstHandle, 3, prog0Params)
            ' and query all parameter values of the program #3 again...
            Dim prog1bParams As Single() = BassVst.BASS_VST_GetProgramParam(vstHandle, 3)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramName(System.Int32,System.Int32)">
            <summary>
            Gets the name of any program of a VST effect.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="programIndex">The program number for which to get the name, must be smaller than <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramCount(System.Int32)"/>.</param>
            <returns>The name of the program given or NULL if not valid.</returns>
            <remarks>The names are limited to 24 characters. This function does not change the selected program!</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramNames(System.Int32)">
            <summary>
            Returns a list of all available program names.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <returns>An array of strings representing the list of available program names. The index corresponds to the program numbers.</returns>
            <remarks>You might use this method to enumerate over all programs or to initialize a menu for example.
            <para>This function does not change the selected program!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetProgramName(System.Int32,System.Int32,System.String)">
            <summary>
            Sets the name of any program of a VST effect.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="programIndex">The program number for which to set the name, must be smaller than <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetProgramCount(System.Int32)"/>.</param>
            <param name="name">The new name to use. Names are limited to 24 characters, BASS_VST truncates the names, if needed.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function does not change the selected program!</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetParamRestoreDefaults(System.Int32)">
            <summary>
            Restores all default values for all VST effect parameters (on the current selected program).
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <remarks>Internally all default values for all parameters are retried <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamInfo(System.Int32,System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO)"/>.</remarks>
            <example>
            <code>
            // assign a Vst effect to a channel
            int vst = BassVst.BASS_VST_ChannelSetDSP(_stream, 
                              "C:\\VstPlugins\\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 0);
            
            // change some parameters (e.g. #1 to 0.75)
            BassVst.BASS_VST_SetParam(vst, 1, 0.75f);
            
            // restore all parameters to it's default values
            BassVst.BASS_VST_SetParamRestoreDefaults(vst);
            </code>
            <code lang="vbnet">
            ' assign a Vst effect to a channel
            Dim vst As Integer = BassVst.BASS_VST_ChannelSetDSP(_stream, 
                                         "C:\VstPlugins\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 0)
            
            ' change some parameters (e.g. #1 to 0.75)
            BassVst.BASS_VST_SetParam(vst, 1, 0.75F)
            
            ' restore all parameters to it's default values
            BassVst.BASS_VST_SetParamRestoreDefaults(vst)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetParamCopyParams(System.Int32,System.Int32)">
            <summary>
            Copies all parameters from one vstHandle to another one.
            <para>Both vstHandles must be of the same VST effect plugin!</para>
            </summary>
            <param name="sourceVstHandle">The source VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/> from where to copy the parameters.</param>
            <param name="destinVstHandle">The destination VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/> to where the parameters should be copied.</param>
            <remarks>Copying parameters might be useful, if you created multiple instances of a VST effect plugin (e.g. for different channels).</remarks>
            <example>
            For crossfadings, you might use several BASS channels for playback - each should have the same VST-effects of course.
            So changes done in the VST-editor need to be applied to several channels under some circumstances - on the other hand, if the player is stopped and no channel is available, the VST-editor should still be accessible.
            <code>
            private VSTPROC _myVstProc; // make global, so GC will not collect it
            private int vst1;
            private int vst2;
            private int ch1;
            private int ch2;
            ...
            // create the 'real' channels to use
            ch1 = BASS_StreamCreateFile(...);
            vst1 = BassVst.BASS_VST_ChannelSetDSP(0, 
                           "C:\\VstPlugins\\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1);
            ch2 = BASS_StreamCreateFile(...);
            vst2 = BassVst.BASS_VST_ChannelSetDSP(0, 
                           "C:\\VstPlugins\\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1);
            
            // create an 'unchanneled' VST-editor
            int vstDummy = BassVst.BASS_VST_ChannelSetDSP(0, 
                                   "C:\\VstPlugins\\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 0);
            
            // we want to be notified about parameter changes ...
            myVstProc = new VSTPROC(vstEditorCallback);
            BassVst.BASS_VST_SetCallback(vstDummy, myVstProc, IntPtr.Zero);
            
            // so when the user opens the VST-editor this is being called
            public int vstEditorCallback(int vstDummy, int action, int param1, int param2, IntPtr user)
            {
                if (action == BASS_VST_PARAM_CHANGED)
                {
                    // the user has changed some slider in the unchanneled editor
                    // copy the changes to the 'real' channels
                    BassVst.BASS_VST_SetParamCopyParams(vstDummy, vst1);
                    BassVst.BASS_VST_SetParamCopyParams(vstDummy, vst2);
                }
                return 0;  
            }
            </code>
            <code lang="vbnet">
            Private _myVstProc As VSTPROC ' make global, so GC will not collect it
            Private vst1 As Integer
            Private vst2 As Integer
            Private ch1 As Integer
            Private ch2 As Integer
            ...
            ' create the 'real' channels to use
            ch1 = BASS_StreamCreateFile(...)
            vst1 = BassVst.BASS_VST_ChannelSetDSP(0, 
                           "C:\VstPlugins\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1)
            ch2 = BASS_StreamCreateFile(...)
            vst2 = BassVst.BASS_VST_ChannelSetDSP(0, 
                           "C:\VstPlugins\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1)
            
            ' create an 'unchanneled' VST-editor
            Dim vstDummy As Integer = BassVst.BASS_VST_ChannelSetDSP(0, 
                                              "C:\VstPlugins\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 0)
            
            ' we want to be notified about parameter changes ...
            myVstProc = New VSTPROC(vstEditorCallback)
            BassVst.BASS_VST_SetCallback(vstDummy, myVstProc, IntPtr.Zero)
            
            ' so when the user opens the VST-editor this is being called
            Public Function vstEditorCallback(vstDummy As Integer, action As Integer, 
                                              param1 As Integer, param2 As Integer, user As IntPtr) As Integer
              If action = BASS_VST_PARAM_CHANGED Then
                ' the user has changed some slider in the unchanneled editor
                ' copy the changes to the 'real' channels
                BassVst.BASS_VST_SetParamCopyParams(vstDummy, vst1)
                BassVst.BASS_VST_SetParamCopyParams(vstDummy, vst2)
              End If
              Return 0
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_Resume(System.Int32)">
            <summary>
            Call this function after position changes or sth. like that.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Some VST effects will use an internal buffer for effect calculation and handling.
            This will reset the internal VST buffers which may remember some "old" data.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetBypass(System.Int32,System.Boolean)">
            <summary>
            Bypasses the effect processing (state=TRUE) or switch back to normal processing (state=FALSE).
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="state"></param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>By default bypassing is OFF and the effect will be processed normally. Use <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetBypass(System.Int32)"/> returns the current state.
            <para>Note, that the bypassing is completely done by BASS_VST, we're not using the so-called "soft" bypass that is implemented by some effects. 
            This is for the following reasons:</para>
            <para>- Soft-bypassing is not supported by all effects</para>
            <para>- The state of soft-bypassing cannot be queried safely</para>
            <para>- Soft-bypassing would not be a real bypass as some channel transformations may still be needed</para>
            <para>- Performance reasons - soft-bypassing would require still most of the needed BASS_VST transformations</para>
            <para>- Finally, I do not see any advantages of the soft-bypassing</para>
            <para>Soft bypassing is not supported in the BASS.NET API.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetBypass(System.Int32)">
            <summary>
            Gets the current bypasses state of the the effect processing (state=TRUE or FALSE).
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)">
            <summary>
            Gets general information about a VST effect plugin.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="ret">An instance of the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO"/> where to store the parameter information at.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Some words to the number of input/output channels:
            <para>VST effects that have no input channels (so called "Instruments") are not loaded by BASS_VST.  So you can assume chansIn and chansOut to be at least 1.</para>
            <para>Multi-channel streams should work correctly, if supported by a effect.
            If not, only the first chansIn channels are processed by the effect, the other ones stay unaffected.  
            The opposite, eg. assigning multi-channel effects to stereo channels, should be no problem at all.</para>
            <para>If mono effects are assigned to stereo channels, the result will be mono, expanded to both channels.
            This behaviour can be switched of using the BASS_VST_KEEP_CHANS in <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</para>
            </remarks>
            <example>
            <code>
            BASS_VST_INFO vstInfo = new BASS_VST_INFO();
            if ( BassVst.BASS_VST_GetInfo(vstHandle, vstInfo))
            	Console.WriteLine(vstInfo.ToString());
            </code>
            <code lang="vbnet">
            Dim vstInfo As New BASS_VST_INFO()
            If BassVst.BASS_VST_GetInfo(vstHandle, vstInfo) Then
              Console.WriteLine(vstInfo.ToString())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32)">
            <summary>
            Gets general information about a VST effect plugin.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <returns>If successful, an instance of the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO"/> is returned, else NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Some words to the number of input/output channels:
            <para>VST effects that have no input channels (so called "Instruments") are not loaded by BASS_VST.  So you can assume chansIn and chansOut to be at least 1.</para>
            <para>Multi-channel streams should work correctly, if supported by a effect.
            If not, only the first chansIn channels are processed by the effect, the other ones stay unaffected.  
            The opposite, eg. assigning multi-channel effects to stereo channels, should be no problem at all.</para>
            <para>If mono effects are assigned to stereo channels, the result will be mono, expanded to both channels.
            This behaviour can be switched of using the BASS_VST_KEEP_CHANS in <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</para>
            </remarks>
            <example>
            <code>
            BASS_VST_INFO vstInfo = BassVst.BASS_VST_GetInfo(vstHandle);
            if (vstInfo != null)
            	Console.WriteLine(vstInfo.ToString());
            </code>
            <code lang="vbnet">
            Dim vstInfo As BASS_VST_INFO = BassVst.BASS_VST_GetInfo(vstHandle)
            If Not (vstInfo Is Nothing) Then
              Console.WriteLine(vstInfo.ToString())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_EmbedEditor(System.Int32,System.IntPtr)">
            <summary>
            Many VST effects come along with an graphical parameters editor; with the following function, you can embed these editors to your user interface.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="parentWindow">The IntPtr to the window handle (HWND) of the parents window in which the editor should be embedded (e.g. use a new modeless dialog or user control).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>To embed the editor to another window, call this function with parentWindow set to the HWND (this.Handle) of the parent window.
            To check, if an effect has an editor, see the hasEditor flag set by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.</para>
            <para>To "unembed" the editor, call this function with parentWindow set to NULL.</para>
            <para>If you create the editor window independently of a real channel (by skipping the channel parameter when calling <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>) and the editor displays any spectrums, VU-meters or such, 
            the data for this come from the most recent channel using the same effect  and the same scope.
            The scope can be set by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetScope(System.Int32,System.Int32)"/> to any ID, the default is 0.</para>
            <para>In order to create a new window in which the editor should be embedded, it is a good idea to call <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/> in order to retrieve the editors height and width.</para>
            </remarks>
            <example>
            <code>
            private int _vstHandle = 0;
            ...
            _vstHandle = BassVst.BASS_VST_ChannelSetDSP(_stream, 
                                 "C:\\VstPlugins\\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1 );
            // show the embedded editor
            BASS_VST_INFO vstInfo = new BASS_VST_INFO();
            if ( BassVst.BASS_VST_GetInfo(vstHandle, vstInfo) &amp;&amp; vstInfo.hasEditor )
            {
              // create a new System.Windows.Forms.Form
              Form f = new Form();
              f.Width = vstInfo.editorWidth+4;
              f.Height = vstInfo.editorHeight+34;
              f.Closing += new CancelEventHandler(f_Closing);
              f.Text = vstInfo.effectName;
              f.Show();
              BassVst.BASS_VST_EmbedEditor(_vstHandle, f.Handle);
            }
            
            private void f_Closing(object sender, CancelEventArgs e)
            {
              // unembed the VST editor
              BassVst.BASS_VST_EmbedEditor(_vstHandle, IntPtr.Zero);
            }
            </code>
            <code lang="vbnet">
            Private _vstHandle As Integer = 0
            ...
            _vstHandle = BassVst.BASS_VST_ChannelSetDSP(_stream, 
                                 "C:\VstPlugins\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 1)
            ' show the embedded editor
            Dim vstInfo As New BASS_VST_INFO()
            If BassVst.BASS_VST_GetInfo(vstHandle, vstInfo) AndAlso vstInfo.hasEditor Then
              ' create a new System.Windows.Forms.Form
              Dim f As New Form()
              f.Width = vstInfo.editorWidth + 4
              f.Height = vstInfo.editorHeight + 34
              AddHandler f.Closing, AddressOf f_Closing
              f.Text = vstInfo.effectName
              f.Show()
              BassVst.BASS_VST_EmbedEditor(_vstHandle, f.Handle)
            End If
            
            Private Sub f_Closing(sender As Object, e As CancelEventArgs)
              ' unembed the VST editor
              BassVst.BASS_VST_EmbedEditor(_vstHandle, IntPtr.Zero)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetScope(System.Int32,System.Int32)">
            <summary>
            Sets the scope of an Editor to a given ID.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="scope">The ID to set the scope to.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If you create an editor window with <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_EmbedEditor(System.Int32,System.IntPtr)"/> independently of a real channel (by skipping the channel parameter when calling <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>) 
            and the editor displays any spectrums, VU-meters or such, the data for this come from the most recent channel using the same effect 
            and the same scope. The scope can be set by this method to any ID, the default is 0.</para>
            <para>The 'scope' is used to forward 'real' audio data to 'unchanneled' editors (you may want to use these editors as you may want the user to open the editor window at any time, independent of a playing channel).
            Imaging the following code, where two streams are prepared for crossfading:
            <code>
            ch1 = BASS_StreamCreateFile(false, "sth1.mp3", ...);
            dsp1 = BASS_VST_ChannelSetDSP(ch1, "sth.dll", ...);
            ch2 = BASS_StreamCreateFile(false, "sth2.mp3", ...);
            dsp2 = BASS_VST_ChannelSetDSP(ch2, "sth.dll", ...);
            </code>
            For the user, this is one logical channel. If the user opens the editor for the 'sth' effect, it should display first the spectrum/vu/etc. from the first, 
            after crossfading from the second channel. To let the editor know this, you should use the 'scope'.
            The 'scope' simply brings independent channels together to one logical unit - mainly for displaying the correct spectrum/vu/etc. in the editors.
            </para>
            <para>So before the crossfade, you should set the scope:
            <code>
            BASS_VST_SetScope(dsp1, 123); // any number, scope is created implicitly
            BASS_VST_SetScope(dsp2, 123); // any number, scope is created implicitly
            </code>
            </para>
            <para>To open the unchanneled editor, you can then simply use the following code:
            <code>
            editor = BASS_VST_ChannelSetDSP(0, "sth.dll", ...);
            BASS_VST_SetScope(editor, 123);
            BASS_VST_EmbedEditor(editor, ...);
            </code>
            The editor can then be opened, closed, created and destroyed independingly of the playing stuff.
            </para>
            <para>If you use BASSmix, maybe you won't need the VST-scopes as you can add the effects to the finaly mix. However, even in this case, there may be situations where <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetScope(System.Int32,System.Int32)"/> is just fine and simplifies your code.</para>
            <para></para>
            <para></para>
            <para></para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetCallback(System.Int32,Un4seen.Bass.AddOn.Vst.VSTPROC,System.IntPtr)">
            <summary>
            Assign a callback function to a vstHandle.
            </summary>
            <param name="vstHandle">The VST effect handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="proc">The user defined callback delegate (see <see cref="T:Un4seen.Bass.AddOn.Vst.VSTPROC"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The callback function is called with one of the following actions (see <see cref="T:Un4seen.Bass.AddOn.Vst.BASSVSTAction"/>):
            <list type="table">
            <listheader><term>Actions:</term><description></description></listheader>
            <item><term>BASS_VST_PARAM_CHANGED</term><description>Some parameters are changed by the editor opened by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_EmbedEditor(System.Int32,System.IntPtr)"/>, NOT called if you call <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetParam(System.Int32,System.Int32,System.Single)"/>.</description></item>
            <item><term>BASS_VST_EDITOR_RESIZED</term><description>The embedded editor window should be resized, the new width/height can be found in param1/param2 and in <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.</description></item>
            <item><term>BASS_VST_AUDIO_MASTER</term><description>Can be used to subclass the audioMaster callback (see the VST SDK), param1 is a pointer to a <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AUDIO_MASTER_PARAM"/> structure.</description></item>
            </list>
            </para>
            <para>Unless defined otherwise, the callback function should always return 0.</para>
            </remarks>
            <example>
            <code>
            private VSTPROC _myVstProc; // keep the callback delegate in a global member
            ...
            // your VST callback - referenced below by BASS_VST_SetCallback()
            private int YourVstProc(int vstHandle, BASSVSTAction action, int param1, int param2, IntPtr user)
            {
              switch (action)
              {
                case BASSVSTAction.BASS_VST_PARAM_CHANGED:
                  // we get notified that the user has changed some sliders in the editor - 
                  // do what to do here ...
                  break;
                case BASSVSTAction.BASS_VST_EDITOR_RESIZED:
                  // the editor window requests a new size,
                  // maybe we should resize the window the editor is embedded in?
                  // the new width/height can be found in param1/param2
                  break;
                case BASSVSTAction.BASS_VST_AUDIO_MASTER:
                  // this is only for people familiar with the VST SDK,
                  // param1 is a pointer to a BASS_VST_AUDIO_MASTER_PARAM structure
                  // which contains all information needed
                  break;
              }
              return 0;
            }
            ...
            // open the VST editor (e.g. if we are inside a System.Windows.Forms.Form)
            BassVst.BASS_VST_EmbedEditor(vstHandle, this.Handle);
            // we want to get notified for parameter changes etc.
            _myVstProc = new VSTPROC(YourVstProc);
            BassVst.BASS_VST_SetCallback(vstHandle, _myVstProc, IntPtr.Zero);
            </code>
            <code lang="vbnet">
            Private _myVstProc As VSTPROC ' keep the callback delegate in a global member
            ...
            ' your VST callback - referenced below by BASS_VST_SetCallback()
            Private Function YourVstProc(vstHandle As Integer, action As BASSVSTAction, param1 As Integer, param2 As Integer, user As IntPtr) As Integer
              Select Case action
                Case BASSVSTAction.BASS_VST_PARAM_CHANGED
                  ' we get notified that the user has changed some sliders in the editor - 
                  ' do what to do here ...
                Case BASSVSTAction.BASS_VST_EDITOR_RESIZED
                  ' the editor window requests a new size,
                  ' maybe we should resize the window the editor is embedded in?
                  ' the new width/height can be found in param1/param2
                Case BASSVSTAction.BASS_VST_AUDIO_MASTER
                  ' this is only for people familiar with the VST SDK,
                  ' param1 is a pointer to a BASS_VST_AUDIO_MASTER_PARAM structure
                  ' which contains all information needed
              End Select
              Return 0
            End Function
            ...
            ' open the VST editor (e.g. if we are inside a System.Windows.Forms.Form)
            BassVst.BASS_VST_EmbedEditor(vstHandle, Me.Handle)
            ' we want to get notified for parameter changes etc.
            _myVstProc = New VSTPROC(AddressOf YourVstProc)
            BassVst.BASS_VST_SetCallback(vstHandle, _myVstProc, IntPtr.Zero)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetLanguage(System.String)">
            <summary>
            Set the VST language to be used by any plugins.
            </summary>
            <param name="lang">The desired language as ISO 639.1, e.g. "en", "de", "es"...</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Some VST effects come along localized.  With this function you can set the
            desired language as ISO 639.1 -- eg. "en" for english, "de" for german,
            "es" for spanish and so on.  The default language is english.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSVST from the application's startup path:
            <code>
            Bass.LoadMe();
            BassVst.LoadMe();
            ...
            // when not used anymore...
            BassVst.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSVST from a different directory:
            <code>
            Bass.LoadMe( @"C:\Development\BASS\_libs" );
            BassVst.LoadMe( @"C:\Development\BASS\_libs" );
            ...
            // when not used anymore...
            BassVst.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BassVst.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.BASSVSTDsp">
            <summary>
            VST DSP flags to be used within the <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/> method.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDsp.BASS_VST_DEFAULT">
            <summary>
            Default VST DSP processing.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDsp.BASS_VST_KEEP_CHANS">
            <summary>
            By default, mono effects assigned to stereo channels are mixed down before processing and converted back
            to stereo afterwards. Set this flag to avoid this behaviour in which case only the first channel is
            affected by processing.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDsp.BASS_UNICODE">
            <summary>
            file is a Unicode (16-bit characters) filename
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.BASSVSTAction">
            <summary>
            VST action parameters as used within the <see cref="T:Un4seen.Bass.AddOn.Vst.VSTPROC"/> callback.
            <para>See also <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetCallback(System.Int32,Un4seen.Bass.AddOn.Vst.VSTPROC,System.IntPtr)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAction.BASS_VST_PARAM_CHANGED">
            <summary>
            Some parameters are changed by the editor opened by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_EmbedEditor(System.Int32,System.IntPtr)"/>, NOT called if you call <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetParam(System.Int32,System.Int32,System.Single)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAction.BASS_VST_EDITOR_RESIZED">
            <summary>
            The embedded editor window should be resized, the new width/height can be found in param1/param2 and in <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAction.BASS_VST_AUDIO_MASTER">
            <summary>
            Can be used to subclass the audioMaster callback (see the VST SDK), param1 is a pointer to a instance of the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AUDIO_MASTER_PARAM"/> class.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes">
            <summary>
            VST Dispatcher OpCodes to be used within the <see cref="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_Dispatcher"/> callback when using <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT"/>.
            <para>For more info see the Steinberg VST SDK documentation.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effOpen">
            <summary>
            Initialise.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effClose">
            <summary>
            Exit, release all memory and other resources!
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetProgram">
            <summary>
            program no in "value".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetProgram">
            <summary>
            Return current program no.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetProgramName">
            <summary>
            User changed program name (max 24 char + 0) to as passed in string.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetProgramName">
            <summary>
            Stuff program name (max 24 char + 0) into string.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetParamLabel">
            <summary>
            Stuff parameter "index" label (max 8 char + 0) into string.
            <para>Examples: 'sec', 'dB', 'type'</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetParamDisplay">
            <summary>
            Stuff parameter "index" textual representation into string.
            <para>Examples: '0.5', '-3', 'PLATE'</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetParamName">
            <summary>
            Stuff parameter "index" label (max 8 char + 0) into string.
            <para>Examples: 'Time', 'Gain', 'RoomType'</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetVu">
            <summary>
            Called if (flags &amp; (effFlagsHasClip | effFlagsHasVu)).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetSampleRate">
            <summary>
            System: In opt (float value in Hz; for example 44100.0Hz).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetBlockSize">
            <summary>
            System: In value (this is the maximun size of an audio block, pls check sampleframes in process call).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effMainsChanged">
            <summary>
            System: The user has switched the 'power on' button to value (0 off, else on). This only switches audio  processing; you should flush delay buffers etc.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effEditGetRect">
            <summary>
            Editor: Stuff rect (top, left, bottom, right) into ptr.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effEditOpen">
            <summary>
            Editor: System dependant Window pointer in ptr.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effEditClose">
            <summary>
            Editor: No arguments.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effEditDraw">
            <summary>
            Editor: Draw method, ptr points to rect (MAC Only).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effEditMouse">
            <summary>
            Editor: index: x, value: y (MAC Only).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effEditKey">
            <summary>
            Editor: System keycode in value.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effEditIdle">
            <summary>
            Editor: no arguments. Be gentle!
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effEditTop">
            <summary>
            Editor: Window has topped, no arguments.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effEditSleep">
            <summary>
            Editor: Window goes to background.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effIdentify">
            <summary>
            Returns 'NvEf'.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetChunk">
            <summary>
            Host requests pointer to chunk into (void**)ptr, byteSize returned.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetChunk">
            <summary>
            Plug-in receives saved chunk, byteSize passed.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effProcessEvents">
            <summary>
            VstEvents* in "ptr".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effCanBeAutomated">
            <summary>
            Parameter index in "index".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effString2Parameter">
            <summary>
            Parameter index in "index", string in "ptr".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetNumProgramCategories">
            <summary>
            No arguments. This is for dividing programs into groups (like GM).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetProgramNameIndexed">
            <summary>
            Get program name of category "value", program "index" into "ptr".
            <para>Category (that is, "value") may be -1, in which case program indices are enumerated linearily (as usual); otherwise, each category starts over with index 0.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effCopyProgram">
            <summary>
            Copy current program to destination "index"
            <para>Note: implies setParameter connections, configuration.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effConnectInput">
            <summary>
            Input at "index" has been (dis-)connected; "value" == 0: disconnected, else connected.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effConnectOutput">
            <summary>
            Onput at "index" has been (dis-)connected; "value" == 0: disconnected, else connected.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetInputProperties">
            <summary>
            "index", VstPinProperties* in ptr, return != 0 means true.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetOutputProperties">
            <summary>
            "index", VstPinProperties* in ptr, return != 0 means true.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetPlugCategory">
            <summary>
            No parameter, return value is category.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetCurrentPosition">
            <summary>
            Realtime: for external dsp, see flag bits below.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetDestinationBuffer">
            <summary>
            Realtime: for external dsp, see flag bits below. returns float*.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effOfflineNotify">
            <summary>
            Offline: ptr = VstAudioFile array, value = count, index = start flag.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effOfflinePrepare">
            <summary>
            Offline: ptr = VstOfflineTask array, value = count.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effOfflineRun">
            <summary>
            Offline: ptr = VstOfflineTask array, value = count.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effProcessVarIo">
            <summary>
            VstVariableIo* in "ptr".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetSpeakerArrangement">
            <summary>
            VstSpeakerArrangement* pluginInput in "value"; VstSpeakerArrangement* pluginOutput in "ptr".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetBlockSizeAndSampleRate">
            <summary>
            Block size in "value", sampleRate in "opt"
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetBypass">
            <summary>
            On/Off in "value" (0 = off, 1 = on).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetEffectName">
            <summary>
            char* name (max 32 bytes) in "ptr".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetErrorText">
            <summary>
            char* text (max 256 bytes) in "ptr".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetVendorString">
            <summary>
            Fills "ptr" with a string identifying the vendor (max 64 char).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetProductString">
            <summary>
            Fills "ptr" with a string with product name (max 64 char).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetVendorVersion">
            <summary>
            Returns vendor-specific version.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effVendorSpecific">
            <summary>
            No definition, vendor specific handling.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effCanDo">
            <summary>
            "ptr" contains one of the 'plugCanDos' strings (e.g. "bypass").
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetTailSize">
            <summary>
            Returns tail size; 0 is default (return 1 for 'no tail').
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effIdle">
            <summary>
            Idle call in response to audioMasterneedIdle. Must return 1 to keep idle calls beeing issued.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetIcon">
            <summary>
            GUI: void* in "ptr", not yet defined.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetViewPosition">
            <summary>
            GUI: set view position (in window) to x "index" y "value"
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetParameterProperties">
            <summary>
            Of param "index", VstParameterProperties* in "ptr".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effKeysRequired">
            <summary>
            Returns 0: needs keys (default for 1.0 plugs), 1: don't need.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetVstVersion">
            <summary>
            Returns 2 for VST 2; older versions return 0; 2100 for VST 2.1...2400 for VST 2.4.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effEditKeyDown">
            <summary>
            Character in "index", virtual in "value", modifiers in "opt", return -1 if not used, return 1 if used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effEditKeyUp">
            <summary>
            Character in "index", virtual in "value", modifiers in "opt", return -1 if not used, return 1 if used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetEditKnobMode">
            <summary>
            Mode in "value": 0: circular, 1:circular relativ, 2:linear.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetMidiProgramName">
            <summary>
            Passed "ptr" points to MidiProgramName struct.
            <para>Struct will be filled with information for 'thisProgramIndex'.
            Returns number of used programIndexes, if 0 is returned, no MidiProgramNames supported.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetCurrentMidiProgram">
            <summary>
            Returns the programIndex of the current program.
            <para>Passed "ptr" points to MidiProgramName struct, struct will be filled with information for the current program.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetMidiProgramCategory">
            <summary>
            Passed "ptr" points to MidiProgramCategory struct.
            <para>Struct will be filled with information for 'thisCategoryIndex'.
            Returns number of used categoryIndexes, if 0 is returned, no MidiProgramCategories supported.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effHasMidiProgramsChanged">
            <summary>
            Returns 1 if the MidiProgramNames or MidiKeyNames had changed on this channel, 0 otherwise. "ptr" ignored.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetMidiKeyName">
            <summary>
            Passed "ptr" points to MidiKeyName struct.
            <para>Struct will be filled with information for 'thisProgramIndex' and 'thisKeyNumber'.
            If keyName is "" the standard name of the key will be displayed. If 0 is returned, no MidiKeyNames are defined for 'thisProgramIndex'.
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effBeginSetProgram">
            <summary>
            Called before a new program is loaded.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effEndSetProgram">
            <summary>
            Called when the program is loaded.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetSpeakerArrangement">
            <summary>
            VstSpeakerArrangement** pluginInput in "value". VstSpeakerArrangement** pluginOutput in "ptr".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effShellGetNextPlugin">
            <summary>
            This opcode is only called, if plugin is of type kPlugCategShell. Returns the next plugin's uniqueID.
            <para>"ptr" points to a char buffer of size 64, which is to be filled with the name of the plugin including the terminating zero.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effStartProcess">
            <summary>
            Called before the start of process call.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effStopProcess">
            <summary>
            Called after the stop of process call.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetTotalSampleToProcess">
            <summary>
            Called in offline (non RealTime) Process before process is called, indicates how many sample will be processed.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetPanLaw">
            <summary>
            PanLaw : Type (Linear, Equal Power,.. see enum PanLaw Type) in "value", Gain in "opt": for Linear : [1.0 means 0dB PanLaw], [~0.58 means -4.5dB], [0.5 means -6.02dB].
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effBeginLoadBank">
            <summary>
            Called before a Bank is loaded, "ptr" points to VstPatchChunkInfo structure.
            Return -1 if the Bank can not be loaded, return 1 if it can be loaded else 0 (for compatibility).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effBeginLoadProgram">
            <summary>
            Called before a Program is loaded, "ptr" points to VstPatchChunkInfo structure.
            Return -1 if the Program can not be loaded, return 1 if it can be loaded else 0 (for compatibility).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effSetProcessPrecision">
            <summary>
            Sets the processing precision in "value" (0=32 bit, 1=64 bit).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetNumMidiInputChannels">
            <summary>
            Returns the number of used MIDI input channels (1-15).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effGetNumMidiOutputChannels">
            <summary>
            Returns the number of used MIDI output channels (1-15).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes.effNumOpcodes">
            <summary>
            Returns the number of available OpCodes
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags">
            <summary>
            <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT"/> bit flags.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags.effFlagsHasEditor">
            <summary>
            If set, is expected to react to editor messages
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags.effFlagsHasClip">
            <summary>
            Return &gt; 1. in getVu() if clipped
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags.effFlagsHasVu">
            <summary>
            Return vu value in getVu(); > 1. means clipped
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags.effFlagsCanMono">
            <summary>
            If numInputs == 2, makes sense to be used for mono in
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags.effFlagsCanReplacing">
            <summary>
            Supports in place output (processReplacing() exsists)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags.effFlagsProgramChunks">
            <summary>
            Program data are handled in formatless chunks
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags.effFlagsIsSynth">
            <summary>
            Plug-in is a synth (VSTi), Host may assign mixer channels for its outputs.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags.effFlagsNoSoundInStop">
            <summary>
            Plug-in does not produce sound when input is all silence.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags.effFlagsExtIsAsync">
            <summary>
            Plug-in is asynchronious.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags.effFlagsExtHasBuffer">
            <summary>
            Plug-in has a buffer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags.effFlagsCanDoubleReplacing">
            <summary>
            Plug-in supports double precision processing.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO">
            <summary>
            Common information structure about an editable parameter to a VST plugin parameter to be used with <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetParamInfo(System.Int32,System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO.name">
            <summary>
            Name of the parameter (empty strings returned if a plugin does not provide these information).
            <para>Examples: Time, Gain, RoomType</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO.unit">
            <summary>
            Unit of the parameter.
            <para>Examples: sec, dB, type</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO.display">
            <summary>
            The current value in a readable format (empty strings returned if a plugin does not provide these information).
            <para>Examples: 0.5, -3, PLATE</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO.defaultValue">
            <summary>
            The default value (in the range of 0.0 and 1.0).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_PARAM_INFO.ToString">
            <summary>
            A description of the VST parameter value (name = display unit, e.g. "Gain = 0.7 dB").
            </summary>
            <returns></returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO">
            <summary>
            <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/> writes some information about a vstHandle returned by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/> to this BASS_VST_INFO structure.
            </summary>
            <remarks>Some words to the number of input/output channels:
            <para>VST effects that have no input channels (so called "Instruments") are not loaded by BASS_VST.  So you can assume chansIn and chansOut to be at least 1.</para>
            <para>Multi-channel streams should work correctly, if supported by a effect.
            If not, only the first chansIn channels are processed by the effect, the other ones stay unaffected.  
            The opposite, eg. assigning multi-channel effects to stereo channels, should be no problem at all.</para>
            <para>If mono effects are assigned to stereo channels, the result will be mono, expanded to both channels.
            This behaviour can be switched of using the BASS_VST_KEEP_CHANS in <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.channelHandle">
            <summary>
            The channelHandle as given to <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.uniqueID">
            <summary>
            A unique ID for the effect (the IDs are registered at Steinberg).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.effectName">
            <summary>
            The effect name (empty strings returned if a plugin does not provide these information).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.effectVersion">
            <summary>
            The effect version (example 0x01010000 for version 1.1.0.0).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.effectVstVersion">
            <summary>
            The VST version, the effect was written for (example 0x02030000 for version 2.3.0.0).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.hostVstVersion">
            <summary>
            The VST version supported by BASS_VST (e.g. 2.4).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.productName">
            <summary>
            The product name (may be empty).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.vendorName">
            <summary>
            The vendor name (may be empty).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.vendorVersion">
            <summary>
            The vendor-specific version number (example 0x01010000 for version 1.1.0.0).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.chansIn">
            <summary>
            Maximum number of possible input channels (should be at least 1 here).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.chansOut">
            <summary>
            Maximum number of possible output channels (should be at least 1 here).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.initialDelay">
            <summary>
            For algorithms which need input in the first place, in number of samples.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.hasEditor">
            <summary>
            Has this plugin an embedded editor?
            <para>If TRUE, the <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_EmbedEditor(System.Int32,System.IntPtr)"/> method can be called.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.editorWidth">
            <summary>
            Initial/current width of the embedded editor, see also BASS_VST_EDITOR_RESIZED in <see cref="T:Un4seen.Bass.AddOn.Vst.BASSVSTAction"/>.
            <para>For a very few plugins, editorWidth and editorHeight may be 0 if the editor is not yet opened.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.editorHeight">
            <summary>
            Initial/current height of the embedded editor, see also BASS_VST_EDITOR_RESIZED in <see cref="T:Un4seen.Bass.AddOn.Vst.BASSVSTAction"/>.
            <para>For a very few plugins, editorWidth and editorHeight may be 0 if the editor is not yet opened.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.aeffect">
            <summary>
            The underlying AEffect object (see the VST SDK).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.rsvd">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.ToString">
            <summary>
            Returns a description string for the VST plugin info: "effectName (productName, vendorName)".
            </summary>
            <returns></returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AUDIO_MASTER_PARAM">
            <summary>
            This class is only needed if you subclass the audioMaster callback using BASS_VST_AUDIO_MASTER in the <see cref="T:Un4seen.Bass.AddOn.Vst.VSTPROC"/> (see the VST DSK for more information).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AUDIO_MASTER_PARAM.aeffect">
            <summary>
            Parameter forwarded from the audioMaster callback.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AUDIO_MASTER_PARAM.opcode">
            <summary>
            Parameter forwarded from the audioMaster callback (one of the <see cref="T:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AUDIO_MASTER_PARAM.index">
            <summary>
            Parameter forwarded from the audioMaster callback.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AUDIO_MASTER_PARAM.value">
            <summary>
            Parameter forwarded from the audioMaster callback.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AUDIO_MASTER_PARAM.ptr">
            <summary>
            Parameter forwarded from the audioMaster callback.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AUDIO_MASTER_PARAM.opt">
            <summary>
            Parameter forwarded from the audioMaster callback.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AUDIO_MASTER_PARAM.doDefault">
            <summary>
            Set this to 0 if you want to skip the normal BASS_VST audioMaster processing.
            In this case the return value is forwarded to the effect.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_AUDIO_MASTER_PARAM.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT">
            <summary>
            Basic VST Effect class as returned in the aeffect member of the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO"/> class as obtained by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.
            <para>See the VST SDK for more informaton.</para>
            </summary>
            <remarks>This class can only be used in the .Net Framework version 2.0 or above!
            <para>In order to retrieve an instance of this class you must first call <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/> and then pass the <see cref="F:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO.aeffect"/> IntPtr to the
            static method <see cref="M:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.FromIntPtr(System.IntPtr)"/>.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.magic">
            <summary>
            Must be kEffectMagic ('VstP')
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.dispatcher">
            <summary>
            Host to Plug-in dispatcher delegate method (see <see cref="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_Dispatcher"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.process">
            <summary>
            Accumulating process mode delegate method (deprecated in VST 2.4, use processReplacing instead - see <see cref="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_Process"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.setParameter">
            <summary>
            Set new value of automatable parameter (see <see cref="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_SetParameter"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.getParameter">
            <summary>
            Returns current value of automatable parameter (see <see cref="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_GetParameter"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.numPrograms">
            <summary>
            Number of programs.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.numParams">
            <summary>
            All programs are assumed to have numParams parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.numInputs">
            <summary>
            Number of audio inputs.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.numOutputs">
            <summary>
            Number of audio outputs.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.flags">
            <summary>
            Effect flags (see <see cref="T:Un4seen.Bass.AddOn.Vst.BASSVSTAEffectFlags"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.resvd1">
            <summary>
            Reserved for Host, must be 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.resvd2">
            <summary>
            Reserved for Host, must be 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.initialDelay">
            <summary>
            For algorithms which need input in the first place (group delay or latency). This value should be initialized in a resume state.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.realQualities">
            <summary>
            Number of realtime qualities (0: realtime).
            Deprecated in VST 2.4!
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.offQualities">
            <summary>
            Number of offline qualities (0: realtime only).
            Deprecated in VST 2.4!
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.ioRatio">
            <summary>
            Input samplerate to output samplerate ratio, not used yet.
            Deprecated in VST 2.4!
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.obj">
            <summary>
            AudioEffect class pointer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.user">
            <summary>
            User-defined pointer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.uniqueID">
            <summary>
            Registered unique identifier (register it at Steinberg 3rd party support Web). This is used to identify a plug-in during save+load of preset and project.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.version">
            <summary>
            Plug-in version (example 0x1100 for version 1.1.0.0)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.processReplacing">
            <summary>
            Realtime process mode delegate method (see <see cref="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_ProcessReplacing"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.processDoubleReplacing">
            <summary>
            Process double-precision audio samples in replacing mode (see <see cref="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_ProcessDoubleProc"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.future">
            <summary>
            Reserved for future use (please zero)
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.FromIntPtr(System.IntPtr)">
            <summary>
            Returns an instance of the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT"/> class derived from an IntPtr (aeffect) as obtained via <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.
            </summary>
            <param name="aeffect">The IntPtr to the AEffect structure as obtained from the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_INFO"/> class when calling <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.</param>
            <returns>An instance of the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT"/> class if successfull, otherwise NULL will be returned.</returns>
            <remarks>This method can only be used in the .Net Framework version 2.0 or above!</remarks>
            <example>
            <code>
            vstHandle = BassVst.BASS_VST_ChannelSetDSP(_stream, 
                                "C:\\VstPlugins\\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 0);
            BASS_VST_INFO vstInfo = new BASS_VST_INFO();
            if (BassVst.BASS_VST_GetInfo(vstHandle, vstInfo))
            {
              BASS_VST_AEFFECT aeffect = BASS_VST_AEFFECT.FromIntPtr(vstInfo.aeffect);
              if (aeffect != null)
              {
                // now you might use the aeffect instance, e.g. retrieve the number of programs...
                int numPrograms = aeffect.numPrograms;
                ...
                // or call the dispatcher...
                string cmd = "bypass";
                GCHandle gch = GCHandle.Alloc(cmd, GCHandleType.Pinned);
                if (aeffect.dispatcher(vstInfo.aeffect, BASSVSTDispatcherOpCodes.effCanDo, 
                                        0, 0, gch.AddrOfPinnedObject(), 0.0f) != 0)
                {
                  int ret = aeffect.dispatcher(vstInfo.aeffect, BASSVSTDispatcherOpCodes.effSetBypass, 
                                               0, 1, IntPtr.Zero, 0.0f);
                  Console.WriteLine(ret.ToString());
                }
                gch.Free();
                ...
              }
            }
            </code>
            <code lang="vbnet">
            vstHandle = BassVst.BASS_VST_ChannelSetDSP(_stream, 
                                "C:\VstPlugins\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 0)
            Dim vstInfo As New BASS_VST_INFO()
            If BassVst.BASS_VST_GetInfo(vstHandle, vstInfo) Then
              Dim aeffect As BASS_VST_AEFFECT = BASS_VST_AEFFECT.FromIntPtr(vstInfo.aeffect)
              If Not (aeffect Is Nothing) Then
                ' now you might use the aeffect instance, e.g. retrieve the number of programs
                Dim numPrograms As Integer = aeffect.numPrograms
                ...
                ' or call the dispatcher...
                Dim cmd As String = "bypass"
                Dim gch As GCHandle = GCHandle.Alloc(cmd, GCHandleType.Pinned)
                If aeffect.dispatcher(vstInfo.aeffect, BASSVSTDispatcherOpCodes.effCanDo, 
                                      0, 0, gch.AddrOfPinnedObject(), 0F) &lt;&gt; 0 Then
                  Dim ret As Integer = aeffect.dispatcher(vstInfo.aeffect, BASSVSTDispatcherOpCodes.effSetBypass, 
                                                          0, 1, IntPtr.Zero, 0F)
                  ...
                  Console.WriteLine(ret.ToString())
                End If
                gch.Free()
                ...
              End If 
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.ToString">
            <summary>
            Returns the description of this instance (In=x, Out=y).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.GetCurrentProgramName">
            <summary>
            Returns the currently selected program name of the VST effect.
            </summary>
            <returns>The name of the selected program - or an empty string, if the effect has no programs.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.GetProgramName(System.Int32)">
            <summary>
            Returns a specific program name of the VST effect.
            </summary>
            <param name="program">The number of the program to return (must be between 0 .. numPrograms-1).</param>
            <returns>The name of the selected program - or an empty string, if the effect has no programs.</returns>
            <remarks>Retrieving a program name other than the current one enforces to change the current program inernally. 
            So this method first retrieves the current program number, then changes the program in order to get that name and afterwards restores the currect selected program.
            But since changing the program is enforced even for a short period of time, calling this method on a channel based VST effect might produce some sound disturbance.
            So it is a good idea to either call this method on a non-channel vstHandle (<see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/> called with chan=0) or make sure the channel is currently not playing.
            </remarks>
            <example>
            Calling on a non-channel vstHandle:
            <code>
            vstHandle = BassVst.BASS_VST_ChannelSetDSP(0, 
                                "C:\\VstPlugins\\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 0);
            BASS_VST_INFO vstInfo = new BASS_VST_INFO();
            if ( BassVst.BASS_VST_GetInfo(vstHandle, vstInfo) )
            {
              if (vstInfo.aeffect != IntPtr.Zero)
              {
                BASS_VST_AEFFECT aeffect = BASS_VST_AEFFECT.FromIntPtr(vstInfo.aeffect);
                // list all available programs
                for (int i=0; i&lt;aeffect.numPrograms; i++)
                  Console.WriteLine( aeffect.GetProgramName(i) );
              }
            }
            </code>
            <code lang="vbnet">
            vstHandle = BassVst.BASS_VST_ChannelSetDSP(0, "C:\VstPlugins\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 0)
            Dim vstInfo As New BASS_VST_INFO()
            If BassVst.BASS_VST_GetInfo(vstHandle, vstInfo) Then
              If vstInfo.aeffect &lt;&gt; IntPtr.Zero Then
                Dim aeffect As BASS_VST_AEFFECT = BASS_VST_AEFFECT.FromIntPtr(vstInfo.aeffect)
                ' list all available programs
                Dim i As Integer
                For i = 0 To aeffect.numPrograms - 1
                  Console.WriteLine(aeffect.GetProgramName(i))
                Next i
              End If
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.GetProgramNames">
            <summary>
            Returns an array of strings representing the available program names.
            </summary>
            <returns></returns>
            <remarks>Retrieving a program name other than the current one enforces to change the current program inernally. 
            So this method first retrieves the current program number, then changes the program in order to get that name and afterwards restores the currect selected program.
            But since changing the program is enforced even for a short period of time, calling this method on a channel based VST effect might produce some sound disturbance.
            So it is a good idea to either call this method on a non-channel vstHandle (<see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/> called with chan=0) or make sure the channel is currently not playing.
            </remarks>
            <example>
            Calling on a non-channel vstHandle:
            <code>
            vstHandle = BassVst.BASS_VST_ChannelSetDSP(0, 
                                "C:\\VstPlugins\\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 0);
            BASS_VST_INFO vstInfo = new BASS_VST_INFO();
            if (BassVst.BASS_VST_GetInfo(vstHandle, vstInfo))
            {
              if (vstInfo.aeffect != IntPtr.Zero)
              {
                // get all available programs
                string[] progs = aeffect.GetProgramNames();
                if (progs != null)
                {
                  for (int i = 0; i &lt; progs.Length; i++)
                    Console.WriteLine(String.Format( "{0}: {1}", i, progs[i]));
                }
              }
            }
            </code>
            <code lang="vbnet">
            vstHandle = BassVst.BASS_VST_ChannelSetDSP(0, 
                                "C:\VstPlugins\Ambience.dll", BASSVSTDsp.BASS_VST_DEFAULT, 0)
            Dim vstInfo As New BASS_VST_INFO()
            If BassVst.BASS_VST_GetInfo(vstHandle, vstInfo) Then
              If vstInfo.aeffect &lt;&gt; IntPtr.Zero Then
                ' get all available programs
                Dim progs As String() = aeffect.GetProgramNames()
                If Not (progs Is Nothing) Then
                  Dim i As Integer
                  For i = 0 To progs.Length - 1
                    Console.WriteLine([String].Format("{0}: {1}", i, progs(i)))
                  Next i
                End If
              End If
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.GetCurrentProgram">
            <summary>
            Returns the currently selected program number of the VST effect.
            </summary>
            <returns>The name of the selected program - or an empty string, if the effect has no programs.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.SetCurrentProgram(System.Int32)">
            <summary>
            Sets the selected program number of the VST effect.
            </summary>
            <param name="program">The number of the program to set (must be between 0 .. numPrograms-1).</param>
            <returns>TRUE on success, else FALSE.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT.SetCurrentProgramName(System.String)">
            <summary>
            Sets (overwrites) the current selected program name of the VST effect.
            </summary>
            <param name="name">The new name of the program to set (max. 24 characters long!).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>This changes only the name to the VST effect program name, but does not change the program istself.
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.VSTPROC">
            <summary>
            User defined VST callback method to be used with <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetCallback(System.Int32,Un4seen.Bass.AddOn.Vst.VSTPROC,System.IntPtr)"/>.
            </summary>
            <param name="vstHandle">The VST plugin handle as returned from <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_ChannelSetDSP(System.Int32,System.String,Un4seen.Bass.AddOn.Vst.BASSVSTDsp,System.Int32)"/>.</param>
            <param name="action">The action parameter, one of the <see cref="T:Un4seen.Bass.AddOn.Vst.BASSVSTAction"/> values (see below).</param>
            <param name="param1">The first parameter (see the VST SDK for further details).</param>
            <param name="param2">The second parameter (see the VST SDK for further details).</param>
            <param name="user">The user parameter as specified in the <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetCallback(System.Int32,Un4seen.Bass.AddOn.Vst.VSTPROC,System.IntPtr)"/> call.</param>
            <returns>Unless defined otherwise, the callback function should always return 0.</returns>
            <remarks>
            <para>The callback function is called with one of the following actions (see <see cref="T:Un4seen.Bass.AddOn.Vst.BASSVSTAction"/>):
            <list type="table">
            <listheader><term>Actions:</term><description></description></listheader>
            <item><term>BASS_VST_PARAM_CHANGED</term><description>Some parameters are changed by the editor opened by <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_EmbedEditor(System.Int32,System.IntPtr)"/>, NOT called if you call <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_SetParam(System.Int32,System.Int32,System.Single)"/>.</description></item>
            <item><term>BASS_VST_EDITOR_RESIZED</term><description>The embedded editor window should be resized, the new width/height can be found in param1/param2 and in <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.</description></item>
            <item><term>BASS_VST_AUDIO_MASTER</term><description>Can be used to subclass the audioMaster callback (see the VST SDK), param1 is a pointer to a <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AUDIO_MASTER_PARAM"/> structure.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            private VSTPROC _myVstProc; // keep the callback delegate in a global member
            ...
            // your VST callback - referenced below by BASS_VST_SetCallback()
            private int YourVstProc(int vstHandle, BASSVSTAction action, int param1, int param2, IntPtr user)
            {
              switch (action)
              {
                case BASSVSTAction.BASS_VST_PARAM_CHANGED:
                  // we get notified that the user has changed some sliders in the editor - 
                  // do what to do here ...
                  break;
                case BASSVSTAction.BASS_VST_EDITOR_RESIZED:
                  // the editor window requests a new size,
                  // maybe we should resize the window the editor is embedded in?
                  // the new width/height can be found in param1/param2
                  break;
                case BASSVSTAction.BASS_VST_AUDIO_MASTER:
                  // this is only for people familiar with the VST SDK,
                  // param1 is a pointer to a BASS_VST_AUDIO_MASTER_PARAM structure
                  // which contains all information needed
                  break;
              }
              return 0;
            }
            ...
            // open the VST editor (e.g. if we are inside a System.Windows.Forms.Form)
            BassVst.BASS_VST_EmbedEditor(vstHandle, this.Handle);
            // we want to get notified for parameter changes etc.
            _myVstProc = new VSTPROC(YourVstProc);
            BassVst.BASS_VST_SetCallback(vstHandle, _myVstProc, IntPtr.Zero);
            </code>
            <code lang="vbnet">
            Private _myVstProc As VSTPROC ' keep the callback delegate in a global member
            ...
            ' your VST callback - referenced below by BASS_VST_SetCallback()
            Private Function YourVstProc(vstHandle As Integer, action As BASSVSTAction, param1 As Integer, param2 As Integer, user As IntPtr) As Integer
              Select Case action
                Case BASSVSTAction.BASS_VST_PARAM_CHANGED
                  ' we get notified that the user has changed some sliders in the editor - 
                  ' do what to do here ...
                Case BASSVSTAction.BASS_VST_EDITOR_RESIZED
                  ' the editor window requests a new size,
                  ' maybe we should resize the window the editor is embedded in?
                  ' the new width/height can be found in param1/param2
                Case BASSVSTAction.BASS_VST_AUDIO_MASTER
                  ' this is only for people familiar with the VST SDK,
                  ' param1 is a pointer to a BASS_VST_AUDIO_MASTER_PARAM structure
                  ' which contains all information needed
              End Select
              Return 0
            End Function
            ...
            ' open the VST editor (e.g. if we are inside a System.Windows.Forms.Form)
            BassVst.BASS_VST_EmbedEditor(vstHandle, Me.Handle)
            ' we want to get notified for parameter changes etc.
            _myVstProc = New VSTPROC(AddressOf YourVstProc)
            BassVst.BASS_VST_SetCallback(vstHandle, _myVstProc, IntPtr.Zero)
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_Dispatcher">
            <summary>
            The general VST plugin dispatcher callback delegate).
            </summary>
            <param name="effect">The aeffect as retrieved via <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.</param>
            <param name="opCode">The operation code (OpCode), one of the <see cref="T:Un4seen.Bass.AddOn.Vst.BASSVSTDispatcherOpCodes"/> values.</param>
            <param name="index">The index parameter (see the VST SDK for further details).</param>
            <param name="value">The value parameter (see the VST SDK for further details).</param>
            <param name="ptr">The user parameter, a pointer to an element, e.g. a string or structure (see the VST SDK for further details).</param>
            <param name="opt">The optional parameter (see the VST SDK for further details).</param>
            <returns>See Steinberg VST SDK documentaion for more information.</returns>
            <remarks>
            <para>This delegate is only used internally within the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT"/> class and can not be used directly! It is also only supported in the .Net Framework version 2.0 or above!</para>
            <para>See Steinberg VST SDK documentaion for more information.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_Process">
            <summary>
            The VST plugin process callback delegate. Accumulating process mode is deprecated in VST 2.4, use <see cref="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_ProcessReplacing"/> instead.
            <para>See Steinberg VST SDK documentaion for more information.</para>
            </summary>
            <param name="effect">The aeffect as retrieved via <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.</param>
            <param name="inputs">An array of pointers to the data (e.g. for stereo channels this will be an IntPtr to an array of 2 element containing the IntPtr to the float values).</param>
            <param name="outputs">An array of pointers to where the data can be written to (e.g. for stereo channels this will be an IntPtr to an array of 2 element containing the IntPtr to the float values).</param>
            <param name="sampleframes">Number of sample frames to process.</param>
            <remarks>
            <para>This delegate is only used internally within the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT"/> class and can not be used directly! It is also only supported in the .Net Framework version 2.0 or above!</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_ProcessReplacing">
            <summary>
            The VST plugin process callback delegate (non accumulating).
            <para>See Steinberg VST SDK documentaion for more information.</para>
            </summary>
            <param name="effect">The aeffect as retrieved via <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.</param>
            <param name="inputs">An array of pointers to the data (e.g. for stereo channels this will be an IntPtr to an array of 2 element containing the IntPtr to the float values).</param>
            <param name="outputs">An array of pointers to where the data can be written to (e.g. for stereo channels this will be an IntPtr to an array of 2 element containing the IntPtr to the float values).</param>
            <param name="sampleframes">Number of sample frames to process.</param>
            <remarks>
            <para>This delegate is only used internally within the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT"/> class and can not be used directly! It is also only supported in the .Net Framework version 2.0 or above!</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_ProcessDoubleProc">
            <summary>
            The VST plugin process callback delegate (non accumulating, double-precision).
            <para>See Steinberg VST SDK documentaion for more information.</para>
            </summary>
            <param name="effect">The aeffect as retrieved via <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.</param>
            <param name="inputs">An array of pointers to the data (e.g. for stereo channels this will be an IntPtr to an array of 2 element containing the IntPtr to the float values).</param>
            <param name="outputs">An array of pointers to where the data can be written to (e.g. for stereo channels this will be an IntPtr to an array of 2 element containing the IntPtr to the float values).</param>
            <param name="sampleframes">Number of sample frames to process.</param>
            <remarks>
            <para>This delegate is only used internally within the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT"/> class and can not be used directly! It is also only supported in the .Net Framework version 2.0 or above!</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_SetParameter">
            <summary>
            Set new value of automatable parameter.
            </summary>
            <param name="effect">The aeffect as retrieved via <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.</param>
            <param name="index">The parameter index.</param>
            <param name="parameter">The new parameter value (a float value between 0.0 and 1.0 inclusive).</param>
            <returns>See Steinberg VST SDK documentaion for more information.</returns>
            <remarks>
            <para>This delegate is only used internally within the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT"/> class and can not be used directly! It is also only supported in the .Net Framework version 2.0 or above!</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vst.VST_AEFFECT_GetParameter">
            <summary>
            Gets a value of automatable parameter.
            </summary>
            <param name="effect">The aeffect as retrieved via <see cref="M:Un4seen.Bass.AddOn.Vst.BassVst.BASS_VST_GetInfo(System.Int32,Un4seen.Bass.AddOn.Vst.BASS_VST_INFO)"/>.</param>
            <param name="index">The parameter index.</param>
            <returns>The parameter value (a float value between 0.0 and 1.0 inclusive).</returns>
            <remarks>
            <para>Returns the value of parameter index (a float value between 0.0 and 1.0 inclusive).</para>
            <para>This delegate is only used internally within the <see cref="T:Un4seen.Bass.AddOn.Vst.BASS_VST_AEFFECT"/> class and can not be used directly! It is also only supported in the .Net Framework version 2.0 or above!</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Utils">
            <summary>
            BASS.NET API helper and misc. class containing some general useful methods.
            </summary>
            <remarks>Contains basically some generic converter utilities.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Utils.MakeWord(System.Byte,System.Byte)">
            <summary>
            Returns an signed Int16 value which is composed out of a low and high byte.
            </summary>
            <param name="lowByte">The significant part for the lower 8-bit.</param>
            <param name="highByte">The significant part for the higher 8-bit.</param>
            <returns>The combined signed Int16 value.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)">
            <summary>
            Returns an signed Int32 value which is composed out of a low and high value.
            </summary>
            <param name="lowWord">The significant part for the lower 16-bit.</param>
            <param name="highWord">The significant part for the higher 16-bit.</param>
            <returns>The combined signed Int32 value.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.MakeLong(System.Int32,System.Int32)">
            <summary>
            Returns an signed Int32 value which is composed out of a low and high value.
            </summary>
            <param name="lowWord">The significant part for the lower 16-bit.</param>
            <param name="highWord">The significant part for the higher 16-bit.</param>
            <returns>The combined signed Int32 value.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.MakeLong64(System.Int32,System.Int32)">
            <summary>
            Returns an signed Int64 value which is composed out of a low and high value.
            </summary>
            <param name="lowWord">The significant part for the lower 16-bit.</param>
            <param name="highWord">The significant part for the higher 16-bit.</param>
            <returns>The combined signed Int64 value.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.MakeLong64(System.Int64,System.Int64)">
            <summary>
            Returns an signed Int64 value which is composed out of a low and high value.
            </summary>
            <param name="lowWord">The significant part for the lower 16-bit.</param>
            <param name="highWord">The significant part for the higher 16-bit.</param>
            <returns>The combined signed Int64 value.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.HighWord(System.Int32)">
            <summary>
            Returns the higher 16-bit of an signed Int32 as a short value.
            </summary>
            <param name="dWord">The signed Int32 value from which to extract the higher significant 16-bit.</param>
            <returns>The higher 16-bit value as a short.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.HighWord32(System.Int32)">
            <summary>
            Returns the higher 16-bit of an signed Int32 as an integer value.
            </summary>
            <param name="dWord">The signed Int32 value from which to extract the higher significant 16-bit.</param>
            <returns>The higher 16-bit value as an integer.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.HighWord(System.Int64)">
            <summary>
            Returns the higher 32-bit of an signed Int64 as an integer value.
            </summary>
            <param name="qWord">The signed Int64 value from which to extract the higher significant 32-bit.</param>
            <returns>The higher 32-bit value as an integer.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.LowWord(System.Int32)">
            <summary>
            Returns the lower 16-bit of an signed Int32 as a short value.
            </summary>
            <param name="dWord">The signed Int32 value from which to extract the lower significant 16-bit.</param>
            <returns>The lower 16-bit value as a short.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.LowWord32(System.Int32)">
            <summary>
            Returns the lower 16-bit of an signed Int32 as an integer value.
            </summary>
            <param name="dWord">The signed Int32 value from which to extract the lower significant 16-bit.</param>
            <returns>The lower 16-bit value as an integer.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.LowWord(System.Int64)">
            <summary>
            Returns the lower 32-bit of an signed Int64 as an integer value
            </summary>
            <param name="qWord">The signed Int64 value from which to extract the lower significant 32-bit.</param>
            <returns>The lower 32-bit value as an integer</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)">
            <summary>
            Converts any integer level value to its dB value.
            </summary>
            <param name="level">The integer level to convert.</param>
            <param name="maxLevel">The maximum value allowed as an integer level value (e.g. use 32768 for stream levels)</param>
            <returns>The dB value (from 0dB to -infinite).</returns>
            <remarks>If you pass a level greater than maxLevel positive dB values will be returned.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.LevelToDB(System.Double,System.Double)">
            <summary>
            Converts any level value to its dB value.
            </summary>
            <param name="level">The level to convert, as a double value.</param>
            <param name="maxLevel">The maximum value allowed as a double level value (e.g. use 32768.0 for 16-bit stream levels or use 1.0 for 32-bit floating streams).</param>
            <returns>The dB value (from 0dB to -infinite).</returns>
            <remarks>If you pass a level greater than maxLevel positive dB values will be returned.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)">
            <summary>
            Converts any dB level value to its level value (integer).
            </summary>
            <param name="dB">The dB level to convert.</param>
            <param name="maxLevel">The maximum value allowed as an integer level value (e.g. use 32768 for stream levels)</param>
            <returns>The integer level value (from 0 to maxLevel).</returns>
            <remarks>If you pass a positive dB value then the return value will be greater than maxLevel.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Double)">
            <summary>
            Converts any dB level value to its level value (double).
            </summary>
            <param name="dB">The dB level to convert.</param>
            <param name="maxLevel">The maximum value allowed as a double level value (e.g. use 1.0 for floating-point stream levels)</param>
            <returns>The dopuble level value (from 0 to maxLevel).</returns>
            <remarks>If you pass a positive dB value then the return value will be greater than maxLevel.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.FixTimespan(System.Double)">
            <summary>
            Converts a second value as reveived by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelBytes2Seconds(System.Int32,System.Int64)"/> to a string representation.
            </summary>
            <param name="seconds">A value representing seconds.</param>
            <returns>The seconds as a string in the format: [-][d.]hh:mm:ss[.ff]</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.FixTimespan(System.Double,System.String)">
            <summary>
            Converts a second value as reveived by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelBytes2Seconds(System.Int32,System.Int64)"/> to a string representation.
            </summary>
            <param name="seconds">A value representing seconds.</param>
            <param name="format">One of the following constants:
            <list type="table">
            <item><term>HHMM</term><description></description>hours:minutes, e.g. 00:03</item>
            <item><term>HHMMSS</term><description>hours:minutes:seconds, e.g. 00:03:17</description></item>
            <item><term>MMSS</term><description>minutes:seconds, e.g. 03:17</description></item>
            <item><term>MMSSFF</term><description>minutes:seconds.milliseconds, e.g. 03:17.25</description></item>
            <item><term>MMSSFFF</term><description>minutes:seconds.milliseconds, e.g. 03:17.257</description></item>
            <item><term>MMSSF</term><description>minutes:seconds.milliseconds, e.g. 03:17.2</description></item>
            <item><term>HHMMSSFF</term><description>hours:minutes:seconds.milliseconds, e.g. 00:03:17.25</description></item>
            <item><term>HHMMSSFFF</term><description>hours:minutes:seconds.milliseconds, e.g. 00:03:17.257</description></item>
            <item><term>HHMMSSF</term><description>hours:minutes:seconds.milliseconds, e.g. 00:03:17.2</description></item>
            <item><term>all others</term><description>Will be converted according to the standard DateTimeFormatInfo pattern as specified in the <paramref name="format"/> parameter.</description></item>
            </list>
            </param>
            <returns>The seconds as a string in the given format.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.FFTFrequency2Index(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the index of a specific frequency for FFT data.
            </summary>
            <param name="frequency">The frequency (in Hz) for which to get the index.</param>
            <param name="length">The FFT data length (e.g. 4096 for BASS_DATA_FFT4096).</param>
            <param name="samplerate">The sampling rate of the device or stream (e.g. 44100).</param>
            <returns>The index within the FFT data array (max. to length/2 -1).</returns>
            <remarks>Example: If the stream is 44100Hz, then 16500Hz will be around bin 191 of a 512 sample FFT (512*16500/44100).
            Or, if you are using BASS_DATA_FFT4096 on a stream with a sample rate of 44100 a tone at 540Hz will be at: 540*4096/44100 = 50 (so a bit of the energy will be in fft[51], but mostly in fft[50]).
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.FFTIndex2Frequency(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the frequency of a specific index in FFT data.
            </summary>
            <param name="index">The index within the FFT data array (half the requested).</param>
            <param name="length">The FFT data length (e.g. 4096 for BASS_DATA_FFT4096).</param>
            <param name="samplerate">The sampling rate of the device or stream (e.g. 44100).</param>
            <returns>The frequency (in Hz) which is represented by the index.</returns>
            <remarks>Example: If the stream is 44100Hz, then bin 191 of a 512 sample FFT (191*44100/512) will represent 16451Hz.
            Or, if you are using BASS_DATA_FFT4096 on a stream with a sample rate of 44100 an index of 50 will represent a tone of 538Hz: 50*44100/4096 = 50.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo8Bit(System.Byte)">
            <summary>
            Converts an 8-bit unsigned sample to an unsigned 8-bit sample.
            </summary>
            <param name="sample">The unsigned 8-bit sample to convert.</param>
            <returns>A byte array representing the converted 8-bit unsigned sample (byte[1]).</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo8Bit(System.Int16)">
            <summary>
            Converts a 16-bit signed sample to an 8-bit unsigned sample.
            </summary>
            <param name="sample">The 16-bit signed sample to convert.</param>
            <returns>A byte array representing the converted 8-bit sample (byte[1]).</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo8Bit(System.Single)">
            <summary>
            Converts a float 32-bit signed sample to an 8-bit unsigned sample.
            </summary>
            <param name="sample">The 32-bit signed sample to convert.</param>
            <returns>A byte array representing the converted 8-bit unsigned sample (byte[1]).</returns>
            <remarks>Note: values greater 1.0 or less than -1.0 are capped.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo16Bit(System.Byte)">
            <summary>
            Converts an 8-bit unsigned sample to a 16-bit signed sample.
            </summary>
            <param name="sample">The 8-bit unsigned sample to convert.</param>
            <returns>A byte array representing the converted 16-bit signed sample (byte[2]).</returns>
            <remarks>The byte order is represented in the "Little Endian" format as saved on Intel platforms (meaning lower byte first, the LSB is stored at index 0).
            If you need a "Big Endian" format just traverse the array from the back.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo16Bit(System.Int16)">
            <summary>
            Converts a 16-bit signed sample to a 16-bit signed sample.
            </summary>
            <param name="sample">The 16-bit signed sample to convert.</param>
            <returns>A byte array representing the converted 16-bit signed sample (byte[2]).</returns>
            <remarks>The byte order is represented in the "Little Endian" format as saved on Intel platforms (meaning lower byte first, the LSB is stored at index 0).
            If you need a "Big Endian" format just traverse the array from the back.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo16Bit(System.Single)">
            <summary>
            Converts a float 32-bit signed sample to a 16-bit signed sample.
            </summary>
            <param name="sample">The 32-bit signed sample to convert.</param>
            <returns>A byte array representing the converted 16-bit signed sample (byte[2]).</returns>
            <remarks>The byte order is represented in the "Little Endian" format as saved on Intel platforms (meaning lower byte first, the LSB is stored at index 0).
            If you need a "Big Endian" format just traverse the array from the back.
            <para>Note: values greater 1.0 or less than -1.0 are capped.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo24Bit(System.Byte)">
            <summary>
            Converts an 8-bit unsigned sample to a 24-bit signed sample.
            </summary>
            <param name="sample">The 8-bit unsigned sample to convert.</param>
            <returns>A byte array representing the converted 24-bit signed sample (byte[3]).</returns>
            <remarks>The byte order is represented in the "Little Endian" format as saved on Intel platforms (meaning lower byte first, the LSB is stored at index 0).
            If you need a "Big Endian" format just traverse the array from the back.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo24Bit(System.Int16)">
            <summary>
            Converts a 16-bit signed sample to a 24-bit signed sample.
            </summary>
            <param name="sample">The 16-bit signed sample to convert.</param>
            <returns>A byte array representing the converted 24-bit signed sample (byte[3]).</returns>
            <remarks>The byte order is represented in the "Little Endian" format as saved on Intel platforms (meaning lower byte first, the LSB is stored at index 0).
            If you need a "Big Endian" format just traverse the array from the back.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo24Bit(System.Single)">
            <summary>
            Converts a float 32-bit signed sample to a 24-bit signed sample.
            </summary>
            <param name="sample">The 32-bit signed sample to convert.</param>
            <returns>A byte array representing the converted 24-bit signed sample (byte[3]).</returns>
            <remarks>The byte order is represented in the "Little Endian" format as saved on Intel platforms (meaning lower byte first, the LSB is stored at index 0).
            If you need a "Big Endian" format just traverse the array from the back.
            <para>Note: values greater 1.0 or less than -1.0 are capped.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo32Bit(System.Byte)">
            <summary>
            Converts an 8-bit unsigned sample to a float 32-bit signed sample.
            </summary>
            <param name="sample">The 8-bit unsigned sample to convert.</param>
            <returns>A float 32-bit signed value representing the converted 8-bit unsigned sample.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo32Bit(System.Int16)">
            <summary>
            Converts a 16-bit signed sample to a float 32-bit signed sample.
            </summary>
            <param name="sample">The 16-bit signed sample to convert.</param>
            <returns>A float 32-bit signed value representing the converted 16-bit signed sample.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo32Bit(System.Byte[])">
            <summary>
            Converts a byte array (in "Little Endian" notation) to a float 32-bit signed sample.
            </summary>
            <param name="sample">The byte array sample to convert (must by in "Little Endian", low byte first notation).</param>
            <returns>A float 32-bit signed value representing the converted sample.</returns>
            <remarks>The length of the byte array determines the value to convert. A length of 1 will be treated as an 8-bit sample, a length of 2 will be treated as a 16-bit sample, a length of 3 will be treated as a 24-bit sample etc.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo24Bit(System.Byte[])">
            <summary>
            Converts a byte array (in "Little Endian" notation) to a 24-bit signed sample.
            </summary>
            <param name="sample">The byte array sample to convert (must by in "Little Endian", low byte first notation).</param>
            <returns>A int 24-bit signed value representing the converted sample.</returns>
            <remarks>The length of the byte array must be at least 3 (however only the last 3 elements are evaluated).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo16Bit(System.Byte[])">
            <summary>
            Converts a byte array (in "Little Endian" notation) to a 16-bit signed sample.
            </summary>
            <param name="sample">The byte array sample to convert (must by in "Little Endian", low byte first notation).</param>
            <returns>A short 16-bit signed value representing the converted sample.</returns>
            <remarks>The length of the byte array must be at least 2 (however only the last 2 elements are evaluated).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo8Bit(System.Byte[])">
            <summary>
            Converts a byte array (in "Little Endian" notation) to an 8-bit unsigned sample.
            </summary>
            <param name="sample">The byte array sample to convert (must by in "Little Endian", low byte first notation).</param>
            <returns>A byte 8-bit unsigned value representing the converted sample.</returns>
            <remarks>The length of the byte array must be at least 1 (however only the last element is evaluated).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.Semitone2Samplerate(System.Single,System.Int32)">
            <summary>
            Calculates a new samplerate according to a shift of an original samplerate by a number of semitones.
            </summary>
            <remarks>A semitone, or half-step is a musical interval. An octave is 12 semitones wide.
            Changing a samplerate in semitones will result in faster resp. slower playback - speed.</remarks>
            <param name="origfreq">The original samplerate which should be changed.</param>
            <param name="semitones">The number of semitones for which the original samplerate should be changed (negative values will slow down, positve numbers will fasten).</param>
            <returns>The resulting samplerate which was changed by the number of given semitones.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.BPM2Seconds(System.Single)">
            <summary>
            Calculates the length of one beat for a given BPM value.
            </summary>
            <param name="bpm">The BPM value to translate.</param>
            <returns>The length in seconds of one beat (or -1 if bpm is zero).</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.Seconds2BPM(System.Double)">
            <summary>
            Calculates the BPM value which represented the given length for one beat.
            </summary>
            <param name="seconds">The length of one beat in seconds.</param>
            <returns>The translated BPM value (or -1 if seconds is zero).</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrAsStringAnsi(System.IntPtr)">
            <summary>
            Translates an IntPtr into a .NET managed string.
            <para>Sometime BASS returns an IntPtr which actually represents a pointer to a memory block containing a null-terminated Ansi *char (string, 8-bit).
            This method does this translation for you and returns the actual string.</para>
            </summary>
            <param name="ansiPtr">The IntPtr which represents the address of the first character of the unmanaged *char (string, 8-bit).</param>
            <returns>The translated unicode string.</returns>
            <remarks>This method actually expands the original 8-bit chars to unicode 16-bit chars as required by .NET (since here each string a unicode ;-).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrAsStringUnicode(System.IntPtr)">
            <summary>
            Translates an IntPtr into a .NET managed string.
            <para>Sometime BASS returns an IntPtr which actually represents a pointer to a memory block containing a null-terminated Unicode *char (string, 16-bit).
            This method does this translation for you and returns the actual string.</para>
            </summary>
            <param name="unicodePtr">The IntPtr which represents the address of the first character of the unmanaged *char (string, 16-bit).</param>
            <returns>The translated unicode string.</returns>
            <remarks>This method actually expands the original UFT-8 chars to unicode 16-bit chars as required by .NET (since here each string a unicode ;-).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrAsStringUtf8(System.IntPtr)">
            <summary>
            Translates an IntPtr into a .NET managed string.
            <para>Sometime BASS returns an IntPtr which actually represents a pointer to a memory block containing a null-terminated UTF-8 *char (string, 16-bit).
            This method does this translation for you and returns the actual string.</para>
            </summary>
            <param name="utf8Ptr">The IntPtr which represents the address of the first character of the unmanaged *char (string, UTF-8, 16-bit).</param>
            <returns>The translated unicode string.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntAsObject(System.IntPtr,System.Type)">
            <summary>
            Translates an IntPtr into a .NET managed object of a given <see cref="T:System.Type"/>.
            <para>Sometime BASS returns a pointer which actually represents a memory block containing a structured object.
            This method does this translation for you and returns the actual object.</para>
            </summary>
            <param name="ptr">The pointer which represents the address of the structured object.</param>
            <param name="structureType">The <see cref="T:System.Type"/> of object to be created. This type object must represent a formatted class or structure.</param>
            <returns>The managed object of the specified type.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetVersion">
            <summary>
            Returns the version of the BASS.NET API (Bass.Net.dll)
            </summary>
            <returns>The version of the Bass.Net.dll</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrToArrayNullTermAnsi(System.IntPtr)">
            <summary>
            Retrieves an array of strings from a given unmanaged memory location.
            <para>NOTE: This method evaluates the pointer as 'a series/array of null-terminated Ansi strings.</para>
            </summary>
            <param name="pointer">The pointer to the unmanaged memory block.</param>
            <returns>NULL or an array of strings. Each array element will represent one text as obtained from the IntPtr.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrToArrayNullTermUtf8(System.IntPtr)">
            <summary>
            Retrieves an array of strings from a given unmanaged memory location.
            <para>NOTE: This method evaluates the pointer as 'a series/array of null-terminated UTF-8 strings.</para>
            </summary>
            <param name="pointer">The pointer to the unmanaged memory block.</param>
            <returns>NULL or an array of strings. Each array element will represent one text as obtained from the IntPtr.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrToArrayNullTermUnicode(System.IntPtr)">
            <summary>
            Retrieves an array of strings from a given unmanaged memory location.
            <para>NOTE: This method evaluates the pointer as 'a series/array of null-terminated UNICODE strings.</para>
            </summary>
            <param name="pointer">The pointer to the unmanaged memory block.</param>
            <returns>NULL or an array of strings. Each array element will represent one text as obtained from the IntPtr.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrToArrayNullTermInt32(System.IntPtr)">
            <summary>
            Retrieves an array of int from a given unmanaged memory location.
            <para>NOTE: This method evaluates the pointer as 'a series/array of Int32 values terminated by a 0 value.</para>
            </summary>
            <param name="pointer">The pointer to the unmanaged memory block.</param>
            <returns>NULL or an array of int. Each array element will represent one Int32 value as obtained from the IntPtr.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrToArrayNullTermInt16(System.IntPtr)">
            <summary>
            Retrieves an array of int from a given unmanaged memory location.
            <para>NOTE: This method evaluates the pointer as 'a series/array of Int16 values terminated by a 0 value.</para>
            </summary>
            <param name="pointer">The pointer to the unmanaged memory block.</param>
            <returns>NULL or an array of int. Each array element will represent one Int16 value as obtained from the IntPtr.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.ChannelNumberToString(System.Int32)">
            <summary>
            Converts a channel number to a string.
            </summary>
            <param name="chans">The number of channels.</param>
            <returns>The description of number of channels.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSChannelTypeToString(Un4seen.Bass.BASSChannelType)">
            <summary>
            Converts a <see cref="T:Un4seen.Bass.BASSChannelType"/> to a character representation describing the channel type or file type. Returns e.g. 'WMA', 'FLAC', 'MP3' etc.
            </summary>
            <param name="ctype">The <see cref="T:Un4seen.Bass.BASSChannelType"/> for which to get the description (needs to be casted to an int).</param>
            <returns>The description of the channel type.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)">
            <summary>
            Returns the supported stream file extensions of the given add-on file (e.g. "bassflac.dll").
            <para>Use NULL to retrieve the native supported stream file extensions of Bass.</para>
            <para>Use "music" to retrive the native supported music file extensions of Bass.</para>
            </summary>
            <param name="file">The file name and/or path of the bass add-on dll from which to retrieve the supported file extensions (or NULL or "music").</param>
            <returns>A list of supported file extensions (pattern-like, semicolon-seperated, e.g. "*.wma;*.wmv").</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileName(System.String)">
            <summary>
            Returns the supported stream file name of the given add-on file (e.g. "bassflac.dll").
            <para>Use NULL to retrieve the native supported stream file name of Bass.</para>
            <para>Use "music" to retrive the native supported music name of Bass.</para>
            </summary>
            <param name="file">The file name and/or path of the bass add-on dll from which to retrieve the supported file name (or NULL or "music").</param>
            <returns>The name of the supported audio format (e.g. "Windows Media Audio").</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.Collections.Generic.Dictionary{System.Int32,System.String},System.Boolean)">
            <summary>
            Returns the supported stream file extensions for all loaded plugins.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method.</param>
            <param name="includeBASS">TRUE, if also the native BASS formats should be added.</param>
            <returns>The supported stream file extension string (*.ext1;*.ext2;...*.extN)</returns>
            <remarks>This method uses <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)"/> internally and might include all native BASS extensions.</remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory(dir);
            string exts = Utils.BASSAddOnGetSupportedFileExtensions(loadedPlugIns, true);
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory(dir)
            Dim exts As String = Utils.BASSAddOnGetSupportedFileExtensions(loadedPlugIns, True)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileFilter(System.Collections.Generic.Dictionary{System.Int32,System.String},System.String)">
            <summary>
            Returns a file filter which can be used in a standard 'OpenFileDialog'.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method.</param>
            <param name="allFormatName">The name of the first entry which will describe all available formats. Or NULL, if only the plain formats should be returned.</param>
            <returns>The file filter string which can be used in a standard 'OpenFileDialog' in the format:
            allFormatName|AllExtensions|FormatName1|externtions1|FormatName2|externtions2...</returns>
            <remarks>This method uses <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileName(System.String)"/> and <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)"/> internally and also includes all native BASS formats.</remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory(dir);
            openFileDialog.Filter = Utils.BASSAddOnGetSupportedFileFilter(loadedPlugIns, "All supported Audio Files");
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory(dir)
            openFileDialog.Filter = Utils.BASSAddOnGetPluginFileFilter(loadedPlugIns, "All supported Audio Files")
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileFilter(System.Collections.Generic.Dictionary{System.Int32,System.String},System.String,System.Boolean)">
            <summary>
            Returns a file filter which can be used in a standard 'OpenFileDialog'.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method.</param>
            <param name="allFormatName">The name of the first entry which will describe all available formats. Or NULL, if only the plain formats should be returned.</param>
            <param name="includeBASS">TRUE, if also the native BASS formats should be added.</param>
            <returns>The file filter string which can be used in a standard 'OpenFileDialog' in the format:
            allFormatName|AllExtensions|FormatName1|externtions1|FormatName2|externtions2...</returns>
            <remarks>This method uses <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileName(System.String)"/> and <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)"/> internally.</remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory(dir);
            openFileDialog.Filter = Utils.BASSAddOnGetSupportedFileFilter(loadedPlugIns, null, false);
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory(dir)
            openFileDialog.Filter = Utils.BASSAddOnGetPluginFileFilter(loadedPlugIns, Nothing, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetPluginFileFilter(System.Collections.Generic.Dictionary{System.Int32,System.String},System.String)">
            <summary>
            Returns a file filter which can be used in a standard 'OpenFileDialog'.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method.</param>
            <param name="allFormatName">The name of the first entry which will describe all available formats. Or NULL, if only the plain formats should be returned.</param>
            <returns>The file filter string which can be used in a standard 'OpenFileDialog' in the format:
            allFormatName|AllExtensions|FormatName1|externtions1|FormatName2|externtions2...</returns>
            <remarks>This method uses <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> and <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)"/> internally and also includes all native BASS formats.</remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory(dir);
            openFileDialog.Filter = Utils.BASSAddOnGetPluginFileFilter(loadedPlugIns, "All supported Audio Files");
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory(dir)
            openFileDialog.Filter = Utils.BASSAddOnGetPluginFileFilter(loadedPlugIns, "All supported Audio Files")
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetPluginFileFilter(System.Collections.Generic.Dictionary{System.Int32,System.String},System.String,System.Boolean)">
            <summary>
            Returns a file filter which can be used in a standard 'OpenFileDialog'.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method.</param>
            <param name="allFormatName">The name of the first entry which will describe all available formats. Or NULL, if only the plain formats should be returned.</param>
            <param name="includeBASS">TRUE, if also the native BASS formats should be added.</param>
            <returns>The file filter string which can be used in a standard 'OpenFileDialog' in the format:
            allFormatName|AllExtensions|FormatName1|externtions1|FormatName2|externtions2...</returns>
            <remarks>This method uses <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> and <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)"/> internally.</remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory(dir);
            openFileDialog.Filter = Utils.BASSAddOnGetPluginFileFilter(loadedPlugIns, null, false);
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory(dir)
            openFileDialog.Filter = Utils.BASSAddOnGetPluginFileFilter(loadedPlugIns, Nothing, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnIsFileSupported(System.Collections.Generic.Dictionary{System.Int32,System.String},System.String)">
            <summary>
            Checks if a certain file is supported by the currently loaded add-ons.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method or NULL to only check BASS extensions.</param>
            <param name="filename">The audio filename to check,</param>
            <returns>TRUE, if the audio file is supported by any of the loaded plugins.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.AbsSignMax(System.Int16,System.Int16)">
            <summary>
            Returns the absolute signed maximum value of two values.
            </summary>
            <param name="val1">The first value to compare.</param>
            <param name="val2">The second value to compare.</param>
            <returns>The signed value of the parameter whose absolute value is greater.</returns>
            <remarks>The two values are compared by their absolute unsigned value but are returned with their signed value.
            E.g. -10000 will be returned by comparing -10000 and +8000.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.AbsSignMax(System.Single,System.Single)">
            <summary>
            Returns the absolute signed maximum value of two values.
            </summary>
            <param name="val1">The first value to compare.</param>
            <param name="val2">The second value to compare.</param>
            <returns>The signed value of the parameter whose absolute value is greater.</returns>
            <remarks>The two values are compared by their absolute unsigned value but are returned with their signed value.
            E.g. -10000 will be returned by comparing -10000 and +8000.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleDither(System.Double,System.Double,System.Double)">
            <summary>
            Applies a dither to a single sample value.
            </summary>
            <param name="sample">The sample data to add a dither to (e.g. an 8- or 16-bit sample value as a double value).</param>
            <param name="factor">The bit depth factor for the dither (typically between 0.3 and 0.9).</param>
            <param name="max">The maximum sample data range (e.g. 256 for 8-bit samples or 32768 for 16-bit samples).</param>
            <returns>The dithered sample value: </returns>
            <remarks>Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dithering here is implemented as a triangular probability density function (TPDF), actually a factor-bit triangular dither.</para>
            <para>All parameters here are implemented as double values for maximum precision and performance. 
            However, you might also pass 8-bit(byte) or 16-bit(short) values and then simply cast back the return value.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The 16-bit buffer to get the level from.</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size, use -1 to scan the whole buffer size).</param>
            <returns>If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits). If the channel is mono, then the low word is duplicated in the high word.</returns>
            <remarks>
            <para>Structure of the return value (int = 32-bit):
            <code lang="none">
            |               32-bit              |
            |    right-peak    |   left-peak    |
            </code>
            </para>
            <para>Each peak level ranges linearly from 0 (silent) to +32767 (max).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel2(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The 16-bit buffer to get the level from.</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size, use -1 to scan the whole buffer size).</param>
            <returns>If successful, the level of the left channel is returned in the low Dword (low 32-bits), and the level of the right channel is returned in the high Dword (high 32-bits).
            Each Dword (32-bit) carries the maximum peak level value in the high word (high 16-bit) and the the minimum peak level value in the low word (low 16-bit).
            If the channel is mono, then the low Dword is duplicated in the high Dword.</returns>
            <remarks>
            <para>Structure of one element (long = 64-bit):
            <code lang="none">
            |               64-bit              |
            |      right       |      left      |
            |max.peak|min.peak|max.peak|min.peak|
            </code>
            </para>
            <para>Each peak level ranges linearly from -32768 to 0 (silent) to +32767.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The 32-bit buffer to get the level from.</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size, use -1 to scan the whole buffer size).</param>
            <returns>If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits). If the channel is mono, then the low word is duplicated in the high word.</returns>
            <remarks>
            <para>Structure of the return value (int = 32-bit):
            <code lang="none">
            |               32-bit              |
            |    right-peak    |   left-peak    |
            </code>
            </para>
            <para>Each peak level ranges linearly from 0 (silent) to +32767 (max).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel2(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The 32-bit buffer to get the level from.</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size, use -1 to scan the whole buffer size).</param>
            <returns>If successful, the level of the left channel is returned in the low Dword (low 32-bits), and the level of the right channel is returned in the high Dword (high 32-bits).
            Each Dword (32-bit) carries the maximum peak level value in the high word (high 16-bit) and the the minimum peak level value in the low word (low 16-bit).
            If the channel is mono, then the low Dword is duplicated in the high Dword.</returns>
            <remarks>
            <para>Structure of one element (long = 64-bit):
            <code lang="none">
            |               64-bit              |
            |      right       |      left      |
            |max.peak|min.peak|max.peak|min.peak|
            </code>
            </para>
            <para>Each peak level ranges linearly from -32768 to 0 (silent) to +32767.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The 8-bit buffer to get the level from.</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size, use -1 to scan the whole buffer size).</param>
            <returns>If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits). If the channel is mono, then the low word is duplicated in the high word.</returns>
            <remarks>
            <para>Structure of the return value (int = 32-bit):
            <code lang="none">
            |               32-bit              |
            |    right-peak    |   left-peak    |
            </code>
            </para>
            <para>Each peak level ranges linearly from 0 (silent) to +32767 (max).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel2(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The 8-bit buffer to get the level from.</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size, use -1 to scan the whole buffer size).</param>
            <returns>If successful, the level of the left channel is returned in the low Dword (low 32-bits), and the level of the right channel is returned in the high Dword (high 32-bits).
            Each Dword (32-bit) carries the maximum peak level value in the high word (high 16-bit) and the the minimum peak level value in the low word (low 16-bit).
            If the channel is mono, then the low Dword is duplicated in the high Dword.</returns>
            <remarks>
            <para>Structure of one element (long = 64-bit):
            <code lang="none">
            |               64-bit              |
            |      right       |      left      |
            |max.peak|min.peak|max.peak|min.peak|
            </code>
            </para>
            <para>Each peak level ranges linearly from -32768 to 0 (silent) to +32767.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The buffer pointer to the sample data (e.g. as obtained in a <see cref="T:Un4seen.Bass.DSPPROC"/>).</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="bps">The bytes per sample (or bitwidth) - which can be either 1, 2 or 4 bytes per sample or 8, 16 or 32 bits per sample.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size) - no range check is applied here!.</param>
            <returns>If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits). If the channel is mono, then the low word is duplicated in the high word.</returns>
            <remarks>
            <para>Structure of the return value (int = 32-bit):
            <code lang="none">
            |               32-bit              |
            |    right-peak    |   left-peak    |
            </code>
            </para>
            <para>Each peak level ranges linearly from 0 (silent) to +32767 (max).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel2(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The buffer pointer to the sample data (e.g. as obtained in a <see cref="T:Un4seen.Bass.DSPPROC"/>).</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="bps">The bytes per sample (or bitwidth) - which can be either 1, 2 or 4 bytes per sample or 8, 16 or 32 bits per sample.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size) - no range check is applied here!.</param>
            <returns>If successful, the level of the left channel is returned in the low Dword (low 32-bits), and the level of the right channel is returned in the high Dword (high 32-bits).
            Each Dword (32-bit) carries the maximum peak level value in the high word (high 16-bit) and the the minimum peak level value in the low word (low 16-bit).
            If the channel is mono, then the low Dword is duplicated in the high Dword.</returns>
            <remarks>
            <para>Structure of one element (long = 64-bit):
            <code lang="none">
            |               64-bit              |
            |      right       |      left      |
            |max.peak|min.peak|max.peak|min.peak|
            </code>
            </para>
            <para>Each peak level ranges linearly from -32768 to 0 (silent) to +32767.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DecodeAllData(System.Int32,System.Boolean)">
            <summary>
            Decodes all the available data of the given channel right away.
            </summary>
            <param name="channel">The channel handle who's channel data should be decoded (should typically be a decoding channel).</param>
            <param name="autoFree">TRUE, if the channel should be freed (via <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/>) when all the data has been decoded.</param>
            <returns>The total number of bytes actually decoded.</returns>
            <remarks>Internally <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> will be called in a loop as long as the channel is active (BASS_ACTIVE_PLAYING).
            This method might be useful, if you want to quickly decode all the data of the channel to e.g. feed it through a DSP.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DetectCuePoints(System.String,System.Single,System.Double@,System.Double@,System.Double,System.Double,System.Int32)">
            <summary>
            Detects the cue-in and -out points of a given audio file.
            </summary>
            <param name="filename">The audio file to analyze.</param>
            <param name="blockSize">The block-size in seconds which will be used to scan the file (between 0.1 and 30 seconds).</param>
            <param name="cueInPos">Returns the cue-in position in seconds according to <paramref name="dBIn"/>.</param>
            <param name="cueOutPos">Returns the cue-out position in seconds according to <paramref name="dBOut"/>.</param>
            <param name="dBIn">The threshold in dB to be used to detect the <paramref name="cueInPos"/>.</param>
            <param name="dBOut">The threshold in dB to be used to detect the <paramref name="cueOutPos"/>.</param>
            <param name="findZeroCrossing">Position adjustment flag. 0=no adjustment, 1=move to zero-crossing sample to avoid clicks, 2=move to quiter sample (threshold/2) to avoid clicks.</param>
            <returns>TRUE on success - else FALSE.</returns>
            <remarks>If <paramref name="findZeroCrossing"/> is set to 1 the zero-crossing determination will only be performed within the last analyzed <paramref name="blockSize"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetNormalizationGain(System.String,System.Single,System.Double,System.Double)">
            <summary>
            Determines a gain factor (normalization), so that the maximum peak level of the stream will be at 0 dB.
            </summary>
            <param name="filename">The audio file to analyze.</param>
            <param name="blockSize">The block-size in seconds which will be used to scan the file (between 0.1 and 30 seconds).</param>
            <param name="startpos">The position (in seconds) where to start the calculation (between 0 and file duration, or -1 to scan from the beginning).</param>
            <param name="endpos">The position (in seconds) til where to perform the calculation (between 0 and file duration, or -1 to scan til the end; must be bigger than startpos).</param>
            <returns>The gain factor as a float value (or -1 on error) - a value of 1 means no amplification.</returns>
            <remarks>
            You might use the gain factor as a multiplier to the sample data to apply a volume adjustment, so that the maximum peak level of the audio samples is at 0 dB.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DMACopyMemory(System.IntPtr,System.IntPtr,System.Int64)">
            <summary>
            DMA (kernel32.dll) - The CopyMemory function copies a block of memory from one location to another.
            </summary>
            <param name="destination">Pointer to the starting address of the copied block's destination.</param>
            <param name="source">Pointer to the starting address of the block of memory to copy.</param>
            <param name="length">Size of the block of memory to copy, in bytes.</param>
            <remarks>If the source and destination blocks overlap, the results are undefined. For overlapped blocks, use the <see cref="M:Un4seen.Bass.Utils.DMAMoveMemory(System.IntPtr,System.IntPtr,System.IntPtr)"/> function.
            <para>CAUTION: This method makes a direct call to the windows kernel.dll - you can crash everything when using it in a wrong way!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DMAMoveMemory(System.IntPtr,System.IntPtr,System.Int64)">
            <summary>
            DMA (kernel32.dll) - The MoveMemory function moves a block of memory from one location to another.
            </summary>
            <param name="destination">Pointer to the starting address of the move destination.</param>
            <param name="source">Pointer to the starting address of the block of memory to be moved.</param>
            <param name="length">Size of the block of memory to move, in bytes.</param>
            <remarks>The source and destination blocks may overlap.
            <para>CAUTION: This method makes a direct call to the windows kernel.dll - you can crash everything when using it in a wrong way!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DMAFillMemory(System.IntPtr,System.Int64,System.Byte)">
            <summary>
            DMA (kernel32.dll) - The FillMemory macro fills a block of memory with a specified value.
            </summary>
            <param name="destination">Pointer to the starting address of the block of memory to fill.</param>
            <param name="length">Size of the block of memory to fill, in bytes. This value must be less than the size of the Destination buffer.</param>
            <param name="fill">Byte value with which to fill the memory block.</param>
            <remarks>
            <para>CAUTION: This method makes a direct call to the windows kernel.dll - you can crash everything when using it in a wrong way!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DMAZeroMemory(System.IntPtr,System.Int64)">
            <summary>
            DMA (kernel32.dll) - The ZeroMemory macro fills a block of memory with zeros.
            </summary>
            <param name="destination">Pointer to the starting address of the block of memory to fill with zeros.</param>
            <param name="length">Size of the block of memory to fill with zeros, in bytes.</param>
            <remarks>
            <para>CAUTION: This method makes a direct call to the windows kernel.dll - you can crash everything when using it in a wrong way!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.LIBLoadLibrary(System.String)">
            <summary>
            LIB (kernel32.dll) - Loads a native unmanaged library (dll) into the process of our executable.
            </summary>
            <param name="fileName">Name and/or path to the executable module (either a .dll or .exe file). The name specified is the file name of the module and is not related to the name stored in the library module itself.
            <para>If the string does not specify a path, the function uses a standard search strategy to find the file</para>
            </param>
            <returns>If the function succeeds, the return value is a handle to the module. If the function fails, the return value is 0.</returns>
            <remarks>This can be used for late bound explicit linking.
            <para>If fileName does not include a path and there is more than one loaded module with the same base name and extension, the function returns a handle to the module that was loaded first.
            If no file name extension is specified in the fileName parameter, the default library extension .dll is appended. However, the file name string can include a trailing point character (.) to indicate that the module name has no extension. 
            When no path is specified, the function searches for loaded modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds. Otherwise, the function searches for the file.
            The first directory searched is the one directory containing the image file used to create the calling process.
            </para>
            <para>A module loaded via LIBLoadLibrary should be released using the <see cref="M:Un4seen.Bass.Utils.LIBFreeLibrary(System.Int32)"/> method when it is not needed anymore.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.LIBFreeLibrary(System.Int32)">
            <summary>
            This function decrements the reference count of the loaded dynamic-link library (DLL) loaded via <see cref="M:Un4seen.Bass.Utils.LIBLoadLibrary(System.String)"/>. 
            When the reference count reaches zero, the module is unmapped from the address space of the calling process and the handle is no longer valid.
            </summary>
            <param name="hModule">Handle to the loaded DLL module. The <see cref="M:Un4seen.Bass.Utils.LIBLoadLibrary(System.String)"/> returns this handle.</param>
            <returns>If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE.</returns>
            <remarks>Each process maintains a reference count for each loaded library module. This reference count is incremented each time <see cref="M:Un4seen.Bass.Utils.LIBLoadLibrary(System.String)"/> is called and is decremented each time <see cref="M:Un4seen.Bass.Utils.LIBFreeLibrary(System.Int32)"/> is called.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.LoadLib(System.String,System.Int32@)">
            <summary>
            For internal use only! Will load a given dll into memory.
            </summary>
            <param name="moduleName">The name and/or path of the module (dll) to load.</param>
            <param name="handle">The handle where to store the returned module handle when loaded.</param>
            <returns>TRUE on success, else FALSE.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.FreeLib(System.Int32@)">
            <summary>
            For internal use only! Will unload a dll by handle.
            </summary>
            <param name="handle">The module handle to unload.</param>
            <returns>TRUE on success, else FALSE.</returns>
        </member>
        <member name="P:Un4seen.Bass.Utils.Is64Bit">
            <summary>
            Returns TRUE, if running on a 64-bit Operating-System - else false (32-bit OS).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSTimer">
            <summary>
            Implements a secure Timer, which raises an event in defined intervals.
            </summary>
            <remarks>This timer implementation is based on the <see cref="T:System.Threading.Timer"/>, but is optimized to be used in multi-threading environments as well as UI threads.
            <para>This Timer uses a <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event handler which will be raised every <see cref="P:Un4seen.Bass.BASSTimer.Interval"/> milliseconds once the <see cref="M:Un4seen.Bass.BASSTimer.Start"/> method was called and the timer is activated.</para>
            <para>This implementation ensures, that the <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event will be executed in the main thread the subscriber executes in!
            So when subscribing to this event from a UI thread, the specified event delegate will also be called in that UI thread.</para>
            <para>Use the <see cref="M:Un4seen.Bass.BASSTimer.Stop"/> method to deactivate the Timer.</para>
            <para>You might change the <see cref="P:Un4seen.Bass.BASSTimer.Interval"/> at any time. If the Timer has already been activated, this will also take immediate effect (the next <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event will be raised after the new interval value).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSTimer.#ctor">
            <summary>
            Creates a new Timer instance using a default interval of 50ms.
            </summary>
            <remarks>The timer will not be activated automatically. Call <see cref="M:Un4seen.Bass.BASSTimer.Start"/> to activate the timer.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSTimer.#ctor(System.Int32)">
            <summary>
            Creates a new Timer instance using the given interval.
            </summary>
            <param name="interval">The interval in milliseconds at which the <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event should be raised.</param>
            <remarks>The timer will not be activated automatically. Call <see cref="M:Un4seen.Bass.BASSTimer.Start"/> to activate the timer.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSTimer.Dispose">
            <summary>
            Implement IDisposable.
            </summary>
            <remarks>Do not make this method virtual. A derived class should not be able to override this method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSTimer.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSTimer.Start">
            <summary>
            Activates (starts) the Timer.
            </summary>
            <remarks>After activating the Timer every <see cref="P:Un4seen.Bass.BASSTimer.Interval"/> milliseconds a <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event will be raised.
            <para>Calling this method on an already active timer will have no effect.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSTimer.Stop">
            <summary>
            Deativates (stops) the Timer.
            </summary>
            <remarks>After deactivating the Timer no more <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> events will be raised.</remarks>
        </member>
        <member name="E:Un4seen.Bass.BASSTimer.Tick">
            <summary>
            Event handler used to notify that the timer has elapsed.
            </summary>
            <remarks>This event will be raised, if the Timer has been started (see <see cref="M:Un4seen.Bass.BASSTimer.Start"/>) and the <see cref="P:Un4seen.Bass.BASSTimer.Interval"/> has been elapsed.
            <para>Note: This implementation ensures, that the event will be executed in the main thread the subscriber executes in!
            So when subscribing to this event from UI thread, the specified event delegate will also be called in that UI thread.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASSTimer.Interval">
            <summary>
            Gets or Sets the number of milliseconds between two <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> events.
            </summary>
            <remarks>To get the interval in seconds you need to divide this nbumber by 1000.
            <para>The <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event will only be raised, if the Timer is active (see <see cref="M:Un4seen.Bass.BASSTimer.Start"/>).</para>
            <para>Specify 0 (zero) or a nagative value to inactivate the periodic signalling of the <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event - however in this case the Timer remain activated.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASSTimer.Enabled">
            <summary>
            Gets or Sets if the Timer is currently active.
            </summary>
            <remarks>Returns TRUE, if the Timer is active.
            <para>Setting this property will have the same effect as calling <see cref="M:Un4seen.Bass.BASSTimer.Start"/> respectivly <see cref="M:Un4seen.Bass.BASSTimer.Stop"/>.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.BASSBuffer">
            <summary>
            Implements a fast and generic circular ring buffer (FiFo).
            </summary>
            <remarks>This implementation uses an internal byte array as a buffer and can be used in multi-threading environments, since all members are thread-safe.
            <para>The default size of the ring buffer is 2 seconds (when using it with 44.1kHz, 16-bit stereo sample data).</para>
            <para>This class supports multiple readers using the ring buffer (default is 1). Use the <see cref="P:Un4seen.Bass.BASSBuffer.Readers"/> property to set the maximum number of parallel readers accessing the ring buffer.</para>
            <para>The ring buffer is not a dynamic buffer, meaning it has a fixed size once created. However, the ring buffer size might be increased at any time through the <see cref="M:Un4seen.Bass.BASSBuffer.Resize(System.Single)"/> method, even if you should avoid this for performance reasons.</para>
            <para>Use the <see cref="M:Un4seen.Bass.BASSBuffer.Write(System.IntPtr,System.Int32)"/> method to add sample data to the ring buffer. And use the <see cref="M:Un4seen.Bass.BASSBuffer.Read(System.IntPtr,System.Int32,System.Int32)"/> method to retrieve sample data from the ring buffer.</para>
            <para>This class might be useful for full-duplex monitoring of a recording streams or in order to clone existing streams.</para>
            <para>In order to reduce latency, you might probably want to minimize the recording update period (see <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>.
            You'll probably also want to reduce the update period (BASS_CONFIG_UPDATEPERIOD) and buffer length (BASS_CONFIG_BUFFER), to reduce output latency (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>).</para>
            </remarks>
            <example>
            BASS Recording with full-duplex monitoring:
            <code>
            private RECORDPROC _myRecProc; // make it global, so that the GC can not remove it
            private int _recHandle = 0;
            // The buffer: 44.1kHz, 16-bit, stereo (like we record!)
            private BASSBuffer _monBuffer = new BASSBuffer(2f, 44100, 2, 16);
            private int _monStream = 0;
            private STREAMPROC _monProc = null;
            ...
            // enable lower latency settings (optional)
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 20);
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_BUFFER, 100);
            // start recording with 20ms update period
            _myRecProc = new RECORDPROC(MyRecording);
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, 20, _myRecProc, IntPtr.Zero);
            // setup the full-duplex monitoring
            _monProc = new STREAMPROC(MonitoringStream);
            _monStream = Bass.BASS_StreamCreate(44100, 2, 0, _monProc, IntPtr.Zero); // user = reader#
            Bass.BASS_ChannelPlay(_monStream, false);
            
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
            	monBuffer.Write(buffer, length);
            }
            
            private int MonitoringStream(int handle, IntPtr buffer, int length, IntPtr user)
            {
            	return monBuffer.Read(buffer, length, user.ToInt32());
            }
            </code>
            <code lang="vbnet">
            Private _myRecProc As RECORDPROC ' make it global, so that the GC can not remove it
            Private _recHandle As Integer = 0
            ' The buffer: 44.1kHz, 16-bit, stereo (like we record!)
            Private _monBuffer As New BASSBuffer(2F, 44100, 2, 16)
            Private _monStream As Integer = 0
            Private _monProc As STREAMPROC = Nothing
            ...
            ' enable lower latency settings (optional)
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 20)
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_BUFFER, 100)
            ' start recording with 20ms update period
            _myRecProc = New RECORDPROC(MyRecording)
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, 20, _myRecProc, IntPtr.Zero)
            ' setup the full-duplex monitoring
            _monProc = New STREAMPROC(AddressOf MonitoringStream)
            _monStream = Bass.BASS_StreamCreate(44100, 2, 0, _monProc, IntPtr.Zero) ' user = reader#
            Bass.BASS_ChannelPlay(_monStream, False)
            
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              monBuffer.Write(buffer, length)
            End Function
            
            Private Function MonitoringStream(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
              Return monBuffer.Read(buffer, length, user.ToInt32())
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.#ctor">
            <summary>
            Default Constructor using the default buffer size.
            </summary>
            <remarks>The default size of the buffer is 2 seconds (when using it with 44.1kHz, 16-bit stereo sample data).</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.#ctor(System.Single,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an instance of the ring buffer with a size acconding to the given parameters.
            </summary>
            <param name="seconds">The length of the buffer in seconds (e.g. 2.0 for 2 seconds or 0.2 for 200ms).</param>
            <param name="samplerate">The samplerate in Hz to use.</param>
            <param name="chans">The number of channels to use.</param>
            <param name="bps">Bytes per Sample (1 = 8-bit, 2 = 16-bit or 4 = 32-bit sample data, but you might also use 8, 16 or 32 here directly).</param>
            <remarks>The internal buffer size is calculated accordingly to the above parameters, rounded to the next sample mathich the given bytes per sample.
            <para>The buffer size is calculated as: seconds * samplerate * chans * bps</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Dispose">
            <summary>
            Implement IDisposable.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Clear">
            <summary>
            Clears the ring buffer (zeros all elements) and resets all read and write pointers.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Resize(System.Single)">
            <summary>
            Resizes (enlarges) the ring buffer by the given factor.
            </summary>
            <param name="factor">The factor to use for resizing (the buffer size is multiplied by this factor). Must be greater than 1.0.</param>
            <remarks>Shrinking the buffer size is not allowed.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Space(System.Int32)">
            <summary>
            Returns the number of bytes available in the ring buffer for writing until an overflow of the read pointer will happen (space between the current write pointer position and the read pointer position).
            </summary>
            <param name="reader">The zero-based index of the reader to use (0=first reader) or -1 to get the smallest available space for all readers.</param>
            <remarks>In order to convert the available space in the buffer to number of samples, simply devide the result by the bytes per sample
            (e.g. if the result is 56780 and you are using the buffer with 16-bit stereo sample data, the number of sample are 56780/2 = 28390 samples or 14195 stereo pairs).
            <para>Note, that there is never a real physical write limitation, since writing to the buffer always has priority.
            Meaning if there is not sufficient space left between the write pointer position and the last read pointer position, this fact is simply ignored. The data will be written anyhow.
            However, this will result in an overflow, so that the next read operation will only have the overflown sample data available - resulting in a gap in the sound.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Count(System.Int32)">
            <summary>
            Returns the number of bytes available in the ring buffer for reading (between the current read pointer position and the write pointer position).
            </summary>
            <param name="reader">The zero-based index of the reader to use (0=first reader) or -1 to get the biggest number of bytes for all readers.</param>
            <remarks>In order to convert the bytes in the buffer to number of samples, simply devide the result by the bytes per sample
            (e.g. if the result is 56780 and you are using the buffer with 16-bit stereo sample data, the number of sample are 56780/2 = 28390 samples or 14195 stereo pairs).</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Write(System.IntPtr,System.Int32)">
            <summary>
            Writes (add) the given number of sample data to the ring buffer.
            </summary>
            <param name="buffer">The pointer to the buffer containing the sample data to write to the ring buffer (e.g. as provided by a <see cref="T:Un4seen.Bass.RECORDPROC"/>, <see cref="T:Un4seen.Bass.DSPPROC"/> etc. or even by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>).</param>
            <param name="length">The number of BYTES to write to the ring buffer (from the <paramref name="buffer"/>).</param>
            <returns>The number of bytes actually written to the ring buffer.</returns>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes (add) the given number of sample data to the ring buffer.
            </summary>
            <param name="buffer">The byte array containing the sample data to write to the ring buffer.</param>
            <param name="length">The number of BYTES to write to the ring buffer (from the <paramref name="buffer"/>).</param>
            <returns>The number of bytes actually written to the ring buffer.</returns>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Read(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Reads (removes) the given number of sample data from the ring buffer.
            </summary>
            <param name="buffer">The pointer to the buffer where the read sample data should be written to (e.g. as provided by a <see cref="T:Un4seen.Bass.STREAMPROC"/>).</param>
            <param name="length">The number of BYTES to read from the ring buffer (which will be written to the <paramref name="buffer"/>).</param>
            <param name="reader">The zero-based index of the reader to use (0=first reader).</param>
            <returns>The number of bytes actually read from the ring buffer (which be be less than requested).</returns>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads (removes) the given number of sample data from the ring buffer.
            </summary>
            <param name="buffer">The byte array where the read sample data should be written to (must be initialized and large enough to keep the data).</param>
            <param name="length">The number of BYTES to read from the ring buffer (which will be written to the <paramref name="buffer"/>).</param>
            <param name="reader">The zero-based index of the reader to use (0=first reader).</param>
            <returns>The number of bytes actually read from the ring buffer (which be be less than requested).</returns>
        </member>
        <member name="P:Un4seen.Bass.BASSBuffer.BufferLength">
            <summary>
            Gets the total length in bytes of the ring buffer.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASSBuffer.Bps">
            <summary>
            Gets the Bytes per sample used with the ring buffer (1=8-bit, 2=16-bit default, 4=32-bit).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASSBuffer.SampleRate">
            <summary>
            Gets the sample rate in Hz used with the ring buffer (default is 44100 Hz).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASSBuffer.NumChans">
            <summary>
            Gets the number of channels used with the ring buffer (1=mono, 2=stereo default, etc).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASSBuffer.Readers">
            <summary>
            Gets or Sets the number of parallel Readers which can be used with the ring buffer.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.BroadCast">
            <summary>
            Enables streaming of audio content to the internet.
            </summary>
            <remarks>
            <para>To setup broadcast streaming you first need to create an instance of a class, which is derived from the <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> class (e.g. <see cref="T:Un4seen.Bass.Misc.SHOUTcast"/> or <see cref="T:Un4seen.Bass.Misc.ICEcast"/>).
            These classes will contain all necessary configuration data (e.g. server address an port, username and password, station description etc., as well as an <see cref="T:Un4seen.Bass.Misc.IBaseEncoder"/> instance, which defines the target broadcasting encoder format).</para>
            <para>The BroadCast class support manual streaming (e.g. in your own <see cref="T:Un4seen.Bass.DSPPROC"/> or <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/>) as well as
            automatic streaming. Automatic streaming is implemented internally also via a user DSP.</para>
            <para>If you want to broadcast to multiple outputs (multiple servers) you need to create an instance for each output seperately.</para>
            </remarks>
            <example>
            The following example uses the generic Encoder-Framework with the generic StreamingServer-Framework 
            to implement streaming of any recording data (here uing LAME MP3 encoding to a SHOUTcast server):
            <code>
            private int _recHandle;
            private BroadCast _broadCast;
            ...
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, null, 0);
            ...
            // create an encoder instance (e.g. for MP3 use EncoderLAME):
            EncoderLAME lame = new EncoderLAME(_recHandle);
            lame.InputFile = null;	//STDIN
            lame.OutputFile = null;	//STDOUT
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_56;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono;
            lame.LAME_TargetSampleRate = (int)EncoderLAME.SAMPLERATE.Hz_22050;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            
            // create a StreamingServer instance (e.g. SHOUTcast) using the encoder:
            SHOUTcast shoutcast = new SHOUTcast(lame);
            shoutcast.ServerAddress = "localhost";
            shoutcast.ServerPort = 8000;
            shoutcast.Password = "changeme";
            shoutcast.PublicFlag = true;
            
            // use the BroadCast class to control streaming:
            _broadCast = new BroadCast(shoutcast);
            _broadCast.AutoReconnect = true;
            _broadCast.Notification += new BroadCastEventHandler(OnBroadCast_Notification);
            _broadCast.AutoConnect();
            
            private void OnBroadCast_Notification(object sender, BroadCastEventArgs e)
            {
              // Note: this method might be called from another thread (non UI thread)!
              if (_broadCast == null)
                return;
              if (_broadCast.IsConnected)
              {
                // we are connected...
              }
              else
              {
                // we are not connected...
              }
            }
            </code>
            <code lang="vbnet">
            Private _recHandle As Integer
            Private _broadCast As BroadCast
            ...
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, Nothing, 0)
            ...
            ' create an encoder instance (e.g. for MP3 use EncoderLAME):
            Dim lame As New EncoderLAME(_recHandle)
            lame.InputFile = Nothing 'STDIN
            lame.OutputFile = Nothing 'STDOUT
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_56)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono
            lame.LAME_TargetSampleRate = CInt(EncoderLAME.SAMPLERATE.Hz_22050)
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            
            ' create a StreamingServer instance (e.g. SHOUTcast) using the encoder:
            Dim shoutcast As New SHOUTcast(lame)
            shoutcast.ServerAddress = "localhost"
            shoutcast.ServerPort = 8000
            shoutcast.Password = "changeme"
            shoutcast.PublicFlag = True
            
            ' use the BroadCast class to control streaming:
            _broadCast = New BroadCast(shoutcast)
            _broadCast.AutoReconnect = True
            AddHandler _broadCast.Notification, AddressOf OnBroadCast_Notification
            _broadCast.AutoConnect()
            
            Private Sub OnBroadCast_Notification(sender As Object, e As BroadCastEventArgs)
              ' Note: this method might be called from another thread (non UI thread)!
              If _broadCast Is Nothing Then
                Return
              End If
              If _broadCast.IsConnected Then
                ' we are connected...
              Else
                ' we are not connected...
              End If 
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.#ctor">
            <summary>
            Default constructor not allowed.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.#ctor(Un4seen.Bass.Misc.IStreamingServer)">
            <summary>
            Creates an instance of the broadcasting class using the specified streaming server.
            </summary>
            <param name="server">Instance of a streaming server class to use (containing the configuration and parameter data).</param>
            <remarks>In order to create a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> instance use one of the implementations (e.g. <see cref="T:Un4seen.Bass.Misc.SHOUTcast"/> or <see cref="T:Un4seen.Bass.Misc.ICEcast"/>).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.AutoConnect">
            <summary>
            Connects automatically to a broadcast server (performs a <see cref="M:Un4seen.Bass.Misc.StreamingServer.Connect"/> and <see cref="M:Un4seen.Bass.Misc.StreamingServer.Login"/>).
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>
            <para>If the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> has set the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> flag to TRUE, the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> will handle any communication via <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/>.</para>
            <para>If the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> has set the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> flag to FALSE, the following will be handled:</para>
            <para>Prior to the <see cref="M:Un4seen.Bass.Misc.StreamingServer.Connect"/> an internal encoder callback will be created.</para>
            <para>The internal encoder callback is created using <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.
            This internal callback will already handle the <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/>, <see cref="M:Un4seen.Bass.Misc.BroadCast.StartEncoder(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> and <see cref="M:Un4seen.Bass.Misc.BroadCast.StopEncoder"/> automatically for you.</para>
            <para>If already connected, this method will first <see cref="M:Un4seen.Bass.Misc.BroadCast.Disconnect"/> from the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/>, which might result in stopping the underlying <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/>.</para>
            <para>If the channel handle (as defined in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/>) is already playing, it will be shortly paused during the setup and resumed when done.</para>
            <para>Please note, that some methods should NOT be used, if in automatic mode: <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/>, <see cref="M:Un4seen.Bass.Misc.BroadCast.StartEncoder(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>, <see cref="M:Un4seen.Bass.Misc.BroadCast.StopEncoder"/> and <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/>!</para>
            <para>Note: If you have set the <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> property to TRUE this call will automatically try to reconnect even if this method returns FALSE!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.Connect">
            <summary>
            Connects manually to a broadcast server (performs a <see cref="M:Un4seen.Bass.Misc.StreamingServer.Connect"/> and <see cref="M:Un4seen.Bass.Misc.StreamingServer.Login"/>).
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>The automatic reconnect settings (<see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> and <see cref="P:Un4seen.Bass.Misc.BroadCast.ReconnectTimeout"/>) will also work with a manual connection.
            But, you must create and handle your own <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback and call <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> manually!
            <para>If already connected, this method will first <see cref="M:Un4seen.Bass.Misc.BroadCast.Disconnect"/> from the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/>, which might result in stopping the underlying <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/>.</para>
            <para>If the channel handle (as defined in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/>) is already playing, it will be shortly paused during the setup and resumed when done.</para>
            <para>Note: If you have set the <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> property to TRUE this call will automatically try to reconnect even if this method returns FALSE!</para>
            </remarks>
            <example>
            This example demonstrates manual broadcasting:
            <code>
            private BroadCast _broadCast;
            private ENCODEPROC _myEncProc;
            ...
            // create your encoder (using a recording handle)
            EncoderLAME lame = new EncoderLAME(_recHandle);
            
            // create an streaming server instance
            SHOUTcast shoutcast = new SHOUTcast(lame);
            
            // create the broadcast instance
            _broadCast = new BroadCast(shoutcast);
            _broadCast.AutoReconnect = true;
            _broadCast.Notification += new BroadCastEventHandler(OnBroadCast_Notification);
            
            // create your encoder callback
            _myEncProc = new ENCODEPROC(MyEncodingCallback);
            // start the encoder (paused)
            _broadCast.StartEncoder(_myEncProc, IntPtr.Zero, true);
            // now connect to start your broadcast
            _broadCast.Connect();
            // and really start the encoder
            _broadCast.Server.Encoder.Pause(false);
            ...
            
            // your broadcast encoder callback implementation
            private void MyEncodingCallback(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              // here we receive the encoded data back (manual mode)
              if ( _broadCast.IsConnected )
              {
                _broadCast.SendData(buffer, length);
              }
            }
            
            private void OnBroadCast_Notification(object sender, BroadCastEventArgs e)
            {
              if (e.EventType == BroadCastEventType.EncoderRestartRequired)
                _broadCast.StartEncoder(_myEncProc, 0);
            	
              if (!_broadCast.IsConnected)
              {
                // connection lost
              }
            }
            </code>
            <code lang="vbnet">
            Private _broadCast As BroadCast
            Private _myEncProc As ENCODEPROC
            ...
            ' create your encoder (using a recording handle)
            Dim lame As New EncoderLAME(_recHandle)
            
            ' create an streaming server instance
            Dim shoutcast As New SHOUTcast(lame)
            
            ' create the broadcast instance
            _broadCast = New BroadCast(shoutcast)
            _broadCast.AutoReconnect = True
            AddHandler _broadCast.Notification, AddressOf OnBroadCast_Notification
            
            ' create your encoder callback
            _myEncProc = New ENCODEPROC(AddressOf MyEncodingCallback)
            ' start the encoder (paused)
            _broadCast.StartEncoder(_myEncProc, IntPtr.Zero, True)
            ' now connect to start your broadcast
            _broadCast.Connect()
            ' and really start the encoder
            _broadCast.Server.Encoder.Pause(False)
            ...
            
            ' your broadcast encoder callback implementation
            Private Sub MyEncodingCallback(handle As Integer, channel As Integer, 
                                           buffer As IntPtr, length As Integer, user As IntPtr)
              ' here we receive the encoded data back (manual mode)
              If _broadCast.IsConnected Then
                _broadCast.SendData(buffer, length)
              End If
            End Sub
            
            Private Sub OnBroadCast_Notification(sender As Object, e As BroadCastEventArgs)
              If e.EventType = BroadCastEventType.EncoderRestartRequired Then
                _broadCast.StartEncoder(_myEncProc, 0)
              End If 
            
              If Not _broadCast.IsConnected Then
                ' connection lost
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.Disconnect">
            <summary>
            Disconnects from the broadcast server calling <see cref="M:Un4seen.Bass.Misc.StreamingServer.Disconnect"/> (also stops the encoder using <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/>).
            </summary>
            <returns>TRUE on success (not connected), else FALSE (connection status unknown, see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>This method disconnects no matter if you started broadcasting in the automatic mode (via <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/>) or manually (via <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/>).
            <para>Note: If you stop or free the underlying stream channel you must also call this method in order to disconnect from the server.</para>
            <para>Caution: Disconnecting will in any case also stop the underlying server encoder in use (<see cref="M:Un4seen.Bass.Misc.BroadCast.StopEncoder"/> will be called!).
            So if you started broadcasting in the manual mode (via <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/>) you need to manually start your encoder again.
            If you have enabled the <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> feature a <see cref="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderRestartRequired"/> event <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> will be raised.</para>
            <para>If this method returns FALSE, check the <see cref="P:Un4seen.Bass.Misc.BroadCast.Status"/>, it might be the case, that you are still connected (e.g. if the encoder could not be stopped)!</para>
            <para>Once disconnected successfully, the <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/> feature will also be disabled (no further connect retries will be made). 
            You need to start broadcasting again via <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> or <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/> in order to restart.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.StartEncoder(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            Starts the underlying encoder (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.Encoder"/>).
            </summary>
            <param name="proc">Optional callback function to receive the encoded data. 
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Return TRUE, if the encoder was successfully started - else FALSE is returned (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>
            <para>Do NOT call this method, if you are in <see cref="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode"/>, since the encoder will be started automatically in this case.</para>
            <para>If the encoder was already started, this method anyhow returns TRUE - however no <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event will be raised in this case.</para>
            <para>If you <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> manually, your <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> must call <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/> manually as well, see the example below.</para>
            </remarks>
            <example>
            This example demonstrates a user defined ENCODEPROC:
            <code>
            private BroadCast _broadCast;
            private ENCODEPROC _myEncProc;
            ...
            // create your encoder (using a recording handle)
            EncoderLAME lame = new EncoderLAME(_recHandle);
            
            // create an streaming server instance
            SHOUTcast shoutcast = new SHOUTcast(lame);
            
            // create the broadcast instance
            _broadCast = new BroadCast(shoutcast);
            _broadCast.AutoReconnect = true;
            _broadCast.Notification += new BroadCastEventHandler(OnBroadCast_Notification);
            
            // create your encoder callback
            _myEncProc = new ENCODEPROC(MyEncodingCallback);
            // start the encoder (paused)
            _broadCast.StartEncoder(_myEncProc, IntPtr.Zero, true);
            // now connect to start your broadcast
            _broadCast.Connect();
            // and really start the encoder
            _broadCast.Server.Encoder.Pause(false);
            ...
            
            // your broadcast encoder callback implementation
            private void MyEncodingCallback(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              // here we receive the encoded data back (manual mode)
              if ( _broadCast.IsConnected )
              {
                _broadCast.SendData(buffer, length);
              }
            }
            
            private void OnBroadCast_Notification(object sender, BroadCastEventArgs e)
            {
              if (e.EventType == BroadCastEventType.EncoderRestartRequired)
                _broadCast.StartEncoder(_myEncProc, 0);
            	
              if (!_broadCast.IsConnected)
              {
                // connection lost
              }
            }
            </code>
            <code lang="vbnet">
            Private _broadCast As BroadCast
            Private _myEncProc As ENCODEPROC
            ...
            ' create your encoder (using a recording handle)
            Dim lame As New EncoderLAME(_recHandle)
            
            ' create an streaming server instance
            Dim shoutcast As New SHOUTcast(lame)
            
            ' create the broadcast instance
            _broadCast = New BroadCast(shoutcast)
            _broadCast.AutoReconnect = True
            AddHandler _broadCast.Notification, AddressOf OnBroadCast_Notification
            
            ' create your encoder callback
            _myEncProc = New ENCODEPROC(AddressOf MyEncodingCallback)
            ' start the encoder (paused)
            _broadCast.StartEncoder(_myEncProc, IntPtr.Zero, True)
            ' now connect to start your broadcast
            _broadCast.Connect()
            ' and really start the encoder
            _broadCast.Server.Encoder.Pause(False)
            ...
            
            ' your broadcast encoder callback implementation
            Private Sub MyEncodingCallback(handle As Integer, channel As Integer, 
                                           buffer As IntPtr, length As Integer, user As IntPtr)
              ' here we receive the encoded data back (manual mode)
              If _broadCast.IsConnected Then
                _broadCast.SendData(buffer, length)
              End If
            End Sub
            
            Private Sub OnBroadCast_Notification(sender As Object, e As BroadCastEventArgs)
              If e.EventType = BroadCastEventType.EncoderRestartRequired Then
                _broadCast.StartEncoder(_myEncProc, 0)
              End If 
            
              If Not _broadCast.IsConnected Then
                ' connection lost
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.StopEncoder">
            <summary>
            Stops the <see cref="P:Un4seen.Bass.Misc.StreamingServer.Encoder"/>
            </summary>
            <returns>TRUE, if the encoder was stopped successfully, else FALSE is returned (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>Please note that, if FALSE is returned, the <see cref="P:Un4seen.Bass.Misc.StreamingServer.Encoder"/> will still be active.
            <para>If you are handling broadcasting manually (by using <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/>), it is a good idea to stop the encoder whenever you are not connected anymore.
            You might check the status of the broadcast connection by asking for the <see cref="P:Un4seen.Bass.Misc.BroadCast.Status"/> or by subscribing to the <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event handler.</para>
            <para>If the encoder was already stopped, this method returns TRUE - however no <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event will be raised in this case.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)">
            <summary>
            Sends encoded sample data manually to the broadcast server (e.g. the data as received in an own <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/>).
            </summary>
            <param name="buffer">The pointer to the encoded buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <param name="length">The length of the buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>If an error occures the connection will be closed automatically (using <see cref="M:Un4seen.Bass.Misc.StreamingServer.Disconnect"/>).
            In this case the <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> feature (if enabled) will try a reconnect after <see cref="P:Un4seen.Bass.Misc.BroadCast.ReconnectTimeout"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.UpdateTitle(System.String,System.String)">
            <summary>
            Updates the title of the playing song on a broadcast server.
            </summary>
            <param name="song">The new song title to set.</param>
            <param name="url">The optional song url to go along with the title (only for SHOUtcast - else NULL).</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>This method can be used for both the manual and the automatic connection mode.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.GetListeners(System.String)">
            <summary>
            Returns the number of listeners currently connected.
            </summary>
            <param name="password">The optional admin password to use (NULL=use default).</param>
            <returns>The current number of listeners (or -1 if not available).</returns>
            <remarks>Some <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> implementations might not be able to retrieve the current listener count, in which case -1 would be returned.
            However, the following servers should be supported: SHOUTcast, ICEcast, WMAcast (if not using a publishing point).
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.GetStats(System.String)">
            <summary>
            Returns the XML stats of the server.
            </summary>
            <param name="password">An optional password to use (should be set to NULL to use the default publish password).</param>
            <returns>The string representing the XML formatted statistics (or NULL on error/not available).</returns>
            <remarks>Some <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> implementations might not be able to retrieve an XML statistic, in which case NULL would be returned.
            However, the following servers should be supported: SHOUTcast, ICEcast, WMAcast.
            </remarks>
        </member>
        <member name="E:Un4seen.Bass.Misc.BroadCast.Notification">
            <summary>
            Event handler used to notify that the BroadCast status has changed or that a BroadCast event has occurred.
            </summary>
            <remarks>It is a good idea to subscribe to this event handler before calling <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> or <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/>.
            <para>The properties <see cref="P:Un4seen.Bass.Misc.BroadCast.NotificationSupressDataSend"/> and <see cref="P:Un4seen.Bass.Misc.BroadCast.NotificationSupressIsAlive"/> might be used to supress sending certain events.</para>
            <para>The <see cref="T:Un4seen.Bass.Misc.BroadCastEventArgs"/> contains a <see cref="T:Un4seen.Bass.Misc.BroadCastEventType"/> which allows you to react to all possible scenarios and to log all these events.</para>
            <para>Note: This implementation ensures, that the event will be executed in the main thread the subscriber executes in!
            So when subscribing to this event from UI thread, the specified event delegate will also be called in that UI thread.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.Server">
            <summary>
            Returns the streaming server interface which is used with this instance.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.IsConnected">
            <summary>
            Connected to the server? (TRUE=connected).
            </summary>
            <remarks>Sending encoded data to the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> via <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/> should only be performed, if connected to the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> 
            and the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> has the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> flag set to FALSE!</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.Status">
            <summary>
            Gets the current broadcast status.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode">
            <summary>
            Gets if the automatic mode was used (TRUE, if <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/> was called, else FALSE meaning <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> was used instead).
            </summary>
            <remarks>When the automatic mode is used, the following is handled directly by this class and does not need to be handled manually:
            <para>Setup of an internal encoder callback procedure and sending of the encoded data to the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> (either internally or via <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/>).
            So the only task you need to handle is title updates manually when in automatic mode.</para>
            <para>Please note, that some methods should NOT be used, if in automatic mode: <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/>, <see cref="M:Un4seen.Bass.Misc.BroadCast.StartEncoder(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>, <see cref="M:Un4seen.Bass.Misc.BroadCast.StopEncoder"/> and <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/>!</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect">
            <summary>
            Gets or Sets if the broadcast connection should automatically be reconnected in case of a connection or encoder error (default=FALSE).
            </summary>
            <remarks>The auto connect feature can be used for both <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> and <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/>.
            <para>When AutoReconnect was set to TRUE, the following will be checked automatically:</para>
            <para>1. Is the encoder still active? - if not, restart encoder, if in <see cref="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode"/>.</para>
            <para>2. Are we still connected to the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/>? - if not, reconnect to the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/>.</para>
            <para>This means, that if you are NOT in <see cref="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode"/>, you need to restart your <see cref="P:Un4seen.Bass.Misc.StreamingServer.Encoder"/> manually.
            You can do so by subscribing to the <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event handler and react on the <see cref="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderRestartRequired"/> event and then call <see cref="M:Un4seen.Bass.Misc.BroadCast.StartEncoder(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> again.</para>
            <para>Please note, that the encoder will automatically be stopped, if a reconnect to the server was not successful!</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.ReconnectTimeout">
            <summary>
            Gets or Sets the reconnect timeout in seconds (default is 5sec.).
            </summary>
            <remarks>The auto connect feature can be used for both <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> and <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/>.
            <para>The timeout period must be between 1 and 86400 seconds.</para>
            <para>Changing the reconnect timeout takes immediate effect.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.NotificationSupressDataSend">
            <summary>
            Gets or Sets, if the <see cref="F:Un4seen.Bass.Misc.BroadCastEventType.DataSend"/> event will be raised when subscribed to the <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event handler (default is FALSE).
            </summary>
            <remarks>Note: If the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> has the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> flag set to TRUE this property will have no effect.
            A <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> with <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> will be unable to to report the number of bytes send to the server.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.NotificationSupressIsAlive">
            <summary>
            Gets or Sets, if the <see cref="F:Un4seen.Bass.Misc.BroadCastEventType.IsAlive"/> event will be raised when subscribed to the <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event handler and <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> is enabled (default is FALSE).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.TotalBytesSend">
            <summary>
            Returns the total number of bytes send to the server during a broadcast.
            </summary>
            <remarks>If the value reaches the maximum (Int64.MaxValue) it will be wrapped around and reset to 0 (zero).
            <para>Note: If the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> has the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> flag set to TRUE this property will have no effect and always report 0 (zero).
            A <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> with <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> will be unable to to report the number of bytes send to the server.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.TotalConnectionTime">
            <summary>
            Returns the total online connection time (for how long the broadcast is already running since it was connected).
            </summary>
            <remarks>This value is only correct, if <see cref="P:Un4seen.Bass.Misc.BroadCast.IsConnected"/> is TRUE resp. the broadcast <see cref="P:Un4seen.Bass.Misc.BroadCast.Status"/> is CONNECTED.</remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.BroadCast.BROADCASTSTATUS">
            <summary>
            List of all possible broadcast status.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCast.BROADCASTSTATUS.NotConnected">
            <summary>
            Not connected.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCast.BROADCASTSTATUS.Connected">
            <summary>
            Connected to the broadcast server.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCast.BROADCASTSTATUS.Unknown">
            <summary>
            Connection status is unknown.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.BroadCastEventHandler">
            <summary>
            Definition of the <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event handler.
            </summary>
            <param name="sender">Set to the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> object instance that raised the event.</param>
            <param name="e">An instance of the <see cref="T:Un4seen.Bass.Misc.BroadCastEventArgs"/> event args containing the event details.</param>
            <remarks>
            This definition complies with the .NET Framework's standard for event handlers.
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.BroadCastEventType">
            <summary>
            Types of event that has occurred with the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.
            </summary>
            <remarks>
            A variable of this type is passed inside the <see cref="T:Un4seen.Bass.Misc.BroadCastEventArgs"/> object 
            for the <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.Connected">
            <summary>
            A connection to the server was successfully established.
            </summary>
            <remarks>Object data: DateTime (start of connection).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.Disconnected">
            <summary>
            The server was disconnected (either by user request or due to a connection error).
            </summary>
            <remarks>Object data: DateTime (time of disconnect).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.DisconnectError">
            <summary>
            An error occurred during the disconnect (the server might still be connected).
            </summary>
            <remarks>Object data: DateTime (time of disconnect).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.ConnectionLost">
            <summary>
            The connection was lost (can only be discovered at <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/>).
            </summary>
            <remarks>Object data: DateTime (time of lost connection).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.ConnectionError">
            <summary>
            A connection to the server could not be established (will only be raised at <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> or <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/>).
            </summary>
            <remarks>Object data: DateTime (time of lost connection).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.ReconnectTry">
            <summary>
            A reconnect will be tried (after the <see cref="P:Un4seen.Bass.Misc.BroadCast.ReconnectTimeout"/>).
            </summary>
            <remarks>Object data: DateTime (time of reconnect try).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.UnsuccessfulReconnectTry">
            <summary>
            A reconnect was unsuccessfully tried.
            </summary>
            <remarks>Object data: DateTime (time of unsuccessful reconnect try).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderStarted">
            <summary>
            The encoder was started successfully (will only be raised in <see cref="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode"/>).
            </summary>
            <remarks>Object data: <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> (the encoder instance which needs to be restarted).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderStartError">
            <summary>
            The encoder could not be started  (will only be raised in <see cref="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode"/>).
            </summary>
            <remarks>Object data: <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> (the encoder instance which needs to be restarted).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderStopped">
            <summary>
            The encoder was stopped (will only be raised in <see cref="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode"/>).
            </summary>
            <remarks>Object data: <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> (the encoder instance which needs to be restarted).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderStopError">
            <summary>
            The encoder could not be stopped (will only be raised during <see cref="M:Un4seen.Bass.Misc.BroadCast.Disconnect"/> - the disconnect might fail and might still be connected).
            </summary>
            <remarks>Object data: <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> (the encoder instance which needs to be restarted).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderRestartRequired">
            <summary>
            The underlying encoder is not active and needs to be started again.
            </summary>
            <remarks>Object data: <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> (the encoder instance which needs to be restarted).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.DataSend">
            <summary>
            All data was send to the server successfully (will only be raised when <see cref="P:Un4seen.Bass.Misc.BroadCast.NotificationSupressDataSend"/> is FALSE and <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to FALSE).
            </summary>
            <remarks>Object data: long (number of bytes send).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.LessDataSend">
            <summary>
            Data was send to the server, but not all data was send (will only be raised when <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to FALSE).
            </summary>
            <remarks>Object data: int (number of bytes not send).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.IsAlive">
            <summary>
            The broadcast connection is alive and streaming is active (will only be raised when <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> is TRUE and <see cref="P:Un4seen.Bass.Misc.BroadCast.NotificationSupressIsAlive"/> is FALSE and <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to FALSE).
            </summary>
            <remarks>Object data: DateTime (time of is alive signal).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.TitleUpdated">
            <summary>
            The song title was updated.
            </summary>
            <remarks>Object data: string (song title).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.TitleUpdateError">
            <summary>
            The song title was not updated.
            </summary>
            <remarks>Object data: string (song title).</remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.BroadCastEventArgs">
            <summary>
            EventArgs class to be passed as the second parameter of a <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event handler.
            </summary>
            <remarks>
            This class provides all the information relevant to an event which might occur to a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCastEventArgs.#ctor(Un4seen.Bass.Misc.BroadCastEventType,System.Object)">
            <summary>
            Initializes a new instance of the BroadCastEventArgs class by initializing all of its properties.
            </summary>
            <param name="pEventType">The type of event which occurred (see <see cref="T:Un4seen.Bass.Misc.BroadCastEventType"/>).</param>
            <param name="pData">Some data which should be passed along with the notification event.</param>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCastEventArgs.EventType">
            <summary>
            Gets the type of event which occurred.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCastEventArgs.Data">
            <summary>
            Gets the object data which was passed along with the event.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCastEventArgs.DateTime">
            <summary>
            Gets the date and time when the event occurred.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.IStreamingServer">
            <summary>
            Defines a generalized streaming server class interface that a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> class must implement.
            </summary>
            <remarks>This interface is for example used in the constructor of a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> instance to specify which server should be used.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.Connect">
            <summary>
            Connects to a streaming server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>A server connect should only be successfull, if the underlying encoder was started.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.Disconnect">
            <summary>
            Disconnects to a streaming server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> for details).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.Login">
            <summary>
            Performs a login and/or init of the streaming server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>When the login was successfully made, you should set the <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> to <see cref="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Ok"/> and the <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> to String.Empty.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.SendData(System.IntPtr,System.Int32)">
            <summary>
            Sends encoded sample data (manually) to the streaming server (e.g. the data as received in an own <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/>).
            </summary>
            <param name="buffer">The pointer to the encoded buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <param name="length">The length of the buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <returns>The number of bytes send to the server (or -1, if no bytes could be send (see <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>If an error occures the connection should be closed automatically (using <see cref="M:Un4seen.Bass.Misc.IStreamingServer.Disconnect"/>).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.UpdateTitle(System.String,System.String)">
            <summary>
            Updates the title song and/or url of the streaming server.
            </summary>
            <param name="song">The title of the song which should be updated.</param>
            <param name="url">The url which should be updated along with the title (or NULL).</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> for details).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.GetListeners(System.String)">
            <summary>
            Returns the number of listeners currently connected.
            </summary>
            <param name="password">The optional admin password to use (NULL=use default).</param>
            <returns>The current number of listeners (or -1 if not available).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.GetStats(System.String)">
            <summary>
            Returns the XML stats of the server.
            </summary>
            <param name="password">The optional admin password to use (NULL=use default).</param>
            <returns>The string representing the XML formatted statistics (or NULL on error/not available).</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.UseBASS">
            <summary>
            Gets if native BASS should be used to connect and stream to the server.
            </summary>
            <remarks>
            <para>If set to TRUE (see constructor) native BASSenc will handle all TCP socket and cast communication.
            This should be the more secure and preferred option, however in this mode it is not possible to use the <see cref="M:Un4seen.Bass.Misc.IStreamingServer.SendData(System.IntPtr,System.Int32)"/> method manually!</para>
            <para>If set to FALSE an internal .Net TCP socket connection will be used and manual feed of encoded sample data via <see cref="M:Un4seen.Bass.Misc.IStreamingServer.SendData(System.IntPtr,System.Int32)"/> is possible.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.IsConnected">
            <summary>
            Returns TRUE, if connected to a streaming server - else FALSE.
            </summary>
            <remarks>Normally it is sufficient to return TRUE once a <see cref="M:Un4seen.Bass.Misc.IStreamingServer.Connect"/> was successful.
            However, if the server implementation also requires a <see cref="M:Un4seen.Bass.Misc.IStreamingServer.Login"/> this method should only return TRUE, if also the <see cref="M:Un4seen.Bass.Misc.IStreamingServer.Login"/> was successful.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.Encoder">
            <summary>
            Returns the encoder interface which is used with this instance.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.LastError">
            <summary>
            Gets or Sets the last streaming error.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage">
            <summary>
            Gets or Sets the last streaming error message.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.SongTitle">
            <summary>
            Gets or Sets the current/last song title.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.SongUrl">
            <summary>
            Gets or Sets the current/last song url.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.StreamingServer">
            <summary>
            Base class for all streaming server classes (e.g. <see cref="T:Un4seen.Bass.Misc.SHOUTcast"/> or <see cref="T:Un4seen.Bass.Misc.ICEcast"/>).
            </summary>
            <remarks>This base class is not intended for direct use, but defines all abstract properties and methods which needs to be implemented by an actual streaming server class.
            A derived class must implement: <see cref="P:Un4seen.Bass.Misc.StreamingServer.IsConnected"/>, <see cref="M:Un4seen.Bass.Misc.StreamingServer.Connect"/>, <see cref="M:Un4seen.Bass.Misc.StreamingServer.Disconnect"/>, <see cref="M:Un4seen.Bass.Misc.StreamingServer.Login"/>, <see cref="M:Un4seen.Bass.Misc.StreamingServer.SendData(System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.Misc.StreamingServer.UpdateTitle(System.String,System.String)"/>.
            <para>The properties <see cref="P:Un4seen.Bass.Misc.StreamingServer.Encoder"/>, <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> and <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> have been already implemented.</para>
            <para>You might use this base class to derive your own streaming server implementations.</para>
            <para>If an instance of a derived class is being disposed, an already created connection to a streaming server will automatically be closed (using <see cref="M:Un4seen.Bass.Misc.StreamingServer.Disconnect"/>) and an <see cref="P:Un4seen.Bass.Misc.StreamingServer.Encoder"/> will be stopped, if active.</para>
            <para></para>
            </remarks>
            <example>
            This example shows a basic implementation of an own streaming server class:
            <code>
            public class MyOwnServer : StreamingServer
            {
            	// Constructor
            	public MyOwnServer(IBaseEncoder encoder, bool useBASS) : base(encoder, useBASS)
            	{
            	  // validity check
            	  if (encoder.EncoderType != BASSChannelType.BASS_CTYPE_STREAM_MP3 &amp;&amp;
            	      encoder.EncoderType != BASSChannelType.BASS_CTYPE_STREAM_AAC)
            	    throw new Exception( "Invalid EncoderType (only MP3 and AAC is supported)!" );
            	}
            	
            	private Socket _socket = null;
            	private bool _loggedIn = false;
            	private byte[] _data = null;
            	private object _lock = false;
            	public string ServerAddress = "localhost";
            	public int ServerPort = 8000;
            	
            	public override bool IsConnected
            	{
            	  get
            	  {
            	    if (_socket != null)
            	      return _socket.Connected &amp;&amp; _loggedIn;
            	    else
            	      return false;
            	  }
            	}
            	
            	public override bool Connect()
            	{
            	  // check the encoder
            	  if (!Encoder.IsActive)
            	  {
            	    LastError = STREAMINGERROR.Error_EncoderError;
            	    LastErrorMessage = "Encoder not active!";
            	    return false;
            	  }
            	  // close any connections, if still open
            	  if (_socket != null &amp;&amp; _socket.Connected)
            	  {
            	    _socket.Close();
            	    _socket = null;
            	  }
            	  // create a connection at port+1
            	  _socket = CreateSocket( ServerAddress, ServerPort+1 );
            	  return (_socket != null &amp;&amp; _socket.Connected);
            	}
            	
            	public override bool Disconnect()
            	{
            	  bool ok = false;
            	  try
            	  {
            	    _socket.Close();
            	  }
            	  catch { }
            	  finally
            	  {
            	    if (_socket != null &amp;&amp; _socket.Connected) 
            	    {
            	      LastError = STREAMINGERROR.Error_Disconnect;
            	      LastErrorMessage = "Winsock error: " + 
                        Convert.ToString(System.Runtime.InteropServices.Marshal.GetLastWin32Error());
            	    }
            	    else
            	    {
            	      ok = true;
            	      _socket = null;
            	      _loggedIn = false;
            	    }
            	  }
            	  return ok;
            	}
            	
            	public override bool Login()
            	{
            	  if (_socket == null)
            	  {
            	    LastError = STREAMINGERROR.Error_NotConnected;
            	    LastErrorMessage = "Not connected to server.";
            	    return false;
            	  }
            	  bool ok = false;
            	  if ( MyLogin() )
            	  {
            	    if ( MyInit() )
            	    {
            	      ok = true;
            	      _loggedIn = true;
            	      LastError = STREAMINGERROR.Ok;
            	      LastErrorMessage = String.Empty;
            	    }
            	    else
            	    {
            	      LastError = STREAMINGERROR.Error_Login;
            	      LastErrorMessage = "Server could not be initialized.";
            	    }
            	  }
            	  else
            	  {
            	    LastError = STREAMINGERROR.Error_Login;
            	    LastErrorMessage = "Invalid username or password.";
            	  }
            	  return ok;
            	}
            	
            	public override int SendData(IntPtr buffer, int length)
            	{
            	  if (buffer == IntPtr.Zero || length == 0)
            	    return 0;
            	  int sendData = -1;
            	  try
            	  {
            	    lock (_lock)
            	    {
            	      // dynamic buffer allocation
            	      if (_data == null || _data.Length &lt; length)
            	        _data = new byte[length];
            	      Marshal.Copy(buffer, _data, 0, length);
            	      sendData = _socket.Send( _data, 0, length, SocketFlags.None );
            	      if (sendData &lt; 0)
            	      {
            	        LastError = STREAMINGERROR.Error_SendingData;
            	        LastErrorMessage = String.Format( "{0} bytes not send.", length);
            	        Disconnect();
            	      }
            	      else if (sendData != length)
            	      {
            	        LastError = STREAMINGERROR.Warning_LessDataSend;
            	        LastErrorMessage = String.Format( "{0} of {1} bytes send.", sendData, length);
            	      }
            	    }
            	  }
            	  catch (Exception e)
            	  { 
            	    LastError = STREAMINGERROR.Error_SendingData;
            	    LastErrorMessage = e.Message;
            	    sendData = -1;
            	    Disconnect();
            	  }
            	  return sendData;
            	}
            	
            	public override bool UpdateTitle(string song, string url)
            	{
            	  SongTitle = song;
            	  return MyUpdateTitle(song);
            	}
            	
            	private Socket CreateSocket(string serveraddress, int port)
            	{
            	  Socket socket = null;
            	  IPHostEntry hostEntry = null;
            	  try
            	  {
            	    // Get host related information
            	    hostEntry = Dns.GetHostEntry(serveraddress);
            	    // Loop through the AddressList to obtain the supported AddressFamily.
            	    foreach(IPAddress address in hostEntry.AddressList)
            	    {
            	      try
            	      {
            	        IPEndPoint ipe = new IPEndPoint(address, port);
            	        Socket tempSocket = new Socket(ipe.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            	        tempSocket.Connect(ipe);
            	        if (tempSocket.Connected)
            	        {
            	          socket = tempSocket;
            	          break;
            	        }
            	        else
            	        {
            	          continue;
            	        }
            	      }
            	      catch (Exception e)
            	      { 
            	        LastError = STREAMINGERROR.Error_CreatingConnection;
            	        LastErrorMessage = e.Message;
            	        socket = null; 
            	      }
            	    }
            	  }
            	  catch (Exception e)
            	  { 
            	    LastError = STREAMINGERROR.Error_ResolvingServerAddress;
            	    LastErrorMessage = e.Message;
            	    socket = null;
            	  }
            	  return socket;
            	}
            	
            	private bool MyLogin() 
            	{
            	  if (_socket == null)
            	    return false;
            	  // e.g. send password here using the "_socket"
            	  ...
            	}
            	
            	private bool MyInit() 
            	{
            	  if (_socket == null)
            	    return false;
            	  // e.g. send some init data to the server here using the "_socket"
            	  ...
            	}
            	
            	private bool MyUpdateTitle(string song)
            	{
            	  bool ok = false;
            	  Socket socket = null;
            	  try
            	  {
            	    socket = CreateSocket( ServerAddress, ServerPort );
            	    if (socket != null)
            	    {
            	      // send the song title using the created "socket"
            	      ...
            	      ok = true;
            	    }
            	  }
            	  catch { }
            	  finally
            	  {
            	    // disconnect
            	    if (socket != null)
            	    {
            	      socket.Close();
            	      socket = null;
            	    }
            	  }
            	  return ok;
            	}
            }
            </code>
            <code lang="vbnet">
            Public Class MyOwnServer Inherits StreamingServer
            
                ' Constructor
                Public Sub New(encoder As IBaseEncoder, useBASS As Boolean) MyBase.New(encoder, useBASS)
                  ' validity check
                  If encoder.EncoderType &lt;&gt; BASSChannelType.BASS_CTYPE_STREAM_MP3 AndAlso 
                     encoder.EncoderType &lt;&gt; BASSChannelType.BASS_CTYPE_STREAM_AAC Then
                     Throw New Exception("Invalid EncoderType (only MP3 and AAC is supported)!")
                  End If
                End Sub
            
                Private _socket As Socket = Nothing
                Private _loggedIn As Boolean = False
                Private _data As Byte() = Nothing
                Private _lock As Object = False
                Public ServerAddress As String = "localhost"
                Public ServerPort As Integer = 8000
            
                Public Overrides ReadOnly Property IsConnected() As Boolean
                  Get
                    If Not (_socket Is Nothing) Then
                      Return _socket.Connected AndAlso _loggedIn
                    Else
                      Return False
                    End If
                  End Get
                End Property
            
                Public Overrides Function Connect() As Boolean
                  ' check the encoder
                  If Not Encoder.IsActive Then
                    LastError = STREAMINGERROR.Error_EncoderError
                    LastErrorMessage = "Encoder not active!"
                    Return False
                  End If
                  ' close any connections, if still open
                  If Not (_socket Is Nothing) AndAlso _socket.Connected Then
                    _socket.Close()
                    _socket = Nothing
                  End If
                  ' create a connection at port+1
                  _socket = CreateSocket(ServerAddress, ServerPort + 1)
                  Return Not (_socket Is Nothing) AndAlso _socket.Connected
                End Function
            
                Public Overrides Function Disconnect() As Boolean
                  Dim ok As Boolean = False
                  Try
                    _socket.Close()
                  Catch
                  Finally
                    If Not (_socket Is Nothing) AndAlso _socket.Connected Then
                      LastError = STREAMINGERROR.Error_Disconnect
                      LastErrorMessage = "Winsock error: " + 
                                         Convert.ToString(System.Runtime.InteropServices.Marshal.GetLastWin32Error())
                    Else
                      ok = True
                      _socket = Nothing
                      _loggedIn = False
                    End If
                  End Try
                  Return ok
                End Function
            
                Public Overrides Function Login() As Boolean
                  If _socket Is Nothing Then
                    LastError = STREAMINGERROR.Error_NotConnected
                    LastErrorMessage = "Not connected to server."
                    Return False
                  End If
                  Dim ok As Boolean = False
                  If MyLogin() Then
                    If MyInit() Then
                      ok = True
                      _loggedIn = True
                      LastError = STREAMINGERROR.Ok
                      LastErrorMessage = [String].Empty
                    Else
                      LastError = STREAMINGERROR.Error_Login
                      LastErrorMessage = "Server could not be initialized."
                    End If
                  Else
                    LastError = STREAMINGERROR.Error_Login
                    LastErrorMessage = "Invalid username or password."
                  End If
                  Return ok
                End Function
            
                Public Overrides Function SendData(buffer As IntPtr, length As Integer) As Integer
                  If buffer = IntPtr.Zero OrElse length = 0 Then
                    Return 0
                  End If
                  Dim sendData As Integer = -1
                  Try
                    SyncLock _lock
                    ' dynamic buffer allocation
                    If _data Is Nothing OrElse _data.Length &lt; length Then
                      _data = New Byte(length) {}
                    End If
                    Marshal.Copy(buffer, _data, 0, length)
                    sendData = _socket.Send(_data, 0, length, SocketFlags.None)
                    If sendData &lt; 0 Then
                      LastError = STREAMINGERROR.Error_SendingData
                      LastErrorMessage = [String].Format("{0} bytes not send.", length)
                      Disconnect()
                    Else
                      If sendData &lt;&gt; length Then
                        LastError = STREAMINGERROR.Warning_LessDataSend
                        LastErrorMessage = [String].Format("{0} of {1} bytes send.", sendData, length)
                      End If
                    End If
                  End SyncLock
                  Catch e As Exception
                    LastError = STREAMINGERROR.Error_SendingData
                    LastErrorMessage = e.Message
                    sendData = -1
                    Disconnect()
                  End Try
                  Return sendData
                End Function
            
                Public Overrides Function UpdateTitle(song As String) As Boolean
                  SongTitle = song
                  Return MyUpdateTitle(song)
                End Function
            
                Private Function CreateSocket(serveraddress As String, port As Integer) As Socket
                  Dim socket As Socket = Nothing
                  Dim hostEntry As IPHostEntry = Nothing
                  Try
                    ' Get host related information
                    hostEntry = Dns.GetHostEntry(serveraddress)
                    ' Loop through the AddressList to obtain the supported AddressFamily.
                    Dim address As IPAddress
                    For Each address In hostEntry.AddressList
                      Try
                        Dim ipe As New IPEndPoint(address, port)
                        Dim tempSocket As New Socket(ipe.AddressFamily, SocketType.Stream, ProtocolType.Tcp)
                        tempSocket.Connect(ipe)
                        If tempSocket.Connected Then
                          socket = tempSocket
                          Exit ForEach
                        Else
                          GoTo ContinueForEach1
                        End If
                      Catch e As Exception
                        LastError = STREAMINGERROR.Error_CreatingConnection
                        LastErrorMessage = e.Message
                        socket = Nothing
                      End Try
                      ContinueForEach1:
                    Next address
                  Catch e As Exception
                    LastError = STREAMINGERROR.Error_ResolvingServerAddress
                    LastErrorMessage = e.Message
                    socket = Nothing
                  End Try
                  Return socket
                End Function
            
                Private Function MyLogin() As Boolean
                  If _socket Is Nothing Then
                    Return False
                  End If 
                  ' e.g. send password here using the "_socket"
                  ...
                End Function
            
                Private Function MyInit() As Boolean
                  If _socket Is Nothing Then
                    Return False
                  End If 
                  ' e.g. send some init data to the server here using the "_socket"
                  ...
                End Function
            
                Private Function MyUpdateTitle(song As String) As Boolean
                  Dim ok As Boolean = False
                  Dim socket As Socket = Nothing
                  Try
                    socket = CreateSocket(ServerAddress, ServerPort)
                    If Not (socket Is Nothing) Then
                      ' send the song title using the created "socket"
                      ...
                      ok = True
                    End If
                  Catch
                  Finally
                    ' disconnect
                    If Not (socket Is Nothing) Then
                      socket.Close()
                      socket = Nothing
                    End If
                  End Try
                  Return ok
                End Function
            
            End Class
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.#ctor(Un4seen.Bass.Misc.IBaseEncoder)">
            <summary>
            Default constructor, creating an instance for a streaming server implementation (using BASSenc as the default processor).
            </summary>
            <param name="encoder">The encoder interface which should be used with this streaming server.</param>
            <remarks>This overload will set the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property to TRUE.</remarks>
            <exception cref="T:System.ArgumentNullException">No <paramref name="encoder"/> specified.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="encoder"/> could not be found. Make sure the encoder (.exe) is present.</exception>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.#ctor(Un4seen.Bass.Misc.IBaseEncoder,System.Boolean)">
            <summary>
            Default constructor, creating an instance for a streaming server implementation.
            </summary>
            <param name="encoder">The encoder interface which should be used with this streaming server.</param>
            <param name="useBASS">TRUE, if BASSenc should be used to handle all cast server handling. FALSE, if the internal implementation should be used.</param>
            <exception cref="T:System.ArgumentNullException">No <paramref name="encoder"/> specified.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="encoder"/> could not be found. Make sure the encoder (.exe) is present.</exception>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.Dispose">
            <summary>
            Implement IDisposable.
            </summary>
            <remarks>Do not make this method virtual. A derived class should not be able to override this method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.Connect">
            <summary>
            Connects to a streaming server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.Disconnect">
            <summary>
            Disconnects from a streaming server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>A server connect should only be successfull, if the underlying encoder was started.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.Login">
            <summary>
            Performs a login to and/or initializes the streaming server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>If a server doesn't not need to handle a particular login or initialization, you might simply return TRUE in the implementation.
            However, when the login was successfully made, you should set the <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> to <see cref="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Ok"/> and the <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> to String.Empty.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.SendData(System.IntPtr,System.Int32)">
            <summary>
            Sends encoded sample data (manually) to the streaming server (e.g. the data as received in an own <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/>).
            </summary>
            <param name="buffer">The pointer to the encoded buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <param name="length">The length of the buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <returns>The number of bytes send to the server (or -1, if no bytes could be send (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>If an error occures the connection will be closed automatically (using <see cref="M:Un4seen.Bass.Misc.StreamingServer.Disconnect"/>).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.UpdateTitle(System.String,System.String)">
            <summary>
            Updates the song title of the streaming server.
            </summary>
            <param name="song">The song title to use.</param>
            <param name="url">The url which should be updated along with the title (or NULL).</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.GetListeners(System.String)">
            <summary>
            Returns the number of listeners currently connected.
            </summary>
            <param name="password">The optional admin password to use (NULL=use default).</param>
            <returns>The current number of listeners (or -1 if not available).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.GetStats(System.String)">
            <summary>
            Returns the XML stats of the server.
            </summary>
            <param name="password">The optional admin password to use (NULL=use default).</param>
            <returns>The string representing the XML formatted statistics (or NULL on error/not available).</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.UseBASS">
            <summary>
            Gets if native BASSenc should be used to connect and stream to the server (as specified in the constructor).
            </summary>
            <remarks>
            <para>If set to TRUE native BASSenc will handle all TCP socket and cast communication.
            This should be the more secure and preferred option, however in this mode it is not possible to use the <see cref="M:Un4seen.Bass.Misc.StreamingServer.SendData(System.IntPtr,System.Int32)"/> method manually!</para>
            <para>If set to FALSE an internal .Net TCP socket connection will be used and manual feed of encoded sample data via <see cref="M:Un4seen.Bass.Misc.StreamingServer.SendData(System.IntPtr,System.Int32)"/> is possible.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.SongTitle">
            <summary>
            The current/last song title.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.SongUrl">
            <summary>
            The current/last song url.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.IsConnected">
            <summary>
            Returns TRUE, if connected to a boadcast server - else FALSE.
            </summary>
            <remarks>Normally it is sufficient to return TRUE once a <see cref="M:Un4seen.Bass.Misc.StreamingServer.Connect"/> was successful.
            However, if the server implementation also requires a <see cref="M:Un4seen.Bass.Misc.StreamingServer.Login"/> this method should only return TRUE, if also the <see cref="M:Un4seen.Bass.Misc.StreamingServer.Login"/> was successful.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.Encoder">
            <summary>
            Returns the encoder interface which is used with this instance.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.LastError">
            <summary>
            Gets or Sets the last streaming error.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage">
            <summary>
            Gets or Sets the last streaming error message.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR">
            <summary>
            List of all possible streaming errors.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Ok">
            <summary>
            All OK.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_ResolvingServerAddress">
            <summary>
            The server address could not be resolved (DNS error).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_CreatingConnection">
            <summary>
            A TCP socket connection to the server could not be established (TCP error).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_SendingData">
            <summary>
            The data could not be send to the server (TCP error).
            <para>The server will automatically be disconnected.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_EncoderError">
            <summary>
            The encoder could not be started or is inactive.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_Login">
            <summary>
            Access was denied (check username and password).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_Disconnect">
            <summary>
            An error occurred during a disconnect (disconnect failed, still connected).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_NotConnected">
            <summary>
            A connection to the server was not established.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Warning_LessDataSend">
            <summary>
            Not all data could not be send to the server (less data send).
            <para>The server will automatically be disconnected.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Unknown">
            <summary>
            An unknown error occurred.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.SHOUTcast">
            <summary>
            SHOUTcast streaming parameter class.
            To be used when creating an instance of the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.
            </summary>
            <remarks>An instance of the class will providing all necessary setup and configuration data in order to connect to a SHOUTcast server.
            <para>For more information about the SHOUTcast streaming parameters take a look to the <a href="http://www.shoutcast.com">www.shoutcast.com</a> documentation.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.#ctor(Un4seen.Bass.Misc.IBaseEncoder)">
            <summary>
            Creates an instance for a SHOUTcast configuration parameter setting.
            </summary>
            <param name="encoder">The output encoder instance to be used.</param>
            <remarks>An instance of this class is needed in order to create a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> instance.
            <para>Please note, that you need an appropriate encoder for SHOUTcast streaming. For MP3 streaming we recommend using the latest stable version of LAME (see <see cref="T:Un4seen.Bass.Misc.EncoderLAME"/>).</para>
            <para>When streaming in AACplus format an external encoder is needed as well, which accepts pcm data from STDIN and is able to send it's encoded data to STDOUT.
            As of today the only 'free' AACplus encoders comes with Winamp - please take a look to the BASS Forum and search for 'enc_aacPlus.exe' (see <see cref="T:Un4seen.Bass.Misc.EncoderWinampAACplus"/>).</para>
            <para>Also take care of all neccessary patent and license issues when streaming or broadcasting!</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property to decide, whether you want to use the BASS build-in streaming support (default) or if you want to use the BASS.NET internal implementation.
            The major difference is, that the BASS.NET implementation allows you to use <see cref="M:Un4seen.Bass.Misc.SHOUTcast.SendData(System.IntPtr,System.Int32)"/> manually.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid EncoderType (only MP3 and AAC is supported)!</exception>
            <example>
            Creates a SHOUTcast configuration instance.
            <code>
            // create an encoder instance
            EncoderLAME lame = new EncoderLAME(_recHandle);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_56;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono;
            lame.LAME_TargetSampleRate = (int)EncoderLAME.SAMPLERATE.Hz_22050;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            
            // now create the SHOUTcast instance using LAME
            SHOUTcast shoutcast = new SHOUTcast(lame);
            shoutcast.ServerAddress = "http://serveraddress.com";
            shoutcast.ServerPort = 8000;
            shoutcast.Password = "password";
            ...
            </code>
            <code lang="vbnet">
            ' create an encoder instance
            Dim lame As New EncoderLAME(_recHandle)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_56)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono
            lame.LAME_TargetSampleRate = CInt(EncoderLAME.SAMPLERATE.Hz_22050)
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            
            ' now create the SHOUTcast instance using LAME
            Dim shoutcast As New SHOUTcast(lame)
            shoutcast.ServerAddress = "http://serveraddress.com"
            shoutcast.ServerPort = 8000
            shoutcast.Password = "password"
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.#ctor(Un4seen.Bass.Misc.IBaseEncoder,System.Boolean)">
            <summary>
            Creates an instance for a SHOUTcast configuration parameter setting.
            </summary>
            <param name="encoder">The output encoder instance to be used.</param>
            <param name="useBASS">TRUE, if BASSenc should be used to handle all cast server handling. FALSE, if the internal implementation should be used.</param>
            <remarks>An instance of this class is needed in order to create a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> instance.
            <para>Please note, that you need an appropriate encoder for SHOUTcast streaming. For MP3 streaming we recommend using the latest stable version of LAME (see <see cref="T:Un4seen.Bass.Misc.EncoderLAME"/>).</para>
            <para>When streaming in AACplus format an external encoder is needed as well, which accepts pcm data from STDIN and is able to send it's encoded data to STDOUT.
            As of today the only 'free' AACplus encoders comes with Winamp - please take a look to the BASS Forum and search for 'enc_aacPlus.exe' (see <see cref="T:Un4seen.Bass.Misc.EncoderWinampAACplus"/>).</para>
            <para>Also take care of all neccessary patent and license issues when streaming or broadcasting!</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property to decide, whether you want to use the BASS build-in streaming support (default) or if you want to use the BASS.NET internal implementation.
            The major difference is, that the BASS.NET implementation allows you to use <see cref="M:Un4seen.Bass.Misc.SHOUTcast.SendData(System.IntPtr,System.Int32)"/> manually.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid EncoderType (only MP3 and AAC is supported)!</exception>
            <example>
            Creates a SHOUTcast configuration instance.
            <code>
            // create an encoder instance
            EncoderLAME lame = new EncoderLAME(_recHandle);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_56;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono;
            lame.LAME_TargetSampleRate = (int)EncoderLAME.SAMPLERATE.Hz_22050;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            
            // now create the SHOUTcast instance using LAME
            SHOUTcast shoutcast = new SHOUTcast(lame, true);
            shoutcast.ServerAddress = "http://serveraddress.com";
            shoutcast.ServerPort = 8000;
            shoutcast.Password = "password";
            ...
            </code>
            <code lang="vbnet">
            ' create an encoder instance
            Dim lame As New EncoderLAME(_recHandle)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_56)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono
            lame.LAME_TargetSampleRate = CInt(EncoderLAME.SAMPLERATE.Hz_22050)
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            
            ' now create the SHOUTcast instance using LAME
            Dim shoutcast As New SHOUTcast(lame, True)
            shoutcast.ServerAddress = "http://serveraddress.com"
            shoutcast.ServerPort = 8000
            shoutcast.Password = "password"
            ...
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.ServerAddress">
            <summary>
            SHOUTcast server address (of the form 192.168.1.100 or shoutcast-server.domain.com).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.ServerPort">
            <summary>
            SHOUTcast server TCP port (usually 8000).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Password">
            <summary>
            SHOUTcast server broadcast password (the "Password" config item on the server's config file).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.StationName">
            <summary>
            A brief description of your station or of what content you'll be broadcasting (usually 10-20 words).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Genre">
            <summary>
            A genre list of the variety of content you're providing (usually 1-3 words like Rock, 80s, etc.)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.PublicFlag">
            <summary>
            TRUE, if you want your broadcast to be listed in the public directory of SHOUTcast broadcasts (default).
            Else FALSE, which means private.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Url">
            <summary>
            A URL of a website that contains information about your broadcast.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Irc">
            <summary>
            A channel on Efnet IRC for your listeners to interact with (don't worry if you don't understand this).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Icq">
            <summary>
            If you have one, your ICQ number for listeners to interact with you through. (www.icq.com)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Aim">
            <summary>
            Your AOL Instant Messenger (AIM) name for listeners to interact with you. (aim.aol.com)
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.Connect">
            <summary>
            Establishes a TCP socket connection to the SHOUTcast server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>A server connect will only be successfull, if the underlying <see cref="T:System.Text.Encoder"/> was started and is active.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.Disconnect">
            <summary>
            Disconnects from a SHOUTcast server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>Disconnecting from the server will also STOP the underlying encoder by calling the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.Login">
            <summary>
            Performs a login and initializes the SHOUTcast server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>If <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to TRUE, nothing will happen here and TRUE is returned in any case.
            So this method is only effective, if <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to FALSE.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.SendData(System.IntPtr,System.Int32)">
            <summary>
            Sends encoded sample data to the SHOUTcast server (e.g. the data as received in an own <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/>).
            </summary>
            <param name="buffer">The pointer to the encoded buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <param name="length">The length of the buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <returns>The number of bytes send to the server (or -1, if no bytes could be send (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>NOTE: Only possible, if <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to FALSE.
            <para>If an error occures the connection will be closed automatically (using <see cref="M:Un4seen.Bass.Misc.SHOUTcast.Disconnect"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.UpdateTitle(System.String,System.String)">
            <summary>
            Updates the song title of the streaming server.
            </summary>
            <param name="song">The new song title to use.</param>
            <param name="url">The url which should be updated along with the title (or NULL).</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>When <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to TRUE, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastSetTitle(System.Int32,System.String,System.String)"/> will be used internally -
            else an internal implementation will be used.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.GetListeners(System.String)">
            <summary>
            Returns the number of listeners currently connected.
            </summary>
            <param name="password">The optional admin password to use (NULL=use default).</param>
            <returns>The current number of listeners (or -1 if not available).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.GetStats(System.String)">
            <summary>
            Returns the XML stats of the server.
            </summary>
            <param name="password">The optional admin password to use (NULL=use default).</param>
            <returns>The string representing the XML formatted statistics (or NULL on error/not available).</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.SHOUTcast.IsConnected">
            <summary>
            Returns TRUE, if connected and logged into the SHOUTcast server - else FALSE.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.ICEcast">
            <summary>
            ICEcast streaming parameter class.
            To be used when creating an instance of the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.
            </summary>
            <remarks>An instance of the class will providing all necessary setup and configuration data in order to connect to an ICEcast server.
            <para>For more information about the ICEcast streaming parameters take a look to the <a href="http://www.icecast.org">www.icecast.org</a> documentation.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.#ctor(Un4seen.Bass.Misc.IBaseEncoder)">
            <summary>
            Creates an instance for an ICEcast configuration parameter setting.
            </summary>
            <param name="encoder">The output encoder instance to be used.</param>
            <remarks>An instance of this class is needed in order to create a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> instance.
            <para>Please note, that you need an appropriate encoder for ICEcast streaming. For MP3 streaming we recommend using the latest stable version of LAME (see <see cref="T:Un4seen.Bass.Misc.EncoderLAME"/>). For OGG streaming we recommend using the latest stable version of oggenc2 (see <see cref="T:Un4seen.Bass.Misc.EncoderOGG"/>).</para>
            <para>When streaming in AACplus format an external encoder is needed as well, which accepts pcm data from STDIN and is able to send it's encoded data to STDOUT.
            As of today the only 'free' AACplus encoders comes with Winamp - please take a look to the BASS Forum and search for 'enc_aacPlus.exe' (see <see cref="T:Un4seen.Bass.Misc.EncoderWinampAACplus"/>).</para>
            <para>Also take care of all neccessary patent and license issues when streaming or broadcasting!</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property to decide, whether you want to use the BASS build-in streaming support (default) or if you want to use the BASS.NET internal implementation.
            The major difference is, that the BASS.NET implementation allows you to use <see cref="M:Un4seen.Bass.Misc.ICEcast.SendData(System.IntPtr,System.Int32)"/> manually.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid EncoderType (only OGG, MP3 and AAC is supported)!</exception>
            <example>
            Creates an ICEcast configuration instance.
            <code>
            // create an encoder instance
            EncoderLAME lame = new EncoderLAME(_recHandle);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_56;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono;
            lame.LAME_TargetSampleRate = (int)EncoderLAME.SAMPLERATE.Hz_22050;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            
            // now create the ICEcast instance using LAME
            ICEcast icecast = new ICEcast(lame);
            icecast.ServerAddress = "http://serveraddress.com";
            icecast.ServerPort = 8000;
            icecast.Password = "password";
            icecast.Mountpoint = "/mystream";
            ...
            </code>
            <code lang="vbnet">
            ' create an encoder instance
            Dim lame As New EncoderLAME(_recHandle)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_56)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono
            lame.LAME_TargetSampleRate = CInt(EncoderLAME.SAMPLERATE.Hz_22050)
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            
            ' now create the ICEcast instance using LAME
            Dim icecast As New ICEcast(lame)
            icecast.ServerAddress = "http://serveraddress.com"
            icecast.ServerPort = 8000
            icecast.Password = "password"
            icecast.Mountpoint = "/mystream"
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.#ctor(Un4seen.Bass.Misc.IBaseEncoder,System.Boolean)">
            <summary>
            Creates an instance for an ICEcast configuration parameter setting.
            </summary>
            <param name="encoder">The output encoder instance to be used.</param>
            <param name="useBASS">TRUE, if BASSenc should be used to handle all cast server handling. FALSE, if the internal implementation should be used.</param>
            <remarks>An instance of this class is needed in order to create a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> instance.
            <para>Please note, that you need an appropriate encoder for ICEcast streaming. For MP3 streaming we recommend using the latest stable version of LAME (see <see cref="T:Un4seen.Bass.Misc.EncoderLAME"/>). For OGG streaming we recommend using the latest stable version of oggenc2 (see <see cref="T:Un4seen.Bass.Misc.EncoderOGG"/>).</para>
            <para>When streaming in AACplus format an external encoder is needed as well, which accepts pcm data from STDIN and is able to send it's encoded data to STDOUT.
            As of today the only 'free' AACplus encoders comes with Winamp - please take a look to the BASS Forum and search for 'enc_aacPlus.exe' (see <see cref="T:Un4seen.Bass.Misc.EncoderWinampAACplus"/>).</para>
            <para>Also take care of all neccessary patent and license issues when streaming or broadcasting!</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property to decide, whether you want to use the BASS build-in streaming support (default) or if you want to use the BASS.NET internal implementation.
            The major difference is, that the BASS.NET implementation allows you to use <see cref="M:Un4seen.Bass.Misc.ICEcast.SendData(System.IntPtr,System.Int32)"/> manually.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid EncoderType (only OGG, MP3 and AAC is supported)!</exception>
            <example>
            Creates an ICEcast configuration instance.
            <code>
            // create an encoder instance
            EncoderLAME lame = new EncoderLAME(_recHandle);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_56;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono;
            lame.LAME_TargetSampleRate = (int)EncoderLAME.SAMPLERATE.Hz_22050;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            
            // now create the ICEcast instance using LAME
            ICEcast icecast = new ICEcast(lame, true);
            icecast.ServerAddress = "http://serveraddress.com";
            icecast.ServerPort = 8000;
            icecast.Password = "password";
            icecast.Mountpoint = "/mystream";
            ...
            </code>
            <code lang="vbnet">
            ' create an encoder instance
            Dim lame As New EncoderLAME(_recHandle)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_56)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono
            lame.LAME_TargetSampleRate = CInt(EncoderLAME.SAMPLERATE.Hz_22050)
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            
            ' now create the ICEcast instance using LAME
            Dim icecast As New ICEcast(lame, True)
            icecast.ServerAddress = "http://serveraddress.com"
            icecast.ServerPort = 8000
            icecast.Password = "password"
            icecast.Mountpoint = "/mystream"
            ...
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.ServerAddress">
            <summary>
            ICEcast server address (hostname, in the form 192.168.1.100 or icecast-server.domain.com).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.ServerPort">
            <summary>
            ICEcast server TCP port (usually 8000).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.MountPoint">
            <summary>
            The ICEcast mountpoint you want to use.
            </summary>
            <remarks>All Ogg Vorbis streams should have mountpoints that end in .ogg (i.e. "/mystream.ogg"). 
            This is due to the lazy way most media players infer the type of stream. 
            MP3 streams usually do not contain an extension (e.g. "/mystream"). 
            Mount points also should not contain any spaces or odd characters (again due to the lazy way many of the media players are coded) and MUST start with a slash ('/')!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.Username">
            <summary>
            ICEcast server user name (the "source" username which should be used).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.Password">
            <summary>
            ICEcast server broadcast password (the "source-password" config item on the server's config file).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.StreamName">
            <summary>
            The name of your stream or station (usually 1-5 words).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.StreamDescription">
            <summary>
            A description of your stream or station or of what content you'll be broadcasting (usually 10-20 words).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.StreamUrl">
            <summary>
            A URL of a website that contains information about your broadcast.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.StreamGenre">
            <summary>
            A genre list of the variety of content you're providing (usually 1-3 words like Rock, 80s, etc.)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.PublicFlag">
            <summary>
            TRUE, if you want your broadcast to be listed in the public directory of ICEcast broadcasts (default).
            Else FALSE, which means private.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.Quality">
            <summary>
            The bitrate quality name (e.g. "Quality").
            </summary>
            <remarks>Set to NULL (default), if you want to use the effective bitrate (in kbps) of the encoder instead.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.Connect">
            <summary>
            Establishes a TCP socket connection to the ICEcast server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>A server connect will only be successfull, if the underlying <see cref="T:System.Text.Encoder"/> was started and is active.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.Disconnect">
            <summary>
            Disconnects from an ICEcast server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>Disconnecting from the server will also STOP the underlying encoder by calling the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.Login">
            <summary>
            Performs a login and initializes the ICEcast server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>If <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to TRUE, nothing will happen here and TRUE is returned in any case.
            So this method is only effective, if <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to FALSE.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.SendData(System.IntPtr,System.Int32)">
            <summary>
            Sends encoded sample data to the ICEcast server (e.g. the data as received in an own <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/>).
            </summary>
            <param name="buffer">The pointer to the encoded buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <param name="length">The length of the buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <returns>The number of bytes send to the server (or -1, if no bytes could be send (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>NOTE: Only possible, if <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to FALSE.
            <para>If an error occures the connection will be closed automatically (using <see cref="M:Un4seen.Bass.Misc.ICEcast.Disconnect"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.UpdateTitle(System.String,System.String)">
            <summary>
            Updates the song title of the streaming server.
            </summary>
            <param name="song">The new song title to use.</param>
            <param name="url">NULL - not supported for ICEcast.</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>When <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to TRUE, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastSetTitle(System.Int32,System.String,System.String)"/> will be used internally -
            else an internal implementation will be used.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.GetListeners(System.String)">
            <summary>
            Returns the number of listeners currently connected.
            </summary>
            <param name="password">The optional admin password to use (NULL=use default).</param>
            <returns>The current number of listeners (or -1 if not available).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.GetStats(System.String)">
            <summary>
            Returns the XML stats of the server.
            </summary>
            <param name="password">The optional admin password to use (NULL=use default).</param>
            <returns>The string representing the XML formatted statistics (or NULL on error/not available).</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.ICEcast.IsConnected">
            <summary>
            Returns TRUE, if connected and logged into the ICEcast server - else FALSE.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.WMAcast">
            <summary>
            Windows Media Streaming (WMAcast) streaming parameter class.
            To be used when creating an instance of the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.
            </summary>
            <remarks>An instance of the class will providing all necessary setup and configuration data in order to connect to an Windows Media server or directly stream to the network (acting like a server).
            <para>The <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property will in this implementation in any case return TRUE (since BASSwma is used internally).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WMAcast.#ctor(Un4seen.Bass.Misc.IBaseEncoder)">
            <summary>
            Creates an instance for an WMAcast configuration parameter setting.
            </summary>
            <param name="encoder">The output encoder instance to be used (must be of type <see cref="T:Un4seen.Bass.Misc.EncoderWMA"/>).</param>
            <remarks>An instance of this class is needed in order to create a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> instance.
            <para>Also take care of all neccessary patent and license issues when streaming or broadcasting!</para>
            <para>The <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property will in this implementation in any case be set to TRUE (since BASSwma is used internally).</para>
            <para>Also the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseNetwork"/> flag will always be forced and set to TRUE, as well as the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> will in any case be set to NULL as well.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid EncoderType (only OGG, MP3 and AAC is supported)!</exception>
            <exception cref="T:System.ArgumentNullException">Invalid Encoder used, encoder must be of type EncoderWMA!</exception>
            <example>
            Creates an WMAcast configuration instance.
            <code>
            // create an encoder instance
            EncoderWMA wma = new EncoderWMA(_recHandle);
            wma.WMA_Bitrate = (int)EncoderWMA.BITRATE.kbps_64;
            wma.WMA_UseNetwork = true;
            
            // now create the WMAcast instance
            WMAcast wmacast = new WMAcast(wma);
            wmacast.ServerPort = 8080;
            ...
            wma.Start(null, IntPtr.Zero, true); // start paused
            wma.Connect();
            wma.Pause(false); // start encoding
            Bass.BASS_ChannelPlay(_recHandle, false);
            ...
            </code>
            <code lang="vbnet">
            ' create an encoder instance
            Dim wma As New EncoderWMA(_recHandle)
            wma.WMA_Bitrate = CInt(EncoderWMA.BITRATE.kbps_64)
            wma.WMA_UseNetwork = True
            
            ' now create the WMAcast instance
            Dim wmacast As New WMAcast(wma)
            wmacast.ServerPort = 8080
            ...
            wma.Start(Nothing, IntPtr.Zero, True) ' start paused
            wma.Connect()
            wma.Pause(False) ' start encoding
            Bass.BASS_ChannelPlay(_recHandle, False)
            ...
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.Misc.WMAcast.StreamAuthor">
            <summary>
            An optional author of the stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WMAcast.StreamPublisher">
            <summary>
            An optional publisher of the stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WMAcast.StreamGenre">
            <summary>
            An optional genre of the stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WMAcast.StreamCopyright">
            <summary>
            A optional copyright notice for the stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WMAcast.StreamDescription">
            <summary>
            A optional description for the stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WMAcast.StreamRating">
            <summary>
            A optional rating information for the stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WMAcast.StreamUrl">
            <summary>
            A URL of a website that contains information about your broadcast.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.WMAcast.Connect">
            <summary>
            Establishes a connection to the WMAcast server (network or publishing point).
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>A server connect will only be successfull, if the underlying <see cref="T:System.Text.Encoder"/> was started and is active.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WMAcast.Disconnect">
            <summary>
            Disconnects from an WMAcast server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WMAcast.Login">
            <summary>
            Performs a login and initializes the WMAcast server.
            </summary>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WMAcast.SendData(System.IntPtr,System.Int32)">
            <summary>
            Sends sample data to the underlying WMA encoder.
            </summary>
            <param name="buffer">The pointer to the buffer data.</param>
            <param name="length">The length of the buffer data.</param>
            <returns>The number of bytes send to the server (or -1, if no bytes could be send (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>
            <para>IMPORTANT NOTE: This implementation always return <paramref name="length"/>!
            As the underlying <see cref="T:Un4seen.Bass.Misc.EncoderWMA"/> automatically sends data to the encoder there is NO need to call this method at all!
            This because the <see cref="T:Un4seen.Bass.Misc.EncoderWMA"/> will already set up an automatic DSP system whichs feeds the encoder with sample data and already sends the data to the server automatically.</para>
            <para>If you want to get notified about any errors when sending data to the encoder you might use the <see cref="P:Un4seen.Bass.Misc.EncoderWMA.WMA_Notify"/> property.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WMAcast.UpdateTitle(System.String,System.String)">
            <summary>
            Updates the song title of the streaming server.
            </summary>
            <param name="song">The new song title to use.</param>
            <param name="url">NULL - not supported for WMAcast.</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>Updatig the song title on a Windows Media server does effectivly not work. Use the initial <see cref="P:Un4seen.Bass.Misc.StreamingServer.SongTitle"/> instead.
            This method sends the "CAPTION" script command to the encoder. The global <see cref="P:Un4seen.Bass.Misc.StreamingServer.SongTitle"/> is not updated by this call!
            <para>This is a text string that is displayed in the captions area of Windows Media Player. 
            This supports standard HTML formatting, so the text can be formatted as you wish.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WMAcast.GetListeners(System.String)">
            <summary>
            Returns the number of listeners currently connected (only if <see cref="P:Un4seen.Bass.Misc.WMAcast.UsePublish"/> is set to FALSE).
            </summary>
            <param name="password">The optional admin password to use (NULL=use default).</param>
            <returns>The current number of listeners (or -1 if not available).</returns>
            <remarks>The optional password is actually not used in this implementation.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WMAcast.GetStats(System.String)">
            <summary>
            Returns the XML stats of the server.
            </summary>
            <param name="password">An optional password to use (should be set to NULL to use the default publish password).</param>
            <returns>The string representing the XML formatted statistics (or NULL on error/not available).</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.WMAcast.UsePublish">
            <summary>
            Enables WMA encoding to a publishing point on a Windows Media server (default is FALSE, meaning direct network).
            </summary>
            <remarks>The default mode is active network streaming, meaning this server can directly be used by clients to connect.
            <para>Also note, that if streaming to a Windows Media server you must set the properties: <see cref="P:Un4seen.Bass.Misc.WMAcast.PublishUrl"/>, <see cref="P:Un4seen.Bass.Misc.WMAcast.PublishUsername"/> and <see cref="P:Un4seen.Bass.Misc.WMAcast.PublishPassword"/>.</para>
            <para>If you set the <see cref="P:Un4seen.Bass.Misc.WMAcast.UsePublish"/> property to FALSE (default), encoding will directly be done to the network (pull mode): <see cref="P:Un4seen.Bass.Misc.WMAcast.NetworkClients"/> users might connect directly to the specified <see cref="P:Un4seen.Bass.Misc.WMAcast.NetworkPort"/>.</para>
            <para>Set the <see cref="P:Un4seen.Bass.Misc.WMAcast.UsePublish"/> property to TRUE, in order to enable encoding to a publishing point on a Windows Media server (push mode).</para>
            <para>Note: Directly changes the underlying <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> member.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WMAcast.NetworkPort">
            <summary>
            The network port number for clients to conenct to (only used, if <see cref="P:Un4seen.Bass.Misc.WMAcast.UsePublish"/> is set to FALSE) - default is 8080.
            </summary>
            <remarks>
            <para>Note: Directly changes the underlying <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_NetworkPort"/> member.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WMAcast.NetworkClients">
            <summary>
            The maximum number of clients (up to 50) that can be connected (only used, if <see cref="P:Un4seen.Bass.Misc.WMAcast.UsePublish"/> is set to FALSE) - default is 1.
            </summary>
            <remarks>
            <para>Note: Directly changes the underlying <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_NetworkClients"/> member.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WMAcast.PublishUrl">
            <summary>
            URL of the publishing point on the Windows Media server (only used, if <see cref="P:Un4seen.Bass.Misc.WMAcast.UsePublish"/> is set to TRUE).
            </summary>
            <remarks>
            <para>Note: Directly changes the underlying <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_PublishUrl"/> member.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WMAcast.PublishUsername">
            <summary>
            Username to use in connecting to the server (only used, if <see cref="P:Un4seen.Bass.Misc.WMAcast.UsePublish"/> is set to TRUE).
            </summary>
            <remarks>If either this or <see cref="P:Un4seen.Bass.Misc.WMAcast.PublishPassword"/> is NULL, then no username/password is sent to the server.
            <para>Note: Directly changes the underlying <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_PublishUsername"/> member.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WMAcast.PublishPassword">
            <summary>
            Password to use in connecting to the server (only used, if <see cref="P:Un4seen.Bass.Misc.WMAcast.UsePublish"/> is set to TRUE).
            </summary>
            <remarks>If either this or <see cref="P:Un4seen.Bass.Misc.WMAcast.PublishUsername"/> is NULL, then no username/password is sent to the server.
            <para>Note: Directly changes the underlying <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_PublishPassword"/> member.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WMAcast.IsConnected">
            <summary>
            Returns TRUE, if connected and logged into the WMAcast server - else FALSE.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.IBaseEncoder">
            <summary>
            Defines a generalized encoder class interface that a <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> class must implement.
            </summary>
            <remarks>This interface is for example used in the constructor of a streaming server parameter class (e.g. <see cref="T:Un4seen.Bass.Misc.SHOUTcast"/> or <see cref="T:Un4seen.Bass.Misc.ICEcast"/>) 
            to specify which encoder settings should be used.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IBaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method must implement the actual start of the encoder. 
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return a valid HENCODE handle.
            </summary>
            <param name="proc">Optional callback function to receive the encoded data... NULL = no callback. 
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Should return TRUE, if the encoder was successfully started - else FALSE must be returned.</returns>
            <remarks>An imlementation of this method should internally call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> accordingly using the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return 0 (zero).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IBaseEncoder.Stop">
            <summary>
            This method must implement the actual stop of the encoder. 
            After the encoder was stopped successfully the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return 0 (zero).
            </summary>
            <returns>Should return TRUE, if the encoder was successfully stopped - else FALSE must be returned and an <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must stay as before.</returns>
            <remarks>An imlementation of this method should internally call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> accordingly using the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/>.
            After the encoder was stopped successfully the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return 0 (zero). 
            If the encoder was not stopped and is still active or simply paused <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return a valid HENCODE (non-zero).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IBaseEncoder.Pause(System.Boolean)">
            <summary>
            This method must implement the actual pauseing of the encoder. 
            After the encoder was paused successfully the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must still return a valid HENCODE handle (non-zero).
            </summary>
            <param name="paused">Pause the encoder (TRUE) or unpause (FALSE).</param>
            <returns>Should return TRUE, if the encoder was successfully paused - else FALSE must be returned and an <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must stay as before.</returns>
            <remarks>An imlementation of this method should internally call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)"/> accordingly using the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/>.
            After the encoder was paused successfully the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must still return a valid HENCODE handle (non-zero).
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return 0 (zero).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.ChannelHandle">
            <summary>
            This property should get or sets the channel handle which will be used to create the broadcast encoder class.
            </summary>
            <remarks>Only set this member to a new channel, if the encoder is not active (otherwise the channel will not be changed)!</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.ChannelBitwidth">
            <summary>
            This property should return the actual bitwidth of the sample data BASS is using with the channel (e.g. 8, 16, 32).
            </summary>
            <remarks>BASS supports 8/16/32-bit sample data, so if a WAV file, for example, uses another sample resolution, it'll have to be converted by BASS.
            This bitwidth represents the bitwidth which is used by BASS (e.g. in a DSP callback delegate) and does not represent the original bitwidth of the stream.
            The bitwidth used by BASS is determined how the underlying channel handle was created (e.g. using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> with the <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_8BITS"/> or <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT"/> flag)
            and if the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_FLOATDSP"/> option has been set.
            If non of the above was used, by default 16 bits per sample are used.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.ChannelSampleRate">
            <summary>
            This property should return the actual sample rate in Hz of the sample data BASS is using with the channel (e.g. 44100).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.ChannelNumChans">
            <summary>
            This property should return the actual number of channles of the sample data BASS is using with the channel (e.g. 1=mono, 2=stereo, etc.).
            </summary>
            <remarks>BASS supports multi-channel sample data, so make sure the actual encoder implementation supports multi-channel too.
            If the encoder does not support multi-channel make sure that you are using non-multi-channel hanles only.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderType">
            <summary>
            This property should return a value indicating which type of content the broadcast encoder implements.
            </summary>
            <remarks>For example: If the implementation of the broadcast encoder implements an MP3 encoder, you should return BASS_CTYPE_STREAM_MP3.
            For a complete list see <see cref="T:Un4seen.Bass.BASSChannelType"/>.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.DefaultOutputExtension">
            <summary>
            This property should return the default extension of an output file for this encoder (e.g. ".mp3" or ".ogg" etc.).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.SupportsSTDOUT">
            <summary>
            This property should return TRUE, if the base encoder implementation (resp. the underlying command-line tool being used) support STDOUT for output of the encoded data - else FALSE must be returned.
            </summary>
            <remarks>In order to support broadcast streaming with an encoder command-line tool,
            the encoded data needs to be received back by a callback function, so the encoder needs to be told to output to STDOUT (instead of a file).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle">
            <summary>
            This property should get and set a HENCODE encoder handle as returned by the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> method if the the encoder has been started (see <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>) or 0 (zero), if the encoder has not been started or was stopped (see <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Stop"/>).
            </summary>
            <remarks>Take note of the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.IsActive"/> member, which might need to use the the encoder handle in order to retrieve the encoder state.
            <para>If the encoder is not started or not started successfully (see <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>) or is stopped this property must return 0 (zero)!</para>
            <para>If the encoder is started and is active this property must return the valid HENCODE handle (non-zero)!</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.IsActive">
            <summary>
            This property should return TRUE, if the encoder has been started (see <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>) and is active - else FALSE must be returned.
            </summary>
            <remarks>An implementation should first get the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/>.
            If the encoder handle is valid (non-zero) the implementation might use the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/> method in order to check it's state.
            If the state is not BASS_ACTIVE_STOPPED this property should return TRUE.
            In all other cases this property should return FALSE (not started, paused, stopped etc.)</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.IsPaused">
            <summary>
            This property should return TRUE, only if the encoder has been paused (see <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Pause(System.Boolean)"/>) - else FALSE must be returned.
            </summary>
            <remarks>An implementation should first get the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/>.
            If the encoder handle is valid (non-zero) the implementation might use the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/> method in order to check it's state.
            Only if the state is BASS_ACTIVE_PAUSED this property should return TRUE.
            In all other cases this property should return FALSE (not started, active, playing etc.)</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine">
            <summary>
            This property should return an encoder command-line string, 
            which might be used with the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> method in order to create and start the encoder.
            </summary>
            <remarks>Make sure, that the encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.OutputFile"/> members correctly.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderDirectory">
            <summary>
            This property should get and set the encoder's base directory.
            It might be used in the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/> implementation to return a fully qualified encoder command-line.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderExists">
            <summary>
            This property should return TRUE, if the encoder exists and is available - else FALSE should be returned.
            </summary>
            <remarks>When using a command-line encoder this method might check, if the executable file exists in the specified <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderDirectory"/>.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.InputFile">
            <summary>
            Specifies the input file name to be processed by the encoder (null = STDIN).
            </summary>
            <remarks>This member should be used when implementing the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/> property.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.Force16Bit">
            <summary>
            Gets or Sets if a encoding in 16-bit sample data should be forced (default is FALSE).
            </summary>
            <remarks>This member should be used when implementing the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/> property.
            <para>When you want to encode a floating-point channel, but the encoder does not support 32-bit floating-point sample data, then you can use this flags to have the sample data converted to 16 bit integer data before it's passed on to the encoder.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.OutputFile">
            <summary>
            Specifies the output file name to be processed by the encoder (null = STDOUT).
            </summary>
            <remarks>This member should be used when implementing the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/> property.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.EffectiveBitrate">
            <summary>
            Specifies the target effective bitrate of the encoder output (in kbps, e.g. 128 kbps).
            </summary>
            <remarks>This member must return a valid bitrate, if you are using the encoder in a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> implementation.
            If you are encoding in VBR or ABR this member must also return a valid bitrate (e.g. approximated). 
            You might use one of the <see cref="T:Un4seen.Bass.Misc.BaseEncoder.BITRATE"/> constants in order to set a valid effective bitrate.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.TAGs">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure associated with the encoder.
            </summary>
            <remarks>By default this member is NULL - meaning no Tag info is used with the encoder.
            <para>If you set this property to a valid <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance before you call <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>, this will be used (when supported by the encoder) to automatically write the respective tag info to the output.
            Meaning the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/> will be modified accordingly.</para>
            <para>The TAGs will only be used, if you have specified an <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.OutputFile"/>.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.BaseEncoder">
            <summary>
            Base class for all encoder classes (e.g. <see cref="T:Un4seen.Bass.Misc.EncoderLAME"/>, <see cref="T:Un4seen.Bass.Misc.EncoderWinampAACplus"/> or <see cref="T:Un4seen.Bass.Misc.EncoderOGG"/>).
            </summary>
            <remarks>This base class is not intended for direct use, but defines all abstract properties and methods which needs to be implemented by an actual broadcast encoder class.
            <para>Internally, the sending of sample data to the encoder is implemented via a DSP callback on the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/>. That means when you play the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/> (or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            It also means that if the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_FLOATDSP</see> option is enabled, the sample data will be 32-bit floating-point.</para>
            <para>A derived class must implement: <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderType"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EffectiveBitrate"/> and <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/>.</para>
            <para>The properties <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelBitwidth"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelSampleRate"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelNumChans"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.IsActive"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.IsPaused"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/>
            as well as the methods <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> and <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> have been already implemented.</para>
            <para>You might use this base class to derive your own Encoder implementations.
            In this case a derived class must only implement the following members: <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderType"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/>.</para>
            <para>If an instance of a derived class is being disposed, an already assigned Encoder will automatically be stopped.</para>
            <para>How to use an encoder implementation:
            <list type="table">
            <listheader><term>Scenario:</term><description>How-To:</description></listheader>
            <item><term>"Recording" To "Streaming":</term>
            <description>Create a recording handle with <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>.
            <para>Set <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> to NULL (STDIN, STDOUT).</para>
            <para>Use the encoder instance to create a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>, which is then used by the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.</para>
            </description></item>
            <item><term>"Recording" To "File":</term>
            <description>Create a recording handle with <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>.
            <para>Set <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> to NULL and the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> to a file name (STDIN, file).</para>
            <para>Call <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> to start encoding and <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> to stop the live recording encoding.</para>
            <code>
            EncoderNeroAAC n = new EncoderNeroAAC(_recHandle);
            n.InputFile = null;
            n.OutputFile = "test.m4a";
            n.NERO_Bitrate = 48;
            n.Start(null, IntPtr.Zero, false);
            // your recording will be encoded until you call...
            n.Stop();
            </code>
            <code lang="vbnet">
            Dim n As New EncoderNeroAAC(_recHandle)
            n.InputFile = Nothing
            n.OutputFile = "test.m4a"
            n.NERO_Bitrate = 48
            n.Start(Nothing, IntPtr.Zero, False)
            ' your recording will be encoded until you call...
            n.Stop()
            </code>
            </description></item>
            <item><term>"Stream" To "Streaming":</term>
            <description>Create a stream handle e.g. with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> (either normal or decoding).
            <para>Set <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> to NULL and the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> to a file name (STDIN, file).</para>
            <para>Use the encoder instance to create a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>, which is then used by the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.</para>
            <para>Call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> resp. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if using a decoding stream) to play resp. decode the stream and actually feed the encoder and therewith the broadcasting server.</para>
            <para>Hint: You might use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> to create a continues mixer output stream channel for streaming.</para>
            </description></item>
            <item><term>"Stream" To "File":</term>
            <description>Create a stream handle e.g. with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> (either normal or decoding).
            <para>Set <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> to NULL and the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> to a file name (STDIN, file).</para>
            <para>Call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> resp. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if using a decoding stream) to play resp. decode the stream and actually feed the encoder.</para>
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.wav", 0, 0, BASSFlag.BASS_STREAM_DECODE);
            EncoderLAME l = new EncoderLAME(stream);
            l.InputFile = null;	//STDIN
            l.OutputFile = "test.mp3";
            l.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_64;
            l.LAME_Mode = EncoderLAME.LAMEMode.Default;
            l.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            l.Start(null, IntPtr.Zero, false);
            // decode the stream (if not using a decoding channel, simply call "Bass.BASS_ChannelPlay" here)
            byte[] encBuffer = new byte[65536]; // our dummy encoder buffer
            while (Bass.BASS_ChannelIsActive(stream) == BASSActive.BASS_ACTIVE_PLAYING)
            {
            	// getting sample data will automatically feed the encoder
            	int len = Bass.BASS_ChannelGetData(_stream, encBuffer, encBuffer.Length);
            }
            l.Stop();  // finish
            Bass.BASS_StreamFree(stream);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.wav", 0, 0, BASSFlag.BASS_STREAM_DECODE)
            Dim l As New EncoderLAME(stream)
            l.InputFile = Nothing 'STDIN
            l.OutputFile = "test.mp3"
            l.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_64)
            l.LAME_Mode = EncoderLAME.LAMEMode.Default
            l.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            l.Start(Nothing, IntPtr.Zero, False)
            ' decode the stream (if not using a decoding channel, simply call "Bass.BASS_ChannelPlay" here)
            Dim encBuffer(65536) As Byte ' our dummy encoder buffer
            While Bass.BASS_ChannelIsActive(stream) = BASSActive.BASS_ACTIVE_PLAYING
              ' getting sample data will automatically feed the encoder
              Dim len As Integer = Bass.BASS_ChannelGetData(_stream, encBuffer, encBuffer.Length)
            End While
            l.Stop() ' finish
            Bass.BASS_StreamFree(stream)
            </code>
            </description></item>
            <item><term>"File" To "Streaming":</term>
            <description>Create a stream handle e.g. with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> (either normal or decoding).
            Just like the above example. And use the stream handle to create the encoder instance.
            <para>Set <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> to NULL and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> to NULL (STDIN, STDOUT).</para>
            <para>Use the encoder instance to create a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>, which is then used by the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.</para>
            </description></item>
            <item><term>"File" To "File":</term>
            <description>No stream handle is actually needed.
            <para>Set <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> to a file name (file, file).</para>
            <para>Call <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> to start encoding and <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> to stop encoding.</para>
            <para>Or simply use the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/> method instead.</para>
            <code>
            EncoderOGG o = new EncoderOGG(0);
            o.InputFile = "test.wav";
            o.OutputFile = "test.ogg";
            o.OGG_UseQualityMode = true;
            o.OGG_Quality = 4;
            BaseEncoder.EncodeFile(o, null, true, false, true);
            </code>
            <code lang="vbnet">
            Dim o As New EncoderOGG(0)
            o.InputFile = "test.wav"
            o.OutputFile = "test.ogg"
            o.OGG_UseQualityMode = True
            o.OGG_Quality = 4
            BaseEncoder.EncodeFile(o, Nothing, True, False, True)
            </code>
            </description></item>
            </list>
            </para>
            </remarks>
            <example>
            This example shows a basic implementation of an own Encoder class:
            <code>
            public class MyOwnEncoder : BaseEncoder
            {
            	// Constructor
            	public MyOwnEncoder(int channel) : base(channel)
            	{
            	}
            	
            	public override string ToString()
            	{
            	  return "My Encoder (BASS_CTYPE_STREAM_MP3)";
            	}
            	
            	public override string DefaultOutputExtension
            	{
            	  get { return ".mp3"; }
            	}
            	
            	public override BASSChannelType EncoderType
            	{
            	  get { return BASSChannelType.BASS_CTYPE_STREAM_MP3; }
            	}
            	
            	public override bool SupportsSTDOUT
            	{
            	  get { return true; }
            	}
            	
            	public override string EncoderCommandLine
            	{
            	  get { return BuildEncoderCommandLine(); }
            	}
            
            	public override int EffectiveBitrate
            	{
            	  get { return My_Bitrate; }	
            	}
            	
            	public override bool Start(ENCODEPROC proc, IntPtr user, bool paused)
            	{
            	  if (EncoderHandle != 0 || (proc != null &amp;&amp; !SupportsSTDOUT))
            	    return false;
            	  // start the encoder
                  BASSEncode flag = BASSEncode.BASS_ENCODE_NOHEAD;
                  if (Force16Bit)
                    flag |= BASSEncode.BASS_ENCODE_FP_16BIT;
                  if (paused)
                    flag |= BASSEncode.BASS_ENCODE_PAUSE;
            	  EncoderHandle = BassEnc.BASS_Encode_Start(ChannelHandle, EncoderCommandLine, 
            	                                            flag, proc, user);
            	  if (EncoderHandle == 0)
            	    return false;
            	  else
            	    return true;
            	}
            	
            	// local members for setting individual parameters
            	public int My_Bitrate = 128; 
            	
            	// just an example here!
            	private string BuildEncoderCommandLine()
            	{
            	  CultureInfo enCI = new CultureInfo("en-US", false);
            	  StringBuilder sb = new StringBuilder();
            	  // the file name and path
            	  sb.Append( Path.Combine( EncoderDirectory, "myencoder.exe" ) );
            	  // raw input?
            	  if (InputFile == null) // STDIN: add the raw pcm header data
            	    sb.Append( String.Format( enCI, " -r -x -s {0:##0.0##} --bitwidth {1}", 
                               ChannelSampleRate/1000f, ChannelBitwidth &gt; 16 ? 16 : ChannelBitwidth ) );
            	  // ...more options here...
            	  sb.Append( String.Format( enCI, " -b {0} -h", My_Bitrate ) );
            	  // STDIN or filename
            	  if (InputFile != null)
            	    sb.Append( " \""+InputFile+"\"" );
            	  else
            	    sb.Append( " -" );
            	  // STDOUT or filename
            	  if (OutputFile != null)
            	    sb.Append( " \""+OutputFile+"\"" );
            	  else
            	    sb.Append( " -" );
            	  return sb.ToString();	
            	}
            }
            </code>
            <code lang="vbnet">
            Public Class MyOwnEncoder Inherits BaseEncoder
            
                ' Constructor
                Public Sub New(channel As Integer) MyBase.New(channel)
                End Sub
            
                Public Overrides Function ToString() As String
                  Return "My Encoder (BASS_CTYPE_STREAM_MP3)"
                End Function
            
                Public Overrides ReadOnly Property DefaultOutputExtension() As String
                  Get
                    Return ".mp3"
                  End Get
                End Property 
            
                Public Overrides ReadOnly Property EncoderType() As BASSChannelType
                  Get
                    Return BASSChannelType.BASS_CTYPE_STREAM_MP3
                  End Get
                End Property
            
                Public Overrides ReadOnly Property SupportsSTDOUT() As Boolean
                  Get
                    Return True
                  End Get
                End Property 
            
                Public Overrides ReadOnly Property EncoderCommandLine() As String
                  Get
                    Return BuildEncoderCommandLine()
                  End Get
                End Property 
            
                Public Overrides ReadOnly Property EffectiveBitrate() As Integer
                  Get
                    Return My_Bitrate
                  End Get
                End Property
            
                Public Overrides Function Start(proc As ENCODEPROC, user As IntPtr, paused As Boolean) As Boolean
                  If EncoderHandle &lt;&gt; 0 OrElse (Not (proc Is Nothing) AndAlso Not SupportsSTDOUT) Then
                    Return False
                  End If 
                  ' start the encoder
                  Dim flag As BASSEncode = BASSEncode.BASS_ENCODE_NOHEAD
                  If Force16Bit Then
                    flag = flag Or BASSEncode.BASS_ENCODE_FP_16BIT
                  End If
                  If paused Then
                    flag = flag Or BASSEncode.BASS_ENCODE_PAUSE
                  End If
                  EncoderHandle = BassEnc.BASS_Encode_Start(ChannelHandle, EncoderCommandLine, 
                                                            flag, proc, user)
                  End If
                  If EncoderHandle = 0 Then
                    Return False
                  Else
                    Return True
                  End If
                End Function
            
                ' local members for setting individual parameters
                Public My_Bitrate As Integer = 128
            
                ' just an example here!
                Private Function BuildEncoderCommandLine() As String
                  Dim enCI As New CultureInfo("en-US", False)
                  Dim sb As New StringBuilder()
                  ' the file name and path
                  sb.Append(Path.Combine(EncoderDirectory, "myencoder.exe"))
                  ' raw input?
                  If InputFile Is Nothing Then ' STDIN: add the raw pcm header data
                    sb.Append([String].Format(enCI, " -r -x -s {0:##0.0##} --bitwidth {1}", 
                              ChannelSampleRate / 1000F,(If ChannelBitwidth &gt; 16 Then 16 Else ChannelBitwidth))) 'ToDo: Unsupported feature: conditional (?) operator.
                  End If ' ...more options here...
                  sb.Append([String].Format(enCI, " -b {0} -h", My_Bitrate))
                  ' STDIN or filename
                  If Not (InputFile Is Nothing) Then
                    sb.Append((" """ + InputFile + """"))
                  Else
                    sb.Append(" -")
                  End If ' STDOUT or filename
                  If Not (OutputFile Is Nothing) Then
                    sb.Append((" """ + OutputFile + """"))
                  Else
                    sb.Append(" -")
                  End If
                  Return sb.ToString()
                End Function
            
            End Class
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.#ctor(System.Int32)">
            <summary>
            Default constructor, which already evaluates the channel handle and evaluates the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelBitwidth"/>.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>If you pass 0 (zero) as a channel handle, all members are initialized with some default values.
            You can change the channel handle by assigning a new value to the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/> property.
            A channel handle can only be changed, if the encoder is not active (see <see cref="P:Un4seen.Bass.Misc.BaseEncoder.IsActive"/>).
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.Dispose">
            <summary>
            Implement IDisposable.
            </summary>
            <remarks>Do not make this method virtual. A derived class should not be able to override this method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method must implement the actual start of the encoder. 
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> must return a valid HENCODE handle.
            </summary>
            <param name="proc">Optional callback function to receive the encoded data... NULL = no callback. 
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Should return TRUE, if the encoder was successfully started - else FALSE must be returned.</returns>
            <remarks>An imlementation of this method should internally call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> accordingly using the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> must return a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> must return 0 (zero).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.Stop">
            <summary>
            Stops the encoder (if started).
            </summary>
            <returns>Returns TRUE, if the encoder was successfully stopped - else FALSE is returned.</returns>
            <remarks>Internally <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> is called using the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>.
            After the encoder was stopped successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> is set to 0 (zero). 
            If the encoder was not stopped the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> is left unchanged.
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)">
            <summary>
            Pauses or resumes an encoder. 
            </summary>
            <param name="paused">TRUE = pause the encoder, FALSE = resume the encoder.</param>
            <returns>Returns TRUE, if the encoder was successfully paused/resumed - else FALSE must be returned and an <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> must stay as before.</returns>
            <remarks>
            After the encoder was paused/resumed successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> must still return a valid HENCODE handle (non-zero).
            <para>The default imlementation of this method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)"/> accordingly using the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>.
            So normally there is no need to override this method.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="inputFile">The input filename to encode (must exist).</param>
            <param name="outputFile">The target output filename (if NULL, the filename will be composed by changing the file extension to the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.DefaultOutputExtension"/>).</param>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (NULL = no notifcation).</param>
            <param name="overwriteOutput">Set to TRUE, if you want to force to overwrite any already existing output file (will delete the existing file). If set to FALSE and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to TRUE, if you want to delete the input file after the encoding has been successfully completed.</param>
            <returns>Returns TRUE, if the input file was successfully encoded. Returns FALSE if any error occured.</returns>
            <remarks>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Encodes a file using the EncoderWMA (CBR at 128 kbps):
            <code>
            EncoderWMA wma = new EncoderWMA(0);
            wma.WMA_Bitrate = 128;
            BaseEncoder.EncodeFile("test.wav", null, wma, 
                                   new BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), true, false);
            
            public void FileEncodingNotification(long bytesTotal, long bytesDone)
            {
              Console.Write("Encoding: {0:P}\r", Math.Round((double)bytesDone/(double)bytesTotal, 2));
            }
            </code>
            <code lang="vbnet">
            Dim wma As New EncoderWMA(0)
            wma.WMA_Bitrate = 128
            BaseEncoder.EncodeFile("test.wav", Nothing, wma, 
                                   New BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), True, False)
            
            Public Sub FileEncodingNotification(bytesTotal As Long, bytesDone As Long)
              Console.Write("Encoding: {0:P}\r", Math.Round(CDbl(bytesDone) / CDbl(bytesTotal), 2))
            End Sub
            </code>
            Encodes OGG input to an MP3 output using EncoderLAME (with the 'standard' preset):
            <code>
            EncoderLAME enc = new EncoderLAME(0);
            enc.LAME_PresetName = "standard";
            BaseEncoder.EncodeFile("test.ogg", null, enc, null, true, false);
            </code>
            <code lang="vbnet">
            Dim enc As New EncoderLAME(0)
            enc.LAME_PresetName = "standard"
            BaseEncoder.EncodeFile("test.ogg", Nothing, enc, Nothing, True, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (NULL = no notifcation).</param>
            <param name="overwriteOutput">Set to TRUE, if you want to force to overwrite any already existing output file (will delete the existing file). If set to FALSE and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to TRUE, if you want to delete the input file after the encoding has been successfully completed.</param>
            <returns>Returns TRUE, if the input file was successfully encoded. Returns FALSE if any error occured.</returns>
            <remarks>The InputFile and OutputFile will be taken from the encoder settings!
            <para>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.</para>
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Encodes a file using the EncoderWMA (using CBR at 128 kbps Pro):
            <code>
            EncoderWMA wma = new EncoderWMA(0);
            wma.InputFile = "testin.ogg";
            wma.OutputFile = "testout.wma";
            wma.WMA_Bitrate = 128;
            wma.WMA_UsePro = true;
            BaseEncoder.EncodeFile(wma, new BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), true, false);
            
            public void FileEncodingNotification(long bytesTotal, long bytesDone)
            {
            	Console.Write("Encoding: {0:P}\r", Math.Round((double)bytesDone/(double)bytesTotal, 2));
            }
            </code>
            <code lang="vbnet">
            Dim wma As New EncoderWMA(0)
            wma.InputFile = "testin.ogg"
            wma.OutputFile = "testout.wma"
            wma.WMA_Bitrate = 128
            wma.WMA_UsePro = True
            BaseEncoder.EncodeFile(wma, New BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), True, False)
            
            Public Sub FileEncodingNotification(bytesTotal As Long, bytesDone As Long)
              Console.Write("Encoding: {0:P}\r", Math.Round(CDbl(bytesDone) / CDbl(bytesTotal), 2))
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="inputFile">The input filename to encode (must exist).</param>
            <param name="outputFile">The target output filename (if NULL, the filename will be composed by changing the file extension to the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.DefaultOutputExtension"/>).</param>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (NULL = no notifcation).</param>
            <param name="overwriteOutput">Set to TRUE, if you want to force to overwrite any already existing output file (will delete the existing file). If set to FALSE and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to TRUE, if you want to delete the input file after the encoding has been successfully completed.</param>
            <param name="updateTags">Set to TRUE, if you want to use the TAGs from the input file and write them also to the output file. FALSE will write the output without any TAGs.</param>
            <returns>Returns TRUE, if the input file was successfully encoded. Returns FALSE if any error occured.</returns>
            <remarks>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Re-Encodes an OGG file to MP3 using the EncoderLAME (no notification, but copying the TAGs):
            <code>
            EncoderLAME lame = new EncoderLAME(0);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_192;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            lame.TAGs = BassTags.BASS_TAG_GetFromFile("testin.ogg", true, false);;
            BaseEncoder.EncodeFile("testin.ogg", "testout.mp3", lame, null, true, false, true);
            </code>
            <code lang="vbnet">
            Dim lame As New EncoderLAME(0)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_192)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            lame.TAGs = BassTags.BASS_TAG_GetFromFile("testin.ogg", True, False)
            BaseEncoder.EncodeFile("testin.ogg", "testout.mp3", lame, Nothing, True, False, True)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (NULL = no notifcation).</param>
            <param name="overwriteOutput">Set to TRUE, if you want to force to overwrite any already existing output file (will delete the existing file). If set to FALSE and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to TRUE, if you want to delete the input file after the encoding has been successfully completed.</param>
            <param name="updateTags">Set to TRUE, if you want to use the TAGs from the input file and write them also to the output file. FALSE will write the output without any TAGs.</param>
            <returns>Returns TRUE, if the input file was successfully encoded. Returns FALSE if any error occured.</returns>
            <remarks>The InputFile and OutputFile will be taken from the encoder settings!
            <para>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.</para>
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Re-Encodes an OGG file to MP3 using the EncoderLAME (manual tagging):
            <code>
            TAG_INFO tags = new TAG_INFO();
            tags.artist = "The Artist";
            tags.title = "The Title";
            
            EncoderLAME lame = new EncoderLAME(0);
            lame.InputFile = "test.ogg";
            lame.TAGs = tags;
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_192;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            BaseEncoder.EncodeFile(lame, 
                                   new BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), true, false, true);
            
            public void FileEncodingNotification(long bytesTotal, long bytesDone)
            {
            	Console.Write("Encoding: {0:P}\r", Math.Round((double)bytesDone/(double)bytesTotal, 2));
            }
            </code>
            <code lang="vbnet">
            Dim tags As New TAG_INFO()
            tags.artist = "The Artist"
            tags.title = "The Title"
            
            Dim lame As New EncoderLAME(0)
            lame.InputFile = "test.ogg"
            lame.TAGs = tags
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_192)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            BaseEncoder.EncodeFile(lame, 
                                   New BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), True, False, True)
            
            Public Sub FileEncodingNotification(bytesTotal As Long, bytesDone As Long)
              Console.Write("Encoding: {0:P}\r", Math.Round(CDbl(bytesDone) / CDbl(bytesTotal), 2))
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Int64)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="inputFile">The input filename to encode (must exist).</param>
            <param name="outputFile">The target output filename (if NULL, the filename will be composed by changing the file extension to the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.DefaultOutputExtension"/>).</param>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (NULL = no notifcation).</param>
            <param name="overwriteOutput">Set to TRUE, if you want to force to overwrite any already existing output file (will delete the existing file). If set to FALSE and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to TRUE, if you want to delete the input file after the encoding has been successfully completed.</param>
            <param name="updateTags">Set to TRUE, if you want to use the TAGs from the input file and write them also to the output file. FALSE will write the output without any TAGs.</param>
            <param name="fromPos">Sets the start position in bytes from where to start encoding or -1 to encode from the beginning.</param>
            <param name="toPos">Sets the end position in bytes til where want to encode or -1 to encode til the end. toPos must be greater than fromPos!</param>
            <returns>Returns TRUE, if the input file was successfully encoded. Returns FALSE if any error occured.</returns>
            <remarks>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Re-Encodes an OGG file partially to MP3 using the EncoderLAME:
            <code>
            EncoderLAME lame = new EncoderLAME(0);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_192;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            BaseEncoder.EncodeFile("testin.ogg", "testout.mp3", lame, null, true, false, true, 4096, 61440);
            </code>
            <code lang="vbnet">
            Dim lame As New EncoderLAME(0)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_192)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            BaseEncoder.EncodeFile("testin.ogg", "testout.mp3", lame, Nothing, True, False, True, 4096, 61440)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Int64)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (NULL = no notifcation).</param>
            <param name="overwriteOutput">Set to TRUE, if you want to force to overwrite any already existing output file (will delete the existing file). If set to FALSE and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to TRUE, if you want to delete the input file after the encoding has been successfully completed.</param>
            <param name="updateTags">Set to TRUE, if you want to use the TAGs from the input file and write them also to the output file. FALSE will write the output without any TAGs.</param>
            <param name="fromPos">Sets the start position in bytes from where to start encoding or -1 to encode from the beginning.</param>
            <param name="toPos">Sets the end position in bytes til where want to encode or -1 to encode til the end. toPos must be greater than fromPos!</param>
            <returns>Returns TRUE, if the input file was successfully encoded. Returns FALSE if any error occured.</returns>
            <remarks>The InputFile and OutputFile will be taken from the encoder settings!
            <para>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.</para>
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Re-Encodes an OGG file partially to MP3 using the EncoderLAME:
            <code>
            EncoderLAME lame = new EncoderLAME(0);
            lame.InputFile = "testin.ogg";
            lame.OutputFile = "testout.mp3";
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_192;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            BaseEncoder.EncodeFile(lame, 
                                   new BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), 
                                   true, false, true, 4096, 61440);
            
            public void FileEncodingNotification(long bytesTotal, long bytesDone)
            {
            	Console.Write("Encoding: {0:P}\r", Math.Round((double)bytesDone/(double)bytesTotal, 2));
            }
            </code>
            <code lang="vbnet">
            Dim lame As New EncoderLAME(0)
            lame.InputFile = "testin.ogg"
            lame.OutputFile = "testout.mp3"
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_192)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            BaseEncoder.EncodeFile(lame, 
                                   New BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), 
                                   True, False, True, 4096, 61440)
            
            Public Sub FileEncodingNotification(bytesTotal As Long, bytesDone As Long)
              Console.Write("Encoding: {0:P}\r", Math.Round(CDbl(bytesDone) / CDbl(bytesTotal), 2))
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="inputFile">The input filename to encode (must exist).</param>
            <param name="outputFile">The target output filename (if NULL, the filename will be composed by changing the file extension to the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.DefaultOutputExtension"/>).</param>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (NULL = no notifcation).</param>
            <param name="overwriteOutput">Set to TRUE, if you want to force to overwrite any already existing output file (will delete the existing file). If set to FALSE and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to TRUE, if you want to delete the input file after the encoding has been successfully completed.</param>
            <param name="updateTags">Set to TRUE, if you want to use the TAGs from the input file and write them also to the output file. FALSE will write the output without any TAGs.</param>
            <param name="fromPos">Sets the start position in seconds (incl. fractions) from where to start encoding or -1.0f to encode from the beginning.</param>
            <param name="toPos">Sets the end position in seconds (incl. fractions) til where want to encode or -1.0f to encode til the end. toPos must be greater than fromPos!</param>
            <returns>Returns TRUE, if the input file was successfully encoded. Returns FALSE if any error occured.</returns>
            <remarks>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Re-Encodes an OGG file partially to MP3 using the EncoderLAME:
            <code>
            EncoderLAME lame = new EncoderLAME(0);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_192;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            BaseEncoder.EncodeFile("testin.ogg", "testout.mp3", lame, 
                                   new BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), 
                                   true, false, true, 5.1f, 25.3f);
            
            public void FileEncodingNotification(long bytesTotal, long bytesDone)
            {
            	Console.Write("Encoding: {0:P}\r", Math.Round((double)bytesDone/(double)bytesTotal, 2));
            }
            </code>
            <code lang="vbnet">
            Dim lame As New EncoderLAME(0)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_192)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            BaseEncoder.EncodeFile("testin.ogg", "testout.mp3", lame, 
                                   New BaseEncoder.ENCODEFILEPROC(FileEncodingNotification),
                                   True, False, True, 5.1F, 25.3F)
            
            Public Sub FileEncodingNotification(bytesTotal As Long, bytesDone As Long)
              Console.Write("Encoding: {0:P}\r", Math.Round(CDbl(bytesDone) / CDbl(bytesTotal), 2))
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (NULL = no notifcation).</param>
            <param name="overwriteOutput">Set to TRUE, if you want to force to overwrite any already existing output file (will delete the existing file). If set to FALSE and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to TRUE, if you want to delete the input file after the encoding has been successfully completed.</param>
            <param name="updateTags">Set to TRUE, if you want to use the TAGs from the input file and write them also to the output file. FALSE will write the output without any TAGs.</param>
            <param name="fromPos">Sets the start position in seconds (incl. fractions) from where to start encoding or -1.0f to encode from the beginning.</param>
            <param name="toPos">Sets the end position in seconds (incl. fractions) til where want to encode or -1.0f to encode til the end. toPos must be greater than fromPos!</param>
            <returns>Returns TRUE, if the input file was successfully encoded. Returns FALSE if any error occured.</returns>
            <remarks>The InputFile and OutputFile will be taken from the encoder settings!
            <para>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.</para>
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Re-Encodes an OGG file to MP3 using the EncoderLAME partially:
            <code>
            EncoderLAME lame = new EncoderLAME(0);
            lame.InputFile = "testin.ogg";
            lame.OutputFile = "testout.mp3";
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_192;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            BaseEncoder.EncodeFile(lame, 
                                   new BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), 
                                   true, false, true,
                                   5.1f, 25.3f);
            
            public void FileEncodingNotification(long bytesTotal, long bytesDone)
            {
            	Console.Write("Encoding: {0:P}\r", Math.Round((double)bytesDone/(double)bytesTotal, 2));
            }
            </code>
            <code lang="vbnet">
            Dim lame As New EncoderLAME(0)
            lame.InputFile = "testin.ogg"
            lame.OutputFile = "testout.mp3"
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_192)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            BaseEncoder.EncodeFile(lame, 
                                   New BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), 
                                   True, False, True, 5.1F, 25.3F)
            
            Public Sub FileEncodingNotification(bytesTotal As Long, bytesDone As Long)
              Console.Write("Encoding: {0:P}\r", Math.Round(CDbl(bytesDone) / CDbl(bytesTotal), 2))
            End Sub
            </code>
            </example>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle">
            <summary>
            Gets or Sets the channel handle which is used to create the broadcast encoder class.
            </summary>
            <remarks>This allows you to move the encoder to another channel on the fly.
            <para>The new channel must have the same sample format (rate, channels, resolution) as the old channel, as that is what the encoder is expecting!</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.ChannelInfo">
            <summary>
            Returns the general channel info.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.ChannelBitwidth">
            <summary>
            This property returns the actual bitwidth of the sample data of the channel (e.g. 8, 16, 32).
            </summary>
            <remarks>BASS supports 8/16/32-bit sample data, so if a WAV file, for example, uses another sample resolution, it'll have to be converted by BASS.
            This bitwidth represents the bitwidth which is used by BASS (e.g. in a DSP callback delegate) and does not represent the original bitwidth of the stream.
            The bitwidth used by BASS is determined how the underlying channel handle was created (e.g. using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> with the <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_8BITS"/> or <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT"/> flag)
            and if the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_FLOATDSP"/> option has been set.
            If non of the above was used, by default 16 bits per sample are used.
            <para>However this bitwidth is the bitwidth in use when sending sample data to an encoder.
            If for example the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_FLOATDSP"/> or the <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT"/> option have been used,
            the encoder would receive 32-bit float samples. If the derived encoder implementation does not support floating-point sample data, 
            the encoder implementation should use one of the <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/> flags: BASS_ENCODE_FP_8BIT, BASS_ENCODE_FP_16BIT, BASS_ENCODE_FP_24BIT, BASS_ENCODE_FP_32BIT.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.ChannelSampleRate">
            <summary>
            This property returns the actual sample rate in Hz of the sample data BASS is using with the channel (e.g. 44100).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.ChannelNumChans">
            <summary>
            This property returns the actual number of channles of the sample data BASS is using with the channel (e.g. 1=mono, 2=stereo, etc.).
            </summary>
            <remarks>BASS supports multi-channel sample data, so make sure the actual encoder implementation supports multi-channel too.
            If the encoder does not support multi-channel make sure that you are using non-multi-channel hanles only.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT">
            <summary>
            This property should return TRUE, if the base encoder implementation (resp. the underlying command-line tool being used) support STDOUT for output of the encoded data - else FALSE must be returned.
            </summary>
            <remarks>In order to support broadcast streaming with an encoder command-line tool,
            the encoded data needs to be received back by a callback function, so the encoder needs to be told to output to STDOUT (instead of a file).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.EncoderType">
            <summary>
            This property should return a value indicating which type of content the broadcast encoder implements.
            </summary>
            <remarks>For example: If the implementation of the broadcast encoder implements an MP3 encoder, you should return BASS_CTYPE_STREAM_MP3.
            For a complete list see <see cref="T:Un4seen.Bass.BASSChannelType"/>.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.DefaultOutputExtension">
            <summary>
            This property should return the default extension of an output file for this encoder (e.g. ".mp3" or ".ogg" etc.).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle">
            <summary>
            Gets or sets the current HENCODE encoder handle.
            </summary>
            <remarks>The encoder handle will be set to a valid HENCODE handle, when the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> method was successfully called.
            The encoder hande will be set to 0 (zero) when <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> is called.
            <para>It is not advised to modify the encoder handle except in the actual implementation of the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> method.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.IsActive">
            <summary>
            Gets a value indicating if the encoder has been started (see <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>) and is active - else FALSE will be returned.
            </summary>
            <remarks>This implementation first gets the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>.
            If the encoder handle is valid (non-zero) the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/> method is used to check the state.
            If the state is not BASS_ACTIVE_STOPPED TRUE is returned.
            In all other cases FALSE is returned (not started, paused, stopped etc.)</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.IsPaused">
            <summary>
            Gets a value indicating if the encoder has been paused (see <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/>) - else FALSE must be returned.
            </summary>
            <remarks>This implementation first gets the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>.
            If the encoder handle is valid (non-zero) the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/> method is used to check the state.
            Only if the state is BASS_ACTIVE_PAUSED this property returns TRUE.
            In all other cases FALSE is returned (not started, active, playing etc.)</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory">
            <summary>
            Gets or Sets the encoder's base directory.
            </summary>
            <remarks>This property might be used in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/> implementation to return a fully qualified path to the encoder executable within the command-line.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine">
            <summary>
            This property should return an encoder command-line string, 
            which might be used with the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> method in order to create and start the encoder.
            </summary>
            <remarks>Make sure, that the encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> members correctly.
            Derived classes might also intruduce additional members which will have a direct impact of the command-line string.
            Therefore the actual implementation of this property should always generate the command-line dynamically when this property is accessed.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.EncoderExists">
            <summary>
            This property should return TRUE, if the encoder exists and is available - else FALSE should be returned.
            </summary>
            <remarks>When using a command-line encoder this method might check, if the executable file exists in the specified <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/>.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.InputFile">
            <summary>
            Gets or Sets the input file name to be processed by the encoder (null = STDIN, default).
            </summary>
            <remarks>This member should be used when implementing the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/> property.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.Force16Bit">
            <summary>
            Gets or Sets if a encoding in 16-bit sample data should be forced (default is FALSE).
            </summary>
            <remarks>This member should be used when implementing the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/> property.
            <para>When you want to encode a floating-point channel, but the encoder does not support 32-bit floating-point sample data, then you can use this flags to have the sample data converted to 16 bit integer data before it's passed on to the encoder.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile">
            <summary>
            Gets or Sets the output file name to be processed by the encoder (null = STDOUT, default).
            </summary>
            <remarks>This member should be used when implementing the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/> property.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.EffectiveBitrate">
            <summary>
            This property should return the target effective bitrate of the encoder output (in kbps, e.g. 128 kbps).
            </summary>
            <remarks>This member must return a valid bitrate (in kbps), if you are using the encoder in a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> implementation (i.e. the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/> is set to TRUE).
            If an encoder implementation will never be used for broadcast streaming (or the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/> is set to FALSE) this property will not be used and mihgt not be overridden therefore.
            <para>If you are encoding in VBR or ABR this member must also return a valid bitrate (e.g. an approximated average). 
            You might use one of the <see cref="T:Un4seen.Bass.Misc.BaseEncoder.BITRATE"/> constants in order to set a valid effective bitrate.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.TAGs">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure associated with the encoder.
            </summary>
            <remarks>By default this member is NULL - meaning no Tag info is used with the encoder.
            <para>If you set this property to a valid <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance before you call <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>, this will be used (when supported by the encoder) to automatically write the respective tag info to the output.
            Meaning the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/> will be modified accordingly.</para>
            <para>The TAGs will only be used, if you have specified an <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/>.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.BaseEncoder.BITRATE">
            <summary>
            List of supported encoding bitrates (kbps).
            </summary>
            <remarks>Not all bitrates are supported for all sample frequencies. See the following table for an overview:
            <list type="table">
            <item><term>MPEG-1 layer III sample frequencies (kHz):  32  44.1  48</term>
            <description>bitrates (kbps): 32 40 48 56 64 80 96 112 128 160 192 224 256 320</description></item>
            <item><term>MPEG-2 layer III sample frequencies (kHz):  16  22.05  24</term>
            <description>bitrates (kbps):  8 16 24 32 40 48 56 64 80 96 112 128 144 160</description></item>
            <item><term>MPEG-2.5 layer III sample frequencies (kHz):   8  11.025  12</term>
            <description>bitrates (kbps):  8 16 24 32 40 48 56 64 80 96 112 128 144 160</description></item>
            <item><term>AACplus sample frequencies (kHz):  32  44.1  48</term>
            <description>bitrates (kbps): 16 20 24 28 32 40 48 56 64 80 96 112 128
            <para>aacPlusHigh additional bitrates (kbps): 160 192 224 256 320</para></description></item>
            <item><term>OGG sample frequencies (kHz):   all from 8  to 96</term>
            <description>bitrates (kbps): 8 16 24 32 40 48 56 64 80 96 112 128 144 160 192 224 256 320</description></item>
            <item><term>WMA sample frequencies (kHz):  8  11.025  16  22  32  44.1  48</term>
            <description>bitrates (kbps): 6 8 10 12 16 20 22 32 40 48 64 80 96 128 160 192 256 320</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_6">
            <summary>
            6kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_8">
            <summary>
            8kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_10">
            <summary>
            10kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_12">
            <summary>
            12kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_16">
            <summary>
            16kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_20">
            <summary>
            20kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_22">
            <summary>
            22kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_24">
            <summary>
            24kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_32">
            <summary>
            32kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_40">
            <summary>
            40kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_48">
            <summary>
            48kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_56">
            <summary>
            56kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_64">
            <summary>
            64kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_80">
            <summary>
            80kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_96">
            <summary>
            96kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_112">
            <summary>
            112kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_128">
            <summary>
            128kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_144">
            <summary>
            144kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_160">
            <summary>
            160kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_192">
            <summary>
            192kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_224">
            <summary>
            224kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_256">
            <summary>
            256kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_320">
            <summary>
            320kbps
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE">
            <summary>
            List of supported broadcast sample rates.
            </summary>
            <remarks>Make sure this samplerate matches your encoder settings.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_8000">
            <summary>
            8 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_11025">
            <summary>
            11.025 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_16000">
            <summary>
            16 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_22050">
            <summary>
            22.05 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_32000">
            <summary>
            32 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_44100">
            <summary>
            44.1 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_48000">
            <summary>
            48 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_96000">
            <summary>
            96 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_192000">
            <summary>
            192 kHz
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC">
            <summary>
            This delegate might be used in the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/> method.
            </summary>
            <param name="bytesTotal">The total number of bytes to be encode.</param>
            <param name="bytesDone">The number of bytes already encoded.</param>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderLAME">
            <summary>
            Encoder class implementation for MP3 encoding using lame.exe.
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MP3"/> encoder type.
            <para>LAME (lame.exe) must be downloaded separately (e.g. from <a href="http://www.rarewares.org/mp3.html">www.rarewares.org</a>).</para>
            <para>Since lame.exe does not support 32-bit IEEE float sample data as input, the BASS_ENCODE_FP_32BIT will be used for highest quality.
            This will be used, whenever the underlying channel handle is 32-bit float or the BASS_CONFIG_FLOATDSP option has been set.</para>
            <para>Make sure to set the LAME_xxx flags before retrieving the <see cref="P:Un4seen.Bass.Misc.EncoderLAME.EncoderCommandLine"/> or calling <see cref="M:Un4seen.Bass.Misc.EncoderLAME.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderLAME.#ctor(System.Int32)">
            <summary>
            Creates an instance of a LAME encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>LAME implements MP3 encoding (BASS_CTYPE_STREAM_MP3).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderLAME.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Returns "LAME Encoder (BASS_CTYPE_STREAM_MP3)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderLAME.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual LAME encoder. 
            </summary>
            <param name="proc">Optional callback function to receive the encoded data (only valid, if <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> is set to NULL)... NULL = no callback.
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.EncoderLAME.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally using the <see cref="P:Un4seen.Bass.Misc.EncoderLAME.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).
            <para>This implementation starts the encoder with the BASS_ENCODE_NOHEAD and BASSEncode.BASS_ENCODE_FP_24BIT flag.</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_UseCustomOptionsOnly">
            <summary>
            Use the <see cref="F:Un4seen.Bass.Misc.EncoderLAME.LAME_CustomOptions"/> parameter string only (default=FALSE).
            </summary>
            <remarks>Caution: If set to TRUE no other LAME_xxx options will be evaluated and ONLY the <see cref="F:Un4seen.Bass.Misc.EncoderLAME.LAME_CustomOptions"/> parameter string will be used!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_CustomOptions">
            <summary>
            The custom parameter string, which should be used, if the <see cref="F:Un4seen.Bass.Misc.EncoderLAME.LAME_UseCustomOptionsOnly"/> property is set to TRUE.
            </summary>
            <remarks>This property string will be appended to all other LAME_xxx options, if the <see cref="F:Un4seen.Bass.Misc.EncoderLAME.LAME_UseCustomOptionsOnly"/> property is set to FALSE (default).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_Mode">
            <summary>
            -m: The encoding mode (stereo, joint stereo, mono etc.).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_Scale">
            <summary>
            --scale: Scale input (multiply PCM data). Set to 1.00 (default) for no scaling.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_PresetName">
            <summary>
            --preset: Preset name must be "medium", "standard", "extreme", "insane" or a value for an average desired bitrate 
            and depending on the value specified, appropriate quality settings will be used.
            </summary>
            <remarks>If a preset name is specified NO other options will be used!
            So make sure to set the preset name to String.Empty, if you want to use any other options.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_Quality">
            <summary>
            Noise shaping and psycho acoustic algorithms (default is Quality).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_ReplayGain">
            <summary>
            --replaygain: ReplayGain analysis.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_FreeFormat">
            <summary>
            --freeformat: produce a free format bitstream? (Default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_Bitrate">
            <summary>
            -b:  Constant (or minimum allowed) bitrate in kbps, default 128 kbps.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_TargetSampleRate">
            <summary>
            --resample: target sampling frequency of output (in Hz). Set to 0 (zero) to use automatic resampling (default).
            </summary>
            <remarks>Specify the target sample rate in Hz, e.g. 22050 for 22.05kHz.
            <para>When using this encoder for broadcast streaming it is advised to always set the target samplerate.</para>
            <para>You might use one of the <see cref="T:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE"/> constants here.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_EnforceCBR">
            <summary>
            --cbr: Enforce use of constant bitrate.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_ABRBitrate">
            <summary>
            --abr: Specify average target bitrate in kbps desired (instead of quality). 
            Set to 0, if this option should be disabled (default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_UseVBR">
            <summary>
            Use variable bitrate (VBR) (Default is FALSE).
            </summary>
            <remarks>If enabled, the <see cref="F:Un4seen.Bass.Misc.EncoderLAME.LAME_Bitrate"/> will be used as the minimum allowed bitrate.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_VBRQuality">
            <summary>
            -V: Quality setting for VBR (default is VBR_Q4).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_VBRMaxBitrate">
            <summary>
            Specify maximum allowed bitrate in kbps, default 320 kbps.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_VBRDisableTag">
            <summary>
            -t: disable writing VBR LAME Tag? (Default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_VBREnforceMinBitrate">
            <summary>
            -F: strictly enforce minimum bitrate, for use with players that do not support low bitrate mp3.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_Copyright">
            <summary>
            -c: mark as copyright (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_NonOriginal">
            <summary>
            -o: mark as non-original (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_Protect">
            <summary>
            -p: error protection. Adds 16-bit checksum to every frame (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_DisableBitReservoir">
            <summary>
            --nores: disable the bit reservoir (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_EnforceISO">
            <summary>
            --strictly-enforce-ISO: comply as much as possible to ISO MPEG spec (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_DisableAllFilters">
            <summary>
            -k: keep ALL frequencies (disables all filters), can cause ringing and twinkling (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_PSYuseShortBlocks">
            <summary>
            --short: use short blocks when appropriate (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_PSYnoShortBlocks">
            <summary>
            --noshort: don't use short blocks (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_PSYallShortBlocks">
            <summary>
            --allshort: use only short blocks (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_PSYnoTemp">
            <summary>
            --notemp: disable temporal masking effect (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_PSYnsSafeJoint">
            <summary>
            --nssafejoint: M/S switching criterion (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_NoASM">
            <summary>
            --noasm: disable assembly optimizations for mmx/3dnow/sse.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_HighPassFreq">
            <summary>
            --highpass: frequency(kHz), highpass filter cutoff below freq.
            </summary>
            <remarks>Set to 0 (zero) to apply default (disabled).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_HighPassFreqWidth">
            <summary>
            --highpass-width: frequency(kHz) - default 15% of highpass freq.
            </summary>
            <remarks>Set to 0 (zero) to apply the default.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_LowPassFreq">
            <summary>
            --lowpass: frequency(kHz), lowpass filter cutoff above freq.
            </summary>
            <remarks>Set to 0 (zero) to apply default (disabled).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_LowPassFreqWidth">
            <summary>
            --lowpass-width: frequency(kHz) - default 15% of lowpass freq.
            </summary>
            <remarks>Set to 0 (zero) to apply the default.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAME_ATHControl">
            <summary>
            --ath...: ATH control.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderLAME.EncoderExists">
            <summary>
            This property return TRUE, if the file "lame.exe" exists in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/> - else FALSE is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderLAME.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here BASS_CTYPE_STREAM_MP3 is always returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderLAME.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (".mp3").
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderLAME.SupportsSTDOUT">
            <summary>
            LAME implements STDOUT, so TRUE is always returned.
            </summary>
            <remarks>LAME support boradcast streaming.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderLAME.EncoderCommandLine">
            <summary>
            Gets the actual encoder command-line string (using all LAME_xxx properties).
            </summary>
            <remarks>The encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> members 
            as well as the LAME_xxx settings.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderLAME.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>If you are encoding in CBR (<see cref="F:Un4seen.Bass.Misc.EncoderLAME.LAME_UseVBR"/> is set to FALSE, default) the <see cref="F:Un4seen.Bass.Misc.EncoderLAME.LAME_Bitrate"/> member will be returned.
            <para>If you are encoding in VBR or ABR (<see cref="F:Un4seen.Bass.Misc.EncoderLAME.LAME_UseVBR"/> is set to TRUE) the average of <see cref="F:Un4seen.Bass.Misc.EncoderLAME.LAME_Bitrate"/> and <see cref="F:Un4seen.Bass.Misc.EncoderLAME.LAME_VBRMaxBitrate"/> resp. <see cref="F:Un4seen.Bass.Misc.EncoderLAME.LAME_ABRBitrate"/> will be used.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderLAME.LAMEATH">
            <summary>
            LAME ATH control options.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEATH.Default">
            <summary>
            Default: standrad ATH control
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEATH.Only">
            <summary>
            --athonly: Ignore output of PSY model, only use masking from ATH (not recommended, use only for testing).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEATH.Disable">
            <summary>
            --noath: Disable ATH.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEATH.OnlyShortBlocks">
            <summary>
            --athshort: use ATH only for short blocks.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderLAME.LAMENOASM">
            <summary>
            --noasm: Assembly optimizations options.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMENOASM.Default">
            <summary>
            Default: mmx/3dnow/sse are enabled.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMENOASM.NO_MMX">
            <summary>
            MMX will be disabled.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMENOASM.NO_3DNOW">
            <summary>
            3dNOW will be disabled.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMENOASM.NO_SSE">
            <summary>
            SSE will be disabled.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderLAME.LAMEVBRQuality">
            <summary>
            -V: Quality setting for VBR (default is VBR_Q4).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEVBRQuality.VBR_Q0">
            <summary>
            -V 0: high quality, bigger files.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEVBRQuality.VBR_Q1">
            <summary>
            -V 1
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEVBRQuality.VBR_Q2">
            <summary>
            -V 2
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEVBRQuality.VBR_Q3">
            <summary>
            -V 3
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEVBRQuality.VBR_Q4">
            <summary>
            -V 4: default.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEVBRQuality.VBR_Q5">
            <summary>
            -V 4
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEVBRQuality.VBR_Q6">
            <summary>
            -V 5
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEVBRQuality.VBR_Q7">
            <summary>
            -V 6
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEVBRQuality.VBR_Q8">
            <summary>
            -V 7
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEVBRQuality.VBR_Q9">
            <summary>
            -V 9: poor quality, samler files.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderLAME.LAMEReplayGain">
            <summary>
            ReplayGain analysis.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEReplayGain.Default">
            <summary>
            Default, use no option.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEReplayGain.Fast">
            <summary>
            Compute RG fast but	 slightly inaccurately (default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEReplayGain.Accurate">
            <summary>
            Compute RG more accurately and find the peak sample.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEReplayGain.None">
            <summary>
            Disable ReplayGain analysis.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality">
            <summary>
            Encoding quality (default is Quality).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.Q0">
            <summary>
            -q 0: Highest quality, slow
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.Q1">
            <summary>
            -q 1
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.Q2">
            <summary>
            -q 2, same as -h
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.Q3">
            <summary>
            -q 3
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.Q4">
            <summary>
            -q 4
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.Q5">
            <summary>
            -q 5, default
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.Q6">
            <summary>
            -q 6
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.Q7">
            <summary>
            -q 7, same as -f
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.Q8">
            <summary>
            -q 8
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.Q9">
            <summary>
            -q 9: poor quality, fast
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.Speed">
            <summary>
            -f: Fast, equals -q 7
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEQuality.Quality">
            <summary>
            -h: Default quality, recommended, equals -q 2
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderLAME.LAMEMode">
            <summary>
            The general LAME encoding mode (stereo, joint stereo, mono etc.).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEMode.Default">
            <summary>
            Default is JointStereo or Stereo depending on bitrate.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEMode.Stereo">
            <summary>
            Stereo
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEMode.JointStereo">
            <summary>
            Force LR stereo on all frames
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEMode.ForcedJointStereo">
            <summary>
            Force MS stereo on all frames
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEMode.Mono">
            <summary>
            Mono
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderLAME.LAMEMode.DualMono">
            <summary>
            Dual Mono
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderWinampAACplus">
            <summary>
            Encoder class implementation for AACplus encoding using "enc_aacPlus.exe" (the command-line encoder using the following Winamp DLLs: "enc_aacplus.dll" and "nscrt.dll").
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_AAC"/> encoder type.
            <para>Please make sure to use the special "enc_aacPlus.exe" version (made by Bernd Niedergesäß) which can be downloaded here: <a href="http://www.un4seen.com/filez/4/enc_aacPlus.zip">enc_aacPlus.zip</a>.</para>
            <para>Since "enc_aacPlus.exe" also needs the mentioned Winamp DLLs ("enc_aacplus.dll" and "nscrt.dll") you also need to install Winamp and copy the Winamp DLLs from the Winamp/PlugIns folder into the same folder which contains enc_aacPlus.exe (or you might also copy enc_aacPlus.exe into the Winamp/PlugIns folder).</para>
            <para>Since the Winamp AACPlus library does only support 16-bit sample data as input, the BASS_ENCODE_FP_16BIT will always be used. Also note, that 8-bit sample data is also not supported!
            This will be used, whenever the underlying channel handle is float or the BASS_CONFIG_FLOATDSP option has been set.</para>
            <para>Make sure to set the AACPlus_xxx flags before retrieving the <see cref="P:Un4seen.Bass.Misc.EncoderWinampAACplus.EncoderCommandLine"/> or calling <see cref="M:Un4seen.Bass.Misc.EncoderWinampAACplus.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>This encoder does not support 8-bit channels!</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWinampAACplus.#ctor(System.Int32)">
            <summary>
            Creates an instance of a Winamp AACplus encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>This encoder implements AACplus v2 encoding (BASS_CTYPE_STREAM_AAC).
            <para>This encoder does not support 8-bit channels!</para>
            </remarks>
            <exception cref="T:System.ArgumentException">8-bit channels are not supported by the Winamp AACPlus encoder.</exception>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWinampAACplus.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Returns "Winamp AACPlus v2 Encoder (BASS_CTYPE_STREAM_AAC)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWinampAACplus.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual AACplus encoder. 
            </summary>
            <param name="proc">Optional callback function to receive the encoded data (only valid, if <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> is set to NULL)... NULL = no callback.
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.EncoderWinampAACplus.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally using the <see cref="P:Un4seen.Bass.Misc.EncoderWinampAACplus.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).
            <para>This implementation starts the encoder with the BASS_ENCODE_NOHEAD and BASSEncode.BASS_ENCODE_FP_16BIT flag.
            So floating-point channels are supported and automatically converted - but 8-bit channels are not supported!.</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWinampAACplus.AACPlus_Bitrate">
            <summary>
            --cbr:  Constant bitrate in kbps, default 48 kbps.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWinampAACplus.AACPlus_DisableParametricStereo">
            <summary>
            --nops: Disable Parametric Stereo (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWinampAACplus.AACPlus_PreferIndependedStereo">
            <summary>
            --is: Prefer Independed Stereo (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWinampAACplus.AACPlus_PreferDualChannels">
            <summary>
            --dc: Prefer Dual Channels (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWinampAACplus.AACPlus_Mpeg2Aac">
            <summary>
            --mpeg2aac: Produce MPEG2 AAC isntead of MPEG4 AAC (default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWinampAACplus.AACPlus_LC">
            <summary>
            --lc: Encode LC-AAC instead HE-AAC+ (supports bitrate up to 320000, default=FALSE).
            </summary>
            <remarks>LC-AAC requires encoding to a physical output file, so it will not be supported, if you output to STDOUT.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWinampAACplus.AACPlus_High">
            <summary>
            --high: use aacPlusHigh Encoder (supports bitrate up to 256000, multichannel not supported, default=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWinampAACplus.AACPlus_Mp4Box">
            <summary>
            --mp4box: Wrap result into MPEG4 container (MP4BOX.EXE must be into executable directory, default=FALSE).
            </summary>
            <remarks>If you are encoding to STDOUT this feature is not available.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWinampAACplus.EncoderExists">
            <summary>
            This property return TRUE, if the files "enc_aacPlus.exe" and "enc_aacplus.dll" exists in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/> - else FALSE is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWinampAACplus.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here BASS_CTYPE_STREAM_AAC is always returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWinampAACplus.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (".aac").
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWinampAACplus.SupportsSTDOUT">
            <summary>
            The special "enc_aacPlus.exe" implements STDOUT, so TRUE is always returned.
            </summary>
            <remarks>Please make sure to use the special "enc_aacPlus.exe" version (made by Bernd Niedergesäß).
            It can be downloaded from here: <a href="http://www.un4seen.com/filez/4/enc_aacPlus.zip">enc_aacPlus.zip</a></remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWinampAACplus.EncoderCommandLine">
            <summary>
            Gets the actual encoder command-line string (using all AACPlus_xxx properties).
            </summary>
            <remarks>The encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> members 
            as well as the AACPlus_xxx settings.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWinampAACplus.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>Since AACPlus does not support VBR, the effective bitrate is always given by the <see cref="F:Un4seen.Bass.Misc.EncoderWinampAACplus.AACPlus_Bitrate"/> member.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWinampAACplus.Force16Bit">
            <summary>
            Always returns true, since this encoder only supports receiving 16 bit sample data.
            </summary>
            <remarks>32-bit float channels are supported, since they are automatically converted to 16-bit integer sample data before sending them to the encoder.</remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderOGG">
            <summary>
            Encoder class implementation for OGG-Vorbis encoding using "oggenc2.exe".
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_OGG"/> encoder type.
            <para>"oggenc2.exe" must be downloaded separately (e.g. from <a href="http://www.rarewares.org/ogg.html">www.rarewares.org</a> or <a href="http://www.vorbis.com">www.vorbis.com</a>).</para>
            <para>Since "oggenc2.exe" does support 8/, 16/ and 32-bit(IEEE float) sample data as input, no BASS_ENCODE_FP_ flag will be used.</para>
            <para>Make sure to set the OGG_xxx flags before retrieving the <see cref="P:Un4seen.Bass.Misc.EncoderOGG.EncoderCommandLine"/> or calling <see cref="M:Un4seen.Bass.Misc.EncoderOGG.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>There are several versions of "oggenc.exe" or "oggenc2.exe" out there (some are highly optimized for SSE etc.). 
            This encoder implementation tries to support the latest version 2.x set of parameters. If you downloaded another OGG-Vorbis encoder version, just try it out and simply make sure that you rename the executable to "oggenc2.exe".</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderOGG.#ctor(System.Int32)">
            <summary>
            Creates an instance of a OGG encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements OGG encoding (BASS_CTYPE_STREAM_OGG).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderOGG.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Returns "OGG Encoder (BASS_CTYPE_STREAM_OGG)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderOGG.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual OGG encoder. 
            </summary>
            <param name="proc">Optional callback function to receive the encoded data (only valid, if <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> is set to NULL)... NULL = no callback.
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.EncoderOGG.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally using the <see cref="P:Un4seen.Bass.Misc.EncoderOGG.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).
            <para>This implementation starts the encoder with the BASS_ENCODE_NOHEAD flag.</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderOGG.Quality2Kbps(System.Single)">
            <summary>
            Converts a quality setting (between -2.0 and 10.0) to an approx. bitrate (in kbps).
            </summary>
            <param name="q">The OGG quality level to convert (between -2.0 and 10.0).</param>
            <returns>The rounded approximate bitrate in kbps.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderOGG.Kbps2Quality(System.Int32)">
            <summary>
            Converts a bitrate (between 32 kbps and 498 kbps) to an approx. quality level.
            </summary>
            <param name="kbps">The bitrate in kbps to convert (between 32 kbps and 498 kbps).</param>
            <returns>The OGG quality level (between -2.0 and 10.0) which approximates the bitrate.</returns>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseCustomOptionsOnly">
            <summary>
            Use the <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_CustomOptions"/> parameter string only (default=FALSE).
            </summary>
            <remarks>Caution: If set to TRUE no other OGG_xxx options will be evaluated and ONLY the <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_CustomOptions"/> parameter string will be used!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGG_CustomOptions">
            <summary>
            The custom parameter string, which should be used, if the <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseCustomOptionsOnly"/> property is set to TRUE.
            </summary>
            <remarks>This property string will be appended to all other OGG_xxx options, if the <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseCustomOptionsOnly"/> property is set to FALSE (default).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Downmix">
            <summary>
            --downmix: Downmix from stereo to mono? (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Scale">
            <summary>
            --scale: Scale input data to n (n = between 0.00 and 1.00, multiply PCM data). Set to 1.0 (default) for no scaling.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseQualityMode">
            <summary>
            Use Quality-Mode? (default is TRUE).
            </summary>
            <remarks>
            <para>When using the Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseQualityMode"/> is set to TRUE, default) you only specify a quality factor via <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Quality"/> and the bitrate parameters (<see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MinBitrate"/>, <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Bitrate"/> and <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MaxBitrate"/>) are ignored.</para>
            <para>When you turn off Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseQualityMode"/> is set to FALSE) the bitrate parameters are evaluated!</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Quality">
            <summary>
            -q: Specify quality between -2 (low) and 10 (high) (default=4), instead of specifying a particular bitrate (<see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Bitrate"/>).
            </summary>
            <remarks>This is the normal, default mode of operation. Fractional qualities (e.g. 2.75) are permitted.
            <para>If you enable the Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseQualityMode"/> is set to TRUE, default) only this value is being evaluated.</para>
            <para>If you disable the Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseQualityMode"/> is set to FALSE) this value is being ignored.</para>
            <para>Here is a list about approximate Quality to Bitrate mappings:
            <list type="table">
            <listheader><term>Quality:</term><description>Bitrate:</description></listheader>
            <item><term>-2</term><description>approx. 32 kbps</description></item>
            <item><term>-1</term><description>approx. 48 kbps</description></item>
            <item><term>0</term><description>approx. 64 kbps</description></item>
            <item><term>1</term><description>approx. 80 kbps</description></item>
            <item><term>2</term><description>approx. 96 kbps</description></item>
            <item><term>3</term><description>approx. 112 kbps</description></item>
            <item><term>4</term><description>approx. 128 kbps</description></item>
            <item><term>5</term><description>approx. 160 kbps</description></item>
            <item><term>6</term><description>approx. 192 kbps</description></item>
            <item><term>7</term><description>approx. 224 kbps</description></item>
            <item><term>8</term><description>approx. 256 kbps</description></item>
            <item><term>9</term><description>approx. 320 kbps</description></item>
            <item><term>10</term><description>approx. 498! kbps</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Bitrate">
            <summary>
            -b: Choose a nominal bitrate to encode at. Attempt to encode at a bitrate averaging this. Takes an argument in kbps.
            </summary>
            <remarks>By default, this produces a VBR encoding, equivalent to using -q or --quality.
            See the <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseManagedBitrate"/> option to use a managed bitrate targetting the selected bitrate.
            <para>Unless the <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseQualityMode"/> is set to FALSE this property is NOT evaluated.</para>
            <para>To use ABR (average bitrate): set <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MinBitrate"/> and <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MaxBitrate"/> to 0 (zero).</para>
            <para>To use CBR (constant bitrate): specify the exact same value also for <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MinBitrate"/> and <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MaxBitrate"/>.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseManagedBitrate">
            <summary>
            --managed: Enable the bitrate management engine. This will allow much greater control over the precise bitrate(s) used, but encoding will be much slower.
            Don't use it unless you have a strong need for detailed control over bitrate, such as for streaming.
            </summary>
            <remarks>This property is not evaluated unless you set <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseQualityMode"/> to FALSE.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MinBitrate">
            <summary>
             -m: Specify a minimum bitrate (in kbps). Useful for encoding for a fixed-size channel. If set to 0 (zero, default) this property is not evaluated!
            </summary>
            <remarks>Unless the <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseQualityMode"/> is set to FALSE this property is NOT evaluated.
            <para>To use ABR (average bitrate): set <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MinBitrate"/> and <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MaxBitrate"/> to 0 (zero) and only specify a value for <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Bitrate"/>.</para>
            <para>To use CBR (constant bitrate): specify the exact same value as you set for <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Bitrate"/> also for <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MinBitrate"/> and <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MaxBitrate"/>.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MaxBitrate">
            <summary>
            -M:  Specify a maximum bitrate in kbps. Useful for streaming applications.  If set to 0 (zero, default) this property is not evaluated!
            </summary>
            <remarks>Unless the <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseQualityMode"/> is set to FALSE this property is NOT evaluated.
            <para>To use ABR (average bitrate): set <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MinBitrate"/> and <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MaxBitrate"/> to 0 (zero) and only specify a value for <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Bitrate"/>.</para>
            <para>To use CBR (constant bitrate): specify the exact same value as you set for <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Bitrate"/> also for <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MinBitrate"/> and <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MaxBitrate"/>.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGG_TargetSampleRate">
            <summary>
            --resample: target sampling frequency of output (in Hz). Set to 0 (zero) if you don't want to do any resampling (default).
            </summary>
            <remarks>Specify the target sample rate in Hz, e.g. 22050 for 22.05kHz.
            <para>You might use one of the <see cref="T:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE"/> constants here.</para>
            <para>Use the <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Converter"/> property to control which resampliung engine should be used.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Converter">
            <summary>
            -S: Specify the resampling engine to be used. Options are: Best, Medium (default) and Fast.
            </summary>
            <remarks>Will only be used, if you have specified a <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_TargetSampleRate"/> which is not 0 (zero).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderOGG.EncoderExists">
            <summary>
            This property return TRUE, if the file "oggenc2.exe" exists in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/> - else FALSE is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderOGG.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here BASS_CTYPE_STREAM_OGG is always returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderOGG.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (".ogg").
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderOGG.SupportsSTDOUT">
            <summary>
            "oggenc2.exe" implements STDOUT, so TRUE is always returned.
            </summary>
            <remarks>"oggenc2.exe" support boradcast streaming.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderOGG.EncoderCommandLine">
            <summary>
            Gets the actual encoder command-line string (using all OGG_xxx properties).
            </summary>
            <remarks>The encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> members 
            as well as the OGG_xxx settings.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderOGG.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>
            <para>When using the Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseQualityMode"/> is set to TRUE, default) you only need to specify a quality factor via <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Quality"/> and the bitrate parameters (<see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MinBitrate"/>, <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Bitrate"/> and <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MaxBitrate"/>) are ignored. 
            In this case the effective bitrate will be calculated automatically according to the OGG-Vorbis specification.</para>
            <para>When you turn off Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseQualityMode"/> is set to FALSE) the bitrate parameters are evaluated!
            However, no matter if you are encoding in CBR (<see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseManagedBitrate"/> is set to TRUE) or VBR/ABR (<see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_UseManagedBitrate"/> is set to FALSE, default) the properties <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MinBitrate"/> and <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_MaxBitrate"/> will not be used - instead only the <see cref="F:Un4seen.Bass.Misc.EncoderOGG.OGG_Bitrate"/> value will be used to return the effective bitrate value.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderOGG.OGGConverter">
            <summary>
            The OGG resampling engine mode (Best, Medium. Fast).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGGConverter.Best">
            <summary>
            Best resampling quality.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGGConverter.Medium">
            <summary>
            Medium resampling quality (default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderOGG.OGGConverter.Fast">
            <summary>
            Fast resampling, low quality.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderNeroAAC">
            <summary>
            Encoder class implementation for the Nero Digital Aac encoder using "neroAacEnc.exe".
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_AAC"/> encoder type.
            <para>The NeroAac Encoder must be downloaded separately (e.g. from <a href="http://www.nero.com/Nero_Digital.html">www.nero.com</a>).</para>
            <para>Since "neroAacEnc.exe" does support 8-, 16-, and 32-bit(IEEE float) sample data as input, no BASS_ENCODE_FP_ flag will be used.</para>
            <para>Make sure to set the NERO_xxx flags before retrieving the <see cref="P:Un4seen.Bass.Misc.EncoderNeroAAC.EncoderCommandLine"/> or calling <see cref="M:Un4seen.Bass.Misc.EncoderNeroAAC.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>There are two versions: "neroEncAac.exe" and "neroAacEnc_sse2.exe" out there (one is highly optimized for SSE etc.). 
            This encoder implementation supports both versions see the <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseSSE"/> property for details.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderNeroAAC.#ctor(System.Int32)">
            <summary>
            Creates an instance of a Nero Digital Aac encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements AAC encoding (BASS_CTYPE_STREAM_AAC).
            <pata>This encoder can NOT be used for streaming, since it does not support STDOUT!</pata>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderNeroAAC.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Returns "Nero Digital Aac Encoder (BASS_CTYPE_STREAM_AAC)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderNeroAAC.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual Nero Digial Aac encoder. 
            </summary>
            <param name="proc">Must be always NULL = no callback - since this encoder does NOT support STDOUT.</param>
            <param name="user">N/A - ignorred.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally using the <see cref="P:Un4seen.Bass.Misc.EncoderNeroAAC.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).
            <para>This implementation starts the encoder with no flags, meaning a Wave header will be send to the encoder to specify the bitrate, number of channels and samplerate.</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseSSE">
            <summary>
            Specifies, if the "neroAacEnc.exe" (FALSE, default) or the "neroAacEnc_sse2.exe" (TRUE) command-line tool should be used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseCustomOptionsOnly">
            <summary>
            Use the <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_CustomOptions"/> parameter string only (default=FALSE).
            </summary>
            <remarks>Caution: If set to TRUE no other NERO_xxx options will be evaluated and ONLY the <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_CustomOptions"/> parameter string will be used!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_CustomOptions">
            <summary>
            The custom parameter string, which should be used, if the <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseCustomOptionsOnly"/> property is set to TRUE.
            </summary>
            <remarks>This property string will be appended to all other NERO_xxx options, if the <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseCustomOptionsOnly"/> property is set to FALSE (default).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseQualityMode">
            <summary>
            Use Quality-Mode? (default is FALSE).
            </summary>
            <remarks>
            <para>When using the Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseQualityMode"/> is set to TRUE) you only specify a quality factor via <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_Quality"/> and the bitrate parameter (<see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_Bitrate"/>) is ignored.</para>
            <para>When you turn off Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseQualityMode"/> is set to FALSE, default) the bitrate parameter is evaluated and the <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_Quality"/> parameter is ignored!</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_Quality">
            <summary>
            -q: Specify quality between 0.00 (low) and 1.00 (high) (default=0.4), instead of specifying a particular bitrate (<see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_Bitrate"/>).
            </summary>
            <remarks>This is an alternative mode of operation. Fractional qualities (e.g. 0.75) are permitted.
            <para>If you enable the Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseQualityMode"/> is set to TRUE) only this value is being evaluated.</para>
            <para>If you disable the Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseQualityMode"/> is set to FALSE, default) this value is being ignored.</para>
            <para>Here is a list about approximate Quality to Bitrate mappings:
            <list type="table">
            <listheader><term>Quality:</term><description>Bitrate:</description></listheader>
            <item><term>0.0</term><description>approx. 13 kbps</description></item>
            <item><term>0.1</term><description>approx. 25 kbps</description></item>
            <item><term>0.2</term><description>approx. 52 kbps</description></item>
            <item><term>0.3</term><description>approx. 83 kbps</description></item>
            <item><term>0.4</term><description>approx. 130 kbps</description></item>
            <item><term>0.5</term><description>approx. 180 kbps</description></item>
            <item><term>0.6</term><description>approx. 227 kbps</description></item>
            <item><term>0.7</term><description>approx. 269 kbps</description></item>
            <item><term>0.8</term><description>approx. 316 kbps</description></item>
            <item><term>0.9</term><description>approx. 362 kbps</description></item>
            <item><term>1.0</term><description>approx. 408! kbps</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_Bitrate">
            <summary>
            -br: Choose a nominal bitrate to encode at. Attempt to encode at a bitrate averaging this. Takes an argument in kbps.
            </summary>
            <remarks>By default, this produces a VBR encoding.
            See the <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseCBR"/> option to use a managed bitrate targetting a constant bitrate.
            <para>Unless the <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseQualityMode"/> is set to FALSE this property is NOT evaluated.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseCBR">
            <summary>
            -cbr: Enables the constant bitrate mode (default is FALSE). When enabled CBR is generated, else VBR is generated.
            </summary>
            <remarks>This property is not evaluated unless you set <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseQualityMode"/> to FALSE.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_2Pass">
            <summary>
            -2pass: Enables two-pass encoding mode. Note that two-pass mode requires a physical file as input, rather than STDIN.
            </summary>
            <remarks>This property is only evaluated, if an <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> is being used.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_2PassPeriod">
            <summary>
            -2passperiod: Overrides two-pass encoding bitrate averaging period, in milliseconds. Specify 0 (zero) to use least restrictive value possible (default).
            </summary>
            <remarks>This property is only evaluated, if <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_2Pass"/> is set to TRUE.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_LC">
            <summary>
            -lc: Forces use of LC AAC profile, HE features disabled (default is FALSE).
            </summary>
            <remarks>Note that the switches (-lc, -he, -hev2) should not be used.
            Optimal AAC profile is automatically determined from quality/bitrate settings when no override is specified.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_HE">
            <summary>
            -he: Forces use of HE AAC profile, HEv2 features disabled (default is FALSE).
            </summary>
            <remarks>Note that the switches (-lc, -he, -hev2) should not be used.
            Optimal AAC profile is automatically determined from quality/bitrate settings when no override is specified.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_HEv2">
            <summary>
            -hev2: Forces use of HEv2 AAC profile (default is FALSE).
            </summary>
            <remarks>Note that the switches (-lc, -he, -hev2) should not be used.
            Optimal AAC profile is automatically determined from quality/bitrate settings when no override is specified.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_HintTrack">
            <summary>
            -hinttrack: Generates an RTP hint track in output MP4 file (default is FALSE).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderNeroAAC.EncoderExists">
            <summary>
            This property return TRUE, if the file "neroAacEnc.exe" or "neroAacEnc_sse2.exe" (depending on your <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseSSE"/> setting) exists in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/> - else FALSE is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderNeroAAC.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here BASS_CTYPE_STREAM_AAC is always returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderNeroAAC.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (".m4a").
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderNeroAAC.SupportsSTDOUT">
            <summary>
            Nero Digital Aac does NOT implement STDOUT, so FASLE is always returned.
            </summary>
            <remarks>This encoder can NOT be used for streaming, since it does not support STDOUT!</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderNeroAAC.EncoderCommandLine">
            <summary>
            Gets the actual encoder command-line string (using all NERO_xxx properties).
            </summary>
            <remarks>The encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> members 
            as well as the NERO_xxx settings.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderNeroAAC.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>
            <para>No matter if you are encoding in CBR (see <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_UseCBR"/>) or VBR (default) the properties <see cref="F:Un4seen.Bass.Misc.EncoderNeroAAC.NERO_Bitrate"/> value will be used to return the effective bitrate value.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderACM">
            <summary>
            Encoder class implementation for the Windows Audio Compression Manager using <see cref="N:Un4seen.Bass.AddOn.Enc"/>.
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WAV"/> encoder type (even if other types might be more propper).
            <para>Since Windows ACM does support 8-, 16-, and 32-bit(IEEE float) sample data as input, no BASS_ENCODE_FP_ flag will be used.</para>
            <para>Make sure to set the ACM_xxx flags before calling <see cref="M:Un4seen.Bass.Misc.EncoderACM.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderACM.#ctor(System.Int32)">
            <summary>
            Creates an instance of a Windows ACM implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements ACM encoding.
            <pata>This encoder might be used for streaming, since it does support STDOUT, however make sure to select an ACM codec matching your <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>!</pata>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderACM.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>E.g. returns "Audio Compression Manager (BASS_CTYPE_STREAM_WAV)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderACM.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual ACM encoder. 
            </summary>
            <param name="proc">Optional callback function to receive the encoded data (only valid, if <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> is set to NULL)... NULL = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACM(System.Int32,Un4seen.Bass.AddOn.Enc.ACMFORMAT,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally using the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/>.
            <para>If you have specified a file name for <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> (instead of NULL), a default stream using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> will be created internally and all it's data will immediately be encoded (meaning the <paramref name="paused"/> flag will have no effect).</para>
            <para>After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderACM.ACM_Codec">
            <summary>
            Gets or Sets the ACM codec to be used.
            </summary>
            <remarks>By default a standard WAVE_FORMAT_PCM (16-bit, stereo, 44.1kHz) ACM codec is selected.
            <para>You might modify the <see cref="F:Un4seen.Bass.AddOn.Enc.ACMFORMAT.waveformatex"/> members in order to change a default WAVE_FORMAT_PCM codec (e.g. change the samplerate or bitwidth).</para>
            <para>In order to load an already defined ACM codec format, make use of the <see cref="M:Un4seen.Bass.AddOn.Enc.ACMFORMAT.LoadFromFile(System.String)"/> method. 
            For more details see the ACM documentation: <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> and <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/>.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderACM.ACM_WriteWaveHeader">
            <summary>
            If set, a WAVE header and the ACM codec content will be written to the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> (default is TRUE).
            </summary>
            <remarks>This is generally required for the file to be playable, but in some cases (a Non-Wave ACM codec was selected, e.g. MP3) this is not wanted.
            So set this property to FALSE for all Non-Wave ACM codecs.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderACM.ACM_EncoderType">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.BASSChannelType"/> which will be supported by the encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderACM.ACM_DefaultOutputExtension">
            <summary>
            Gets or Sets the default output extension to be used by the encoder (e.g. ".wav").
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderACM.EncoderExists">
            <summary>
            This property always return TRUE, since ACM should be installed on every Windows platform.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderACM.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here the <see cref="F:Un4seen.Bass.Misc.EncoderACM.ACM_EncoderType"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderACM.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (e.g. ".wav"). Here the <see cref="F:Un4seen.Bass.Misc.EncoderACM.ACM_DefaultOutputExtension"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderACM.SupportsSTDOUT">
            <summary>
            ACM does implement STDOUT, so TRUE is always returned.
            </summary>
            <remarks>This encoder might be used for streaming, since it does support STDOUT. 
            However, the selected ACM codec must match the <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> implementation!</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderACM.EncoderCommandLine">
            <summary>
            Returns an empty string, since ACM does not use any command-line tool, but instead directly used <see cref="N:Un4seen.Bass.AddOn.Enc"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderACM.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>This implementation evaluates the <see cref="F:Un4seen.Bass.AddOn.Enc.ACMFORMAT.waveformatex"/> structure (nAvgBytesPerSec) in order to calculate the effective bitrate.</remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderWAV">
            <summary>
            Encoder class implementation for the RIFF WAVE format using raw PCM sample data with no real encoder.
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WAV"/> encoder type.
            <para>This format supports 8-, 16- and 32-bit(IEEE float) sample data as input.</para>
            <para>Make sure to set the WAV_xxx flags before calling <see cref="M:Un4seen.Bass.Misc.EncoderWAV.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
            <example>
            Manual encoding "File" To "File" in 32-bit:
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            EncoderWAV w = new EncoderWAV(stream);
            w.InputFile = null;
            w.OutputFile = "test.wav";  // will be a 32-bit IEEE float WAVE file, since the stream is float
            w.Start(null, IntPtr.Zero, false);
            // do the encoding
            Utils.DecodeAllData(stream, true);
            w.Stop();
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            Dim w As New EncoderWAV(stream)
            w.InputFile = Nothing
            w.OutputFile = "test.wav" ' will be a 32-bit IEEE float WAVE file, since the stream is float
            w.Start(Nothing, IntPtr.Zero, False)
            ' do the encoding
            Utils.DecodeAllData(stream, True)
            w.Stop()
            </code>
            Manual encoding "File" To "File" in 24-bit:
            <code>
            EncoderWAV w = new EncoderWAV(0);
            w.InputFile = "testIn.wav";
            w.OutputFile = "testOut.wav";
            w.WAV_BitsPerSample = 24;
            w.Start(null, IntPtr.Zero, false);
            w.Stop();
            </code>
            <code lang="vbnet">
            Dim w As New EncoderWAV(0)
            w.InputFile = "testIn.wav"
            w.OutputFile = "testOut.wav"
            w.WAV_BitsPerSample = 24
            w.Start(Nothing, IntPtr.Zero, False)
            w.Stop()
            </code>
            "Recording" To "File" in 16-bit:
            <code>
            private RECORDPROC _recProc;
            
            // init your recording device (we use the default device)
            if ( !Bass.BASS_RecordInit(-1) )
              MessageBox.Show(this, "Bass_RecordInit error!" );
            _recProc = new RECORDPROC(RecordingHandler);
            // start recording at 44.1kHz, stereo (paused)
            int recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _recProc, IntPtr.Zero);
            if (recHandle == Bass.FALSE)
              MessageBox.Show(this, "BASS_RecordStart error!" );
            
            // setup the encoder
            EncoderWAV w = new EncoderWAV(recHandle);
            w.InputFile = null;
            w.OutputFile = "testrec.wav";
            w.Start(null, IntPtr.Zero, true); // start encoder paused
            ...
            // now really start recording and encoding
            w.Pause(false);
            Bass.BASS_ChannelPlay(recHandle, false);
            ...
            // your recording will be encoded until you call
            w.Stop();
            
            private bool RecordingHandler(int handle, IntPtr buffer, int length, IntPtr user)
            {
              return true;
            }
            </code>
            <code lang="vbnet">
            private RECORDPROC _recProc;
            
            ' init your recording device (we use the default device)
            If Not Bass.BASS_RecordInit(- 1) Then
              MessageBox.Show(Me, "Bass_RecordInit error!")
            End If
            _recProc = New RECORDPROC(AddressOf RecordingHandler)
            ' start recording at 44.1kHz, stereo (paused)
            Dim recHandle As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _recProc, IntPtr.Zero)
            If recHandle = Bass.FALSE Then
              MessageBox.Show(Me, "BASS_RecordStart error!")
            End If 
            
            ' setup the encoder
            Dim w As New EncoderWAV(recHandle)
            w.InputFile = Nothing
            w.OutputFile = "testrec.wav"
            w.Start(Nothing, IntPtr.Zero, True) ' start encoder paused
            ...
            ' now really start recording and encoding
            w.Pause(False)
            Bass.BASS_ChannelPlay(recHandle, False)
            ...
            ' your recording will be encoded until you call
            w.Stop()
            
            Private Function RecordingHandler(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              Return True
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWAV.#ctor(System.Int32)">
            <summary>
            Creates an instance of a RIFF WAVE implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements RIFF WAVE encoding.
            <pata>This encoder might be used for streaming, since it does support STDOUT.</pata>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWAV.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>E.g. returns "RIFF WAVE (BASS_CTYPE_STREAM_WAV)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWAV.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual WAV encoder. 
            </summary>
            <param name="proc">Must be NULL = no callback, since EncoderWAV does not support STDOUT.</param>
            <param name="user">Must be IntPtr.Zero, since EncoderWAV does not support STDOUT.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method uses the BASS_ENCODE_PCM flag to write plain PCM sample data to a file (if an <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> has been specified), without an encoder.
            If no <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> has been specified (NULL) - nothing will actually happen.
            <para>If you have specified a file name for <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> (instead of NULL), a default stream using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> will be created internally and all it's data will immediately be encoded (meaning the <paramref name="paused"/> flag will have no effect),
            else the data from the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/> will be encoded.</para>
            <para>After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWAV.WAV_EncoderType">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.BASSChannelType"/> which will be supported by the encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWAV.WAV_DefaultOutputExtension">
            <summary>
            Gets or Sets the default output extension to be used by the encoder (e.g. ".wav").
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here the <see cref="F:Un4seen.Bass.Misc.EncoderWAV.WAV_EncoderType"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (e.g. ".wav"). Here the <see cref="F:Un4seen.Bass.Misc.EncoderWAV.WAV_DefaultOutputExtension"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.SupportsSTDOUT">
            <summary>
            WAV does not implement STDOUT, so FALSE is always returned.
            </summary>
            <remarks>This encoder might not be used for streaming, since it does not support STDOUT.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.EncoderCommandLine">
            <summary>
            Returns the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/>, since WAV does not use any command-line tool.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>This implementation evaluates the original <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelSampleRate"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelBitwidth"/> and the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelNumChans"/> in order to calculate the effective bitrate.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.Force16Bit">
            <summary>
            Always returns false, since this encoder doesn't supports this flag. The target format can be set via the <see cref="P:Un4seen.Bass.Misc.EncoderWAV.WAV_BitsPerSample"/> property.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.WAV_BitsPerSample">
            <summary>
            Gets or Sets the target resolution (number of bits per sample) of the Wave file to create -
            (by default the original resolution will be used).
            </summary>
            <remarks>This property is only evaluated, if an <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> has been specified or the BASS_CONFIG_FLOATDSP option is set!
            NOTE: In all other cases the original resolution will be used!
            <para>This property should be either 8, 16, 24 or 32.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.WAV_Use32BitInteger">
            <summary>
            Gets or Sets, if 32bit integer (instead of 32bit IEEE float) should be used when setting <see cref="P:Un4seen.Bass.Misc.EncoderWAV.WAV_BitsPerSample"/> to 32 (default is FALSE)?
            </summary>
            <remarks>When seeting this property to TRUE and setting the <see cref="P:Un4seen.Bass.Misc.EncoderWAV.WAV_BitsPerSample"/> property to 32, the 32bit integer wave format is used - 
            else the 32bit IEEE float is used as the default 32bit format.
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderCMDLN">
            <summary>
            Encoder class implementation for any generic Command-Line encoder tool using <see cref="N:Un4seen.Bass.AddOn.Enc"/>.
            </summary>
            <remarks>This class uses by default the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WAV"/> encoder type (even if other types might be more propper) - so make sure to set the <see cref="P:Un4seen.Bass.Misc.EncoderCMDLN.EncoderType"/> property accordingly.
            Also the <see cref="P:Un4seen.Bass.Misc.EncoderCMDLN.DefaultOutputExtension"/> is by default set to ".wav" and needs to be changed if needed.
            <para>Since this is a generic implementation this encoder will always try to use either 32-bit float, 16-bit or 8-bit sample data (depending on the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.Force16Bit"/> property) - meaning the BASS_ENCODE_FP_16BIT might be used, but the BASSEncode.BASS_ENCODE_NOHEAD flags will always be used. 
            So make sure that the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_String"/> which will be used to start the encoder is configured accordingly: the encoder will receive headerless, raw PCM sample data in little endian.</para>
            <para>Make sure to set the CMDLN_xxx flags before calling <see cref="M:Un4seen.Bass.Misc.EncoderCMDLN.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderCMDLN.#ctor(System.Int32)">
            <summary>
            Creates an instance of the generic command-line encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements generic command-line encoding.
            <pata>This encoder might be used for streaming only if the <see cref="P:Un4seen.Bass.Misc.EncoderCMDLN.SupportsSTDOUT"/> property is set to true and it does support STDOUT - however make sure to select a command-line tool matching your <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>!</pata>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderCMDLN.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Eg.: returns "Generic Command-Line Encoder (BASS_CTYPE_STREAM_WAV)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderCMDLN.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual command-line encoder. 
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            </summary>
            <param name="proc">Optional callback function to receive the encoded data (only valid, if <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> is set to NULL)... NULL = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally using the BASS_ENCODE_FP_16BIT and the BASS_ENCODE_NOHEAD flag!
            <para>After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_String">
            <summary>
            Gets or Sets the command-line string to be used with the encoder (also containing the executable to be used, e.g. "encoder.exe -b 128 - output.xyz").
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_EncoderType">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.BASSChannelType"/> which will be supported by the encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_DefaultOutputExtension">
            <summary>
            Gets or Sets the default output extension to be used by the encoder (e.g. ".mp3").
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_SupportsSTDOUT">
            <summary>
            Gets or Sets if the encoder supports output of the encoded data to STDOUT.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_Bitrate">
            <summary>
            Gets or Sets the effective bitrate (in kbps) used with the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_String"/> (only needed when this encoder will be used for a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderCMDLN.EncoderExists">
            <summary>
            This property return TRUE, if the specifiec command-line tool is availabel - else FALSE.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderCMDLN.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_EncoderType"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderCMDLN.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (e.g. ".wav"). Here the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_DefaultOutputExtension"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderCMDLN.SupportsSTDOUT">
            <summary>
            A command-line encoder might implement STDOUT, so here the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_SupportsSTDOUT"/> value is returned.
            </summary>
            <remarks>This encoder might be used for streaming, since it might support STDOUT. 
            However, the selected command-line encoder must match the <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> implementation!</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderCMDLN.EncoderCommandLine">
            <summary>
            Returns the specified command-line string to use. Here the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_String"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderCMDLN.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output. Here the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_Bitrate"/> value is returned.
            </summary>
            <remarks>The effective bitrate value is only needed, if the encoder is used for a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>. This member otherwise will never be really used.</remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderWMA">
            <summary>
            Encoder class implementation for the Windows Media Audio codec using <see cref="N:Un4seen.Bass.AddOn.Wma"/>.
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WMA"/> encoder type.
            <para>Since WMA does support 8-, 16-, and 32-bit(IEEE float) sample data as input, no BASS_ENCODE_FP_ flag will be used.</para>
            <para>Make sure to set the WMA_xxx flags before calling <see cref="M:Un4seen.Bass.Misc.EncoderWMA.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>As with all encoders in this framework also this WMA encoder always automatically encodes sample data (by using a DSP callback). So there is no need to manually send any sample data to the encoder.</para>
            <para>The <see cref="P:Un4seen.Bass.Misc.EncoderWMA.WMA_Notify"/> property can be used to setup a <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC"/> to receive notifications about the encoder status (e.g. when the encoder died).</para>
            <para>IMPORTANT NOTE: This implementation uses BASSwma. So make sure the BASSwma add-on and dll is available.</para>
            </remarks>
            <example>
            Manual encoding of a stream (here in lossless format):
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.wav", 0, 0, BASSFlag.BASS_STREAM_DECODE);
            EncoderWMA wma = new EncoderWMA(stream);
            wma.WMA_UseVBR = true;
            wma.WMA_VBRQuality = 100; // lossless
            wma.InputFile = null;	  //STDIN
            wma.OutputFile = "test.wma";
            wma.Start(null, IntPtr.Zero, false);
            // encode all the data right away
            Utils.DecodeAllData(stream, true);
            wma.Stop();
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.wav", 0, 0, BASSFlag.BASS_STREAM_DECODE)
            Dim wma As New EncoderWMA(stream)
            wma.WMA_UseVBR = True
            wma.WMA_VBRQuality = 100 ' lossless
            wma.InputFile = Nothing 'STDIN
            wma.OutputFile = "test.wma"
            wma.Start(Nothing, IntPtr.Zero, False)
            ' encode all the data right away
            Utils.DecodeAllData(stream, True)
            wma.Stop()
            </code>
            Automatic encoding to the local network (using a recording handle):
            <code>
            EncoderWMA wma = new EncoderWMA(_recHandle);
            wma.WMA_UseVBR = false;
            wma.WMA_Bitrate = 64;
            wma.WMA_UsePro = true;
            wma.WMA_UseNetwork = true;
            wma.WMA_NetworkPort = 80;
            wma.WMA_NetworkClients = 10;
            wma.InputFile = null;  //STDIN
            wma.OutputFile = null; //STDOUT
            wma.Start(null, IntPtr.Zero, false);
            ...
            // encodes until this is called
            wma.Stop();
            </code>
            <code lang="vbnet">
            Dim wma As New EncoderWMA(_recHandle)
            wma.WMA_UseVBR = False
            wma.WMA_Bitrate = 64
            wma.WMA_UsePro = True
            wma.WMA_UseNetwork = True
            wma.WMA_NetworkPort = 80
            wma.WMA_NetworkClients = 10
            wma.InputFile = Nothing 'STDIN
            wma.OutputFile = Nothing 'STDOUT
            wma.Start(Nothing, IntPtr.Zero, False)
            ...
            ' encodes until this is called
            wma.Stop()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWMA.#ctor(System.Int32)">
            <summary>
            Creates an instance of a Windows Media Audio encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements WMA encoding.
            <pata>This encoder might be used for streaming, since it does support STDOUT, however make sure to select an WMA codec matching your <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> implementation!</pata>
            <para>Please note, that there is also a special <see cref="T:Un4seen.Bass.Misc.WMAcast"/> implementation.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWMA.Stop">
            <summary>
            Stops the encoder (if started).
            </summary>
            <returns>Returns TRUE, if the encoder was successfully stopped - else FALSE is returned.</returns>
            <remarks>Internally <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeClose(System.Int32)"/> is called using the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>.
            After the encoder was stopped successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> is set to 0 (zero). 
            If the encoder was not stopped the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> is left unchanged.
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.EncoderWMA.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWMA.Pause(System.Boolean)">
            <summary>
            Pauses or resumes an encoder
            </summary>
            <param name="paused">TRUE = pause the encoder, FALSE = resume the encoder.</param>
            <returns>Will always return TRUE.</returns>
            <remarks>Since WMA does not natively support pausing/resuming of the encoder, this special implementation will suppress writing data to the encoder while the encoder is paused.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWMA.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Returns "Audio Compression Manager (BASS_CTYPE_STREAM_WAV)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWMA.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual WMA encoder. 
            </summary>
            <param name="proc">Optional callback function to receive the encoded data... NULL = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.EncoderWMA.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpen(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,Un4seen.Bass.AddOn.Wma.WMENCODEPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenFile(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.String)"/>, <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenNetwork(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenPublish(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.String,System.String,System.String)"/> (resp. <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenNetworkMulti(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32[],System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenPublishMulti(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32[],System.String,System.String,System.String)"/> if the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_MultiBitrate"/> was set) internally depending on the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseNetwork"/> and <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> properties.
            <para>If you have specified a file name for <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> (instead of NULL), a default stream using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> will be created internally and all it's data will immediately be encoded (meaning the <paramref name="paused"/> flag will have no effect).</para>
            <para>After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).</para>
            <para>The <paramref name="proc"/> is only used, if you have set the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseNetwork"/> property to FALSE and are encoding to STDOUT (<see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> must be NULL).
            If in such case the <paramref name="proc"/> is invoked you need to be aware of one special WMA case:
            When encoding begins, an initial header is given. When encoding is completed, an updated header is given (the initial header should be replaced by the updated one).
            The WMA header can be recognized by a negative 'length' parameter, whereas positive 'length' values will indicate plain WMA encoded data.
            </para>
            <para>Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel. 
            That means when you play the channel (or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> if it's a decoding channel), the sample data will be sent to the encoder at the same time.
            So in contrast to the standard <see cref="T:Un4seen.Bass.AddOn.Wma.BassWma">BASSwma</see> implementation there is no need to manually feed (write) any sample data to the encoder.</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.
            You might use the <see cref="P:Un4seen.Bass.Misc.EncoderWMA.WMA_Notify"/> property to get informed when this happens.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWMA.SetTag(System.String,System.String)">
            <summary>
            Sets a tag in a WMA encoding.
            </summary>
            <param name="tag">The tag to set.
            <para>The standard WMA header tags are as follows:</para>
            <list type="table">
            <item><term>Title</term><description>Content title.</description></item>
            <item><term>Author</term><description>Name of the content author (Artist).</description></item>
            <item><term>Description</term><description>Description of the content.</description></item>
            <item><term>Rating</term><description>Content rating.</description></item>
            <item><term>Copyright</term><description>Content copyright message.</description></item>
            <item><term>WM/AlbumTitle</term><description>Album title.</description></item>
            <item><term>WM/PromotionURL</term><description>URL to an HTML page containing related information.</description></item>
            <item><term>WM/AlbumCoverURL</term><description>URL to an HTML page containing an image of the album cover.</description></item>
            <item><term>WM/Genre</term><description>Genre of the music.</description></item>
            <item><term>WM/Year</term><description>Year of publication of the music.</description></item>
            </list>
            </param>
            <param name="value">The tag's text/data.</param>
            <returns>TRUE on success, else FALSE.</returns>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_Bitrate">
            <summary>
            Choose a total bitrate to encode at. Takes an argument in kbps (default is 128 kbps).
            </summary>
            <remarks>By default, this produces a CBR encoding.
            <para>To use VBR (variable bitrate): set <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseVBR"/> to TRUE and specify a <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_VBRQuality"/>.</para>
            <para>To use CBR (constant bitrate): set <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseVBR"/> to FALSE (default).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_Use24Bit">
            <summary>
            Use 24-bit encoding? (Default is FALSE).
            </summary>
            <remarks>If set to TRUE, the output will be in 24-bit resolution.
            <para>The WMA codec expects 16-bit or 24-bit sample data, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format. 
            Of course, it makes little sense to encode 8-bit or 16-bit data in 24-bit.</para>
            <para>When this parameter is set to TRUE the WMA 10 Professional codec will be used automatically (regardless of the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePro"/> setting).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePro">
            <summary>
            Use the WMA 10 Professional format? (Default is FALSE = WMA 9 format).
            </summary>
            <remarks>Windows Media Audio 10 Professional (WMA 10 Pro) is the most flexible Windows Media audio codec available – supporting profiles that include everything from full-resolution 24-bit/96 kHz audio in stereo, 5.1 channel, or even 7.1 channel surround sound, to highly efficient mobile capabilities at 24 Kbps to 96 Kbps for stereo, and 128 Kbps to 256 Kbps for 5.1-channel sound. WMA 10 Pro offers incredible quality for consumers using high-fidelity hardware and 5.1 channel surround sound-equipped computers -– and for consumers playing audio content on their mobile devices. WMA 10 Pro supports streaming, progressive download, or download-and-play delivery at 128 to 768 Kbps.
            <para>WMA Pro also offers dynamic range control using the maximum and average audio amplitudes that are calculated during the encoding process. Using the Quiet Mode feature in Windows Media Player 9 and later, users can hear either the full dynamic range, a medium difference range up to 12 decibels (dB) above the average, or a little difference range up to 6 dB above the average.</para>
            <para>If a user tries to play back a file that was encoded using the 5.1 channel, 24-bit, 96 kHz sampling capabilities, but does not have a system or sound card that supports multi-channel or high-resolution sound, multiple channels are combined into stereo audio (for example, 16-bit, two channel audio), ensuring that users get the best playback experience their systems can provide.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_ForceStandard">
            <summary>
            When set to TRUE, the WMA standard codec (WMA 9) will be forced to use (default is FALSE).
            </summary>
            <remarks>If neither this or the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePro"/> flag is specified, then either codec (WMA 9 or WMA 10 Pro) could be used (whichever supports the requested sample format and bitrate).
            <para>If the flag is set to TRUE, the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_Use24Bit"/> and <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePro"/> options will not be evaluated!</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseVBR">
            <summary>
            Enable the VBR (variable bitrate) mode (default is FALSE).
            </summary>
            <remarks>If not set to TRUE the CBR (constant bitrate) mode will be used.
            <para>When making a VBR stream, the bitrate is only allowed to vary within set limits:
            <list type="table">
            <listheader><term>Samplerate:</term><description>Bitrate:</description></listheader>
            <item><term>48kHz</term><description>Stereo: 112-384kbps  Mono: 56-192kbps</description></item>
            <item><term>44.1kHz or 32kHz</term><description>Stereo: 192-384kbps  Mono: 96-192kbps</description></item>
            <item><term>24kHz, 22.05kHz or 16kHz</term><description>Stereo/Mono: 8-160kbps</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_VBRQuality">
            <summary>
            Set a VBR quality level from 1 (very low) to 100 (lossless).
            </summary>
            <remarks>The higher the number the better the quality.
            <para>If the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseVBR"/> is set to FALSE, this property is not evaluated!</para>
            <para>VBR and lossless encoding are currently only available at 44100hz stereo (48000hz too, but with limited quality settings). 
            To encode other sample formats, the data will first have to be resampled before.</para>
            <para>Here is a list of quality level to approximate kbps mapping:
            <list type="table">
            <listheader><term>Quality:</term><description>Bitrate:</description></listheader>
            <item><term>10%</term><description>65 kbps</description></item>
            <item><term>25%</term><description>77 kbps</description></item>
            <item><term>50%</term><description>89 kbps</description></item>
            <item><term>75%</term><description>140 kbps</description></item>
            <item><term>100%</term><description>778 kbps</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_TargetSampleRate">
            <summary>
            Currently only used internally.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_TargetNumChans">
            <summary>
            Currently only used internally.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseNetwork">
            <summary>
            Enables WMA encoding to the network (default is FALSE).
            </summary>
            <remarks>When encoding to a network it will not be possible to receive the encoded data (see <see cref="M:Un4seen.Bass.Misc.EncoderWMA.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>).
            However, you might use the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> streaming server implementation in this case.
            <para>Also note, that if streaming to a network you must set the properties: <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_NetworkPort"/> and optionally <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_NetworkClients"/>.</para>
            <para>If you set the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> property to FALSE (default), encoding will directly be done to the network (pull mode): <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_NetworkClients"/> users might connect directly to the specified <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_NetworkPort"/>.</para>
            <para>Set the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> property to TRUE, in order to enable encoding to a publishing point on a Windows Media server (push mode).</para>
            <para>If you are using this encoder in the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class, there will be no need to set this member, since it will automatically be done by the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class implementation!</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish">
            <summary>
            Enables WMA encoding to a publishing point on a Windows Media server.
            </summary>
            <remarks>This property will only be evaluated, if <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseNetwork"/> is set to TRUE.
            <para>When encoding to a network it will not be possible to receive the encoded data (see <see cref="M:Un4seen.Bass.Misc.EncoderWMA.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>).
            However, you might use the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> streaming server implementation in this case.</para>
            <para>Also note, that if streaming to a Windows Media server you must set the properties: <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_PublishUrl"/>, <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_PublishUsername"/> and <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_PublishPassword"/>.</para>
            <para>If you set the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> property to FALSE (default), encoding will directly be done to the network (pull mode): <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_NetworkClients"/> users might connect directly to the specified <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_NetworkPort"/>.</para>
            <para>Set the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> property to TRUE, in order to enable encoding to a publishing point on a Windows Media server (push mode).</para>
            <para>If you are using this encoder in the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class, there will be no need to set this member, since it will automatically be done by the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class implementation!</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_MultiBitrate">
            <summary>
            Here you can specify an array of encoding bitrates (in bits per second!) to use in case you selected <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseNetwork"/> or <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> - default is NULL.
            </summary>
            <remarks>If set to NULL the multi bitrate option for network encoding or encoding to a publishing point on a Windows Media server is not used, but only the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_Bitrate"/> is evaluated.
            <para>If you assign an array of bitrates (in bits per second!) here (e.g. = new int[2] {64000, 128000}) these bitrates will be used instead on the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_Bitrate"/> property!</para>
            <para>This property will only be evaluated in case you set <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseNetwork"/> or <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> to TRUE.</para>
            <para>If you are using this encoder in the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class, there will be no need to set this member, since it will automatically be done by the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class implementation!</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_NetworkPort">
            <summary>
            The network port number for clients to conenct to (only used, if <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseNetwork"/> is set to TRUE and <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> is set to FALSE) - default is 8080.
            </summary>
            <remarks>
            <para>If you are using this encoder in the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class, there will be no need to set this member, since it will automatically be done by the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class implementation!</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_NetworkClients">
            <summary>
            The maximum number of clients (up to 50) that can be connected (only used, if <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UseNetwork"/> is set to TRUE and <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> is set to FALSE) - default is 1.
            </summary>
            <remarks>
            <para>If you are using this encoder in the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class, there will be no need to set this member, since it will automatically be done by the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class implementation!</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_PublishUrl">
            <summary>
            URL of the publishing point on the Windows Media server.
            </summary>
            <remarks>This property is only evaluated, if <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> is set to TRUE.
            <para>If you are using this encoder in the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class, there will be no need to set this member, since it will automatically be done by the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class implementation!</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_PublishUsername">
            <summary>
            Username to use in connecting to the server.
            </summary>
            <remarks>If either this or <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_PublishPassword"/> is NULL, then no username/password is sent to the server.
            <para>This property is only evaluated, if <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> is set to TRUE.</para>
            <para>If you are using this encoder in the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class, there will be no need to set this member, since it will automatically be done by the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class implementation!</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWMA.WMA_PublishPassword">
            <summary>
            Password to use in connecting to the server.
            </summary>
            <remarks>If either this or <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_PublishUsername"/> is NULL, then no username/password is sent to the server.
            <para>This property is only evaluated, if <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_UsePublish"/> is set to TRUE.</para>
            <para>If you are using this encoder in the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class, there will be no need to set this member, since it will automatically be done by the <see cref="T:Un4seen.Bass.Misc.WMAcast"/> class implementation!</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWMA.IsActive">
            <summary>
            Gets a value indicating if the encoder has been started (see <see cref="M:Un4seen.Bass.Misc.EncoderWMA.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>) and is active - else FALSE will be returned.
            </summary>
            <remarks>This implementation first gets the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>.
            If the encoder handle is valid (non-zero) TRUE will be returned. In all other cases FALSE is returned.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWMA.IsPaused">
            <summary>
            Gets a value indicating if the encoder has been paused (see <see cref="M:Un4seen.Bass.Misc.EncoderWMA.Pause(System.Boolean)"/>) - else FALSE will be returned.
            </summary>
            <remarks>While the encoder is paused no data will be written to the encoder, however the input channel is not paused.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWMA.EncoderExists">
            <summary>
            This property always return TRUE, since we use the native BASSWMA add-on.
            </summary>
            <remarks>Make sure to have "basswma.dll" available in your path.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWMA.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here BASS_CTYPE_STREAM_WAV is always returned.
            </summary>
            <remarks>Since it will actually be impossible to return the real ACM codec related channel type, we will instead always use Here BASS_CTYPE_STREAM_WAV.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWMA.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (".wma").
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWMA.SupportsSTDOUT">
            <summary>
            WMA does implement STDOUT, so TRUE is always returned.
            </summary>
            <remarks>This encoder might be used for streaming, since it does support STDOUT. 
            However, the selected WMA codec must match the <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> implementation!
            <para>Please note, that there is also a special <see cref="T:Un4seen.Bass.Misc.WMAcast"/> implementation.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWMA.EncoderCommandLine">
            <summary>
            Returns an empty string, since WMA does not use any command-line tool, but instead directly uses the <see cref="N:Un4seen.Bass.AddOn.Wma"/> add-on.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWMA.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>This implementation always returns the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_Bitrate"/> member.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWMA.Force16Bit">
            <summary>
            Always returns false, since this encoder doesn't supports this flag. Use the <see cref="F:Un4seen.Bass.Misc.EncoderWMA.WMA_Use24Bit"/> property instead.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWMA.WMA_Notify">
            <summary>
            Gets ot Sets a <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC"/> on the WMA encoder.
            </summary>
            <remarks>
            A WMA encoder can only have one notification callback set. Subsequent calls to this property can be used to change the callback, or disable notifications (NULL).
            <para>The WMA encoder's status can be one of the following (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify"/>):
            <list type="table">
            <item><term>BASS_ENCODE_NOTIFY_ENCODER</term><description>The encoder died.</description></item>
            <item><term>BASS_ENCODE_NOTIFY_CAST</term><description>Cast server connection died (or any other mystery problem).</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderTooLAME">
            <summary>
            Encoder class implementation for MPEG Audio Layer II (MP2) encoding using "tooLAME.exe".
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MP2"/> encoder type.
            <para>"tooLAME.exe" must be downloaded separately (e.g. from <a href="http://www.rarewares.org/mp3.html">www.rarewares.org</a> or <a href="http://toolame.sourceforge.net">toolame.sourceforge.net</a>).
             tooLAME is a very good and stable freeware MP2 encoder.</para>
            <para>Since tooLAME does only support 16-bit sample data as input, the BASS_ENCODE_FP_16BIT flag will be used.
            This will be used, whenever the underlying channel handle is float or the BASS_CONFIG_FLOATDSP option has been set.</para>
            <para>Make sure to set the TWO_xxx flags before retrieving the <see cref="P:Un4seen.Bass.Misc.EncoderTooLAME.EncoderCommandLine"/> or calling <see cref="M:Un4seen.Bass.Misc.EncoderTooLAME.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderTooLAME.#ctor(System.Int32)">
            <summary>
            Creates an instance of a tooLAME encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements MP2 encoding (BASS_CTYPE_STREAM_MP2).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderTooLAME.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Returns "tooLAME Encoder (BASS_CTYPE_STREAM_MP2)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderTooLAME.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual tooLAME encoder. 
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            </summary>
            <param name="proc">Optional callback function to receive the encoded data... NULL = no callback. 
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.EncoderTooLAME.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally using the <see cref="P:Un4seen.Bass.Misc.EncoderTooLAME.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).
            <para>This implementation starts the encoder with the BASS_ENCODE_NOHEAD and BASS_ENCODE_FP_16BIT flag.</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_UseCustomOptionsOnly">
            <summary>
            Use the <see cref="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_CustomOptions"/> parameter string only (default=FALSE).
            </summary>
            <remarks>Caution: If set to TRUE no other TOO_xxx options will be evaluated and ONLY the <see cref="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_CustomOptions"/> parameter string will be used!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_CustomOptions">
            <summary>
            The custom parameter string, which should be used, if the <see cref="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_UseCustomOptionsOnly"/> property is set to TRUE.
            </summary>
            <remarks>This property string will be appended to all other TOO_xxx options, if the <see cref="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_UseCustomOptionsOnly"/> property is set to FALSE (default).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_Mode">
            <summary>
            -m: The encoding mode (Stereo, Joint stereo, DualChannel, Mono, default is Auto).
            </summary>
            <remarks>For MPEG Audio Layer II, not all combinations of total bitrate and mode are allowed. See the following table:
            <list type="table">
            <listheader><term>Bitrate (kbps):</term><description>Allowed Modes:</description></listheader>
            <item><term>32, 48, 56</term><description>mono only</description></item>
            <item><term>64</term><description>all modes</description></item>
            <item><term>80</term><description>mono only</description></item>
            <item><term>96, 112, 128, 160, 192</term><description>all modes</description></item>
            <item><term>224, 256, 320, 384</term><description>stereo only</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_Downmix">
            <summary>
            -a: Downmix from stereo to mono? (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_Bitrate">
            <summary>
            -b: Choose a total bitrate to encode at. Takes an argument in kbps (default is 192 kbps).
            </summary>
            <remarks>By default, this produces a CBR encoding.
            <para>To use VBR (variable bitrate): set <see cref="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_UseVBR"/> to TRUE and specify a <see cref="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_VBRLevel"/>.</para>
            <para>To use CBR (constant bitrate): set <see cref="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_UseVBR"/> to FALSE (default).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_UseVBR">
            <summary>
            Enable the VBR (variable bitrate) mode (default is FALSE).
            </summary>
            <remarks>If not set to TRUE the CBR (constant bitrate) mode will be used.
            <para>When making a VBR stream, the bitrate is only allowed to vary within set limits:
            <list type="table">
            <listheader><term>Samplerate:</term><description>Bitrate:</description></listheader>
            <item><term>48kHz</term><description>Stereo: 112-384kbps  Mono: 56-192kbps</description></item>
            <item><term>44.1kHz or 32kHz</term><description>Stereo: 192-384kbps  Mono: 96-192kbps</description></item>
            <item><term>24kHz, 22.05kHz or 16kHz</term><description>Stereo/Mono: 8-160kbps</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_VBRLevel">
            <summary>
            -v: Enable VBR and set a quality level from -50 to 50 (default is disbaled).
            </summary>
            <remarks>The higher the number the better the quality. Maximum range is -50 to 50 but useful range is -10 to 10. See vbr documentation file for details.
            <para>If the <see cref="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_UseVBR"/> is set to FALSE, this property is not evaluated!</para>
            <para>Using for example "-v -5" will force the encoder to favour the lower bitrate. Whereas using "-v 5" will force the encoder to favour the upper bitrate.
            The value can actually be any number. The larger the number, the greater the bitrate bias.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_PsycModel">
            <summary>
            -P: The psychoacoustic model (PAM) tooLAME should use (-1 to 4).
            </summary>
            <remarks>Choose the psycho-acoustic model to use (-1 to 4). Model number -1 turns off psycho-acoustic modelling and uses fixed default values instead.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_ATH">
            <summary>
            -l: Set the ATH level. Default level is 0.0 (which will not use the property).
            </summary>
            <remarks>ATH means Absolute Thresholds of Hearing. The ATH value raises/lowers the ATH by this many dB.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_Quick">
            <summary>
            -q: Enable quick mode (if value is geater than 0 (zero)). Only re-calculate psycho-acoustic model every specified number of frames (default is 0).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_Copyright">
            <summary>
            -c: Turn on Copyright flag in output bitstream (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_Original">
            <summary>
            -o: Mark as Original in output bitstream (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_Protect">
            <summary>
            -e: Enable CRC error protection in output bitstream. An extra 16-bit checksum is added to each frame (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_Padding">
            <summary>
            -r: force padding bit/frame off (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_DeEmphasis">
            <summary>
            -d: Set the de-emphasis type (None, CCIT, 50/15ms). Default is None.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_DABExtension">
            <summary>
            -D: Add DAB extensions of specific length (specify 0 (zero) to not specify a DAB extension, default).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTooLAME.EncoderExists">
            <summary>
            This property return TRUE, if the file "tooLAME.exe" exists in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/> - else FALSE is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTooLAME.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here BASS_CTYPE_STREAM_MP2 is always returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTooLAME.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (".mp2").
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTooLAME.SupportsSTDOUT">
            <summary>
            tooLAME implements STDOUT, so TRUE is always returned.
            </summary>
            <remarks>tooLAME support boradcast streaming.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTooLAME.EncoderCommandLine">
            <summary>
            Gets the actual encoder command-line string (using all TOO_xxx properties).
            </summary>
            <remarks>The encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> members 
            as well as the TOO_xxx settings.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTooLAME.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>
            <para>No matter if you are using CBR- or VBR-Mode (see <see cref="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_UseVBR"/>) the <see cref="F:Un4seen.Bass.Misc.EncoderTooLAME.TOO_Bitrate"/> value will be used to return the effective bitrate value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTooLAME.Force16Bit">
            <summary>
            Always returns true, since this encoder only supports receiving 16 bit sample data.
            </summary>
            <remarks>32-bit float channels are supported, since they are automatically converted to 16-bit integer sample data before sending them to the encoder.</remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderTooLAME.TOOMode">
            <summary>
            The general tooLAME encoding mode (stereo, joint stereo, mono etc.).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOOMode.Auto">
            <summary>
            Default is JointStereo or Stereo depending on bitrate.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOOMode.Stereo">
            <summary>
            Stereo
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOOMode.JointStereo">
            <summary>
            Force LR stereo on all frames
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOOMode.DualChannel">
            <summary>
            Force dual channel all frames
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOOMode.Mono">
            <summary>
            Mono
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderTooLAME.TOOPsycModel">
            <summary>
            The psychoacoustic model tooLAME should use (-1 to 4, default is 1).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOOPsycModel.Default">
            <summary>
            Default model will be selected by encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOOPsycModel.None">
            <summary>
            Psychoacoustic Model: -1 (turns off psycho-acoustic modelling and uses fixed default values instead)
            </summary>
            <remarks>This PAM doesn't actually look at the samples being encoded to decide upon the output values. There is simply a set of 32 default values which are used, regardless of input.
            <para>Pros: Faaaast. Low complexity. Surprisingly good. "Surprising" in that the other PAMs go to the effort of calculating FFTs and subbands and masking, and this one does absolutely nothing. Zip. Nada. Diddly Squat. This model might be the best example of why it is hard to make a good model - if having no computations sounds OK, how do you improve on it?</para>
            <para>Cons: Absolutely no attempt to consider any of the masking effects that would help the audio sound better.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOOPsycModel.Fixed">
            <summary>
            Psychoacoustic Model: 0
            </summary>
            <remarks>This PAM looks at the sizes of the scalefactors for the audio and combines it with the Absolute Threshold of Hearing (ATH) to make the 32 SMR values.
            <para>Pros: Faaast. Low complexity.</para>
            <para>Cons: This model has absolutely no mathematical basis and does not use any perceptual model of hearing. It simply juggles some of the numbers of the input sound to determine the values.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOOPsycModel.ISO_PAM1">
            <summary>
            Psychoacoustic Model: 1
            </summary>
            <remarks>This PAM is from the ISO standard. Just because they are the standard, doesn't mean that they are any good. Look at LAME which basically threw out the MP3 standard psycho models and made their own (GPSYCHO).
            <para>Pros: A reference for future PAMs.</para>
            <para>Cons: Terrible ISO code, buggy tables, poor documentation.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOOPsycModel.ISO_PAM2">
            <summary>
            Psychoacoustic Model: 2
            </summary>
            <remarks>This PAM is from the ISO standard. Just because they are the standard, doesn't mean that they are any good. Look at LAME which basically threw out the MP3 standard psycho models and made their own (GPSYCHO).
            <para>Pros: A reference for future PAMs.</para>
            <para>Cons: Terrible ISO code, buggy tables, poor documentation.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOOPsycModel.PAM3">
            <summary>
            Psychoacoustic Model: 3
            </summary>
            <remarks>A re-implementation of psychoacoustic model 1. ISO11172 was used as the guide for re-writing this PAM from the ground up.
            <para>Pros: No more obscure tables of values from the ISO code. Hopefully a good base to work upon for tweaking PAMs.</para>
            <para>Cons: At the moment, doesn't really sound any better than PAM1.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOOPsycModel.PAM4">
            <summary>
            Psychoacoustic Model: 4
            </summary>
            <remarks>A cleaned up version of PAM2.
            <para>Pros: Faster than PAM2. No more obscure tables of values from the ISO standard. Hopefully a good base to work from for improving the PAMs.</para>
            <para>Cons: Still has the same "warbling"/"Davros" problems as PAM2.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderTooLAME.TOODeEmphMode">
            <summary>
            The general tooLAME encoding mode (stereo, joint stereo, mono etc.).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOODeEmphMode.None">
            <summary>
            No Emphasis
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOODeEmphMode.CCIT_J17">
            <summary>
            Emphasis according to CCIT J.17
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTooLAME.TOODeEmphMode.Five">
            <summary>
            Emphasis 50/15 ms
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderTwoLAME">
            <summary>
            Encoder class implementation for MP2 TwoLAME encoding using "twolame.exe".
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MP2"/> encoder type.
            <para>"twolame.exe" must be downloaded separately (e.g. from <a href="http://www.rarewares.org/mp3.html">www.rarewares.org</a> or <a href="http://www.twolame.org">www.twolame.org</a>). TwoLAME is a fork of the tooLAME project, so don't mix it up. TwoLAME is a very good and stable freeware MP2 encoder.</para>
            <para>Make sure to set the TWO_xxx flags before retrieving the <see cref="P:Un4seen.Bass.Misc.EncoderTwoLAME.EncoderCommandLine"/> or calling <see cref="M:Un4seen.Bass.Misc.EncoderTwoLAME.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderTwoLAME.#ctor(System.Int32)">
            <summary>
            Creates an instance of a TwoLAME encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements MP2 encoding (BASS_CTYPE_STREAM_MP2).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderTwoLAME.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Returns "TwoLAME Encoder (BASS_CTYPE_STREAM_MP2)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderTwoLAME.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual TwoLAME encoder. 
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            </summary>
            <param name="proc">Optional callback function to receive the encoded data... NULL = no callback. 
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.EncoderTwoLAME.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally using the <see cref="P:Un4seen.Bass.Misc.EncoderTwoLAME.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).
            <para>This implementation starts the encoder with the BASS_ENCODE_NOHEAD flag and if your input is 32-bit float the BASS_ENCODE_FP_32BIT flag is used.</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_UseCustomOptionsOnly">
            <summary>
            Use the <see cref="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_CustomOptions"/> parameter string only (default=FALSE).
            </summary>
            <remarks>Caution: If set to TRUE no other TWO_xxx options will be evaluated and ONLY the <see cref="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_CustomOptions"/> parameter string will be used!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_CustomOptions">
            <summary>
            The custom parameter string, which should be used, if the <see cref="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_UseCustomOptionsOnly"/> property is set to TRUE.
            </summary>
            <remarks>This property string will be appended to all other TWO_xxx options, if the <see cref="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_UseCustomOptionsOnly"/> property is set to FALSE (default).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_Mode">
            <summary>
            -m: The encoding mode (Stereo, Joint stereo, DualChannel, Mono, default is Auto).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_Scale">
            <summary>
            --scale: Scale input data (multiply PCM data). Set to 1.0 (default) for no scaling.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_Downmix">
            <summary>
            -a: Downmix from stereo to mono? (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_Bitrate">
            <summary>
            -b: Choose a total bitrate to encode at. Takes an argument in kbps (default is 256 kbps).
            </summary>
            <remarks>By default, this produces a CBR encoding.
            <para>To use VBR (variable bitrate): set <see cref="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_UseVBR"/> to TRUE and optionally specify a <see cref="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_MaxBitrate"/> value.</para>
            <para>To use CBR (constant bitrate): set <see cref="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_UseVBR"/> to FALSE (default). The <see cref="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_MaxBitrate"/> value will be ignored in this case.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_MaxBitrate">
            <summary>
            -B:  Specify a maximum bitrate in kbps when in VBR mode.
            </summary>
            <remarks>If set to 0 (zero, default) or if the <see cref="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_UseVBR"/> is set to FALSE, this property is not evaluated!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_UseVBR">
            <summary>
            -v: Enable the VBR (variable bitrate) mode (default is FALSE).
            </summary>
            <remarks>If not set to TRUE the CBR (constant bitrate) mode will be used.
            <para>When making a VBR stream, the bitrate is only allowed to vary within set limits:
            <list type="table">
            <listheader><term>Samplerate:</term><description>Bitrate:</description></listheader>
            <item><term>48kHz</term><description>Stereo: 112-384kbps  Mono: 56-192kbps</description></item>
            <item><term>44.1kHz or 32kHz</term><description>Stereo: 192-384kbps  Mono: 96-192kbps</description></item>
            <item><term>24kHz, 22.05kHz or 16kHz</term><description>Stereo/Mono: 8-160kbps</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_VBRLevel">
            <summary>
            -V: Enable VBR and set a quality level from -50 to 50 (default is disbaled).
            </summary>
            <remarks>The higher the number the better the quality. Maximum range is -50 to 50 but useful range is -10 to 10. See vbr documentation file for details.
            <para>If a value outside the range or the <see cref="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_UseVBR"/> is set to FALSE, this property is not evaluated!</para>
            <para>Using for example "-V -5" will force the encoder to favour the lower bitrate. Whereas using "-V 5" will force the encoder to favour the upper bitrate.
            The value can actually be any integer. The larger the number, the greater the bitrate bias.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_PsycModel">
            <summary>
            -P: The psychoacoustic model (PAM) TwoLAME should use (-1 to 4).
            </summary>
            <remarks>Choose the psycho-acoustic model to use (-1 to 4). Model number -1 turns off psycho-acoustic modelling and uses fixed default values instead.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_ATH">
            <summary>
            -l: Set the ATH level. Default level is 0.0 (which will not use the property).
            </summary>
            <remarks>ATH means Absolute Thresholds of Hearing. The ATH value raises/lowers the ATH by this many dB.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_Quick">
            <summary>
            -q: Enable quick mode (if value is geater than 0 (zero)). Only re-calculate psycho-acoustic model every specified number of frames (default is 0).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_Copyright">
            <summary>
            -c: Turn on Copyright flag in output bitstream (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_NonOriginal">
            <summary>
            -o: Turn off Original flag in output bitstream (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_Protect">
            <summary>
            -p: Enable CRC error protection in output bitstream. An extra 16-bit checksum is added to each frame (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_Padding">
            <summary>
            -d: Turn on padding in output bitstream (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_Reserve">
            <summary>
            -R: Reserve specified number of bits in the each from of the output bitstream (default is 0, which will not use this property).
            </summary>
            <remarks>The value must be a multiple of 8 (e.g. 8, 16, 24, 32, ...).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_DeEmphasis">
            <summary>
            -e: Set the de-emphasis type (None, CCIT, 50/15ms). Default is None.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_Energy">
            <summary>
            -E: Turn on energy level extensions (default is FALSE).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTwoLAME.EncoderExists">
            <summary>
            This property return TRUE, if the file "twolame.exe" exists in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/> - else FALSE is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTwoLAME.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here BASS_CTYPE_STREAM_MP2 is always returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTwoLAME.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (".mp2").
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTwoLAME.SupportsSTDOUT">
            <summary>
            TwoLAME implements STDOUT, so TRUE is always returned.
            </summary>
            <remarks>TwoLAME support broadcast streaming.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTwoLAME.EncoderCommandLine">
            <summary>
            Gets the actual encoder command-line string (using all TWO_xxx properties).
            </summary>
            <remarks>The encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> members 
            as well as the TWO_xxx settings.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderTwoLAME.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>
            <para>No matter if you are using CBR- or VBR-Mode (see <see cref="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_UseVBR"/>) the <see cref="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWO_Bitrate"/> value will be used to return the effective bitrate value.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderTwoLAME.TWOMode">
            <summary>
            The general TwoLAME encoding mode (stereo, joint stereo, mono etc.).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWOMode.Auto">
            <summary>
            Default is JointStereo or Stereo depending on bitrate.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWOMode.Stereo">
            <summary>
            Stereo
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWOMode.JointStereo">
            <summary>
            Force LR stereo on all frames
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWOMode.DualChannel">
            <summary>
            Force dual channel all frames
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWOMode.Mono">
            <summary>
            Mono
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderTwoLAME.TWOPsycModel">
            <summary>
            The psychoacoustic model TwoLAME should use (-1 to 4, default is 3).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWOPsycModel.Default">
            <summary>
            Default model will be selected by encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWOPsycModel.None">
            <summary>
            Psychoacoustic Model: -1 (turns off psycho-acoustic modelling and uses fixed default values instead)
            </summary>
            <remarks>This PAM doesn't actually look at the samples being encoded to decide upon the output values. There is simply a set of 32 default values which are used, regardless of input.
            <para>Pros: Faaaast. Low complexity. Surprisingly good. "Surprising" in that the other PAMs go to the effort of calculating FFTs and subbands and masking, and this one does absolutely nothing. Zip. Nada. Diddly Squat. This model might be the best example of why it is hard to make a good model - if having no computations sounds OK, how do you improve on it?</para>
            <para>Cons: Absolutely no attempt to consider any of the masking effects that would help the audio sound better.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWOPsycModel.Fixed">
            <summary>
            Psychoacoustic Model: 0
            </summary>
            <remarks>This PAM looks at the sizes of the scalefactors for the audio and combines it with the Absolute Threshold of Hearing (ATH) to make the 32 SMR values.
            <para>Pros: Faaast. Low complexity.</para>
            <para>Cons: This model has absolutely no mathematical basis and does not use any perceptual model of hearing. It simply juggles some of the numbers of the input sound to determine the values.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWOPsycModel.ISO_PAM1">
            <summary>
            Psychoacoustic Model: 1
            </summary>
            <remarks>This PAM is from the ISO standard. Just because they are the standard, doesn't mean that they are any good. Look at LAME which basically threw out the MP3 standard psycho models and made their own (GPSYCHO).
            <para>Pros: A reference for future PAMs.</para>
            <para>Cons: Terrible ISO code, buggy tables, poor documentation.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWOPsycModel.ISO_PAM2">
            <summary>
            Psychoacoustic Model: 2
            </summary>
            <remarks>This PAM is from the ISO standard. Just because they are the standard, doesn't mean that they are any good. Look at LAME which basically threw out the MP3 standard psycho models and made their own (GPSYCHO).
            <para>Pros: A reference for future PAMs.</para>
            <para>Cons: Terrible ISO code, buggy tables, poor documentation.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWOPsycModel.PAM3">
            <summary>
            Psychoacoustic Model: 3
            </summary>
            <remarks>A re-implementation of psychoacoustic model 1. ISO11172 was used as the guide for re-writing this PAM from the ground up.
            <para>Pros: No more obscure tables of values from the ISO code. Hopefully a good base to work upon for tweaking PAMs.</para>
            <para>Cons: At the moment, doesn't really sound any better than PAM1.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWOPsycModel.PAM4">
            <summary>
            Psychoacoustic Model: 4
            </summary>
            <remarks>A cleaned up version of PAM2.
            <para>Pros: Faster than PAM2. No more obscure tables of values from the ISO standard. Hopefully a good base to work from for improving the PAMs.</para>
            <para>Cons: Still has the same "warbling"/"Davros" problems as PAM2.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderTwoLAME.TWODeEmphMode">
            <summary>
            The general TwoLAME encoding mode (stereo, joint stereo, mono etc.).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWODeEmphMode.None">
            <summary>
            No Emphasis
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWODeEmphMode.CCIT_J17">
            <summary>
            Emphasis according to CCIT J.17
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderTwoLAME.TWODeEmphMode.Five">
            <summary>
            Emphasis 50/15 ms
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderFAAC">
            <summary>
            Encoder class implementation for AAC encoding using faac.exe.
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_AAC"/> encoder type.
            <para>FAAC (faac.exe) must be downloaded separately (e.g. from <a href="http://www.rarewares.org/aac.html">www.rarewares.org</a>).</para>
            <para>Make sure to set the FAAC_xxx flags before retrieving the <see cref="P:Un4seen.Bass.Misc.EncoderFAAC.EncoderCommandLine"/> or calling <see cref="M:Un4seen.Bass.Misc.EncoderFAAC.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderFAAC.#ctor(System.Int32)">
            <summary>
            Creates an instance of a FAAC encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>FAAC implements AAC encoding (BASS_CTYPE_STREAM_AAC).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderFAAC.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Returns "FAAC Encoder (BASS_CTYPE_STREAM_AAC)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderFAAC.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual FAAC encoder. 
            </summary>
            <param name="proc">Optional callback function to receive the encoded data... NULL = no callback. 
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.EncoderFAAC.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally using the <see cref="P:Un4seen.Bass.Misc.EncoderFAAC.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).
            <para>This implementation starts the encoder with the BASS_ENCODE_NOHEAD flag.</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderFAAC.Quality2Kbps(System.Int32)">
            <summary>
            Converts a quality setting (between 10 and 500) to an approx. bitrate (in kbps).
            </summary>
            <param name="q">The FACC quality level to convert (between 10 and 500).</param>
            <returns>The rounded approximate bitrate in kbps.</returns>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_UseCustomOptionsOnly">
            <summary>
            Use the <see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_CustomOptions"/> parameter string only (default=FALSE).
            </summary>
            <remarks>Caution: If set to TRUE no other FAAC_xxx options will be evaluated and ONLY the <see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_CustomOptions"/> parameter string will be used!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_CustomOptions">
            <summary>
            The custom parameter string, which should be used, if the <see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_UseCustomOptionsOnly"/> property is set to TRUE.
            </summary>
            <remarks>This property string will be appended to all other FAAC_xxx options, if the <see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_UseCustomOptionsOnly"/> property is set to FALSE (default).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_UseQualityMode">
            <summary>
            Gets or Sets, if the Quality mode (<see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_Quality"/>) will be used (default is FALSE).
            </summary>
            <remarks>
            <para>When using the Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_UseQualityMode"/> is set to TRUE) you only specify a quality factor via <see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_Quality"/> and the bitrate parameter (<see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_Bitrate"/>) is ignored.</para>
            <para>When you turn off Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_UseQualityMode"/> is set to FALSE, default) the bitrate parameter is evaluated and the <see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_Quality"/> parameter is ignored!</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_Quality">
            <summary>
            -q: Set default variable bitrate (VBR) quantizer quality in percent.
            </summary>
            <remarks>Default: 100, averages at approx. 120 kbps VBR for a normal stereo input file with 16 bit and 44.1 kHz sample rate.
            Max. value is 500, Min. value is 10.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_Bitrate">
            <summary>
            -b: Set average bitrate (ABR) to approximately bitrate in kbps.
            <para>Max. value is 152 kbps/stereo with a 16 kHz cutoff, can be raised with a higher -c <see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_Bandwidth"/> setting).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_Bandwidth">
            <summary>
            -c: Set the bandwidth in Hz (default: -1 automatic, i.e. adapts maximum value to input sample rate).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_WrapMP4">
            <summary>
            -w: Wrap AAC data in MP4 container (default is TRUE, generating an .m4a output).
            </summary>
            <remarks>Setting this property to FALSE will generate an AAC stream (TAGs are not supported with AAC).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_EnableTNS">
            <summary>
            --tns: Enable coding of TNS, temporal noise shaping (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_NoMidSide">
            <summary>
            --no-midside: Don't use mid/side coding (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_MpegVersion">
            <summary>
            --mpeg-vers: Force AAC MPEG version 2 or 4 (-1 use default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_ObjectType">
            <summary>
            --obj-type: AAC object type. "LC" (Low Complexity, default), "Main" or "LTP" (Long Term Prediction).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_BlockType">
            <summary>
            --shortctl: Enforce block type (0 = both (default), 1 = no short; 2 = no long).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_RawBitstream">
            <summary>
            -r: Generate raw AAC bitstream (i.e. without any headers, default is FALSE).
            </summary>
            <remarks>Not advised! RAW AAC files are practically useless!</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderFAAC.EncoderExists">
            <summary>
            This property return TRUE, if the file "lame.exe" exists in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/> - else FALSE is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderFAAC.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here BASS_CTYPE_STREAM_AAC is always returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderFAAC.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (".m4a").
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderFAAC.SupportsSTDOUT">
            <summary>
            FAAC implements STDOUT, so TRUE is always returned.
            </summary>
            <remarks>FAAC support boradcast streaming.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderFAAC.EncoderCommandLine">
            <summary>
            Gets the actual encoder command-line string (using all FAAC_xxx properties).
            </summary>
            <remarks>The encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> members 
            as well as the FAAC_xxx settings.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderFAAC.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>
            <para>When using the Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_UseQualityMode"/> is set to TRUE, default) you only need to specify a quality factor via <see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_Quality"/> and the bitrate parameters <see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_Bitrate"/> is ignored. 
            In this case the effective bitrate will be calculated automatically according to the FAAC specification.</para>
            <para>When you turn off Quality-Mode (<see cref="F:Un4seen.Bass.Misc.EncoderFAAC.FAAC_UseQualityMode"/> is set to FALSE) the bitrate parameters is evaluated!</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderFLAC">
            <summary>
            Encoder class implementation for FLAC encoding using "flac.exe".
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_FLAC"/> encoder type.
            <para>"flac.exe" must be downloaded separately (e.g. from <a href="http://www.rarewares.org/lossless.html">www.rarewares.org</a>). FLAC also needs the "libmmd.dll", which is also available at rarewares.org.</para>
            <para>Make sure to set the FLAC_xxx flags before retrieving the <see cref="P:Un4seen.Bass.Misc.EncoderFLAC.EncoderCommandLine"/> or calling <see cref="M:Un4seen.Bass.Misc.EncoderFLAC.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            <para>FLAC 'cuesheets' and the 'skip' and 'until' properties are not supported in this implementation by default, but you might add them with the <see cref="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_CustomOptions"/> parameter.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderFLAC.#ctor(System.Int32)">
            <summary>
            Creates an instance of a FLAC encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements FLAC encoding (BASS_CTYPE_STREAM_FLAC).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderFLAC.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Returns "FLAC Encoder (BASS_CTYPE_STREAM_FLAC)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderFLAC.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual FLAC encoder. 
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            </summary>
            <param name="proc">Optional callback function to receive the encoded data... NULL = no callback. 
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.EncoderFLAC.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally using the <see cref="P:Un4seen.Bass.Misc.EncoderFLAC.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).
            <para>This implementation starts the encoder with the BASS_ENCODE_NOHEAD and if using 32-bit float input with the BASS_ENCODE_FP_24BIT flag.</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_UseCustomOptionsOnly">
            <summary>
            Use the <see cref="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_CustomOptions"/> parameter string only (default=FALSE).
            </summary>
            <remarks>Caution: If set to TRUE no other FLAC_xxx options will be evaluated and ONLY the <see cref="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_CustomOptions"/> parameter string will be used!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_CustomOptions">
            <summary>
            The custom parameter string, which should be used, if the <see cref="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_UseCustomOptionsOnly"/> property is set to TRUE.
            </summary>
            <remarks>This property string will be appended to all other FLAC_xxx options, if the <see cref="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_UseCustomOptionsOnly"/> property is set to FALSE (default).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_UseOgg">
            <summary>
            --ogg: When encoding, generate Ogg FLAC output instead of native FLAC (default is FALSE).
            </summary>
            <remarks>Ogg FLAC streams are FLAC streams wrapped in an Ogg transport layer.
            The resulting file should have an '.ogg' extension and will still be decodable by flac.
            <para>When setting this property to TRUE, the <see cref="P:Un4seen.Bass.Misc.EncoderFLAC.DefaultOutputExtension"/> will be changed to ".ogg".</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_Verify">
            <summary>
            -V: Verify a correct encoding by decoding the output in parallel and comparing to the original (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_Lax">
            <summary>
            --lax: Allow encoder to generate non-Subset files (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_ReplayGain">
            <summary>
            --replay-gain: Calculate ReplayGain values and store in Vorbis comments (default is FALSE).
            </summary>
            <remarks>Title gains/peaks will be computed for each file. 
            NOTE: this option may also leave a few extra bytes in the PADDING block.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_Padding">
            <summary>
            -P: Tell the encoder to write a PADDING metadata block of the given length (in bytes) after the STREAMINFO block (default is off).
            </summary>
            <remarks>This is useful if you plan to tag the file later with an APPLICATION block; instead of having to rewrite the entire file later just to insert your block, you can write directly over the PADDING block.
            Note that the total length of the PADDING block will be 4 bytes longer than the length given, because of the 4 metadata block header bytes.
            You can force no PADDING block at all to be written with "--no-padding".
            The encoder writes a PADDING block of 4096 bytes by default.
            <para>If you set <see cref="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_NoPadding"/> to TRUE, this option will have no effect.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_NoPadding">
            <summary>
            --no-padding: Suppress writing a PADDING block of 4096 bytes (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_Blocksize">
            <summary>
            -b: Specify the blocksize in samples (the default is 1152 for -l 0, else 4608).
            </summary>
            <remarks>This must be one of 192, 576, 1152, 2304, 4608, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768 (unless "--lax" is used).
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_CompressionLevel">
            <summary>
            -0..-8: Defines the compression level (default is 5) between 0 (fast) and 8 (best).
            </summary>
            <remarks>Although FLAC is a lossless format you can adjust the compression level.
            A higher compression level (max. is 8) means a smaller output, whereas a lower compression level (min. is 0) means faster results.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderFLAC.EncoderExists">
            <summary>
            This property return TRUE, if the file "flac.exe" exists in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/> - else FALSE is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderFLAC.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here BASS_CTYPE_STREAM_FLAC is always returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderFLAC.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (".flac").
            </summary>
            <remarks>If you set the option <see cref="F:Un4seen.Bass.Misc.EncoderFLAC.FLAC_UseOgg"/> to TRUE this will return ".ogg" instead.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderFLAC.SupportsSTDOUT">
            <summary>
            FLAC implements STDOUT, so TRUE is always returned.
            </summary>
            <remarks>FLAC support boradcast streaming.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderFLAC.EncoderCommandLine">
            <summary>
            Gets the actual encoder command-line string (using all FLAC_xxx properties).
            </summary>
            <remarks>The encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> members 
            as well as the FLAC_xxx settings.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderFLAC.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>
            <para>Since FLAC is a lossless format, no matter what compression mode you are using, the bitrate will always be taken from the raw input format.
            Meaning the original <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelSampleRate"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelBitwidth"/> and the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelNumChans"/> will be evaluated in order to calculate the effective bitrate.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderWavPack">
            <summary>
            Encoder class implementation for WavPack encoding using "wavpack.exe".
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WV"/> encoder type.
            <para>"wavpack.exe" must be downloaded separately (e.g. from <a href="http://www.wavpack.com">www.wavpack.com</a> or <a href="http://www.rarewares.org/lossless.html">www.rarewares.org</a>).</para>
            <para>Make sure to set the WV_xxx flags before retrieving the <see cref="P:Un4seen.Bass.Misc.EncoderWavPack.EncoderCommandLine"/> or calling <see cref="M:Un4seen.Bass.Misc.EncoderWavPack.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWavPack.#ctor(System.Int32)">
            <summary>
            Creates an instance of a WavPack encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements WavPack encoding (BASS_CTYPE_STREAM_WV).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWavPack.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Returns "WavPack Encoder (BASS_CTYPE_STREAM_WV)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWavPack.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual WavPack encoder. 
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            </summary>
            <param name="proc">Optional callback function to receive the encoded data... NULL = no callback. 
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.EncoderWavPack.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally using the <see cref="P:Un4seen.Bass.Misc.EncoderWavPack.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).
            <para>This implementation starts the encoder with no flags, meaning a Wave header will be send to the encoder to specify the bitrate, number of channels and samplerate (8, 16 and 32 bit are supported).</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_UseCustomOptionsOnly">
            <summary>
            Use the <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_CustomOptions"/> parameter string only (default=FALSE).
            </summary>
            <remarks>Caution: If set to TRUE no other WV_xxx options will be evaluated and ONLY the <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_CustomOptions"/> parameter string will be used!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_CustomOptions">
            <summary>
            The custom parameter string, which should be used, if the <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_UseCustomOptionsOnly"/> property is set to TRUE.
            </summary>
            <remarks>This property string will be appended to all other WV_xxx options, if the <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_UseCustomOptionsOnly"/> property is set to FALSE (default).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_UseHybrid">
            <summary>
            Enable hybrid compression? (default is FALSE)
            </summary>
            <remarks>When set to TRUE, the <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_HybridBitrate"/> property is used.
            If set to FALSE (default) WavPack is pure lossless, which means that the .wv file contains all the information that was in the original .wav file.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_HybridBitrate">
            <summary>
            -b: Hybrid compression, 24 - 9600 kbits/second (default is 1024 kbps).
            </summary>
            <remarks>Only used, if <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_UseHybrid"/> is set to TRUE.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_CreateCorrectionFile">
            <summary>
            -c: Create correction file (.wvc) for hybrid mode (=lossless, default is FALSE)
            </summary>
            <remarks>Only used, if <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_UseHybrid"/> is set to TRUE.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_MaximumHybridCompression">
            <summary>
            -cc: Maximum hybrid compression (hurts lossy quality and decode speed, default is FALSE).
            </summary>
            <remarks>Only used, if <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_UseHybrid"/> is set to TRUE.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_FastMode">
            <summary>
            -f: Fast mode (fast, but some compromise in compression ratio, default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_HighQuality">
            <summary>
            -h: High quality (best compression in all modes, but slower, default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_IgnoreLength">
            <summary>
            -i: Ignore length in wav header (no pipe output allowed, default is FALSE).
            </summary>
            <remarks>Sometimes If the length in the wav headers that is provided is not correct. 
            In this case use this option to force WavPack to ignore the header and accept the actual length. 
            Because WavPack must seek to the beginning of the output file to write the correct length, this option cannot be used with piped output.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_JointStereo">
            <summary>
            -j0: Joint-stereo override (FALSE = left/right, TRUE = mid/side, default is TRUE).
            </summary>
            <remarks>WavPack normally defaults to joint stereo (sometimes called mid/side) in which the left and right channels are combined to form an alternate representation (essentially L+R and L-R) that compresses better in lossless mode and improves quality in lossy mode. 
            This option allows this feature to be forced either on or off.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_LowPriority">
            <summary>
            -l: Run at low priority (for smoother multitasking, default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_ComputeMD5">
            <summary>
            -m: Compute and store MD5 signature of raw audio data (default is FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_CalcAvgPeakQuant">
            <summary>
            -n: Calculate average and peak quantization noise (hybrid only, default is FALSE).
            </summary>
            <remarks>Only used, if <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_UseHybrid"/> is set to TRUE.
            <para>This causes WavPack to calculate the average and peak quantization noise generated in the lossy version of the hybrid mode, both referenced in decibels below full scale. 
            While it is impossible to use this as a guide to determine the audibility of the noise, it is useful for comparing the various compression options and for comparing WavPack's lossy performance to other programs.
            Note that this option does not currently produce meaningfull results for floating point or multichannels files.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_PracticalFloat">
            <summary>
            -p = practical float storage (also 32-bit ints, not lossless, default is FALSE).
            </summary>
            <remarks>This option reduces the storage of some floating-point data files by up to about 10% by eliminating some information that has virtually no effect on the audio data. 
            While this does technically make the compression lossy, it retains all the advantages of floating point data (>600 dB of dynamic range, no clipping, and 25 bits of resolution). 
            This also affects large integer compression by limiting the resolution to 24 bits.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_NewRiffHeader">
            <summary>
            -r: Generate new RIFF wav header (removing extra chunk info, default is FALSE).
            </summary>
            <remarks>WavPack normally saves all the RIFF header information contained in the wav file (including any chunks after the audio data). 
            This is done so that WvUnpack.exe can restore the original wav files exactly. The -r option causes WavPack to discard the header contained in the source file (and any extra chunks) and generate a fresh wav header. 
            Obviously the source wav header is still used to determine the format and size of the file (i.e. this is not a "raw" mode).
            Note that for multichannel files a WAVEFORMATEXTENSIBLE header is generated whether the source file had one or not.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_NoiseShaping">
            <summary>
            -s: noise shaping override (hybrid only, -1.0 to 1.0, 0.0 = off = default)
            </summary>
            <remarks>Only used, if <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_UseHybrid"/> is set to TRUE.
            <para>WavPack uses first-order noise shaping to improve the perceived quality of lossy files and to improve the hybrid lossless compression ratio. 
            Normally WavPack will choose the noise shaping most appropriate for the application, but this option allows the user to override the default. The parameter range is +/- 1.0, where positive values shift the noise higher in frequency and negative values shift the noise lower in frequency. Values very close to -1.0 are clipped to prevent problems associated with very high gain near DC</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_CopyTimestamp">
            <summary>
            -t: Copy input file's time stamp to output file (default is FALSE).
            </summary>
            <remarks>Can only be used, if a <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> is specified.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWavPack.WV_ExtraProcessing">
            <summary>
            -x: Extra encode processing (optional n = 1-6 for more/less, 0 = default).
            </summary>
            <remarks>
            <para>Like previous versions of WavPack (and many other compressors), WavPack 4.31 normally works "symmetrically" in that encoding and decoding operate at about the same rate (regardless of the mode used). 
            However, WavPack now has an option to work "asymmetrically", so that extra processing can be done during encoding to provide better compression, but with NO corresponding cost to decoding performance!</para>
            <para>This is enabled with the -x option and provides an average improvement in CD music compression of about 1% in "fast" mode, about 0.5% in the normal mode, and about 0.25% in "high" mode. 
            Because the standard compression parameters are optimized for "normal" CD music audio, this option works best with "non-standard" audio (synthesized sounds, non-standard sampling rates, etc) where it can often achieve enormous gains. 
            It should be noted that this mode is not just a little slower than the regular mode - it is MUCH slower. 
            However, the fact that it has no effect on decode time could make it attractive in some situations.</para> 
            <para>The "extra" option provides a level of extra processing that has been optimized for the encoding mode selected (i.e. normal, "fast" or "high"). 
            This level can be overridden with the optional numeric parameter from 1 to 6, although this is not generally recommended.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWavPack.EncoderExists">
            <summary>
            This property return TRUE, if the file "wavpack.exe" exists in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/> - else FALSE is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWavPack.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here BASS_CTYPE_STREAM_WV is always returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWavPack.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (".wv").
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWavPack.SupportsSTDOUT">
            <summary>
            WavPack does implement STDOUT, so TRUE is always returned.
            </summary>
            <remarks>WavPack does support boradcast streaming.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWavPack.EncoderCommandLine">
            <summary>
            Gets the actual encoder command-line string (using all WV_xxx properties).
            </summary>
            <remarks>The encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> members 
            as well as the WV_xxx settings.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWavPack.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>
            <para>Since WavPack can be used as a hybrid lossy or fully lossless encoder, the <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_UseHybrid"/> will be used to determine the bitrate in kbps.</para>
            <para>If the <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_UseHybrid"/> is set to TRUE (lossy), the bitrate is directly taken from the <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_HybridBitrate"/> property.</para>
            <para>If the <see cref="F:Un4seen.Bass.Misc.EncoderWavPack.WV_UseHybrid"/> is set to FALSE (lossless), the the original <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelSampleRate"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelBitwidth"/> and the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelNumChans"/> will be evaluated in order to calculate the effective bitrate.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderMPC">
            <summary>
            Encoder class implementation for MusePack MPC encoding using "mppenc.exe".
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MPC"/> encoder type.
            <para>"mppenc.exe" must be downloaded separately (e.g. from <a href="http://www.musepack.net">www.musepack.net</a>).</para>
            <para>Make sure to set the MPC_xxx flags before retrieving the <see cref="P:Un4seen.Bass.Misc.EncoderMPC.EncoderCommandLine"/> or calling <see cref="M:Un4seen.Bass.Misc.EncoderMPC.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            <para>This implementation does not use all possible tweaking switches, since they are mostly not recommended ny MusePack and since the default settings are already pretty much optimized.
            However, if you for what ever reason need to add you swicth, you can make use of the <see cref="F:Un4seen.Bass.Misc.EncoderMPC.MPC_CustomOptions"/> property.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderMPC.#ctor(System.Int32)">
            <summary>
            Creates an instance of a MPC encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements MusePack encoding (BASS_CTYPE_STREAM_MPC).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderMPC.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Returns "MusePack Encoder (BASS_CTYPE_STREAM_MPC)".</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderMPC.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual MPC encoder. 
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            </summary>
            <param name="proc">Optional callback function to receive the encoded data... NULL = no callback. 
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.EncoderMPC.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If TRUE, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns TRUE, if the encoder was successfully started - else FALSE is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally using the <see cref="P:Un4seen.Bass.Misc.EncoderMPC.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).
            <para>This implementation starts the encoder with the BASS_ENCODE_FP_32BIT flag (since no 32bit floating point are supported), this also means a Wave header will be send to the encoder to specify the bitrate, number of channels and samplerate (8, 16, 24 and 32 bit are supported).</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPC_UseCustomOptionsOnly">
            <summary>
            Use the <see cref="F:Un4seen.Bass.Misc.EncoderMPC.MPC_CustomOptions"/> parameter string only (default=FALSE).
            </summary>
            <remarks>Caution: If set to TRUE no other MPC_xxx options will be evaluated and ONLY the <see cref="F:Un4seen.Bass.Misc.EncoderMPC.MPC_CustomOptions"/> parameter string will be used!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPC_CustomOptions">
            <summary>
            The custom parameter string, which should be used, if the <see cref="F:Un4seen.Bass.Misc.EncoderMPC.MPC_UseCustomOptionsOnly"/> property is set to TRUE.
            </summary>
            <remarks>This property string will be appended to all other MPC_xxx options, if the <see cref="F:Un4seen.Bass.Misc.EncoderMPC.MPC_UseCustomOptionsOnly"/> property is set to FALSE (default).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPC_Preset">
            <summary>
            Quality preset (use one of the <see cref="T:Un4seen.Bass.Misc.EncoderMPC.MPCPreset"/> values, default is "standard").
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPC_Scale">
            <summary>
            --scale: Scale input signal by x (default: 1.00000, no scaling).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPC_Quality">
            <summary>
            --quality: Set Quality to x (default is 5).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPC_NMT">
            <summary>
            --nmt: Set NMT value to x dB (default is 6.5).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPC_TMN">
            <summary>
            --tmn: Set TMN value to x dB (default is 18.0).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPC_PNS">
            <summary>
            --pns: Set PNS value to x dB (default is 0.0).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderMPC.EncoderExists">
            <summary>
            This property return TRUE, if the file "mppenc.exe" exists in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/> - else FALSE is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderMPC.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here BASS_CTYPE_STREAM_MPC is always returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderMPC.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (".mpc").
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderMPC.SupportsSTDOUT">
            <summary>
            MusePack does implement STDOUT, so TRUE is always returned.
            </summary>
            <remarks>MusePack does support boradcast streaming.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderMPC.EncoderCommandLine">
            <summary>
            Gets the actual encoder command-line string (using all MPC_xxx properties).
            </summary>
            <remarks>The encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> members 
            as well as the MPC_xxx settings.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderMPC.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>
            Since MusePack uses presets the appropriate bitrate associated with the <see cref="F:Un4seen.Bass.Misc.EncoderMPC.MPC_Preset"/> will be returned in any case.
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderMPC.MPCPreset">
            <summary>
            Profile options, Quality preset. To be used with <see cref="F:Un4seen.Bass.Misc.EncoderMPC.MPC_Preset"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPCPreset.telephone">
            <summary>
            lowest quality (typ.  32... 48 kbps)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPCPreset.thumb">
            <summary>
            low quality/internet (typ.  58... 86 kbps)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPCPreset.radio">
            <summary>
            medium (MP3) quality (typ. 112...152 kbps)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPCPreset.standard">
            <summary>
            high quality (default) (typ. 142...184 kbps)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPCPreset.xtreme">
            <summary>
            extreme high quality (typ. 168...212 kbps)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPCPreset.insane">
            <summary>
            extreme high quality (typ. 232...268 kbps)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderMPC.MPCPreset.braindead">
            <summary>
            extreme high quality (typ. 232...278 kbps)
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Ac3.BassAc3">
            <summary>
            BASS.NET API wrapper for BASS_AC3.DLL
            <para>Requires: bass_ac3.dll - Dolby Digital AC-3 Codec (AC3) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_AC3 is an extension to the BASS audio library, enabling the playback	of AC-3 streams.
            AC-3, often referred to as Dolby Digital, is Dolby's third digital audio coding technology based on a perceptual coding method. It is more advanced than AC-2 and delivers up to 5.1 discrete channels of surround sound in less space than stereo PCM.</para>
            <para>The AC-3 format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/URL/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> /URL/User functions.</para>
            <para>More information can be found on <a href="http://www.dolby.com">www.dolby.com</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Dolby Digital AC-3 file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Dolby Digital AC-3 memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a Dolby Digital AC-3 file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from a Dolby Digital AC-3 file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
             <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="proc">Callback function to receive the file as it is downloaded... NULL = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Ac3.BassAc3.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_ac3.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Ac3.BassAc3.SupportedStreamName">
            <summary>
            Supported file format name of the bass_ac3.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Ac3.BassAc3.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Ac3.BassAc3.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.BassAsio.BassAsio">
            <summary>
            .NET API wrapper for BASSASIO.DLL
            <para>Requires: bassasio.dll - ASIO driver library - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSASIO is basically a wrapper for ASIO drivers, with the addition of channel joining, format conversion and resampling.</para>
            <para>BASSASIO requires a soundcard with ASIO drivers installed. It also makes use of SSE2 and 3DNow optimizations, but is fully functional without them.
            BASS is not required by BASSASIO, but BASS can of course be used to decode, apply DSP/FX, etc.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.BassAsio.BassAsio.BASSASIOVERSION">
            <summary>
            Current BASSASIO version (without minor revision).
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode">
            <summary>
            Retrieves the error code for the most recent BASSASIO function call in the current thread.
            </summary>
            <returns>If no error occured during the last BASSASIO function call then BASS_OK is returned, else one of the <see cref="T:Un4seen.Bass.BASSError"/> values is returned. 
            See the function description for an explanation of what the error code means.</returns>
            <remarks>Error codes are stored for each thread. So if you happen to call 2 or more BASSASIO functions at the same time, they will not interfere with eachother's error codes.</remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfoInternal(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO_INTERNAL@)">
            <summary>
            
            </summary>
            <param name="device"></param>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO)">
            <summary>
            Retrieves information on an Asio device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO"/> class to store the information at.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available Asio devices for a setup dialog. 
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List all available devices:
            <code>
            BASS_ASIO_DEVICEINFO info = new BASS_ASIO_DEVICEINFO();
            for (int n=0; BassAsio.BASS_ASIO_GetDeviceInfo(n, info); n++)
            {
              Console.WriteLine(info.ToString());
            }
            </code>
            <code lang="vbnet">
            Dim n As Integer = 0
            Dim info As New BASS_ASIO_DEVICEINFO()
            While (BassAsio.BASS_ASIO_GetDeviceInfo(n, info))
              Console.WriteLine(info.ToString())
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on an Asio device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <returns>If successful, then an instance of the <see cref="T:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO"/> class is returned, else NULL is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available Asio devices for a setup dialog. 
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_ASIO_DEVICEINFO info;
            for (int n = 0; (info = BassAsio.BASS_ASIO_GetDeviceInfo(n)) != null; n++)
            {
              ...
            }
            </code>
            <code lang="vbnet">
            Dim n As Integer = 0
            Dim info As New BASS_ASIO_DEVICEINFO()
            While Not (info Is Nothing)
              info = BassAsio.BASS_ASIO_GetDeviceDescription(n)
              If Not (info Is Nothing) Then
                ...
              End If
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfos">
            <summary>
            Returns all available Asio devices.
            </summary>
            <returns>An array of <see cref="T:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO"/> elements representing the available Asio devices.</returns>
            <remarks>Uses <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceCount">
            <summary>
            Returns the total number of available Asio devices.
            </summary>
            <returns>Number of ASIO devices available.</returns>
            <remarks>Uses <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)">
            <summary>
            Sets the device to use for subsequent calls in the current thread.
            </summary>
            <param name="device">The device to use... 0 = first device.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. 
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.</para>
            <para>The device context setting is used by any function that may result in a BASS_ERROR_INIT error (except this function), which is the majority of them. When one if those functions is called, it will check the current thread's device setting, and if no device is selected (or the selected device is not initialized), BASSASIO will automatically select the lowest device that is initialized. 
            This means that when using a single device, there is no need to use this function - BASSASIO will automatically use the device that's initialized. Even if you free the device, and initialize another, BASSASIO will automatically switch to the one that is initialized.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The <paramref name="device"/> number specified is invalid.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The device has not been initialized.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the sample rate of device 2:
            <code>
            // select device 2
            BassAsio.BASS_ASIO_SetDevice(2);
            // get the sample rate
            double rate = BassAsio.BASS_ASIO_GetRate();
            </code>
            <code lang="vbnet">
            ' select device 2
            BassAsio.BASS_ASIO_SetDevice(2)
            ' get the sample rate
            Dim rate As Double = BassAsio.BASS_ASIO_GetRate()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDevice">
            <summary>
            Retrieves the Asio device setting in the current thread.
            </summary>
            <returns>If successful, the device number is returned, else -1 is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/>to get the error code.</returns>
            <remarks>As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used needs to be set via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)"/> prior to calling the function. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called - there are no initialized devices.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)">
            <summary>
            Initializes an Asio device/driver.
            </summary>
            <param name="device">The device to use... 0 = first device. <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO)"/> can be used to get the total number of devices.</param>
            <returns>If the device was successfully initialized, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function must be successfully called before any input or output can be performed.</para>
            <para>Simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)"/> is used to switch the current device. 
            When successful, BASS_ASIO_Init automatically sets the current thread's device to the one that was just initialized.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The <paramref name="device"/> number specified is invalid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>A device has already been initialized. You must call <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Free"/> before you can initialize again.</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>The driver couldn't be initialized.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Free">
            <summary>
            Releases the Asio device/driver.
            </summary>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Make sure to free each Asio device you have initialized with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/>, <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)"/> is used to switch the current device.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetVersion">
            <summary>
            Retrieves the version number of the BASSASIO.DLL that is loaded.
            </summary>
            <returns>The BASSASIO version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASSASIO supports all the BASSASIO functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.BassAsio.BassAsio.BASSASIOVERSION"/> to check the major revision.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(BassAsio.BASS_ASIO_GetVersion()) != BassAsio.BASSASIOVERSION )
            {
              MessageBox.Show(this, "Wrong BassAsio Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(BassAsio.BASS_ASIO_GetVersion()) &lt;&gt; BassAsio.BASSASIOVERSION Then
              MessageBox.Show(Me, "Wrong BassAsio Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (BassAsio.BASS_ASIO_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong BassAsio Version!");
            }
            </code>
            <code lang="vbnet">
            If BassAsio.BASS_ASIO_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong BassAsio Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASSASIO.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASSASIO version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASSASIO supports all the BASSASIO functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.</remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (BassAsio.BASS_ASIO_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong BassAsio Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If BassAsio.BASS_ASIO_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong BassAsio Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Stop">
            <summary>
            Stops the current Asio device.
            </summary>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, 
            the device to be used needs to be set via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)"/> prior to calling the function. 
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device hasn't been started.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetInfo(Un4seen.BassAsio.BASS_ASIO_INFO)">
            <summary>
            Retrieves information on the Asio device being used.
            </summary>
            <param name="info">An instance of the <see cref="T:Un4seen.BassAsio.BASS_ASIO_INFO"/> class to store the information at.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used needs to be set via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)"/> prior to calling the function. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Display the number of inputs and outputs:
            <code>
            BassAsio.BASS_ASIO_Init(0);
            BASS_ASIO_INFO info = new BASS_ASIO_INFO();
            if ( BassAsio.BASS_ASIO_GetInfo(info) )
            {
            	Console.WriteLine( info.ToString() );
            }
            </code>
            <code lang="vbnet">
            BassAsio.BASS_ASIO_Init(0)
            Dim info As New BASS_ASIO_INFO()
            If BassAsio.BASS_ASIO_GetInfo(info) Then
              Console.WriteLine(info.ToString())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetInfo">
            <summary>
            Retrieves information on the Asio device being used.
            </summary>
            <returns>An instance of the <see cref="T:Un4seen.BassAsio.BASS_ASIO_INFO"/> class on success - else NULL.</returns>
            <remarks>As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used needs to be set via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)"/> prior to calling the function. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Display the number of inputs and outputs of the current Asio device:
            <code>
            BassAsio.BASS_ASIO_Init(0);
            BASS_ASIO_INFO info = BassAsio.BASS_ASIO_GetInfo();
            if ( info != null )
            {
            	Console.WriteLine( info.ToString() );
            }
            </code>
            <code lang="vbnet">
            BassAsio.BASS_ASIO_Init(0)
            Dim info As BASS_ASIO_INFO = BassAsio.BASS_ASIO_GetInfo()
            If Not (info Is Nothing) Then
              Console.WriteLine(info.ToString())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetRate(System.Double)">
            <summary>
            Sets the Asio device's sample rate.
            </summary>
            <param name="rate">The sample rate.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>When it's not possible to set the device to the rate wanted, <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetRate(System.Boolean,System.Int32,System.Double)"/> can be used to overcome that.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The sample rate is not supported by the device/drivers.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set the Asio device and channel sample rate to the same as the underlying BASS decoding stream, in order to save resampling:
            <code>
            // get the channel info of the decoding stream
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(streamDecoding);
            // set the source rate
            BassAsio.BASS_ASIO_ChannelSetRate(false, 0, (double)info.freq);
            // try to set the device rate too (saves resampling)
            BassAsio.BASS_ASIO_SetRate( (double)info.freq );
            </code>
            <code lang="vbnet">
            ' get the channel info of the decoding stream
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(streamDecoding)
            ' set the source rate
            BassAsio.BASS_ASIO_ChannelSetRate(False, 0, CDbl(info.freq))
            ' try to set the device rate too (saves resampling)
            BassAsio.BASS_ASIO_SetRate(CDbl(info.freq))
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)">
            <summary>
            Starts the current Asio device.
            </summary>
            <param name="buflen">Buffer length in samples... 0 = use current length.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Before starting the device, channels must be enabled using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/>. Once started, channels can't be enabled or disabled until the device is stopped, using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Stop"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The device has already been started.</description></item>
            <item><term>BASS_ERROR_NOCHAN</term><description>No channels have been enabled.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            using Un4seen.Bass;
            using Un4seen.BassAsio;
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, null);
            BassAsio.BASS_ASIO_Init(0);
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
            	// now setup ASIO
            	_myAsioProc = new ASIOPROC(AsioCallback);
            	// enable 1st output channel...(0=first)
            	BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, new IntPtr(stream));
            	// and join the next channels to it
            	BassAsio.BASS_ASIO_ChannelJoin(false, 1, 0);
            	// and start playing it...start output using default buffer/latency
            	BassAsio.BASS_ASIO_Start(0);
            }
            ...
            private ASIOPROC _myAsioProc; // make it global, so that it can not be removed by the Garbage Collector
            private int AsioCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
            {
            	// Note: 'user' contains the underlying stream channel (see above)
            	// We can simply use the bass method to get some data from a decoding channel 
            	// and store it to the asio buffer in the same moment...
            	return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Imports Un4seen.Bass
            Imports Un4seen.BassAsio
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, Nothing)
            BassAsio.BASS_ASIO_Init(0)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' now setup ASIO
              _myAsioProc = New ASIOPROC(AddressOf AsioCallback)
              ' enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, New IntPtr(stream))
              ' and join the next channels to it
              BassAsio.BASS_ASIO_ChannelJoin(False, 1, 0)
              ' and start playing it...start output using default buffer/latency
              BassAsio.BASS_ASIO_Start(0)
            End If
            ...
            Private _myAsioProc As ASIOPROC ' make it global, so that it can not be removed by the Garbage Collector
            Private Function AsioCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
              ' Note: 'user' contains the underlying stream channel (see above)
              ' We can simply use the bass method to get some data from a decoding channel 
              ' and store it to the asio buffer in the same moment...
              Return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length)
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_IsStarted">
            <summary>
            Checks, if the current Asio device has been started.
            </summary>
            <returns>Returns TRUE, if the device has been started, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ControlPanel">
            <summary>
            Displays the current Asio driver's control panel.
            </summary>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetRate">
            <summary>
            Retrieves the current Asio device's sample rate.
            </summary>
            <returns>If succesful, the sample rate is returned, else -1 is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetLatency(System.Boolean)">
            <summary>
            Retrieves the latency of input or output channels of the current Asio device
            </summary>
            <param name="input">Get the input latency? FALSE=the output latency.</param>
            <returns>If successful, the latency in samples is returned, else -1 is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The latency is the delay between the sound being recorded and reaching an <see cref="T:Un4seen.BassAsio.ASIOPROC"/>, in the case of input channels. And the delay between the sample data being fed to an <see cref="T:Un4seen.BassAsio.ASIOPROC"/> and actually being heard, in the case of output channels. 
            The latency is dependant on the buffer size, as specified in the <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)"/> call. So the latency should be checked after making that call, not before.</para>
            <para>The latency time can by calculated be dividing the sample latency by the device sample rate. When a channel is being resampled, the sample latency will change, but the effective latency time remains constant.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Display the input and output latency, in milliseconds:
            <code>
            // get the sample rate
            double rate = BassAsio.BASS_ASIO_GetRate();
            Console.WriteLine("Input Latency = {0} ms", BassAsio.BASS_ASIO_GetLatency(true) * 1000.0 / rate);
            Console.WriteLine("Output Latency = {0} ms", BassAsio.BASS_ASIO_GetLatency(false) * 1000.0 / rate);
            </code>
            <code lang="vbnet">
            Dim rate As Double = BassAsio.BASS_ASIO_GetRate()
            Console.WriteLine("Input Latency = {0} ms", BassAsio.BASS_ASIO_GetLatency(True) * 1000.0 / rate)
            Console.WriteLine("Output Latency = {0} ms", BassAsio.BASS_ASIO_GetLatency(False) * 1000.0 / rate)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetCPU">
            <summary>
            Retrieves the current CPU usage of BASSASIO.
            </summary>
            <returns>The BASSASIO CPU usage as a percentage of total CPU time.</returns>
            <remarks>This function includes the time taken by the <see cref="T:Un4seen.BassAsio.ASIOPROC"/> callback functions.</remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Monitor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Set the direct input monitoring state.
            </summary>
            <param name="input">The input to set the monitoring state of... -1 = all.</param>
            <param name="output">The suggested output for the monitoring.</param>
            <param name="gain">Suggested Gain, ranging from 0 to 0x7fffffff (-inf to +12 dB), 0x20000000 equals 0 dB.</param>
            <param name="state">Monitoring state... 0 = off, 1 = on. Other settings may be possible depending on the drivers, e.g.:
            <para>0 = input monitoring off.</para>
            <para>1 = input monitoring on.</para>
            <para>2 = playback monitoring off.</para>
            <para>3 = playback monitoring on.</para>
            </param>
            <param name="pan">Suggested Pan, ranging from 0 = left to 0x7fffffff = right</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>If the hardware does not support patching and mixing a straight 1 to 1 routing is suggested. 
            The driver should ignore all the information of ASIOInputMonitor it cannot deal with, usually these might be either or all of output, gain, pan.
            <para>Output is the base channel of a stereo channel pair, i.e. output is always an even channel (0,2,4...). 
            If an odd input channel should be monitored and no panning or output routing can be applied, the driver has to use the next higher output (imply a hard right pan).
            Note that the output, gain and pan settings are just suggestions, and may be ignored by the device/driver.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetInfo(System.Boolean,System.Int32,Un4seen.BassAsio.BASS_ASIO_CHANNELINFO)">
            <summary>
            Retrieves information on an Asio channel.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO"/> class to store the information at.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Display the information of all channels:
            <code>
            BASS_ASIO_CHANNELINFO info = new BASS_ASIO_CHANNELINFO();
            int chan = 0;
            while (true)
            {
            	if (!BassAsio.BASS_ASIO_ChannelGetInfo(false, chan, info))
            		break;
            	Console.WriteLine( info.ToString() );
            	chan++;
            }
            </code>
            <code lang="vbnet">
            Dim info As New BASS_ASIO_CHANNELINFO()
            Dim chan As Integer = 0
            While True
              If Not BassAsio.BASS_ASIO_ChannelGetInfo(False, chan, info) Then
                Exit While
              End If
              Console.WriteLine(info.ToString())
              chan += 1
            End While
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetInfo(System.Boolean,System.Int32)">
            <summary>
            Retrieves information on an Asio channel.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <returns>If successful, an instance of the <see cref="T:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO"/> class is returned, else NULL is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Display the information of the first channel:
            <code>
            BASS_ASIO_CHANNELINFO info = BassAsio.BASS_ASIO_ChannelGetInfo(false, 0);
            if (info != null)
            {
              Console.WriteLine( info.ToString() );
            }
            </code>
            <code lang="vbnet">
            Dim info As BASS_ASIO_CHANNELINFO = BassAsio.BASS_ASIO_ChannelGetInfo(False, 0)
            If Not (info Is Nothing) Then
              Console.WriteLine(info.ToString())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)">
            <summary>
            Enable/disable processing of an Asio channel.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="proc">The user defined function to process the channel... NULL = disable the channel.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>All ASIO channels are mono. Stereo (and above) channels can be formed by joining multiple channels together using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelJoin(System.Boolean,System.Int32,System.Int32)"/>.</para>
            <para>Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)"/> to begin processing the enabled channels.</para>
            <para>You might also use this function on an already enabled ASIO channel if you just want to change the <see cref="T:Un4seen.BassAsio.ASIOPROC"/> which should be used.
            However changing the callback procedure to NULL would disable the channel - which is only possible, if the ASIO device is stopped.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device has been started - it needs to be stopped before (dis)enabling channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            using Un4seen.Bass;
            using Un4seen.BassAsio;
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, null);
            BassAsio.BASS_ASIO_Init(0);
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
            	// now setup ASIO
            	_myAsioProc = new ASIOPROC(AsioCallback);
            	// enable 1st output channel...(0=first)
            	BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, new IntPtr(stream));
            	// and join the next channels to it
            	BassAsio.BASS_ASIO_ChannelJoin(false, 1, 0);
            	// and start playing it...start output using default buffer/latency
            	BassAsio.BASS_ASIO_Start(0);
            }
            ...
            private ASIOPROC _myAsioProc; // make it global, so that it can not be removed by the Garbage Collector
            private int AsioCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
            {
            	// Note: 'user' contains the underlying stream channel (see above)
            	// We can simply use the bass method to get some data from a decoding channel 
            	// and store it to the asio buffer in the same moment...
            	return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Imports Un4seen.Bass
            Imports Un4seen.BassAsio
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, Nothing)
            BassAsio.BASS_ASIO_Init(0)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' now setup ASIO
              _myAsioProc = New ASIOPROC(AddressOf AsioCallback)
              ' enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, New IntPtr(stream))
              ' and join the next channels to it
              BassAsio.BASS_ASIO_ChannelJoin(False, 1, 0)
              ' and start playing it...start output using default buffer/latency
              BassAsio.BASS_ASIO_Start(0)
            End If
            ...
            Private _myAsioProc As ASIOPROC ' make it global, so that it can not be removed by the Garbage Collector
            Private Function AsioCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
              ' Note: 'user' contains the underlying stream channel (see above)
              ' We can simply use the bass method to get some data from a decoding channel 
              ' and store it to the asio buffer in the same moment...
              Return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length)
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelJoin(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Join a channel to another.
            </summary>
            <param name="input">Dealing with input channels? FALSE = output channels.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="channel2">The channel to join it to... -1 = remove current join.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>All ASIO channels are mono. By joining them, stereo (and above) channels can be formed, making it simpler to process stereo (and above) sample data.</para>
            <para>Channels can only be joined to preceding channels. For example, channel 1 can be joined to channel 0, but not vice versa. When joining a group of channels, they should all be joined to the first channel in the group - do not join a channel to a channel that is itself joined to another channel.
            Mirror channels, setup using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnableMirror(System.Int32,System.Boolean,System.Int32)"/>, can't be joined with.</para>
            <para>While a channel is joined to another, it automatically takes on the attributes of the other channel - the other channel's settings determine the sample format, the sample rate and whether it's enabled.
            The volume setting remains individual though, allowing balance control over the joined channels</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device has been started - it needs to be stopped before (dis)enabling channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // enable processing of output channel 0
            BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, 0);
            // join channel 1 to it
            BassAsio.BASS_ASIO_ChannelJoin(false, 1, 0);
            </code>
            <code lang="vbnet">
            ' enable processing of output channel 0
            BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, 0)
            ' join channel 1 to it
            BassAsio.BASS_ASIO_ChannelJoin(False, 1, 0)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetFormat(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOFormat)">
            <summary>
            Sets a channel's sample format.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="format">The sample format. One of the following (see <see cref="T:Un4seen.BassAsio.BASSASIOFormat"/>):
            <list type="table">
            <item><term>BASS_ASIO_FORMAT_16BIT</term><description>16-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_24BIT</term><description>24-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_32BIT</term><description>32-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_FLOAT</term><description>32-bit floating-point.</description></item>
            </list>
            </param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The sample format can vary between ASIO devices/drivers, which could mean a lot of extra/duplicate code being required. To avoid that extra work, BASSASIO can automatically convert the sample data, whenever necessary, to/from a format of your choice. 
            The native format of a channel can be retrieved via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetInfo(System.Boolean,System.Int32,Un4seen.BassAsio.BASS_ASIO_CHANNELINFO)"/>.</para>
            <para>For performance reasons, it's best not to use 24-bit sample data whenever possible, as 24-bit data requires a bit more processing than the other formats.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid, or <paramref name="format"/> is.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>Format conversion is not available for the channel's native sample format (please report).</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set output channel 0 to use floating-point sample data:
            <code>
            BassAsio.BASS_ASIO_ChannelSetFormat(false, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT);
            </code>
            <code lang="vbnet">
            BassAsio.BASS_ASIO_ChannelSetFormat(False, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetRate(System.Boolean,System.Int32,System.Double)">
            <summary>
            Sets a channel's sample rate.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="rate">The sample rate... 0 = device rate.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>For optimal quality and performance, it is best to set the device to the sample rate you want via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetRate(System.Double)"/>, but that's not always possible. 
            Which is where this function and resampling comes into play. 8 point sinc interpolation is used, giving a good blend of sound quality and performance. It is also SSE2 and 3DNow optimized for an extra boost with supporting CPUs.</para>
            <para>When a channel's sample rate is the same as the device rate, resampling is bypassed, so there's no unnecessary performance hit.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid, or <paramref name="rate"/> is below 0.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>Format conversion is not available for the channel's native sample format (please report).</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // set the device rate
            BassAsio.BASS_ASIO_SetRate(44100);
            // set the channel's rate
            BassAsio.BASS_ASIO_ChannelSetRate(false, 0, 44100);
            </code>
            <code lang="vbnet">
            ' set the device rate
            BassAsio.BASS_ASIO_SetRate(44100)
            ' set the channel's rate
            BassAsio.BASS_ASIO_ChannelSetRate(False, 0, 44100)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelReset(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOReset)">
            <summary>
            Resets the attributes of a channel (or all channels).
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first, -1 = all channels.</param>
            <param name="flags">The attributes to reset. A combination of the following (see <see cref="T:Un4seen.BassAsio.BASSASIOReset"/>):
            <list type="table">
            <item><term>BASS_ASIO_RESET_ENABLE</term><description>Disable the channel.</description></item>
            <item><term>BASS_ASIO_RESET_JOIN</term><description>Unjoin the channel.</description></item>
            <item><term>BASS_ASIO_RESET_PAUSE</term><description>Unpause the channel.</description></item>
            <item><term>BASS_ASIO_RESET_FORMAT</term><description>Set the channel's sample format to the native format.</description></item>
            <item><term>BASS_ASIO_RESET_RATE</term><description>Set the channel's sample rate to the device rate.</description></item>
            <item><term>BASS_ASIO_RESET_VOLUME</term><description>Set the channel's volume to normal (1.0).</description></item>
            </list>
            </param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>When resetting all channels (channel = -1), the resetting only applies to all channels of the specified type, ie. input or output, not both.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid, or <paramref name="format"/> is.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device has been started - it needs to be stopped before disabling or unjoining channels.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Disable all output channels and remove all joins between them:
            <code>
            BassAsio.BASS_ASIO_ChannelReset(false, -1, BASSASIOReset.BASS_ASIO_RESET_ENABLE | BASSASIOReset.BASS_ASIO_RESET_JOIN);
            </code>
            <code lang="vbnet">
            BassAsio.BASS_ASIO_ChannelReset(False, -1, BASSASIOReset.BASS_ASIO_RESET_ENABLE Or BASSASIOReset.BASS_ASIO_RESET_JOIN);
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelPause(System.Boolean,System.Int32)">
            <summary>
            Suspends processing of a channel.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Channels can only be disabled when the device is stopped. When you want to stop processing only some of the enabled channels, there are few ways that could be done. You could quickly stop the device, disable the unwanted channels, and restart the device. 
            In the case of output channels, you could fill the channels' buffers with silence (0s) in the <see cref="T:Un4seen.BassAsio.ASIOPROC"/>. Or you could pause the channels, using this function. 
            The less channels BASSASIO has to process, the less CPU it'll use, so stopping and restarting the device would be the most efficient, but that could cause a slight break in the sound of the other channels. 
            Filling the buffers with silence is the least efficient, as BASSASIO will still process the data as if it was "normal", but it does mean that other channels are unaffected. 
            Pausing is a compromise between the two - the channels will still be enabled, but BASSASIO will bypass any additional processing (resampling/etc) that may normally be required.</para>
            <para>Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelReset(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOReset)"/> to resume processing of a paused channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelIsActive(System.Boolean,System.Int32)">
            <summary>
            Checks if a channel is enabled for processing.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <returns>The return value is one of the folowing (see <see cref="T:Un4seen.BassAsio.BASSASIOActive"/>):
            <list type="table">
            <item><term>BASS_ASIO_ACTIVE_DISABLED</term><description>The channel is not enabled.</description></item>
            <item><term>BASS_ASIO_ACTIVE_ENABLED</term><description>The channel is enabled.</description></item>
            <item><term>BASS_ASIO_ACTIVE_PAUSED</term><description>The channel is enabled and paused.</description></item>
            </list>
            </returns>
            <remarks>
            When a channel is joined to another, the status of the other channel is returned, as that is what determines whether the channel is enabled for processing - whether it's been enabled itself is of no consequence while it is joined to another. 
            For example, if channel B is joined to channel A, and channel A is not enabled, then neither is channel B.
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetFormat(System.Boolean,System.Int32)">
            <summary>
            Retrieves a channel's sample format.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <returns>If an error occurs, -1 (BASS_ASIO_FORMAT_UNKNOWN) is returned, use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.
            <para>If successful, one of the following is returned (see <see cref="T:Un4seen.BassAsio.BASSASIOFormat"/>):
            <list type="table">
            <item><term>BASS_ASIO_FORMAT_16BIT</term><description>16-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_24BIT</term><description>24-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_32BIT</term><description>32-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_FLOAT</term><description>32-bit floating-point.</description></item>
            <item><term>BASS_ASIO_FORMAT_UNKNOWN</term><description>Unknown format, an error occured.</description></item>
            </list>
            </para>
            </returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetRate(System.Boolean,System.Int32)">
            <summary>
            Retrieves a channel's sample rate.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <returns>If succesful, the channel's sample rate is returned (0 = device rate), else -1 is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetLevel(System.Boolean,System.Int32)">
            <summary>
            Retrieves the level (peak amplitude) of a channel.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code. 
            If successful, the level of the channel is returned, ranging from 0 (silent) to 1 (max). If the channel's native sample format is floating-point, it is actually possible for the level to go above 1.</returns>
            <remarks>This function measures the level of a single channel, and is not affected by any other channels that are joined with it.
            <para>Volume settings made via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetVolume(System.Boolean,System.Int32,System.Single)"/> affect the level reading of output channels, but not input channels.</para>
            <para>When an input channel is paused, it is still possible to get its level. Paused output channels will have a level of 0.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device hasn't been started, or the channel isn't enabled.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>Level retrieval is not supported for the channel's sample format (please report).</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // get the linear level
            float level = BassAsio.BASS_ASIO_ChannelSetVolume(false, 0);
            // translate it to logarithmic dB 
            double db = 20.0 * Math.Log10(level);
            </code>
            <code lang="vbnet">
            ' get the linear level
            Dim level As Single = BassAsio.BASS_ASIO_ChannelSetVolume(False, 0)
            ' translate it to logarithmic dB 
            Dim db As Double = 20.0 * Math.Log10(level)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnableMirror(System.Int32,System.Boolean,System.Int32)">
            <summary>
            Enables an output channel, and makes it mirror another channel.
            </summary>
            <param name="channel">The output channel number... 0 = first.</param>
            <param name="input2">Mirroring an input channel? FALSE = an output channel.</param>
            <param name="channel2">The channel to mirror.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function allows an input or output channel to be duplicated in other output channel. This can be achieved using normal <see cref="T:Un4seen.BassAsio.ASIOPROC"/> processing, but it's more efficient to let BASSASIO simply copy the data from one channel to another.</para>
            <para>Mirror channels can't be joined together to form multi-channel mirrors. Instead, to mirror multiple channels, an individual mirror should be setup for each of them.</para>
            <para>After <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)"/> has been called to begin processing, it's not possible to setup new mirror channels, but it is still possible to change the channel that a mirror is mirroring.</para>
            <para>When mirroring an output channel that hasn't been enabled, the mirror channel will just produce silence. When mirroring an input channel that hasn't already been enabled, the channel is automatically enabled for processing when <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)"/> is called, so that it can be mirrored. 
            If the mirror is switched to a disabled input channel once processing has begun, then it will produce silence.</para>
            <para>A mirror channel can be made to have a different volume level to the channel that it's mirroring, using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetVolume(System.Boolean,System.Int32,System.Single)"/>. The volume setting is cumulative. 
            For example, if the mirror channel has a volume setting of 0.5 and the mirrored channel has a volume setting of 0.4, the effective volume of the mirror channel will be 0.2 (0.5 x 0.4).</para>
            <para><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/> can be used to disable a mirror channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device has been started - it needs to be stopped before enabling channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>At least one of the channels is invalid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>It is not possible to mirror channels that do not have the same sample format.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Enable output channel 0, and mirror it to channel 1 for stereo output:
            <code>
            using Un4seen.Bass;
            using Un4seen.BassAsio;
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, null);
            BassAsio.BASS_ASIO_Init(0);
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
            	// now setup ASIO
            	_myAsioProc = new ASIOPROC(AsioCallback);
            	// enable 1st output channel...(0=first)
            	BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, new IntPtr(stream));
            	// mirror it to channel 1
            	BassAsio.BASS_ASIO_ChannelEnableMirror(1, false, 0);
            	// and start playing it...start output using default buffer/latency
            	BassAsio.BASS_ASIO_Start(0);
            }
            ...
            private ASIOPROC _myAsioProc; // make it global, so that it can not be removed by the GC
            private int AsioCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
            {
            	// Note: 'user' contains the underlying stream channel (see above)
            	// We can simply use the bass method to get some data from a decoding channel 
            	// and store it to the asio buffer in the same moment...
            	return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Imports Un4seen.Bass
            Imports Un4seen.BassAsio
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, Nothing)
            BassAsio.BASS_ASIO_Init(0)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' now setup ASIO
              _myAsioProc = New ASIOPROC(AddressOf AsioCallback)
              ' enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, New IntPtr(stream))
              // mirror it to channel 1
              BassAsio.BASS_ASIO_ChannelEnableMirror(1, False, 0)
              ' and start playing it...start output using default buffer/latency
              BassAsio.BASS_ASIO_Start(0)
            End If
            ...
            Private _myAsioProc As ASIOPROC ' make it global, so that it can not be removed by the GC
            Private Function AsioCallback(input As Boolean, channel As Integer, buffer As IntPtr, 
                                          length As Integer, user As IntPtr) As Integer
              ' Note: 'user' contains the underlying stream channel (see above)
              ' We can simply use the bass method to get some data from a decoding channel 
              ' and store it to the asio buffer in the same moment...
              Return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length)
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetVolume(System.Boolean,System.Int32,System.Single)">
            <summary>
            Sets a channel's volume.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first, -1 = master.</param>
            <param name="volume">The volume level... 0 (silent)...1.0 (normal). Above 1.0 amplifies the sound.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para></para>
            <para>Apart from the master volume (channel = -1), this function applies a volume level to a single channel, and does not affect any other channels that are joined with it. This allows balance control over joined channels, by setting the individual volume levels accordingly.</para>
            <para>The volume "curve" is linear, but logarithmic levels can be easily used. See the example below.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid, or <paramref name="volume"/> is below 0.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set a logarithmic volume level:
            <code>
            // translate logarithmic dB level to linear
            float volume = (float)Math.Pow(10d, db / 20d);
            // apply it
            BassAsio.BASS_ASIO_ChannelSetVolume(false, 0 , volume);
            </code>
            <code lang="vbnet">
            ' translate logarithmic dB level to linear
            Dim volume As Single = CSng(Math.Pow(10.0, db / 20.0))
            ' apply it
            BassAsio.BASS_ASIO_ChannelSetVolume(False, 0, volume)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetVolume(System.Boolean,System.Int32)">
            <summary>
            Retrieves a channel's volume setting.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <returns>If successful, the channel's volume setting is returned, else -1 is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>To set a channel volume use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetVolume(System.Boolean,System.Int32,System.Single)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSWMA from the application's startup path:
            <code>
            Bass.LoadMe();
            BassWma.LoadMe();
            ...
            // when not used anymore...
            BassWma.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSWMA from a different directory:
            <code>
            Bass.LoadMe( @"C:\Development\BASS\_libs" );
            BassWma.LoadMe( @"C:\Development\BASS\_libs" );
            ...
            // when not used anymore...
            BassWma.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.BassAsio.BassAsio.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.BassAsio.BassAsio.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.BassAsio.BASSASIOFormat">
            <summary>
            BassAsio sample formats to be used with <see cref="T:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO"/> and <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetInfo(System.Boolean,System.Int32,Un4seen.BassAsio.BASS_ASIO_CHANNELINFO)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_UNKNOWN">
            <summary>
            Unknown format. Error
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_16BIT">
            <summary>
            16-bit integer
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_24BIT">
            <summary>
            24-bit integer
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_32BIT">
            <summary>
            32-bit integer
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT">
            <summary>
            32-bit floating-point
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BASSASIOReset">
            <summary>
            BassAsio attributes to be used when to reset a channel with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelReset(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOReset)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_ENABLE">
            <summary>
            Disable the channel.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_JOIN">
            <summary>
            Unjoin the channel.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_PAUSE">
            <summary>
            Unpause the channel.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_FORMAT">
            <summary>
            Set the channel's sample format to the native format.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_RATE">
            <summary>
            Set the channel's sample rate to the device rate.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_VOLUME">
            <summary>
            Reset volume to 1.0
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BASSASIOActive">
            <summary>
            BassAsio active values return by <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelIsActive(System.Boolean,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOActive.BASS_ASIO_ACTIVE_DISABLED">
            <summary>
            The channel is not enabled.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOActive.BASS_ASIO_ACTIVE_ENABLED">
            <summary>
            The channel is enabled.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOActive.BASS_ASIO_ACTIVE_PAUSED">
            <summary>
            The channel is enabled and paused.
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO">
            <summary>
            Used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO)"/> to retrieve information on an asio device.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO.name">
            <summary>
            The description of the device.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO.driver">
            <summary>
            The filename of the driver being used.
            <para>Further information can be obtained from the file using the GetFileVersionInfo Win32 API function.</para>
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO.ToString">
            <summary>
            A description of the decive info object (name).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Un4seen.BassAsio.BASS_ASIO_INFO">
            <summary>
            Used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetInfo(Un4seen.BassAsio.BASS_ASIO_INFO)"/> to retrieve information on the current device.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.name">
            <summary>
            The name of the device/driver.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.version">
            <summary>
            The driver version.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.inputs">
            <summary>
            The number of input channels available.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.outputs">
            <summary>
            The number of output channels available.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.bufmin">
            <summary>
            The minimum buffer length, in samples.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.bufmax">
            <summary>
            The maximum buffer length, in samples.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.bufpref">
            <summary>
            The preferred/default buffer length, in samples.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.bufgran">
            <summary>
            The buffer length granularity, that is the smallest possible length change... -1 = the possible buffer lengths increase in powers of 2.
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BASS_ASIO_INFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BASS_ASIO_INFO.ToString">
            <summary>
            A description of the decive info object (the driver/device name).
            </summary>
            <returns>The name of the device/driver.</returns>
        </member>
        <member name="T:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO">
            <summary>
            Used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetInfo(System.Boolean,System.Int32,Un4seen.BassAsio.BASS_ASIO_CHANNELINFO)"/> to retrieve information on the current device.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO.group">
            <summary>
            The channel's group.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO.format">
            <summary>
            The channel's sample format, one of the following (see <see cref="T:Un4seen.BassAsio.BASSASIOFormat"/>):
            <list type="table">
            <item><term>BASS_ASIO_FORMAT_16BIT</term><description>16-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_24BIT</term><description>24-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_32BIT</term><description>32-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_FLOAT</term><description>32-bit floating-point.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO.name">
            <summary>
            The name of the channel.
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO.ToString">
            <summary>
            A description of the channel info object (name).
            </summary>
            <returns>The name of the channel.</returns>
        </member>
        <member name="T:Un4seen.BassAsio.ASIOPROC">
            <summary>
            User defined ASIO channel callback function (to be used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/>).
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="buffer">The pointer to the buffer containing the recorded data (input channel), or in which to put the data to output (output channel).</param>
            <param name="length">The number of bytes to process.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/> was called.</param>
            <returns>The number of bytes written (ignored with input channels).</returns>
            <remarks>
            <para>ASIO is a low latency system, so a channel callback function should obviously be as quick as possible. <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetCPU"/> can be used to monitor that.</para>
            <para>When multiple channels are joined together, the sample data of the channels is interleaved. For example, with 2 channels (ie. stereo), the sample data would be arranged as channel 1, channel 2, channel 1, channel 2, channel 1, etc...</para>
            <para>When an output channel needs to be empty/silent but still enabled, the channel's function could fill the buffer with 0s to achieve that, but it is more efficient to pause the channel using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelPause(System.Boolean,System.Int32)"/>.
            That way, BASSASIO knows it can bypass any additional processing (resampling/etc) that may normally be required, thus saving some CPU. A channel can be paused from within it's own callback function, in which case the buffered data is outputted (if it's an output channel), and the function is not called again until the channel is unpaused.</para>
            <para>Do not call these functions from within an ASIO callback: <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Stop"/>, <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Free"/>. 
            Also, if it's an output channel, <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetFormat(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOFormat)"/> and <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetRate(System.Boolean,System.Int32,System.Double)"/> should not be used on the channel being processed by the callback.</para>
            <para>Prior to calling this function, BASSASIO will set the thread's device context to the device that the channel belongs to. So when using multiple devices, <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDevice"/> can be used to determine which device the channel is on.</para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
              // now setup ASIO
              _myAsioProc = new ASIOPROC(AsioCallback);
              // get the stream channel info
              BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
              // enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, new IntPtr(stream));
              // and join the next channels to it
              for (int a=1; a&lt;info.chans; a++)
                BassAsio.BASS_ASIO_ChannelJoin(false, a, 0);
              // since we joined the channels, the next commands will apply to all channles joined
              // so setting the values to the first channels changes them all automatically
              // set the source format (float, as the decoding channel is)
              BassAsio.BASS_ASIO_ChannelSetFormat(false, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT);
              // set the source rate
              BassAsio.BASS_ASIO_ChannelSetRate(false, 0, (double)info.freq);
              // try to set the device rate too (saves resampling)
              BassAsio.BASS_ASIO_SetRate( (double)info.freq );
              // and start playing it...start output using default buffer/latency
              BassAsio.BASS_ASIO_Start(0);
            }
            ...
            private ASIOPROC _myAsioProc; // make it global, so that it can not be removed by the GC
            private int AsioCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
            {
              // Note: 'user' contains the underlying stream channel (see above)
              // We can simply use the bass method to get some data from a decoding channel 
              // and store it to the asio buffer in the same moment...
              return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' now setup ASIO
              _myAsioProc = New ASIOPROC(AsioCallback)
              ' get the stream channel info
              Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
              ' enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, New IntPtr(stream))
              ' and join the next channels to it
              Dim a As Integer
              For a = 1 To info.chans - 1
                BassAsio.BASS_ASIO_ChannelJoin(False, a, 0)
              Next a
              ' since we joined the channels, the next commands will apply to all channles joined
              ' so setting the values to the first channels changes them all automatically
              ' set the source format (float, as the decoding channel is)
              BassAsio.BASS_ASIO_ChannelSetFormat(False, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT)
              ' set the source rate
              BassAsio.BASS_ASIO_ChannelSetRate(False, 0, CDbl(info.freq))
              ' try to set the device rate too (saves resampling)
              BassAsio.BASS_ASIO_SetRate(CDbl(info.freq))
              ' and start playing it...start output using default buffer/latency
              BassAsio.BASS_ASIO_Start(0)
            End If
            ...
            Private _myAsioProc As ASIOPROC ' make it global, so that it can not be removed by the GC
            Private Function AsioCallback(input As Boolean, channel As Integer, 
                                          buffer As IntPtr, length As Integer, user As IntPtr) As Integer
              ' Note: 'user' contains the underlying stream channel (see above)
              ' We can simply use the bass method to get some data from a decoding channel 
              ' and store it to the asio buffer in the same moment...
              Return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length)
            End Function
            </code>
            </example>
        </member>
        <member name="T:Un4seen.BassAsio.BassAsioHandler">
            <summary>
            This class provides ready-made members for direct and more simple ASIO usage together with BASS channels.
            </summary>
            <remarks>
            You might use this class for almost all use cases in terms of Asio handling, e.g.:
            <list type="table">
            <listheader><term>Scenario:</term><description>How-To:</description></listheader>
            <item><term>Asio output</term><description>A Bass decoding channel or a recording channel feeding Asio output.
            <para>Simply use the corresponding output constructor to specify the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> as well the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> to use and you are done.
            The <see cref="P:Un4seen.BassAsio.BassAsioHandler.SampleRate"/>, <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.Format"/> will automatically be aligned. Use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AssignOutputChannel(System.Int32)"/> method to change the underlying bass channel on the fly.</para>
            </description></item>
            <item><term>Asio input</term><description>Directly record from Asio input.
            <para>Simply use the corresponding input constructor to specify the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/>, <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/>, <see cref="P:Un4seen.BassAsio.BassAsioHandler.SampleRate"/>, <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.Format"/> you want to record at.
            To retrieve the input sample data use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> channel (e.g. setup an <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)">own DSP</see>, use it with the <see cref="T:Un4seen.Bass.Misc.WaveWriter"/> or <see cref="T:Un4seen.Bass.Misc.BaseEncoder">Encoder Framework</see>).</para>
            </description></item>
            <item><term>Asio input, full-duplex to Asio</term><description>Monitor your Asio input on any Asio output.
            <para>To enable full-duplex just call the Asio overload of the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> method (when done call <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)"/>).</para>
            </description></item>
            <item><term>Asio input, full-duplex to BASS</term><description>Monitor your Asio input on any BASS device.
            <para>To enable full-duplex just call the bass overload of the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> method (when done call <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)"/>).</para>
            </description></item>
            <item><term>DSP/FX</term><description>You can set any DSP/FX on either the input and/or the output (full-duplex).
            <para>See <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> for more details.</para>
            </description></item>
            In addition to the above this class supports overloading of the default Asio callbacks (<see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioOutputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioInputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToAsioFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToBassFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>).
            </list>
            <para>You might use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Volume"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.Pan"/> properties to easily control your Asio input/output settings.
            Asio mirrors are also supported via the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetMirror(System.Int32)"/> and <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveMirror"/> methods. Mirrors have independent <see cref="P:Un4seen.BassAsio.BassAsioHandler.VolumeMirror"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.PanMirror"/> settings.</para>
            <para>Asio channels can be paused and resumed at any time by using the <see cref="M:Un4seen.BassAsio.BassAsioHandler.Pause(System.Boolean)"/> method.
            To physically start the used Asio device the <see cref="M:Un4seen.BassAsio.BassAsioHandler.Start(System.Int32)"/> method might be used. <see cref="M:Un4seen.BassAsio.BassAsioHandler.Stop"/> will unjoin, disable and stop the Asio device (if really needed).</para>
            <para>Caution: Once you created an instance of this class, the respective ASIO channels are joined and enabled.
            The used ASIO channels will NOT be unjoined or disabled automatically when an instance of this class is being disposed by the .Net Garbage Collector!
            Call the <see cref="M:Un4seen.BassAsio.BassAsioHandler.Dispose"/> method manually to completely free all assigned ASIO channels, including any full-duplex and the mirror options.
            However, calling <see cref="M:Un4seen.BassAsio.BassAsioHandler.Dispose"/> will not stop the Asio device - this has to be done manually in any case (e.g. by calling <see cref="M:Un4seen.BassAsio.BassAsioHandler.Stop"/>)!</para>
            <para>Note: This class internally uses <see cref="N:Un4seen.Bass"/>, so you need to provide the native BASS.dll as well when using this class.</para>
            <para>The <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioOutputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioInputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToAsioFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> and <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToBassFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> callbacks are virtual methods 
            which might be overloaded if you want to derive your own ASIO handler with any special callback handling.</para>
            </remarks>
            <example>
            Automatic use of the BassAsioHandler (a Bass channel is feeding Asio output):
            <code>
            private BassAsioHandler _asio;
            ...
            // not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0);
            // setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, 0, 0, null);
            BassAsio.BASS_ASIO_Init(0);
            ...
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
            	// assign ASIO output to the first device and channel
            	// and assume the ASIO format, samplerate and number of channels from the BASS stream
            	_asio = new BassAsioHandler(0, 0, stream);
            	// start ASIO
            	_asio.Start(0);
            }
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0)
            ' setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, 0, 0, Nothing)
            BassAsio.BASS_ASIO_Init(0)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' assign ASIO output to the first device and channel
              ' and assume the ASIO format, samplerate and number of channels from the BASS stream
              _asio = New BassAsioHandler(0, 0, stream)
              ' start ASIO
              _asio.Start(0)
            End If
            </code>
            Automatic use of the BassAsioHandler (Asio recording input, Asio full-duplex output):
            <code>
            private BassAsioHandler _asio;
            ...
            // not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0);
            // setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, 0, 0, null);
            BassAsio.BASS_ASIO_Init(0);
            ...
            // assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = new BassAsioHandler(true, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000);
            // set the full-duplex option to the first ASIO output device and channel
            // the ASIO output format will aways be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0);
            // start ASIO
            _asio.Start(0);
            ...
            // when you want to disbale all associated channels, call:
            _asio.Dispose();
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0)
            ' setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, 0, 0, Nothing)
            BassAsio.BASS_ASIO_Init(0)
            ...
            ' assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = New BassAsioHandler(True, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000)
            ' set the full-duplex option to the first ASIO output device and channel
            ' the ASIO output format will aways be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0)
            ' start ASIO
            _asio.Start(0)
            ...
            ' when you want to disbale all associated channels, call:
            _asio.Dispose()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.#ctor">
            <summary>
            Default constructor - leaving all defaults and not assigning any ASIO channel.
            </summary>
            <remarks>Use this constructor, if you for example want to leverage the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToBassFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioInputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> or <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToAsioFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> callback methods.
            In this case make sure to also set the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> property, since this member will be used in the mentioned default callback procedures.
            Also make sure, that the ASIO channel use will use matches the samplerate and the format of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>!
            </remarks>
            <example>Manual use of the BassAsioHandler:
            <code>
            private ASIOPROC _myAsioProc;
            private BassAsioHandler _asio;
            ...
            // not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0);
            // setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, 0, 0, null);
            BassAsio.BASS_ASIO_Init(0);
            ...
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
              _asio = new BassAsioHandler();
              _asio.OutputChannel = stream;
            
              // now setup ASIO manually
              _myAsioProc = new ASIOPROC(_asio.BassToAsioOutputCallback);
              // get the stream channel info
              BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
              // enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, stream);
              // and join the next channels to it
              for (int a=1; a&lt;info.chans; a++)
                BassAsio.BASS_ASIO_ChannelJoin(false, a, 0);
              // since we joined the channels, the next commands will apply to all channles joined
              // so setting the values to the first channels changes them all automatically
              // set the source format (float, as the decoding channel is)
              BassAsio.BASS_ASIO_ChannelSetFormat(false, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT);
              // set the source rate
              BassAsio.BASS_ASIO_ChannelSetRate(false, 0, (double)info.freq);
              // try to set the device rate too (saves resampling)
              BassAsio.BASS_ASIO_SetRate( (double)info.freq );
              // and start playing it...start output using default buffer/latency
              _asio.Start(0);
            }
            </code>
            <code lang="vbnet">
            Private _myAsioProc As ASIOPROC
            Private _asio As BassAsioHandler
            ...
            ' not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0)
            ' setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, 0, 0, Nothing)
            BassAsio.BASS_ASIO_Init(0)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              _asio = New BassAsioHandler()
              _asio.OutputChannel = stream
            
              ' now setup ASIO manually
              _myAsioProc = New ASIOPROC(AddressOf _asio.BassToAsioOutputCallback)
              ' get the stream channel info
              Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
              ' enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, stream)
              ' and join the next channels to it
              Dim a As Integer
              For a = 1 To info.chans - 1
                BassAsio.BASS_ASIO_ChannelJoin(False, a, 0)
              Next a
              ' since we joined the channels, the next commands will apply to all channles joined
              ' so setting the values to the first channels changes them all automatically
              ' set the source format (float, as the decoding channel is)
              BassAsio.BASS_ASIO_ChannelSetFormat(False, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT)
              ' set the source rate
              BassAsio.BASS_ASIO_ChannelSetRate(False, 0, CDbl(info.freq))
              ' try to set the device rate too (saves resampling)
              BassAsio.BASS_ASIO_SetRate(CDbl(info.freq))
              ' and start playing it...start output using default buffer/latency
              _asio.Start(0)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,Un4seen.BassAsio.BASSASIOFormat,System.Double)">
            <summary>
            Creates an instance of the ASIO handler - initializing and enabling the given ASIO device and channel.
            </summary>
            <param name="input">Dealing with an input channel? FALSE=an output channel, TRUE = an input channel (in which case the <see cref="P:Un4seen.BassAsio.BassAsioHandler.UseInput"/> will automatically set to TRUE, so that you can use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/>.).</param>
            <param name="asioDevice">The ASIO device to use (0=first).</param>
            <param name="asioChannel">The ASIO input/output channel number (0=first).</param>
            <param name="asioNumChans">The total number of ASIO channels to use (following channels will be joined - e.g. 2 for stereo).</param>
            <param name="asioFormat">The ASIO sample format to use for the channel(s) - see <see cref="T:Un4seen.BassAsio.BASSASIOFormat"/> for details.</param>
            <param name="asioSamplerate">The desired samplerate to use with the channel(s) - use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetRate"/> or -1 if uncertain and to prevent resampling.
            If the ASIO device samplerate could not be set to the desired samplerate, the device's current samplerate will be taken instead.</param>
            <remarks>
            Use this constructor for either manual Asio handler use or for Asio input recording.
            <para>The following will be done internally:</para>
            <para>1. The ASIO device will be initialized (if already done, the ASIO device will just be set).</para>
            <para>2. The ASIO device's samplerate will be set to the given <paramref name="asioSamplerate"/> - if the ASIO device samplerate could not be changed the device's current samplerate will be taken!</para>
            <para>3a. If input: use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioInputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> as the internal <see cref="T:Un4seen.BassAsio.ASIOPROC"/>. Also <see cref="P:Un4seen.BassAsio.BassAsioHandler.UseInput"/> will be set to TRUE, so that you can use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> to retrieve the recorded sample data.</para>
            <para>3b. If output: use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioOutputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> as the internal <see cref="T:Un4seen.BassAsio.ASIOPROC"/>.</para>
            <para>4. If the ASIO device was already started, it will be stopped when necessary (only if the ASIO channel has not yet been enabled). The device will be started again.</para>
            <para>5. Enable and join the given <paramref name="asioChannel"/> with the following channels according to the total <paramref name="asioNumChans"/>.</para>
            <para>6. Set the ASIO channel format and samplerate according to the given <paramref name="asioSamplerate"/> and <paramref name="asioFormat"/>.</para>
            <para>Note: If the given <paramref name="asioChannel"/> has already been enabled, it will be reused and not enabled and joined again!
            This means, that the channel number of the already joined channel will not be changed as well and might not match to the channel number of the given <paramref name="asioNumChans"/> parameter.</para>
            </remarks>
            <example>
            Automatic use of the BassAsioHandler (Asio recording input, Asio full-duplex output):
            <code>
            private BassAsioHandler _asio;
            ...
            // not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0);
            // setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, 0, 0, null);
            BassAsio.BASS_ASIO_Init(0);
            ...
            // assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = new BassAsioHandler(true, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000);
            // set the full-duplex option to the first ASIO output device and channel
            // the ASIO output format will aways be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0);
            // start ASIO
            _asio.Start(0);
            ...
            // when you want to disbale all associated channels, call:
            _asio.Dispose();
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0)
            ' setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, 0, 0, Nothing)
            BassAsio.BASS_ASIO_Init(0)
            ...
            ' assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = New BassAsioHandler(True, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000)
            ' set the full-duplex option to the first ASIO output device and channel
            ' the ASIO output format will aways be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0)
            ' start ASIO
            _asio.Start(0)
            ...
            ' when you want to disbale all associated channels, call:
            _asio.Dispose()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an instance of the ASIO handler for output - initializing and enabling the given ASIO device and channel according to the Bass stream.
            </summary>
            <param name="asioDevice">The ASIO device to use (0=first).</param>
            <param name="asioChannel">The ASIO output channel number (0=first).</param>
            <param name="outputChannel">The BASS channel handle which should be used with ASIO output (must be a decoding or recording channel and must be either 16-bit or 32-bit).</param>
            <remarks>
            Use this constructor for automatic Asio output using either a decoding or recording <paramref name="outputChannel"/>.
            <para>The following will be done internally:</para>
            <para>1. The ASIO device will be initialized (if already done, the ASIO device will just be set).</para>
            <para>2. The samplerate, format and number of channels will be determined from the given <paramref name="outputChannel"/>.</para>
            <para>3. The ASIO device will be set to the determined samplerate. If this fails, the current ASIO samplerate will not be changed. In this case it might happen (if ASIO device samplerate and stream samplerate are different) that the ASIO output needs to be resampled.</para>
            <para>4. Output: use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioOutputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> as the internal <see cref="T:Un4seen.BassAsio.ASIOPROC"/>.</para>
            <para>4. Enable and join the given <paramref name="asioChannel"/> with the following channels according to the total number of chans of the <paramref name="outputChannel"/>.</para>
            <para>5. Set the <paramref name="asioChannel"/> format and samplerate according to the given samplerate and format of the <paramref name="outputChannel"/>.</para>
            <para>Note: If the given <paramref name="asioChannel"/> has already been enabled, it will be reused and not enabled and joined again!
            This means, that the channel number of the already joined channel will not be changed as well and might not match to the channel number of the given <paramref name="outputChannel"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid channel: must be a valid BASS channel (either decoding or recording).</exception>
            <example>
            Automatic use of the BassAsioHandler (Asio output from a Bass stream):
            <code>
            private BassAsioHandler _asio;
            ...
            // not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0);
            // setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, 0, 0, null);
            BassAsio.BASS_ASIO_Init(0);
            ...
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
              // assign ASIO output to the first device and channel
              // and assume the ASIO format, samplerate and number of channels from the BASS stream
              _asio = new BassAsioHandler(0, 0, stream);
              // start ASIO
              _asio.Start(0);
            }
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0)
            ' setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, 0, 0, Nothing)
            BassAsio.BASS_ASIO_Init(0)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' assign ASIO output to the first device and channel
              ' and assume the ASIO format, samplerate and number of channels from the BASS stream
              _asio = New BassAsioHandler(0, 0, stream)
              ' start ASIO
              _asio.Start(0)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.Dispose">
            <summary>
            Disposes an instance of this class also unjoining and disabling all used ASIO channels.
            </summary>
            <remarks>The used ASIO channel(s) will be unjoined and disabled! This means, that the ASIO device needs to stopped for a short moment!
            <para>Caution: Once you created an instance of this class, the respective ASIO channel(s) are joined and enabled.
            Calling this method will automatically unjoin and disable the used ASIO channels as well as the full-duplex and mirror channels will be removed and disabled!
            If you want to prevent this little break in the ASIO device (since the ASIO device needs to be stopped for a short moment) make sure this method is never called during the device is started.</para>
            <para>Also if you want to leave all ASIO channels enabled (even if you do not need this instance anymore) do NOT call this method! In such case you might call <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveMirror"/> and <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)"/> manually if needed, 
            and you might also call <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/> or <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelReset(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOReset)"/> manually.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.Start(System.Int32)">
            <summary>
            Starts the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/>.
            </summary>
            <param name="buflen">Buffer length in samples... 0 = use current length.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Calls <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)"/> internally on the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> being used by the Asio handler (if not already started).
            <para>If you need to stop the Asio device you might call <see cref="M:Un4seen.BassAsio.BassAsioHandler.Stop"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.Stop">
            <summary>
            Stops the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/>.
            </summary>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Calls <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Stop"/> internally on the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> being used by the Asio handler (if not already stopped).
            <para>If you need to start the Asio device you might call <see cref="M:Un4seen.BassAsio.BassAsioHandler.Start(System.Int32)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.StartFullDuplex(System.Int32)">
            <summary>
            Starts the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice"/>.
            </summary>
            <param name="buflen">Buffer length in samples... 0 = use current length.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Calls <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)"/> internally on the <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice"/> being used by the Asio handler (if not already stopped and if used).
            <para>If you need to stop the full-duplex Asio device you might call <see cref="M:Un4seen.BassAsio.BassAsioHandler.StopFullDuplex"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.StopFullDuplex">
            <summary>
            Stops the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice"/>.
            </summary>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Calls <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Stop"/> internally on the <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice"/> being used by the Asio handler (if not already stopped and if used).
            <para>If you need to start the full-duplex Asio device you might call <see cref="M:Un4seen.BassAsio.BassAsioHandler.StartFullDuplex(System.Int32)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.Pause(System.Boolean)">
            <summary>
            Pauses or Unpauses the ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/>(s) being used.
            </summary>
            <param name="pause">TRUE if you want to pause the ASIO channel(s) - FALSE if you want to unpause.</param>
            <returns>On success TRUE is returned, else FALSE will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>When in full-duplex input mode (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInputFullDuplex"/>) the related AISO input as well as the ASIO output channel(s) will be (un)paused.</remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.PauseMirror(System.Boolean)">
            <summary>
            Pauses or Unpauses the <see cref="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel"/>(s) being used.
            </summary>
            <param name="pause">TRUE if you want to pause the ASIO channel(s) - FALSE if you want to unpause.</param>
            <returns>On success TRUE is returned, else FALSE will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.AssignOutputChannel(System.Int32)">
            <summary>
            Assigns a (new) BASS channel handle for ASIO output.
            </summary>
            <param name="outputChannel">The BASS channel handle which should be used with ASIO output (should be a decoding or recording channel and must be either 16-bit or 32-bit) - or 0 (zero) to remove an existing <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>.</param>
            <returns>On success TRUE is returned, else FALSE will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>
            <para>The following will be done internally:</para>
            <para>1. The current ASIO channel will be paused (if already enabled).</para>
            <para>2. The samplerate, format and number of channels will be determined from the given <paramref name="outputChannel"/>.</para>
            <para>3. The ASIO device will be set to the determined samplerate. If this fails, the current ASIO samplerate will not be changed. In this case it might happen (if ASIO device samplerate and stream samplerate are different) that the ASIO output needs to be resampled.</para>
            <para>4a. ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> enabled: use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioOutputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> as the internal <see cref="T:Un4seen.BassAsio.ASIOPROC"/>, if the ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> was already enabled and joined, it will not be changed.</para>
            <para>4b. ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> disabled: Enable and join the given <paramref name="asioChannel"/> with the following channels according to the total number of chans of the <paramref name="outputChannel"/>.</para>
            <para>5. Set the ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> format and samplerate according to the given samplerate and format of the <paramref name="outputChannel"/>.</para>
            <para>6. The current ASIO channel will be unpaused (if it was paused before).</para>
            <para>This method can not be used with ASIO input (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/>). It will immediately return with no effect.</para>
            <para>Tyically a decoding channel must be used, but a recording channel will also work, since the interal ASIO procedure being used simply calls <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to pull the sample data from the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> as needed and reqested by ASIO.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid channel: must be a valid BASS channel (either decoding or recording).</exception>
            <example>
            Automatic use of the BassAsioHandler (output):
            <code>
            private BassAsioHandler _asio;
            ...
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
              // assign ASIO output to the first device and channel
              // and assume the ASIO format, samplerate and number of channels from the BASS stream
              _asio = new BassAsioHandler(0, 0, stream);
              // start ASIO
              BassAsio.BASS_ASIO_Start(0);
            }
            ...
            // assign a new channel to ASIO output
            Bass.BASS_StreamFree(stream);
            int newStream = Bass.BASS_StreamCreateFile(newFileName, 0, 0, 
                                 BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT );
            _asio.AssignOutputChannel(newStream);
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' assign ASIO output to the first device and channel
              ' and assume the ASIO format, samplerate and number of channels from the BASS stream
              _asio = New BassAsioHandler(0, 0, stream)
              ' start ASIO
              BassAsio.BASS_ASIO_Start(0)
            End If
            ...
            ' assign a new channel to ASIO output
            Bass.BASS_StreamFree(stream)
            Dim newStream As Integer = Bass.BASS_StreamCreateFile(newFileName, 0, 0, 
                                            BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            _asio.AssignOutputChannel(newStream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)">
            <summary>
            Sets the full-duplex option for ASIO input using the given ASIO output device and channel.
            </summary>
            <param name="asioDevice">The ASIO output device which should be used for full-duplex monitoring.</param>
            <param name="asioChannel">The ASIO output channel which should be used for full-duplex monitoring.</param>
            <returns>On success TRUE is returned, else FALSE will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>
            <para>The full-duplex options is only available on input channels. However even a full-duplex output channel on a different ASIO device might even be used.</para>
            <para>If you want to mirror an ASIO input channel to an output channel on the same device, you might might also use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetMirror(System.Int32)"/> method instead, which is more efficient in such case.</para>
            <para>The following will be done internally:</para>
            <para>1. The ASIO input <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> will be used (and enabled and joined, only if not enabled yet).</para>
            <para>2. A custom dummy decoding stream (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>) will be created with the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToAsioFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> as the internal <see cref="T:Un4seen.BassAsio.ASIOPROC"/>.</para>
            <para>3. The samplerate, format and number of channels will not be changed for ASIO input, since this will be used as already specified in the constructor.</para>
            <para>4. The ASIO output <paramref name="asioDevice"/> will only be stopped, if already started and the <paramref name="asioChannel"/> has not yet been enabled - it will automatically be started again if needed.</para>
            <para>5. The ASIO output device will be set to the same samplerate as the ASIO input. If this fails, the current ASIO samplerate will not be changed. In this case it might happen (if ASIO device samplerate and input samplerate are different) that the ASIO output needs to be resampled.</para>
            <para>6. The ASIO output <paramref name="asioChannel"/> will be enabled and joined (only if not already enabled) as well as the format and samplerate will be set. All according to the given number of channels, samplerate and format of the ASIO input <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/>.</para>
            <para>This method can not be used with ASIO output (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/>). It will immediately return with no effect.</para>
            <para>To disable and remove the full-duplex option call <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)"/>.</para>
            <para>The full-duplex ASIO output is provided by an internal custom dummy decoding stream <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>. You might use this stream to set up DSPs or FX on it so that these are applied on the ASIO output.</para>
            </remarks>
            <example>
            Automatic use of the BassAsioHandler (Asio recording input, full-duplex Asio output):
            <code>
            private BassAsioHandler _asio;
            private DSP_PeakLevelMeter _plm;
            ...
            // assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = new BassAsioHandler(true, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000);
            // set the full-duplex option to the first ASIO output device and channel
            // the ASIO output format will always be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0);
            
            // set up a ready-made DSP (here the PeakLevelMeter) on the full-duplex channel
            _plm = new DSP_PeakLevelMeter(_asio.OutputChannel, 0);
            _plm.UpdateTime = 0.1f; // 100ms
            _plm.CalcRMS = true;
            _plm.Notification += new EventHandler(OnPlmNotification);
            
            // start ASIO
            BassAsio.BASS_ASIO_Start(0);
            ...
            private void OnPlmNotification(object sender, EventArgs e)
            {
              if (_plm == null)
                return;
              // sender will be the DSP_PeakLevelMeter instance
              // you could also access it via: DSP_PeakLevelMeter p = (DSP_PeakLevelMeter)sender;
              this.progressBarPeak1Left.Value = _plm.LevelL;
              this.progressBarPeak1Right.Value = _plm.LevelR;
              this.labelLevel1.Text = String.Format( "RMS: {0:#00.0} dB   AVG: {1:#00.0} dB   Peak: {2:#00.0} dB", 
                   _plm.RMS_dBV, _plm.AVG_dBV, Math.Max(_plm.PeakHoldLevelL_dBV, _plm.PeakHoldLevelR_dBV) );
            }
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            Private _plm As DSP_PeakLevelMeter
            ...
            ' assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = New BassAsioHandler(True, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000)
            ' set the full-duplex option to the first ASIO output device and channel
            ' the ASIO output format will always be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0)
            
            ' set up a ready-made DSP (here the PeakLevelMeter) on the full-duplex channel
            _plm = New DSP_PeakLevelMeter(_asio.OutputChannel, 0)
            _plm.UpdateTime = 0.1F ' 100ms
            _plm.CalcRMS = True
            AddHandler _plm.Notification, AddressOf OnPlmNotification
            
            ' start ASIO
            BassAsio.BASS_ASIO_Start(0)
            ...
            Private Sub OnPlmNotification(sender As Object, e As EventArgs)
              If _plm Is Nothing Then
                Return
              End If
              ' sender will be the DSP_PeakLevelMeter instance
              ' you could also access it via: 
              ' Dim p As DSP_PeakLevelMeter = CType(sender, DSP_PeakLevelMeter)
              Me.progressBarPeak1Left.Value = _plm.LevelL
              Me.progressBarPeak1Right.Value = _plm.LevelR
              Me.labelLevel1.Text = [String].Format("RMS: {0:#00.0} dB   AVG: {1:#00.0} dB   Peak: {2:#00.0} dB", 
                 _plm.RMS_dBV, _plm.AVG_dBV, Math.Max(_plm.PeakHoldLevelL_dBV, _plm.PeakHoldLevelR_dBV))
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,Un4seen.Bass.BASSFlag,System.Boolean)">
            <summary>
            Sets the full-duplex option for ASIO input using the given BASS output device.
            </summary>
            <param name="bassDevice">The BASS output device which should be used for full-duplex monitoring.</param>
            <param name="flags">The optional <see cref="T:Un4seen.Bass.BASSFlag"/> flags to be used to create the full-duplex monitoring <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>.
            Typically only the following flags should be used: BASS_STREAM_DECODE, BASS_SAMPLE_SOFTWARE or BASS_SPEAKER_xxx.</param>
            <param name="buffered">TRUE, if the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> should be (pre)buffered - else FALSE.
            <para>Prebuffering of sample data is often requied for buffered output to enable a constant playback. So even if you are using a BASS_STREAM_DECODE flag you might need to prebuffer it's data.</para>
            </param>
            <returns>On success TRUE is returned, else FALSE will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>
            <para>The following will be done internally:</para>
            <para>1. The ASIO input <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> will be used (and enabled and joined, only if not enabled yet).</para>
            <para>2. The BASS output <paramref name="bassDevice"/> will be used.</para>
            <para>3. A custom push stream (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>) will be created (using the given <paramref name="flags"/>) with an internal ASIO callback to push the ASIO sample data from the input to the output.</para>
            <para>4. The samplerate, format and number of channels will not be changed for ASIO input, since this will be used as already specified in the constructor.</para>
            <para>5. The custom push stream will be started playing (via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) - unless the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_DECODE"/> flag has been specified.</para>
            <para>This method can not be used with ASIO output (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/>). It will immediately return with no effect.</para>
            <para>To disable and remove the full-duplex option call <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)"/>.</para>
            <para>The full-duplex BASS output is provided by the internal custom push stream <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>. You might use this stream to set up DSPs or FX on it so that these are applied on the BASS output.</para>
            <para>You might use the 0 (no-sound) bass device together with the BASS_STREAM_DECODE flag in order to create a custom decoding <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> which might for example be used with an <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> or <see cref="T:Un4seen.Bass.Misc.WaveWriter"/> or 
            as a source for a <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">mixer channel</see>.</para>
            </remarks>
            <example>
            Automatic use of the BassAsioHandler (Asio recording input, full-duplex to BASS):
            <code>
            private BassAsioHandler _asio;
            ...
            // assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = new BassAsioHandler(true, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000);
            // set the full-duplex option to the first BASS output device using the rear speakers
            // the BASS output format will always be the same as the ASIO input for full-duplex
            _asio.SetFullDuplex(1, BASSFlag.BASS_SPEAKER_REAR, true);
            
            // start ASIO
            BassAsio.BASS_ASIO_Start(0);
            
            // setup an FX on the full-duplex BASS output
            BASS_FXECHO echo = new BASS_FXECHO();
            int fxHandle = Bass.BASS_ChannelSetFX(_asio.OutputChannel, BASSFXType.BASS_FX_ECHO, 0);
            echo.Preset_Long();
            // apply the effect parameters
            Bass.BASS_FXSetParameters(fxHandle, echo);
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = New BassAsioHandler(True, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000)
            ' set the full-duplex option to the first BASS output device using the rear speakers
            ' the BASS output format will always be the same as the ASIO input for full-duplex
            _asio.SetFullDuplex(1, BASSFlag.BASS_SPEAKER_REAR, True)
            
            ' start ASIO
            BassAsio.BASS_ASIO_Start(0)
            
            ' setup an FX on the full-duplex BASS output
            Dim echo As New BASS_FXECHO()
            Dim fxHandle As Integer = Bass.BASS_ChannelSetFX(_asio.OutputChannel, BASSFXType.BASS_FX_ECHO, 0)
            echo.Preset_Long()
            ' apply the effect parameters
            Bass.BASS_FXSetParameters(fxHandle, echo)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)">
            <summary>
            Removes the full-duplex option from ASIO input.
            </summary>
            <param name="disableOutput">Disable and unjoin the ASIO output channel? FALSE=leave them enabled and joined.</param>
            <returns>On success TRUE is returned, else FALSE will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>The full-duplex option must have been set before via <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/>.
            <para>The following will be done internally:</para>
            <para>1. The ASIO output <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice"/> will be stopped (if already started).</para>
            <para>2. The ASIO output <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexChannel"/> will be disabled and unjoined.</para>
            <para>3. The ASIO output device will be started again (only, if it has been started before).</para>
            <para>4. The ASIO input <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> will be stopped (if already started).</para>
            <para>5. The ASIO input <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> will be disabled.</para>
            <para>6. Any custom dummy decoding stream (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>) will be freed and the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioInputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> will again be used as the internal <see cref="T:Un4seen.BassAsio.ASIOPROC"/>.</para>
            <para>7. The ASIO input channel will be (re)enabled, the samplerate, format and number of channels will not be changed for ASIO input, since this will be used as already specified in the constructor.</para>
            <para>8. The ASIO input device will be started again (only, if it has been started before).</para>
            <para>Note: This method will only disable the <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexChannel"/> if specified in the <paramref name="disableOutput"/> parameter.</para>
            <para>This method can not be used with ASIO output (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/>). It will immediately return with no effect.</para>
            <para>To enable the full-duplex option again, call <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/>.</para>
            </remarks>
            <example>
            Automatic use of the BassAsioHandler (recording input, full-duplex):
            <code>
            private BassAsioHandler _asio;
            ...
            // assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = new BassAsioHandler(true, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000);
            // set the full-duplex option to the first ASIO output device and channel
            // the ASIO output format will aways be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0); // first output device and channel
            // start ASIO
            _asio.Start(0);
            ...
            // remove the full-duplex option and leave the channel enabled
            _asio.RemoveFullDuplex(false);
            // but pause the unused output channel
            BassAsio.BASS_ASIO_ChannelPause(false, 0);
            ...
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = New BassAsioHandler(True, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000)
            ' set the full-duplex option to the first ASIO output device and channel
            ' the ASIO output format will aways be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0) ' first output device and channel
            ' start ASIO
            _asio.Start(0)
            ...
            ' remove the full-duplex option and leave the channel enabled
            _asio.RemoveFullDuplex(False)
            ' but pause the unused output channel
            BassAsio.BASS_ASIO_ChannelPause(False, 0)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.SetMirror(System.Int32)">
            <summary>
            Mirrors the current ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> to the given output channel.
            </summary>
            <param name="asioChannel">The output channel number... 0 = first.</param>
            <returns>On success TRUE is returned, else FALSE will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>
            <para>This function allows the input or output <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> to be duplicated in other output channel. Mirroring is only available on the same ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/>!</para>
            <para>If you need to monitor an input channel on a different ASIO device, you might use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> method instead.</para>
            <para>The following will be done internally:</para>
            <para>1. The ASIO <paramref name="Device"/> will only be stopped, if already started - it will automatically be started again if needed.</para>
            <para>2. The ASIO output <paramref name="asioChannel"/> will be enabled and mirrored (only if not already enabled). All according to the given <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/>, meaning starting with the <paramref name="asioChannel"/> this one and the next channels will be used as the mirror channels.</para>
            <para>To disable and remove the mirror option call <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveMirror"/>.</para>
            </remarks>
            <example>
            Automatic use of the BassAsioHandler (recording input, mirrored):
            <code>
            private BassAsioHandler _asio;
            ...
            // assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = new BassAsioHandler(true, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000);
            // set the mirror option to the first ASIO output device and channel
            _asio.SetMirror(0);
            ...
            // start ASIO
            _asio.Start(0);
            ...
            // remove the mirror when not needed
            _asio.RemoveMirror();
            ...
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = New BassAsioHandler(True, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000)
            ' set the mirror option to the first ASIO output device and channel
            _asio.SetMirror(0)
            ...
            ' start ASIO
            _asio.Start(0)
            ...
            ' remove the mirror when not needed
            _asio.RemoveMirror()
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.RemoveMirror">
            <summary>
            Removes a mirror set on the current ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/>.
            </summary>
            <returns>On success TRUE is returned, else FALSE will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>The mirror option must have been set before via <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetMirror(System.Int32)"/>.
            <para>The following will be done internally:</para>
            <para>1. The ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> will be stopped (if already started).</para>
            <para>2. The ASIO output <see cref="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel"/> will be disabled.</para>
            <para>3. The ASIO device will be started again (only, if it has been started before).</para>
            <para>CAUTION: This method will always disable the <see cref="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel"/>(s)!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.AsioOutputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Provides a ready made <see cref="T:Un4seen.BassAsio.ASIOPROC"/> callback procedure which might be used for ASIO output.
            </summary>
            <param name="input">Dealing with an input channel? Must be FALSE, since we are dealing with Asio output.</param>
            <param name="channel">The output channel number... 0 = first.</param>
            <param name="buffer">The pointer to the buffer in which to put the data to output.</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">Not used.</param>
            <returns>The number of bytes written.</returns>
            <remarks>Notes:
            <para>In order to use this default output ASIO callback (playback), you need to make sure that you use this callback only with ASIO output (<see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/> must be FALSE).</para>
            <para>Furthermore the following should be considered: If the underlying stream channel <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> is at the end (all data was decoded), 
            this callback does NOT automatically pause ASIO via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelPause(System.Boolean,System.Int32)"/> or <see cref="M:Un4seen.BassAsio.BassAsioHandler.Pause(System.Boolean)"/>.
            So you need to do that by yourself (if you whish to save some performance), e.g. setup a <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">BASS_SYNC_END</see> on the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>.
            If the underlying <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> returns less data, than requested the ASIO output buffer will be filled with 0's (silence).</para>
            <para>Internally <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> will be called on the underlying <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> to request sample data, before the sample data is send to the ASIO output.</para>
            <para>If you intend to overload this callback in a derive implementation make sure to call the base method to not loose any functionatily.</para>
            </remarks>
            <example>
            Implementing your own callback in a derived implementation:
            <code>
            public class MyAsioHandler : BassAsioHandler
            {
            
              public override int AsioOutputCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
              {
                // buffer is not filled
                // do your own stuff here...
                int len = base.AsioOutputCallback(input, channel, buffer, length, user);
                if (len &gt; 0)
                {
                  // buffer is already filled
                  // do your own stuff here...
                }
                return len;
              }
            
            }
            </code>
            <code lang="vbnet">
            Public Class MyAsioHandler 
              Inherits BassAsioHandler
            
              Public Overrides Function AsioOutputCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
                ' buffer is already filled
                ' do your own stuff here...
                Dim len As Integer = MyBase.AsioOutputCallback(input, channel, buffer, length, user)
                If len &gt; 0 Then
                  ' buffer is already filled
                  ' do your own stuff here...
                End If
                Return len
              End Function
            
            End Class
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.AsioInputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Provides a ready made <see cref="T:Un4seen.BassAsio.ASIOPROC"/> callback procedure which might be used for ASIO input.
            </summary>
            <param name="input">Dealing with an input channel? Must be TRUE, since we are only dealing with Asio input.</param>
            <param name="channel">The input channel number... 0 = first.</param>
            <param name="buffer">The pointer to the buffer containing the recorded data (input channel).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">Not used.</param>
            <returns>Returns 0, since we are only dealing with Asio input.</returns>
            <remarks>
            To receive the recorded sample data you might use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> and set up a DSP on it.
            <para>If you intend to overload this callback in a derive implementation make sure to call the base method to not loose any functionatily.</para>
            </remarks>
            <example>
            Implementing your own callback in a derived implementation:
            <code>
            public class MyAsioHandler : BassAsioHandler
            {
            
              public override int AsioInputCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
              {
                // InputChannel not applied yet
                // do your own stuff here...
                int len = base.AsioInputCallback(input, channel, buffer, length, user);
                // InputChannel already applied
                // do your own stuff here...
                return len;
              }
            
            }
            </code>
            <code lang="vbnet">
            Public Class MyAsioHandler 
              Inherits BassAsioHandler
            
              Public Overrides Function AsioInputCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
                ' InputChannel not applied yet
                ' do your own stuff here...
                Dim len As Integer = MyBase.AsioInputCallback(input, channel, buffer, length, user)
                ' InputChannel already applied
                ' do your own stuff here...
                Return len
              End Function
            
            End Class
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.AsioToAsioFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Provides a ready made <see cref="T:Un4seen.BassAsio.ASIOPROC"/> callback procedure which might be used for full-duplex ASIO input to Asio output.
            </summary>
            <param name="input">Dealing with an input channel? FALSE = an output channel, TRUE = an input channel (both input and output must be supported by this callback).</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="buffer">The pointer to the buffer containing the recorded data (if input), or in which to put the data to output (if output).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">Not used.</param>
            <returns>The number of bytes written (if output), else 0 (if input).</returns>
            <remarks>
            To apply DSP/FX independetly to the input and output you might use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> respectively.
            <para>If you intend to overload this callback in a derive implementation make sure to call the base method to not loose any functionatily.</para>
            </remarks>
            <example>
            Implementing your own callback in a derived implementation:
            <code>
            public class MyAsioHandler : BassAsioHandler
            {
            
              public override int AsioToAsioFullDuplexCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
              {
                // FullDuplex not applied yet
                if (input)
                {
                  // do your own input stuff here...
                }
                else
                {
                  // do your own output stuff here...
                }
                int len = base.AsioToAsioFullDuplexCallback(input, channel, buffer, length, user);
                // FullDuplex already applied
                if (input)
                {
                  // do your own input stuff here...
                }
                else
                {
                  // do your own output stuff here...
                }
                return len;
              }
            
            }
            </code>
            <code lang="vbnet">
            Public Class MyAsioHandler 
              Inherits BassAsioHandler
            
              Public Overrides Function AsioToAsioFullDuplexCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
                ' FullDuplex not applied yet
                If input Then
                  ' do your own input stuff here...
                Else
                  ' do your own output stuff here...
                End If
                Dim len As Integer = MyBase.AsioToAsioFullDuplexCallback(input, channel, buffer, length, user)
                ' FullDuplex already applied
                If input Then
                  ' do your own input stuff here...
                Else
                  ' do your own output stuff here...
                End If
                Return len
              End Function
            
            End Class
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.AsioToBassFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Provides a ready made <see cref="T:Un4seen.BassAsio.ASIOPROC"/> callback procedure which might be used for full-duplex ASIO input to Bass output.
            </summary>
            <param name="input">Dealing with an input channel? Must be TRUE, since we are only dealing with Asio input (full-duplex output is via <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>).</param>
            <param name="channel">The input channel number... 0 = first.</param>
            <param name="buffer">The pointer to the buffer containing the recorded data.</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">Not used.</param>
            <returns>Returns 0, since we are only dealing with Asio input.</returns>
            <remarks>
            To apply DSP/FX independetly to the input and output you might use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> respectively.
            <para>If you intend to overload this callback in a derive implementation make sure to call the base method to not loose any functionatily.</para>
            </remarks>
            <example>
            Implementing your own callback in a derived implementation:
            <code>
            public class MyAsioHandler : BassAsioHandler
            {
            
              public override int AsioToBassFullDuplexCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
              {
                // FullDuplex not applied yet
                if (input)
                {
                  // do your own input stuff here...
                }
                else
                {
                  // do your own output stuff here...
                }
                int len = base.AsioToBassFullDuplexCallback(input, channel, buffer, length, user);
                // FullDuplex already applied
                if (input)
                {
                  // do your own input stuff here...
                }
                else
                {
                  // do your own output stuff here...
                }
                return len;
              }
            
            }
            </code>
            <code lang="vbnet">
            Public Class MyAsioHandler 
              Inherits BassAsioHandler
            
              Public Overrides Function AsioToBassFullDuplexCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
                ' FullDuplex not applied yet
                If input Then
                  ' do your own input stuff here...
                Else
                  ' do your own output stuff here...
                End If
                Dim len As Integer = MyBase.AsioToBassFullDuplexCallback(input, channel, buffer, length, user)
                ' FullDuplex already applied
                If input Then
                  ' do your own input stuff here...
                Else
                  ' do your own output stuff here...
                End If
                Return len
              End Function
            
            End Class
            </code>
            </example>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.InternalAsioProc">
            <summary>
            Gets the <see cref="T:Un4seen.BassAsio.ASIOPROC"/> currently being used by the Asio handler.
            </summary>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.Volume">
            <summary>
            Gets or Sets the volume of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> (and all joined <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/>) between 0 (silent) and 1 (full).
            </summary>
            <remarks>Setting the volume uses the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Pan"/> property in case of multi-channel ASIO (<see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> is greater than 1).
            <para>The volume level ranges from 0 (silent) to 1 (normal) or above 1 to amplify the sound.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.VolumeMirror">
            <summary>
            Gets or Sets the volume of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel"/> (and all attached <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/>) between 0 (silent) and 1 (full).
            </summary>
            <remarks>Setting the volume uses the <see cref="P:Un4seen.BassAsio.BassAsioHandler.PanMirror"/> property in case of multi-channel ASIO (<see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> is greater than 1).
            <para>The volume level ranges from 0 (silent) to 1 (normal) or above 1 to amplify the sound.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.Pan">
            <summary>
            Gets or Sets the panning of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> (and all joined <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/>) between -1 (left) to +1 (right), 0=centered.
            </summary>
            <remarks>Setting the panning uses the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Volume"/> property in order to calculate the individual channel volume.
            E.g. if you set the panning to -0.7 at a volume of 1.0: chan1-volume (left) = 0.3, chan2-volume (right) = 1.0.
            <para>The panning value ranges from -1 (left) to 0 (center) to +1 (right).</para>
            <para>In case of multi-channel (not stereo, <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> is greater than 2) the left/right positions are interleaved between the additional channels.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.PanMirror">
            <summary>
            Gets or Sets the panning of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel"/> (and all attached <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/>) between -1 (left) to +1 (right), 0=centered.
            </summary>
            <remarks>Setting the panning uses the <see cref="P:Un4seen.BassAsio.BassAsioHandler.VolumeMirror"/> property in order to calculate the individual channel volume.
            E.g. if you set the panning to -0.7 at a volume of 1.0: chan1-volume (left) = 0.3, chan2-volume (right) = 1.0.
            <para>The panning value ranges from -1.0 (left) to 0.0 (center) to +1.0 (right).</para>
            <para>In case of multi-channel (not stereo, <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> is greater than 2) the left/right positions are interleaved between the additional channels.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.IsInput">
            <summary>
            Returns TRUE, if the ASIO handler is used with an ASIO input device.
            </summary>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.Device">
            <summary>
            Returns the ASIO device being used by the ASIo handler.
            </summary>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.Channel">
            <summary>
            Returns the first ASIO channel being used.
            </summary>
            <remarks>The class will automatically join ASIO channels together when needed (done in the constructor).
            This property reflects the first ASIO channel being used. The <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> property will tell you how many channels are effectively joined and enabled starting with this channel.
            <para>You can not change the number of ASIO channels once joined and enabled.</para>
            <para>Caution: Once you created an instance of this class, the respective ASIO channels are joined and enabled.
            Disposing an instance of this class will not automatically unjoin and disable the used ASIO channels.
            If you want to do so, please call the appropriate overload of the <see cref="M:Un4seen.BassAsio.BassAsioHandler.Dispose"/> method manually.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.IsInputFullDuplex">
            <summary>
            Returns TRUE, if the ASIO handler is used with an ASIO input device and the full-duplex option was set via <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice">
            <summary>
            Returns the full-duplex ASIO output device being used (or -1, if not used).
            </summary>
            <remarks>Note: This property might also return the full-duplex BASS device, if the related <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> overload was used.</remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexChannel">
            <summary>
            Returns the first full-duplex ASIO output channel being used (or -1, if not used).
            </summary>
            <remarks>Note: This property might also return -1 if the full-duplex option was used with a BASS device, if the related <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> overload was used.
            <para>If the ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> is a multi-channel (the <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> property is greater than 1) this property will return the first full-duplex channel only.
            However, full-duplex always enables <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> channels, starting with this one.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.IsMirrored">
            <summary>
            Returns if the ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> is being mirrored to another output channel.
            </summary>
            <remarks>You can enable mirroring with the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetMirror(System.Int32)"/> method and remove it with the <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveMirror"/> method.
            <para>Mirroring allows an ASIO input or output <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> to be duplicated in other output channel (the <see cref="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel"/>).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel">
            <summary>
            Gets the first ASIO mirror channel (or -1 if not mirrored).
            </summary>
            <remarks>You can enable mirroring with the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetMirror(System.Int32)"/> method and remove it with the <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveMirror"/> method.
            <para>Mirroring allows an ASIO input or output <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> to be duplicated in other output channel. The property returnes the mirror channel.</para>
            <para>If the ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> is a multi-channel (the <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> property is greater than 1) this property will return the first mirrored channel only.
            However, mirroring will always mirror <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> channels, starting with this one.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.SampleRate">
            <summary>
            Gets or Sets the actual ASIO channel sample rate in Hz (default is 48000).
            </summary>
            <remarks>By default the samplerate will automatically be adjusted according to the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> being used.
            However, you might change the samplerate for this ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> manually, which might result in resampling, since this property does not change the ASIO device samplerate.</remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans">
            <summary>
            Gets the total number of ASIO channel which are joined together, starting with <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/>.
            </summary>
            <remarks>The class will automatically join ASIO channels together when needed (done in the constructor).
            This property reflects the total of ASIO channels used. Depending on which constructor overload you used, this number can be based on the number of channels of the given <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>.
            <para>You can not change the number of ASIO channels once joined and enabled.</para>
            <para>Caution: Once you created an instance of this class, the respective ASIO channels are joined and enabled.
            Disposing an instance of this class will not automatically unjoin and disable the used ASIO channels.
            If you want to do so, please call the appropriate overload of the <see cref="M:Un4seen.BassAsio.BassAsioHandler.Dispose"/> method manually.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.Format">
            <summary>
            Gets or Sets the actual ASIO channel format (default is BASS_ASIO_FORMAT_FLOAT).
            </summary>
            <remarks>By default the format will automatically be adjusted according to the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> being used.
            However, you might change the format for this ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> manually.</remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel">
            <summary>
            Gets or Sets the BASS output channel handle which is used with this ASIO handler.
            </summary>
            <remarks>
            <para>When using the ASIO handler with an ASIO input device this channel is not available (unless you use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> method, 
            in which case you might use this property to access the full-duplex output channel to apply DSP/FX).</para>
            <para>When using the ASIO handler with an ASIO output device this channel will be assigned once and can later be changed by calling <see cref="M:Un4seen.BassAsio.BassAsioHandler.AssignOutputChannel(System.Int32)"/> 
            and will represent the channel feeding the ASIO output with sample data. Tyically a decoding channel must be used, 
            but a recording channel will also work, since the interal ASIO procedure being used simply calls <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to pull the sample data from it as needed and reqested by ASIO.</para>
            <para>Caution: Setting this parameter manually might break the ASIO chain - only assign it manually, if the BASS chanel uses the same format and samplerate as the related ASIO channel.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.IsResampling">
            <summary>
            Returns TRUE, if resampling takes place on the used <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/>.
            </summary>
            <remarks>Resampling is needed, if the ASIO channel samplerate is different than the ASIO device samplerate.
            If you are using ASIO input with the full-duplex option this property will check both, if resampling happens either on the ASIO input or on the ASIO output.</remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.InputChannel">
            <summary>
            Returns an input channel which allows you to retrieve the recorded sample data and/or apply any DSP/FX on Asio input.
            </summary>
            <remarks>When you are using ASIO with input (<see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/> must return TRUE) and have set the <see cref="P:Un4seen.BassAsio.BassAsioHandler.UseInput"/> property to TRUE 
            you might use this channel to setup any DSP/FX to be applied to the Asio input or just retrieve the recorded sample data. 
            Any DSP/FX set on this channel will also be passed through to the output, if you are using <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/>.
            <para>Note: However, you might independently set any DSP/FX only on the full-duplex output using the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> instead.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.UseInput">
            <summary>
            Enables the use of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> channel with ASIO input (which is the default for Asio input).
            </summary>
            <remarks>When you are using ASIO with input (<see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/> must return TRUE) and set this property to TRUE 
            you might use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> to setup any DSP/FX to be applied to the Asio input or retrieve the recorded sample data. 
            Any DSP/FX set on this channel will also be passed through to the output, if you are using <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/>.
            <para>Note: However, you might independently set any DSP/FX only on the full-duplex output using the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> instead.</para>
            </remarks>
        </member>
        <member name="E:Un4seen.BassAsio.BassAsioHandler.Notification">
            <summary>
            Event handler used to notify that an asio handler notification event (sync) has occurred.
            </summary>
            <remarks>
            <para>The <see cref="T:Un4seen.BassAsio.BassAsioHandlerEventArgs"/> contains a <see cref="T:Un4seen.BassAsio.BassAsioHandlerSyncType"/> which allows you to react to a possible sync scenarios.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.BassAsio.BassAsioHandler.BassAsioHandlerEventHandler">
            <summary>
            Definition of the <see cref="E:Un4seen.BassAsio.BassAsioHandler.Notification"/> event handler.
            </summary>
            <remarks>
            This definition complies with the .NET Framework's standard for event handlers.
            The sender is always set to the <see cref="T:Un4seen.BassAsio.BassAsioHandler"/> object instance that raised the event.
            </remarks>
        </member>
        <member name="T:Un4seen.BassAsio.BassAsioHandlerEventArgs">
            <summary>
            EventArgs class to be passed as the second parameter of a <see cref="E:Un4seen.BassAsio.BassAsioHandler.Notification"/> event handler.
            </summary>
            <remarks>
            This class provides all the information relevant to an event which might occur to a <see cref="T:Un4seen.BassAsio.BassAsioHandler"/> class.
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandlerEventArgs.#ctor(Un4seen.BassAsio.BassAsioHandlerSyncType,System.Int32)">
            <summary>
            Initializes a new instance of the BassAsioHandlerEventArgs class by initializing all of its properties.
            </summary>
            <param name="syncType">The type of event which occurred (see <see cref="T:Un4seen.BassAsio.BassAsioHandlerSyncType"/>).</param>
            <param name="data">Some data which should be passed along with the notification event.</param>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandlerEventArgs.SyncType">
            <summary>
            Gets the type of sync which occurred.
            </summary>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandlerEventArgs.Data">
            <summary>
            Gets the data which was passed along with the event.
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BassAsioHandlerSyncType">
            <summary>
            Types of event that has occurred with the <see cref="T:Un4seen.BassAsio.BassAsioHandler"/> class.
            </summary>
            <remarks>
            A variable of this type is passed inside the <see cref="T:Un4seen.BassAsio.BassAsioHandlerEventArgs"/> object 
            for the <see cref="E:Un4seen.BassAsio.BassAsioHandler.Notification"/> event.
            </remarks>
        </member>
        <member name="F:Un4seen.BassAsio.BassAsioHandlerSyncType.SourceStalled">
            <summary>
            The Asio source is stalled.
            <para>data: not used.</para>
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BassAsioHandlerSyncType.SourceResumed">
            <summary>
            The Asio source is resumed.
            <para>data: not used.</para>
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Aac.BassAac">
            <summary>
            BASS.NET API wrapper for BASS_AAC.DLL
            <para>Requires: bass_aac.dll - AAC and MP4 Audio Codec (AAC) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_AAC is an extension to the BASS audio library, enabling the playback of AAC and MP4 files and streams.</para>
            <para>Advanced Audio Coding (AAC) is a wideband audio coding algorithm that exploits two primary coding strategies to dramatically reduce the amount of data needed to convey high-quality digital audio. 
            First, signal components that are "perceptually irrelevant" and can be discarded without a perceived loss of audio quality are removed. Next, redundancies in the coded audio signal are eliminated.
            Efficient audio compression is achieved by a variety of perceptual audio coding and data compression tools, which are combined in the MPEG-4 AAC specification.</para>
            <para>The AAC and MP4 formats are used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/URL/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Aac.BassAac.BASS_AAC_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> /URL/User functions.</para>
            <para>More information can be found on <a href="http://www.vialicensing.com">www.vialicensing.com</a>.</para>
            <para>BASS_AAC is distributed under the GPL (see LICENSE.TXT).</para>
            <para>- For commercial use of BASS_AAC, please contact Nero AG at <a href="http://www.nero.com/eng/technologies-nerodigital-licensing.html">Partner with Nero to implement Nero Digital™ technology</a>.</para>
            <para>- AAC is a patented technology. To use it in your software, please obtain a license from Via Licensing at <a href="http://www.vialicensing.com">www.vialicensing.com</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.BASS_AAC_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.BASS_AAC_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a AAC file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.BASS_AAC_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.BASS_AAC_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a AAC memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.BASS_AAC_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a AAC file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.BASS_AAC_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from a AAC file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
            <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="proc">Callback function to receive the file as it is downloaded... NULL = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.BASS_MP4_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.BASS_MP4_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a MP4 file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.BASS_MP4_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.BASS_MP4_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a MP4 memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.BASS_MP4_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a MP4 file via user callback functions.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Aac.BassAac.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_aac.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Aac.BassAac.SupportedStreamName">
            <summary>
            Supported file format name of the bass_aac.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Aac.BassAac.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Aac.BassAac.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Aac.BassAac.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.BassTags">
            <summary>
            Internal Tag support of the BASS.NET API .
            <para>Requires: bass.dll - for better Tag reading support.</para>
            </summary>
            <remarks>
            <para>The BASS audio library has very limited support for reading tags, associated with a stream. 
            This class extends that functionality, allowing you to extract specific TAG information from a stream or file. 
            The extracted tag values are formatted into a general <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> class structure.</para>
            <para>Supported tags are ID3v1, ID3v2, WMA, OGG, RIFF, MOD, MP4 and APE and are evaluated as followed:</para>
            <para>MP3, MP2, MP1: first ID3v2, then ID3v1.</para>
            <para>OGG: first OGG, then APE.</para>
            <para>WMA: only WMA.</para>
            <para>MP4, AAC: first MP4, then ID3v2, then APE, then OGG</para>
            <para>all others: first APE, then OGG, then ID3v2, then ID3v1.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)">
            <summary>
            Retrieves the requested tags/headers from a file, if they are available.
            </summary>
            <param name="file">The fully qualified name of the file stream to get the TAG information from.</param>
            <returns>Returns a new <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance if successful. If TAGs could be retrieved successfully NULL is returned.</returns>
            <remarks>
            <para>This method first evaluates the file name extension. If using with a ".wma" or ".wmv" file and you are using the WMA DRM version, the WMA tags are received immediately.
            For all other file types an internal stream handle is created by using the plug-in system and calling <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>. If successful, the TAG_INFO is returned via <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> (see overload list).
            All members of the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure will be updated. However, some files and tag structures might not support all members.
            This overload 
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">Invalid/Unsupported tag version detected.</exception>
            <exception cref="T:System.FormatException">Invalid syncsafe integer found in tag data.</exception>
            <example>
            Getting TAGs from a file directly:
            <code>
            TAG_INFO tagInfo = BassTags.BASS_TAG_GetFromFile(fileName);
            if ( tagInfo != null )
            {
              // display the tags...
            }
            </code>
            <code lang="vbnet">
            Dim tagInfo As TAG_INFO = BassTags.BASS_TAG_GetFromFile(fileName)
            If Not (tagInfo Is Nothing) Then
              ' display the tags...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String,System.Boolean,System.Boolean)">
            <summary>
            Retrieves the requested tags/headers from a file, if they are available.
            </summary>
            <param name="file">The fully qualified name of the file stream to get the TAG information from.</param>
            <param name="setDefaultTitle">If TRUE the <see cref="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.title"/> property will be set to a default value (filename without extension).</param>
            <param name="prescan">If TRUE the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_PRESCAN"/> flag is used to return an exact <see cref="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.title"/> value - else the duration might just be good approximation, but the method will perform faster.</param>
            <returns>Returns a new <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance if successful. If TAGs could be retrieved successfully NULL is returned.</returns>
            <remarks>
            <para>This method first evaluates the file name extension. If using with a ".wma" or ".wmv" file and you are using the WMA DRM version, the WMA tags are received immediately.
            For all other file types an internal stream handle is created by using the plug-in system and calling <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>. If successful, the TAG_INFO is returned via <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> (see overload list).
            All members of the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure will be updated. However, some files and tag structures might not support all members.
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">Invalid/Unsupported tag version detected.</exception>
            <exception cref="T:System.FormatException">Invalid syncsafe integer found in tag data.</exception>
            <example>
            Getting TAGs from a file directly:
            <code>
            TAG_INFO tagInfo = BassTags.BASS_TAG_GetFromFile(fileName, true, true);
            if ( tagInfo != null )
            {
              // display the tags...
            }
            </code>
            <code lang="vbnet">
            Dim tagInfo As TAG_INFO = BassTags.BASS_TAG_GetFromFile(fileName, True, True)
            If Not (tagInfo Is Nothing) Then
              ' display the tags...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.Int32,Un4seen.Bass.AddOn.Tags.TAG_INFO)">
            <summary>
            Retrieves the requested tags/headers from a stream channel, if they are available.
            </summary>
            <param name="stream">The stream channel to get the TAG information from.</param>
            <param name="tags">The <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> class where to put the data.</param>
            <returns>If TAGs could be retrieved successfully TRUE is returned, else FALSE is returned.</returns>
            <remarks>
            <para>This method first evaluates the BASS_CTYPE_xxx for the stream, by calling the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> function internally.
            Based on the retrieved <see cref="T:Un4seen.Bass.BASSChannelType"/> a call to the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> function is made in order to retrieve the pointer to the tags/header data - if available.
            Finally this tag pointer is evaluated and the related tag/header data is evaluated.</para>
            <para>This method is able to retrieve the following TAGs:
            <list type="table">
            <item><term>MP3, MP2, MP1</term><description>BASS_TAG_ID3V2 first, then BASS_TAG_ID3</description></item>
            <item><term>OGG</term><description>BASS_TAG_OGG first, then BASS_TAG_APE</description></item>
            <item><term>RIFF</term><description>according to RIFF INFO List Chunk IDs.</description></item>
            <item><term>MOD</term><description>MOD music name and message are evaluated only.</description></item>
            <item><term>WMA</term><description>BASS_TAG_WMA</description></item>
            <item><term>MP4, AAC, ALAC</term><description>BASS_TAG_MP4 first, then BASS_TAG_ID3V2, then BASS_TAG_APE</description></item>
            <item><term>APE, FLAC, MPC, OFR, WV</term><description>BASS_TAG_APE first, then BASS_TAG_ID3V2, then BASS_TAG_ID3</description></item>
            <item><term>WINAMP</term><description>BASS_TAG_ID3V2 first, then BASS_TAG_APE</description></item>
            <item><term>WAV, SPX, AC3</term><description>not available</description></item>
            </list>
            All members of the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure will be updated. However, some files and tag structures might not support all members.
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">Invalid/Unsupported tag version detected.</exception>
            <exception cref="T:System.FormatException">Invalid syncsafe integer found in tag data.</exception>
            <example>
            <code>
            // create a stream
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, BASSFlag.BASS_DEFAULT);
            // update the tags
            TAG_INFO tagInfo = new TAG_INFO(fileName);
            if ( BassTags.BASS_TAG_GetFromFile( stream, tagInfo) )
            {
              // display the tags...
            }
            </code>
            <code lang="vbnet">
            ' create a stream
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tagInfo As New TAG_INFO(fileName)
            If BassTags.BASS_TAG_GetFromFile(stream, tagInfo) Then
              ' display the tags...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromURL(System.Int32,Un4seen.Bass.AddOn.Tags.TAG_INFO)">
            <summary>
            Retrieves the requested tags/headers from a URL stream, if they are available.
            </summary>
            <param name="stream">The stream to get the TAG information from.</param>
            <param name="tags">The <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> class where to put the data.</param>
            <returns>If TAGs could be retrieved successfully TRUE is returned, else FALSE is returned.</returns>
            <remarks>
            <para>This method first tries to get streaming header information via BASS_TAG_ICY and BASS_TAG_HTTP.
            Then it tries the following tags in that order: BASS_TAG_META, BASS_TAG_OGG, BASS_TAG_APE and BASS_TAG_WMA.</para>
            <para>This method is able to retrieve the following TAGs:
            <list type="table">
            <item><term>Shoutcast streaming</term><description>BASS_TAG_ICY and BASS_TAG_META</description></item>
            <item><term>Icecast streaming</term><description>BASS_TAG_HTTP and BASS_TAG_OGG</description></item>
            <item><term>WMA streaming</term><description>Use <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> instead, since WMA URL stream are created with the file method.</description></item>
            <item><term>APE streaming</term><description>BASS_TAG_HTTP and BASS_TAG_APE</description></item>
            </list>
            </para>
            The following members of the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure will be updated:
            <list type="table">
            <item><term>title</term><description>With the detected new stream title, if found.
            <para>Note: The 'streamtitle' might be composed within the meta data, e.g. Shoutcast combines the artist name and the real track name together. Shoutcast titles will be split at the first occurence of a " - " seperator.</para></description></item>
            <item><term>artist</term><description>With the detected new artist, if found.
            <para>Note: For Shoutcast stream this will be set as the 'streamtile' will splitted.</para></description></item>
            <item><term>album</term><description>With the detected name of the stream, if found (eg. icy-name).</description></item>
            <item><term>genre</term><description>With the detected genre of the stream, if found (eg. icy-genre).</description></item>
            <item><term>comment</term><description>With the detected new stream url, if found.</description></item>
            <item><term>year</term><description>With the detected bitrate, if found (only used with shoutcast streams).</description></item>
            </list>
            </remarks>
            <example>
            <code>
            // create a stream
            int stream = BASS_StreamCreateURL(url, 0, BASSFlag.BASS_STREAM_STATUS, null, 0);
            // update the tags
            TAG_INFO tagInfo = new TAG_INFO(url);
            if ( BassTags.BASS_TAG_GetFromURL( stream, tagInfo) )
            {
              // display the tags...
            }
            </code>
            <code lang="vbnet">
            ' create a stream
            Dim stream As Integer = BASS_StreamCreateURL(url, 0, BASSFlag.BASS_STREAM_STATUS, Nothing, 0)
            ' update the tags
            Dim tagInfo As New TAG_INFO(url)
            If BassTags.BASS_TAG_GetFromURL(stream, tagInfo) Then
              ' display the tags...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetIntPtr(System.Int32,Un4seen.Bass.BASS_CHANNELINFO,Un4seen.Bass.BASSTag@)">
            <summary>
            Gets an IntPtr to the memory block containing the meta tag data.
            </summary>
            <param name="stream">The stream to get the tags from.</param>
            <param name="info">The <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> structure containing the CTYPE, which will be used to find the tags.</param>
            <param name="tagType">Returns the detected <see cref="T:Un4seen.Bass.BASSTag"/> type.</param>
            <returns>An IntPtr to the tag memory block, or IntPtr.Zero if no tags could be found.</returns>
            <remarks>
            This method supports the following tags, which are evaluated in the following order:
            <list type="table">
            <item><term>MP3, MP2, MP1</term><description>BASS_TAG_ID3V2 first, then BASS_TAG_ID3</description></item>
            <item><term>OGG</term><description>BASS_TAG_OGG first, then BASS_TAG_APE</description></item>
            <item><term>WMA</term><description>BASS_TAG_WMA</description></item>
            <item><term>MP4, AAC, ALAC</term><description>BASS_TAG_MP4 first, then BASS_TAG_ID3V2, then BASS_TAG_APE, then BASS_TAG_OGG</description></item>
            <item><term>APE, FLAC, MPC, OFR, WV</term><description>BASS_TAG_APE first, then BASS_TAG_OGG, then BASS_TAG_ID3V2, then BASS_TAG_ID3</description></item>
            <item><term>WINAMP</term><description>BASS_TAG_ID3V2 first, then BASS_TAG_APE, then BASS_TAG_OGG</description></item>
            <item><term>WAV, SPX, AC3</term><description>not available</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.ID3v1Genre">
            <summary>
            List of availbale ID3v1 Genre ids.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Blues">
            <summary>
            Blues 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.ClassicRock">
            <summary>
            ClassicRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Country">
            <summary>
            Country 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Dance">
            <summary>
            Dance 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Disco">
            <summary>
            Disco 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Funk">
            <summary>
            Funk 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Grunge">
            <summary>
            Grunge 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.HipHop">
            <summary>
            HipHop 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Jazz">
            <summary>
            Jazz 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Metal">
            <summary>
            Metal 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.NewAge">
            <summary>
            NewAge 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Oldies">
            <summary>
            Oldies 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Other">
            <summary>
            Other 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Pop">
            <summary>
            Pop 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.RAndB">
            <summary>
            RAndB 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Rap">
            <summary>
            Rap 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Reggae">
            <summary>
            Reggae 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Rock">
            <summary>
            Rock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Techno">
            <summary>
            Techno 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Industrial">
            <summary>
            Industrial 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Alternative">
            <summary>
            Alternative 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Ska">
            <summary>
            Ska 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.DeathMetal">
            <summary>
            DeathMetal 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Pranks">
            <summary>
            Pranks 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Soundtrack">
            <summary>
            Soundtrack 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.EuroTechno">
            <summary>
            EuroTechno 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Ambient">
            <summary>
            Ambient 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.TripHop">
            <summary>
            TripHop 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Vocal">
            <summary>
            Vocal 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.JazzFunk">
            <summary>
            JazzFunk 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Fusion">
            <summary>
            Fusion 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Trance">
            <summary>
            Trance 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Classical">
            <summary>
            Classical 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Instrumental">
            <summary>
            Instrumental 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Acid">
            <summary>
            Acid 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.House">
            <summary>
            House 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Game">
            <summary>
            Game 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.SoundClip">
            <summary>
            SoundClip 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Gospel">
            <summary>
            Gospel 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Noise">
            <summary>
            Noise 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.AltRock">
            <summary>
            AltRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Bass">
            <summary>
            Bass 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Soul">
            <summary>
            Soul 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Punk">
            <summary>
            Punk 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Space">
            <summary>
            Space 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Meditative">
            <summary>
            Meditative 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.InstrumentalPop">
            <summary>
            InstrumentalPop 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.InstrumentalRock">
            <summary>
            InstrumentalRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Ethnic">
            <summary>
            Ethnic 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Gothic">
            <summary>
            Gothic 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Darkwave">
            <summary>
            Darkwave 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.TechnoIndustrial">
            <summary>
            TechnoIndustrial 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Electronic">
            <summary>
            Electronic 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.PopFolk">
            <summary>
            PopFolk 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Eurodance">
            <summary>
            Eurodance 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Dream">
            <summary>
            Dream 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.SouthernRock">
            <summary>
            SouthernRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Comedy">
            <summary>
            Comedy 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Cult">
            <summary>
            Cult 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.GangstaRap">
            <summary>
            GangstaRap 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.HardGrunge">
            <summary>
            HardGrunge 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Top40">
            <summary>
            Top40 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.ChristianRap">
            <summary>
            ChristianRap 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.PopFunk">
            <summary>
            PopFunk 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Jungle">
            <summary>
            Jungle 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.NativeAmerican">
            <summary>
            NativeAmerican 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Cabaret">
            <summary>
            Cabaret 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.NewWave">
            <summary>
            NewWave 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Psychadelic">
            <summary>
            Psychadelic 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Rave">
            <summary>
            Rave 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Showtunes">
            <summary>
            Showtunes 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Trailer">
            <summary>
            Trailer 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.LoFi">
            <summary>
            LoFi 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Tribal">
            <summary>
            Tribal 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.AcidPunk">
            <summary>
            AcidPunk 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.AcidJazz">
            <summary>
            AcidJazz 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Polka">
            <summary>
            Polka 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Retro">
            <summary>
            Retro 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Musical">
            <summary>
            Musical 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.RockAndRoll">
            <summary>
            RockAndRoll 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.HardRock">
            <summary>
            HardRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Folk">
            <summary>
            Folk 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.FolkRock">
            <summary>
            FolkRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.NationalFolk">
            <summary>
            NationalFolk 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Swing">
            <summary>
            Swing 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.FastFusion">
            <summary>
            FastFusion 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Bebop">
            <summary>
            Bebop 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Latin">
            <summary>
            Latin 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Revival">
            <summary>
            Revival 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Celtic">
            <summary>
            Celtic 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Bluegrass">
            <summary>
            Bluegrass 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Avantgarde">
            <summary>
            Avantgarde 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.GothicRock">
            <summary>
            GothicRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.ProgressiveRock">
            <summary>
            ProgressiveRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.PsychedelicRock">
            <summary>
            PsychedelicRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.SymphonicRock">
            <summary>
            SymphonicRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.SlowRock">
            <summary>
            SlowRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.BigBand">
            <summary>
            BigBand 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Chorus">
            <summary>
            Chorus 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.EasyListening">
            <summary>
            EasyListening 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Acoustic">
            <summary>
            Acoustic 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Humour">
            <summary>
            Humour 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Speech">
            <summary>
            Speech 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Chanson">
            <summary>
            Chanson 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Opera">
            <summary>
            Opera 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.ChamberMusic">
            <summary>
            ChamberMusic 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Sonata">
            <summary>
            Sonata 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Symphony">
            <summary>
            Symphony 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.BootyBass">
            <summary>
            BootyBass 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Primus">
            <summary>
            Primus 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.PornGroove">
            <summary>
            PornGroove 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Satire">
            <summary>
            Satire 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.SlowJam">
            <summary>
            SlowJam 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Club">
            <summary>
            Club 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Tango">
            <summary>
            Tango 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Samba">
            <summary>
            Samba 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Folklore">
            <summary>
            Folklore 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Ballad">
            <summary>
            Ballad 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.PowerBallad">
            <summary>
            PowerBallad 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.RhythmicSoul">
            <summary>
            RhythmicSoul 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Freestyle">
            <summary>
            Freestyle 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Duet">
            <summary>
            Duet 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.PunkRock">
            <summary>
            PunkRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.DrumSolo">
            <summary>
            DrumSolo 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.ACapella">
            <summary>
            ACapella 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.EuroHouse">
            <summary>
            EuroHouse 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.DanceHall">
            <summary>
            DanceHall 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Goa">
            <summary>
            Goa 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.DrumAndBass">
            <summary>
            DrumAndBass 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.ClubHouse">
            <summary>
            ClubHouse 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Hardcore">
            <summary>
            Hardcore 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Terror">
            <summary>
            Terror 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Indie">
            <summary>
            Indie 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.BritPop">
            <summary>
            BritPop 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Negerunk">
            <summary>
            Negerunk 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.PolskPunk">
            <summary>
            PolskPunk 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Beat">
            <summary>
            Beat 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.ChristianGangstaRap">
            <summary>
            ChristianGangstaRap 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.HeavyMetal">
            <summary>
            HeavyMetal 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.BlackMetal">
            <summary>
            BlackMetal 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Crossover">
            <summary>
            Crossover 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.ContemporaryChristian">
            <summary>
            ContemporaryChristian 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.ChristianRock">
            <summary>
            ChristianRock 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Merengue">
            <summary>
            Merengue 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Salsa">
            <summary>
            Salsa 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.TrashMetal">
            <summary>
            TrashMetal 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Anime">
            <summary>
            Anime 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.JPop">
            <summary>
            JPop
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Synthpop">
            <summary>
            Synthpop
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.ID3v1Genre.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.TAG_INFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> to retrieve information on the current tags of a stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.title">
            <summary>
            The song title.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.artist">
            <summary>
            The Artist name.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.album">
            <summary>
            The Album name.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.albumartist">
            <summary>
            The Album Artist name (Band/Orchestra/Remixer).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.year">
            <summary>
            The Year (as a string, typically in the format YYYY or YYYY-MM).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.comment">
            <summary>
            The Comment text.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.genre">
            <summary>
            The Genre (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.track">
            <summary>
            The track number (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.copyright">
            <summary>
            The Copyright (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.encodedby">
            <summary>
            The EncodedBy (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.composer">
            <summary>
            The Composer (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.publisher">
            <summary>
            The Publisher, Label (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.bpm">
            <summary>
            Beats Per minute.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.filename">
            <summary>
            The name of the file (only available, if set in the constructor or manually)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.pictures">
            <summary>
            Keeps optional pictures.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.nativetags">
            <summary>
            Keeps all native tags.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.channelinfo">
            <summary>
            The <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> structure.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.duration">
            <summary>
            The estimated duration of the track in seconds.
            </summary>
            <remarks>This value doesn't have to be 100% accurate but is typically a very good estimation.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.bitrate">
            <summary>
            The estimated bitrate of the track in kBit/sec.
            </summary>
            <remarks>This value doesn't have to be 100% accurate but is typically a good estimation.
            Note: Only usefull with files encoded in CBR (constant bitrate).</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.#ctor">
            <summary>
            Default constructor (filename must be set manually in order to be available).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.#ctor(System.String)">
            <summary>
            Constructor already setting the filename (full path) and the title (file name only).
            </summary>
            <param name="FileName">The filename to remember.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor already setting the filename (full path) and the title (file name only).
            </summary>
            <param name="FileName">The filename to remember.</param>
            <param name="setDefaultTitle">If TRUE the <see cref="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.title"/> property will be set to a default value (filename without extension).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.ToString">
            <summary>
            A description of the tag info object (artist - title or filename).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.UpdateFromMETA(System.IntPtr,System.Boolean)">
            <summary>
            Update the tags from a meta data pointer, e.g. when streaming from a URL as triggered by a <see cref="T:Un4seen.Bass.SYNCPROC"/> using BASS_SYNC_META and as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            </summary>
            <param name="data">The pointer to the memory block containing the meta data, e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.</param>
            <param name="utf8">Set to TRUE, if the tags are present in UTF-8 (8-bit), else set to FALSE to use ANSI characters (7-bit).</param>
            <returns>If any tag was updated TRUE is returned. If nothing was changed FALSE will be returned.</returns>
            <remarks>
            The following members will be updated:
            <list type="table">
            <item><term>title</term><description>With the detected new stream title, if found.
            <para>Note: For URL streams (Shoutcast, Oddcast) the 'streamtitle' might be composed within the meta data, e.g. Shoutcast combines the artist name and the real track name together. Shoutcast titles will be splitted at the first occurence of a '-' seperator.</para></description></item>
            <item><term>artist</term><description>With the detected new artist, if found.
            <para>Note: For URL streams (Shoutcast, Oddcast) the 'streamtitle' might be composed within the meta data, e.g. Shoutcast combines the artist name and the real track name together. Shoutcast titles will be splitted at the first occurence of a '-' seperator.</para></description></item>
            <item><term>album</term><description>With the detected album name of the stream, if found (eg. icy-name).</description></item>
            <item><term>genre</term><description>With the detected genre of the stream, if found (eg. icy-genre).</description></item>
            <item><term>comment</term><description>With the detected new comment, if found.
            <item><term>year</term><description>With the detected year, if found.</description></item>
            <item><term>bitrate</term><description>With the detected bitrate, if found.</description></item>
            <para>Note: For URL streams (Shoutcast, Oddcast), the new url location will be used.</para>
            <para>Note: For MIDI lyric text syncs please use the <see cref="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.UpdateFromMIDILyric(Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> method.</para>
            </description></item>
            </list>
            </remarks>
            <example>
            Update tags with a sync proc together with Bass.BASS_StreamCreateURL:
            <code>
            private SYNCPROC _mySync;
            private TAG_INFO _tags;
            ...
            string url = "http://someurl...";
            int stream = Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_STREAM_STATUS, null, 0);
            _tags = new TAG_INFO(url);
            // set a sync to get the title updates out of the meta data...
            _mySync = new SYNCPROC(MetaSync);
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero);
            ...
            private void MetaSync(int handle, int channel, int data, IntPtr user)
            {
              // BASS_SYNC_META is triggered on meta changes of SHOUTcast streams
              _tags.UpdateFromMETA( Bass.BASS_ChannelGetTags(channel, BASSTag.BASS_TAG_META), false );
            }
            </code>
            <code lang="vbnet">
            Private _mySync As SYNCPROC
            Private _tags As TAG_INFO
            ...
            Dim url As String = "http://someurl..."
            Dim stream As Integer = Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_STREAM_STATUS, Nothing, 0)
            _tags = New TAG_INFO(url)
            ' set a sync to get the title updates out of the meta data...
            _mySync = New SYNCPROC(AddressOf MetaSync)
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero)
            ...
            Private Sub MetaSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              ' BASS_SYNC_META is triggered on meta changes of SHOUTcast streams
              _tags.UpdateFromMETA(Bass.BASS_ChannelGetTags(channel, BASSTag.BASS_TAG_META), False)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.UpdateFromMIDILyric(Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)">
            <summary>
            Update the tags from a meta data pointer, when using in a <see cref="T:Un4seen.Bass.SYNCPROC"/> using BASS_SYNC_MIDI_LYRIC or BASS_MIDI_MARK_TEXT.
            </summary>
            <param name="midiMark">The instance of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK"/> structure from which to update the lyric text, as retrieved form <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/>.</param>
            <returns>If any tag was updated TRUE is returned. If nothing was changed FALSE will be returned.</returns>
            <remarks>
            The following members will be updated:
            <list type="table">
            <item><term>comment</term><description>With the detected new lyric text, if found.
            <para>If the lyric text begins with a '/' (slash) character, a new line ('\n')will be added to the comment. 
            If it begins with a '\' (backslash) character, the comment will be cleared first - in all other cases the lyric text will be appended to the existing comment.</para>
            </description></item>
            <item><term>track</term><description>With the midi track number, if changed.</description></item>
            </list>
            </remarks>
            <example>
            Update MIDI lyric text in the comment member:
            <code>
            private SYNCPROC _mySync;
            private TAG_INFO _tags;
            ...
            int midi = BassMidi.BASS_MIDI_StreamCreateFile("test.mid", 0, 0, BASSFlag.BASS_STREAM_AUTOFREE, 44100);
            _tags = new TAG_INFO("test.mid");
            // set a sync to get the lyric text updates out of the MIDI data...
            _mySync = new SYNCPROC(LyricSync);
            Bass.BASS_ChannelSetSync(midi, BASSSync.BASS_SYNC_MIDI_LYRIC, 0, _mySync, IntPtr.Zero);
            // get the initial tags
            BassTags.BASS_TAG_GetFromFile(midi, _tags);
            ...
            private void LyricSync(int handle, int channel, int data, IntPtr user)
            {
            	_tags.UpdateFromMIDILyric( BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_LYRIC, data) );
            	// tags.comment now contains the updated lyric text
                Console.Write("{0}\r", _tags.comment)
            }
            </code>
            <code lang="vbnet">
            Private _mySync As SYNCPROC
            Private _tags As TAG_INFO
            ...
            Dim midiStream As Integer =  BassMidi.BASS_MIDI_StreamCreateFile("test.mid", 0, 0, BASSFlag.BASS_STREAM_AUTOFREE, 44100) 
            _tags = New TAG_INFO("test.mid")
            ' set a sync to get the lyric text updates out of the MIDI data...
            _mySync = New SYNCPROC(AddressOf LyricSync)
            Bass.BASS_ChannelSetSync(midi, BASSSync.BASS_SYNC_MIDI_LYRIC, 0, _mySync, IntPtr.Zero)
            ' get the initial tags...
            BassTags.BASS_TAG_GetFromFile(midi, _tags)
            ...
            Private Sub LyricSync(ByVal handle As Integer, ByVal channel As Integer, ByVal data As Integer, ByVal user As IntPtr)
              tags.UpdateFromMIDILyric(BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_LYRIC, data))
              ' tags.comment now contains the updated lyric text
              Console.Write("{0}\r", _tags.comment)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.EvalTagEntry(System.String)">
            <summary>
            Takes one tag (key=value) and changes the internal members accordingly.
            </summary>
            <param name="tagEntry">The tag string to evaluate (in the format: key=value or or key:value)</param>
            <returns>TRUE, if a tag member was changed, else FALSE.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.AddPicture(Un4seen.Bass.AddOn.Tags.TagPicture)">
            <summary>
            Adds a picture tag directly.
            </summary>
            <param name="tagPicture"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureGetImage(System.Int32)">
            <summary>
            Returns a picture image.
            </summary>
            <param name="i">The zero-based index (number) of the picture to get. You might use <see cref="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureCount"/> to retrieve the total number of pictures available.</param>
            <returns>The image of the picture on success or NULL if no picture is available (at that index).</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureGetDescription(System.Int32)">
            <summary>
            Returns the description of a picture.
            </summary>
            <param name="i">The zero-based index (number) of the picture to access. You might use <see cref="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureCount"/> to retrieve the total number of pictures available.</param>
            <returns>The description of the picture on success or NULL if no picture is available (at that index).</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureGetType(System.Int32)">
            <summary>
            Returns the type of the picture.
            </summary>
            <param name="i">The zero-based index (number) of the picture to access. You might use <see cref="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureCount"/> to retrieve the total number of pictures available.</param>
            <returns>The type of the picture on success or NULL if no picture is available (at that index).</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.ReadPicturesFromDirectory(System.String,System.Boolean)">
            <summary>
            Scans the directory of the <see cref="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.filename"/> location for additional pictures.
            </summary>
            <param name="searchPattern">An optional search string, such as "*.jpg" or "Album*.jpg" or NULL to scan for default images.</param>
            <param name="all">TRUE to add all found images to the picture list or FALSE to only add the first found image.</param>
            <remarks>When scanning for default images (by not using any <paramref name="searchPattern"/>) the following order will be used:
            <list type="number">
            <item><term>&lt;filename&gt;.jpg</term></item>
            <item><term>&lt;filename&gt;.gif</term></item>
            <item><term>&lt;filename&gt;.png</term></item>
            <item><term>&lt;filename&gt;.bmp</term></item>
            <item><term>Folder*.jpg</term></item>
            <item><term>Album*.jpg</term></item>
            <item><term>&lt;album&gt;.jpg</term></item>
            <item><term>&lt;album&gt;.gif</term></item>
            <item><term>&lt;album&gt;.png</term></item>
            <item><term>&lt;album&gt;.bmp</term></item>
            </list>
            In the above list &lt;filename&gt; resp. &lt;album&gt; will be replaced by the actual tag content field values.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.NativeTag(System.String)">
            <summary>
            Returns a certain native tag.
            </summary>
            <param name="tagname">The name of the native tag to retrieve (case-sensitive!) - e.g. use "TPE1" to query for the artist of ID3v2 tags.</param>
            <returns>The value of the tag or NULL if tag with that name could be found.</returns>
            <remarks>If multiple tags with the same name do exist, only the first tag value will be returned.</remarks>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureCount">
            <summary>
            Returns the number of pictures which are available.
            </summary>
            <remarks>Pictures are only available for ID3v2 and WMA tags.</remarks>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.NativeTags">
            <summary>
            Returns all native tags.
            </summary>
            <returns>A string array containing all native tags as being gathered.</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.ID3v2Reader">
            <summary>
            A class for reading the tags from an ID3 header.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.ID3v2Reader.#ctor(System.IntPtr)">
            <summary>
            Reads the tags from an ID3v2 header.
            </summary>
            <param name="pID3v2">The memory pointer to the ID3v2 header.</param>
            <exception cref="T:System.FormatException">Invalid syncsafe integer found in ID3v2 data.</exception>
            <example>
            <code>
            The 10 byte header looks like this:
            struct Id3v2Header 
            {
            	char magic[3];	// always "Id3"
            	char majorVersion;
            	char minorVersion;
            	char flags;
            	int28 size;
            };
            The version is always v2.maj.min -- the v2 is implied.
            flags currently only defines 4 flags.  More on these later.
            The int28 type is a 28-bit integer padded out to a
            32-bit integer, to make it sync-safe.  It's padded by setting
            the most significant bit of each byte to zero.
            i.e. it looks like this:
            0xxxxxxx0xxxxxxx0xxxxxxx0xxxxxxx
            Integers in Id3v2 are big-endian.
            A frame looks like this:
            struct Id3v2Frame 
            {
            	char frame_id[4];
            	int28 size;
            	char flags[2];
            };
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.WMFMetadataEditor.GetAllPictures">
            <summary>
            Returns all available TagPictures.
            </summary>
            <returns>An array list of <see cref="T:Un4seen.Bass.AddOn.Tags.TagPicture"/> instances or NULL</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.WMFMetadataEditor.ReadAllAttributes">
            <summary>
            Gets all available Tags from a file (using default language!).
            </summary>
            <returns>An array list of <see cref="T:Un4seen.Bass.AddOn.Tags.Tag"/> instances or NULL.</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.Tag">
            <summary>
            Represent one tag attribute that can be present in a header of a file.
            There are defined explicit convertion operator for every possible data type 
            represented with this structure. 
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.Tag.#ctor(System.Int32,System.String,Un4seen.Bass.AddOn.Tags.WMT_ATTR_DATATYPE,System.Object)">
            <summary>
            Initialize the Tag structure with proper values.
            </summary>
            <param name="index">the index of the attribute</param>
            <param name="name">Name of the attribute</param>
            <param name="type">WMT_ATTR_DATATYPE enum describing the type of the attribute. </param>
            <param name="val">The atrtibute value. This param is an obcjet and must match the 
            param type, ex. If type is WMT_ATTR_DATATYPE.WMT_TYPE_BOOL val param must be a valid <code>bool</code> and so on. </param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.Tag.ToString">
            <summary>
            ToString is overridden to provide the string representation in "name=value" format.
            </summary>
            <returns>String represantation of this struct in "name=value" format.</returns>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Tags.Tag.Index">
            <summary>
            Index of the attribute
            </summary>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Tags.Tag.Name">
            <summary>
            Name of the attribute
            </summary>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Tags.Tag.DataType">
            <summary>
            Data type of the attribute
            </summary>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Tags.Tag.Value">
            <summary>
            Read/Write object representing the value of the attribute. 
            When writing this property the object must match to the DataType
            </summary>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Tags.Tag.ValueAsString">
            <summary>
            Gets a string representing the value of the attribute. 
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.TagPicture">
            <summary>
            This class represents a picture tag.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.MIMEType">
            <summary>
            The MIMEType of the picture.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureType">
            <summary>
            The type of the picture - one of the <see cref="T:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE"/> values.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.Description">
            <summary>
            The description of the picture.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.Data">
            <summary>
            The raw image data of the picture or the UTF-8 encoded location of the picture.
            </summary>
            <remarks>
            If the <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage"/> is set to <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.Internal"/>, this property directly contains the picture image data.
            If the <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage"/> is set to <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.External"/>, this property contains the link to the picture image as a fully qualified name (UTF-8 encoded).
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.AttributeIndex">
            <summary>
            The index or number of the related picture tag (-1 = undefined).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage">
            <summary>
            The storage type of the picture <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.Data"/>.
            </summary>
            <remarks>
            This property denotes where the image data is stored.
            <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.Internal"/> specifies, that <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.Data"/> directly contains the picture image.
            <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.External"/> specifies, that <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.Data"/> contains the link to the picture image as a fully qualified name (UTF-8 encoded).
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.#ctor(System.Int32,System.String,Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE,System.String,System.Byte[])">
            <summary>
            Creates a picture tag from the given values.
            </summary>
            <param name="attribIndex">The index/number of picture.</param>
            <param name="mimeType">The MIMEType of the picture.</param>
            <param name="pictureType">The PICTURE_TYPE.</param>
            <param name="description">The description of the picture.</param>
            <param name="data">The raw image data.</param>
            <remarks>The <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage"/> will be set to <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.Internal"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.#ctor(System.String)">
            <summary>
            Loads a picture from a file!
            </summary>
            <param name="file">A string that contains the fully qualified name of the file from which to create the picture.</param>
            <remarks>The <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage"/> will be set to <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.External"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.#ctor(System.String,Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE,System.String)">
            <summary>
            Loads a picture from a file!
            </summary>
            <param name="file">A string that contains the fully qualified name of the file from which to create the picture.</param>
            <param name="type">The type of the picture (one of the <see cref="T:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE"/> values).</param>
            <param name="description">The description of the picture.</param>
            <remarks>The <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage"/> will be set to <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.External"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.#ctor(Un4seen.Bass.AddOn.Tags.Tag)">
            <summary>
            Loads a picture from a byte[] Tag!
            </summary>
            <param name="pTag">The Tag containing the raw byte[] image.</param>
            <remarks>The <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage"/> will be set to <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.Internal"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.ToString">
            <summary>
            Returns the description, picture type and MIMEType of the picture.
            </summary>
            <returns>The picture description string.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.GetMimeTypeFromImage(System.Drawing.Image)">
            <summary>
            Returns the MIMEType of a given Image.
            </summary>
            <param name="pImage">The image to get the MIMEType from.</param>
            <returns>The MIMEType of the image.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.GetMimeTypeFromFile(System.String)">
            <summary>
            Returns the MIMEType of a given file.
            </summary>
            <param name="pFile">The name of the file to get the MIMEType from.</param>
            <returns>The MIMEType of the image.</returns>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Tags.TagPicture.PictureImage">
            <summary>
            Returns the related image.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE">
            <summary>
            Picture Type enumeration.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Unknown">
            <summary>
            Picture of a type not specifically listed in this table 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Icon32">
            <summary>
            32 pixel by 32 pixel file icon. Use only with portable network graphics (PNG) format 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.OtherIcon">
            <summary>
            File icon not conforming to type 1 above 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.FrontAlbumCover">
            <summary>
            Front album cover 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.BackAlbumCover">
            <summary>
            Back album cover 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.LeafletPage">
            <summary>
            Leaflet page 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Media">
            <summary>
            Media. Typically this type of image is of the label side of a CD 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.LeadArtist">
            <summary>
            Picture of the lead artist, lead performer, or soloist 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Artists">
            <summary>
            Picture of one of the artists or performers 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Conductor">
            <summary>
            Picture of the conductor 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Orchestra">
            <summary>
            Picture of the band or orchestra 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Composer">
            <summary>
            Picture of the composer 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Writer">
            <summary>
            Picture of the lyricist or writer 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Location">
            <summary>
            Picture of the recording studio or location 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.RecordingSession">
            <summary>
            Picture taken during a recording session 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Performance">
            <summary>
            Picture taken during a performance 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.VideoCapture">
            <summary>
            Screen capture from a movie or video 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.ColoredFish">
            <summary>
            A bright colored fish 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Illustration">
            <summary>
            Illustration 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.BandLogo">
            <summary>
            Logo of the band or artist 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.PublisherLogo">
            <summary>
            Logo of the publisher or studio 
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE">
            <summary>
            Picture Storage enumeration.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.Internal">
            <summary>
            The picture is stored internally as an image.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.External">
            <summary>
            The picture is stored externally as an image link.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tta.BassTta">
            <summary>
            BASS.NET API wrapper for BASS_TTA.DLL
            <para>Requires: bass_tta.dll - The True Audio Codec (TTA) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_TTA is an extension to the BASS audio library, enabling the playing of TTA (The True Audio Codec) encoded files. TTA is a free, simple, realtime lossless audio compressor based on adaptive prognostic filters. The codec was built to offer adequate compression levels while maintaining high operation speeds.</para>
            <para>The True Audio format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Tta.BassTta.BASS_TTA_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> or User functions.</para>
            <para>More information can be found on <a href="http://www.true-audio.com">www.true-audio.com</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.BASS_TTA_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.BASS_TTA_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a True Audio file.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.BASS_TTA_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.BASS_TTA_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a True Audio memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.BASS_TTA_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a True Audio file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tta.BassTta.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_tta.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tta.BassTta.SupportedStreamName">
            <summary>
            Supported file format name of the bass_tta.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Tta.BassTta.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Tta.BassTta.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Mpc.BassMpc">
            <summary>
            BASS.NET API wrapper for BASS_MPC.DLL
            <para>Requires: bass_mpc.dll - MusePack Audio Codec (MPC) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_MPC is an extension to the BASS audio library, enabling the playback of MusePack files.</para>
            <para>MusePack is an audio compression format with a strong emphasis on high quality. It's not lossless, but it is designed for transparency, so that you won't be able to hear differences between the original lossless file and the much smaller MPC. It is based on the MPEG 1 Layer II algorithms, but has rapidly developed and vastly improved and is now at an advanced stage in which it contains heavily optimized and patentless code.</para>
            <para>The MusePack format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> /User functions.</para>
            <para>More information can be found on <a href="http://www.musepack.net">www.musepack.net</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a MusePack Audio file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a MusePack Audio memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a MusePack Audio file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file function (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mpc.BassMpc.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_alac.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mpc.BassMpc.SupportedStreamName">
            <summary>
            Supported file format name of the bass_alac.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Mpc.BassMpc.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Mpc.BassMpc.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BassFx">
            <summary>
            BASS.NET API wrapper for BASS_FX.DLL
            <para>Requires: bass_fx.dll - DSP and Effect support Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_FX is an extension to the BASS audio library, providing a complete set of DSP functions to start programming your own DJ software. 
            Programmed to enable the simple and even the advanced programmers/users to have in their programs some sound effects without knowing any DSP at all.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BassFx.BASSFXVERSION">
            <summary>
            Current BASS_FX version (without minor revision).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_GetVersion">
            <summary>
            Retrieves the version number of the BASS_FX.DLL that is loaded.
            </summary>
            <returns>The BASS_FX version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASS_FX supports all the BASS_FX functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.AddOn.Fx.BassFx.BASSFXVERSION"/> to check the major revision.</para>
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(BassFx.BASS_FX_GetVersion()) != BassFx.BASSFXVERSION )
            {
              MessageBox.Show(this, "Wrong BassFx Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(BassFx.BASS_FX_GetVersion()) &lt;&gt; BassFx.BASSFXVERSION Then
              MessageBox.Show(Me, "Wrong BassFx Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (BassFx.BASS_FX_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong BassFx Version!");
            }
            </code>
            <code lang="vbnet">
            If BassFx.BASS_FX_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong BassFx Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASS_FX.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASS_FX version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASS_FX supports all the BASS_FX functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (BassFx.BASS_FX_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong BassFx Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If BassFx.BASS_FX_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong BassFx Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a resampling stream from a decoding channel.
            </summary>
            <param name="channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel (use BASS_STREAM_DECODE when creating the channel).</param>
            <param name="flags">A combination of the following flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped? Note that only complete sample loops are allowed by DirectSound (ie. you can't loop just part of a sample).</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the sample to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D samples must be mono (use BASS_SAMPLE_MONO).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_FX_FREESOURCE</term><description>Free the source handle as well when the tempo channel is freed.</description></item>
            </list>
            </param>
            <returns>If successful, the tempo stream handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Multi-channels are supported.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>/<see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/> to get or set the attributes of a tempo stream:
            <list type="table">
            <item><term>BASS_ATTRIB_TEMPO</term><description>The tempo of a channel in percent [-95%...0...+5000%].</description></item>
            <item><term>BASS_ATTRIB_TEMPO_PITCH</term><description>The pitch of a channel in semitones [-60...0...+60].</description></item>
            <item><term>BASS_ATTRIB_TEMPO_FREQ</term><description>The sample rate of a channel in Hz (but calculates by the same % as BASS_ATTRIB_TEMPO).</description></item>
            </list>
            These attributes can either be applied to the tempo channel or the underlying decoding source channel.
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_FX_ERROR_NODECODE</term><description>The <paramref name="channel"/> is not a decoding channel. Make sure the channel was created using the BASS_STREAM_DECODE or BASS_MUSIC_DECODE flag.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The <paramref name="channel"/>'s format is not supported. Make sure the channel is either Stereo or Mono.</description></item>
            </list>
            </para>
            <para>Tuning the option attributes parameters (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>):</para>
            <para>The time-stretch algorithm has few parameters that can be tuned to optimize sound quality for certain application. The current default parameters have been chosen by iterative if-then analysis (read: "trial and error") to obtain best subjective sound quality in pop/rock music processing, but in applications processing different kind of sound the default parameter set may result into a sub-optimal result.</para>
            <list type="bullet">
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_USE_AA_FILTER</see> (default = TRUE/1):
            <para>Use FIR low-pass (anti-alias) filter (gain speed, lose quality)? : TRUE=1 / FALSE=0.</para>
            </description>
            </item>
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_AA_FILTER_LENGTH</see> (default = 32):
            <para>The FIR low-pass (anti-alias) filter length in taps: between 8 and 128 (should be around %4).</para>
            </description>
            </item>
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_USE_QUICKALGO</see> (default = FALSE/0):
            <para>Use quicker tempo change algorithm (gain speed, lose quality)? TRUE=1 / FALSE=0.</para>
            </description>
            </item>
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_SEQUENCE_MS</see> (default = 82):
            <para>This is the default length of a single processing sequence in milliseconds which determines the how the original sound is chopped in the time-stretch algorithm. Larger values mean fewer sequences are used in processing. In principle a larger value sounds better when slowing down the tempo, but worse when increasing the tempo and vice versa.</para>
            </description>
            </item>
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_SEEKWINDOW_MS</see> (default = 14):
            <para>The seeking window default length in milliseconds is for the algorithm that seeks the best possible overlapping location. This determines from how wide a sample "window" the algorithm can use to find an optimal mixing location when the sound sequences are to be linked back together.
            The bigger this window setting is, the higher the possibility to find a better mixing position becomes, but at the same time large values may cause a "drifting" sound artifact because neighboring sequences can be chosen at more uneven intervals. If there's a disturbing artifact that sounds as if a constant frequency was drifting around, try reducing this setting.</para>
            </description>
            </item>
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_OVERLAP_MS</see> (default = 12):
            <para>Overlap length in milliseconds. When the sound sequences are mixed back together to form again a continuous sound stream, this parameter defines how much the ends of the consecutive sequences will overlap with each other.
            This shouldn't be that critical parameter. If you reduce the BASS_FX_TEMPO_OPTION_SEQUENCE_MS setting by a large amount, you might wish to try a smaller value on this</para>
            </description>
            </item>
            </list>
            <para>The table below summarizes how the parameters can be adjusted for different applications:</para>
            <list type="table">
            <listheader><term>Parameter:</term><description>Effect:</description></listheader>
            <item><term>SEQUENCE_MS</term>
            <description>
            <para>Default value magnitude: Default value is relatively large, chosen for slowing down music tempo.</para>
            <para>Larger value affects: Larger value is usually better for slowing down tempo. Growing the value decelerates the "echoing" artifact when slowing down the tempo.</para>
            <para>Smaller value affects: Smaller value might be better for speeding up tempo. Reducing the value accelerates the "echoing" artifact when slowing down the tempo.</para>
            <para>Music: Default value usually good.</para>
            <para>Speech: A smaller value than default might be better.</para>
            <para>Effect in CPU burden: Increasing the parameter value reduces computation burden.</para>
            </description>
            </item>
            <item><term>SEEKWINDOW_MS</term>
            <description>
            <para>Default value magnitude: Default value is relatively large, chosen for slowing down music tempo.</para>
            <para>Larger value affects: Larger value eases finding a good mixing position, but may cause a "drifting" artifact.</para>
            <para>Smaller value affects: Smaller reduce possibility to find a good mixing position, but reduce the "drifting" artifact.</para>
            <para>Music: Default value usually good, unless a "drifting" artifact is disturbing.</para>
            <para>Speech: Default value usually good.</para>
            <para>Effect in CPU burden: Increasing the parameter value increases computation burden.</para>
            </description>
            </item>
            <item><term>OVERLAP_MS</term>
            <description>
            <para>Default value magnitude: Default value is relatively large, chosen to suit with above parameters.</para>
            <para>Larger value affects: --</para>
            <para>Smaller value affects: If you reduce the "sequence ms" setting, you might wish to try a smaller value.</para>
            <para>Music: --</para>
            <para>Speech: --</para>
            <para>Effect in CPU burden: Increasing the parameter value increases computation burden.</para>
            </description>
            </item>
            </list>
            <para>Performance Optimizations:</para>
            <list type="bullet">
            <item>
            <description>The time-stretch routine has a 'quick' mode that substantially speeds up the algorithm but may degrade the sound quality by a small amount. This mode is activated by <see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_USE_QUICKALGO</see> and value TRUE=1.</description>
            </item>
            <item>
            <description>Intel SSE optimized routines are used with compatible CPUs when floating point sample type is used. SSE optimizations are currently implemented for Win32 platform only. Processors compatible with SSE extension are Intel processors starting from Pentium-III, and AMD processors starting from Athlon XP.</description>
            </item>
            <item>
            <description>AMD 3DNow! optimized routines are used with compatible CPUs when floating point sample type is used, but SSE extension isn't supported . 3DNow! optimizations are currently implemented for Win32 platform only. These optimizations are used in AMD K6-2 and Athlon (classic) CPU's; better performing SSE routines are used with AMD processor starting from Athlon XP.</description>
            </item>
            </list>
            </remarks>
            <example>
            Create a playing tempo stream out of a decoding stream and loop it:
            <code>
            // the source channel
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE);
            // the tempo channel
            int streamFX = BassFx.BASS_FX_TempoCreate(stream, BASSFlag.BASS_FX_FREESOURCE);
            ...
            // change the sampling rate by 20%, the streamFX will be played faster
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_TEMPO_FREQ, 0.2f);
            
            // change the tempo by -15%, the streamFX will be slower
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_TEMPO, -0.15f);
            
            // change the pitch (key) by one octave (12 semitones)
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_TEMPO, 12f);
            </code>
            <code lang="vbnet">
            ' the source channel
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE)
            ' the tempo channel
            Dim streamFX As Integer = BassFx.BASS_FX_TempoCreate(stream, BASSFlag.BASS_FX_FREESOURCE)
            ...
            ' change the sampling rate by 20%, the streamFX will be played faster
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_TEMPO_FREQ, 0.2F)
            
            ' change the tempo by -15%, the streamFX will be slower
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_TEMPO, -0.15F)
            
            ' change the pitch (key) by one octave (12 semitones)
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_TEMPO, 12F)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoGetSource(System.Int32)">
            <summary>
            Get the source channel handle.
            </summary>
            <param name="channel">Tempo stream handle.</param>
            <returns>If successful, the source channel handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // the source channel
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE);
            // the tempo channel
            int streamFX = BassFx.BASS_FX_TempoCreate(stream, BASSFlag.BASS_FX_FREESOURCE);
            ...
            // this will return 'stream'
            int chan = BassFx.BASS_FX_TempoGetSource(streamFX);
            </code>
            <code lang="vbnet">
            ' the source channel
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE)
            ' the tempo channel
            Dim streamFX As Integer = BassFx.BASS_FX_TempoCreate(stream, BASSFlag.BASS_FX_FREESOURCE)
            ...
            ' this will return 'stream'
            Dim chan As Integer = BassFx.BASS_FX_TempoGetSource(streamFX);
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoGetRateRatio(System.Int32)">
            <summary>
            Get the ratio of the resulting rate and source rate (the resampling ratio).
            </summary>
            <param name="chan">Tempo stream (or source channel) handle.</param>
            <returns>If successful, the resampling ratio is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Will return eg. 1.2 if the samplerate was increased by 20%:
            <code>
            float ratio = BassFx.BASS_FX_TempoGetRateRatio(streamFX);
            </code>
            <code lang="vbnet">
            Dim ratio As Single = BassFx.BASS_FX_TempoGetRateRatio(streamFX)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_ReverseCreate(System.Int32,System.Single,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a reversed stream from a decoding channel.
            </summary>
            <param name="channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel.</param>
            <param name="dec_block">Length of decoding blocks in seconds. Larger blocks means less seeking overhead but larger spikes.</param>
            <param name="flags">A combination of the following flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped? Note that only complete sample loops are allowed by DirectSound (ie. you can't loop just part of a sample).</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the sample to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D samples must be mono (use BASS_SAMPLE_MONO).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_FX_FREESOURCE</term><description>Free the source handle as well when the reverse channel is freed.</description></item>
            </list>
            </param>
            <returns>If successful, the handle of the reversed stream is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>MODs are supported, if BASS_MUSIC_PRESCAN flag was applied to a source handle. Enable reverse supported flags in <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_ReverseCreate(System.Int32,System.Single,Un4seen.Bass.BASSFlag)"/> and the others to source handle. 
            <para>For better MP3/2/1 reverse playback create the source stream using the BASS_STREAM_PRESCAN flag.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>/<see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/> to get or set the attributes of a reverse stream:
            <list type="table">
            <item><term>BASS_ATTRIB_REVERSE_DIR</term><description>The playback direction of a reverse channel (-1(less than 0)=reverse, 1(greater or equal 0)=forward, or use one of the <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXReverse"/> flags).</description></item>
            </list>
            These attributes can either be applied to the reverse channel or the underlying decoding source channel.
            Note, that when playing the channel reverse, the end of a reverse stream is reached at the logial beginning of the stream (this also applies to BASS_SYNC_END).
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_FX_ERROR_NODECODE</term><description>The <paramref name="channel"/> is not a decoding channel. Make sure the channel was created using the BASS_STREAM_DECODE or BASS_MUSIC_DECODE flag.</description></item>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Create a reverse stream with 2 seconds decoding blocks:
            <code>
            // the source channel
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE | 
                                                                        BASSFlag.BASS_STREAM_PRESCAN);
            // the reverse channel
            int streamFX = BassFx.BASS_FX_ReverseCreate(stream, 2f, BASSFlag.BASS_FX_FREESOURCE);
            ...
            // play the channel reverse
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, -1f);
            // or
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, (float)BASSFXReverse.BASS_FX_RVS_REVERSE);
            
            // play the channel forward
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, 1f);
            // or
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, (float)BASSFXReverse.BASS_FX_RVS_FORWARD);
            </code>
            <code lang="vbnet">
            ' the source channel
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE Or
                                                                                   BASSFlag.BASS_STREAM_PRESCAN)
            ' the tempo channel
            Dim streamFX As Integer = BassFx.BASS_FX_ReverseCreate(stream, 2F, BASSFlag.BASS_FX_FREESOURCE)
            ...
            ' play the channel reverse
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, -1F)
            ' or
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, CSng(BASSFXReverse.BASS_FX_RVS_REVERSE))
            
            ' play the channel forward
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, 1F)
            ' or
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, CSng(BASSFXReverse.BASS_FX_RVS_FORWARD))
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_ReverseGetSource(System.Int32)">
            <summary>
            Get the source channel handle of the reversed stream.
            </summary>
            <param name="channel">The handle of the reversed stream.</param>
            <returns>If successful, the handle of the source of the reversed stream is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // the source channel
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE | 
                                                                        BASSFlag.BASS_STREAM_PRESCAN);
            // the reverse channel
            int streamFX = BassFx.BASS_FX_ReverseCreate(stream, 2f, BASSFlag.BASS_FX_FREESOURCE);
            ...
            // this will return 'stream'
            int chan = BassFx.BASS_FX_ReverseGetSource(streamFX);
            </code>
            <code lang="vbnet">
            ' the source channel
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE Or
                                                                                   BASSFlag.BASS_STREAM_PRESCAN)
            ' the tempo channel
            Dim streamFX As Integer = BassFx.BASS_FX_ReverseCreate(stream, 2F, BASSFlag.BASS_FX_FREESOURCE)
            ...
            ' this will return 'stream'
            Dim chan As Integer = BassFx.BASS_FX_ReverseGetSource(streamFX);
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROCESSPROC)">
            <summary>
            Get the original BPM of a decoding channel.
            </summary>
            <param name="channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel.</param>
            <param name="startSec">Start detecting position in seconds.</param>
            <param name="endSec">End detecting position in seconds (&gt; 0).</param>
            <param name="minMaxBPM">Set min &amp; max bpm, e.g: <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>(LowWord, HighWord), LowWord=Min, HighWord=Max. 0 = defaults to 45/230.</param>
            <param name="flags">Use one of the following (see <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXBpm"/>):
            <list type="table">
            <item><term>BASS_FX_BPM_BKGRND</term><description>If in use, then you can do other stuff while detection's in process.</description></item>
            <item><term>BASS_FX_BPM_MULT2</term><description>If in use, then the detected BPM will be automatically multiplied by 2 if (BPM &lt; minBPM*2) - recommended setting.</description></item>
            <item><term>BASS_FX_FREESOURCE</term><description>Free the source handle as well?</description></item>
            </list>
            </param>
            <param name="proc">User defined function to receive the process in percents (see <see cref="T:Un4seen.Bass.AddOn.Fx.BPMPROCESSPROC"/>), use NULL if not in use.</param>
            <returns>If successful, the original BPM value is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The BPM detection algorithm works by detecting repeating low-frequency (&lt;250Hz) sound patterns and thus works mostly with most rock/pop music with bass or drum beat. 
            The BPM detection doesn't work on pieces such as classical music without distinct, repeating bass frequency patterns. Also pieces with varying tempo, varying bass patterns or very complex bass patterns (jazz, hiphop) may produce odd BPM readings.</para>
            <para>In cases when the bass pattern drifts a bit around a nominal beat rate (e.g. drummer is again drunken ;-), the BPM algorithm may report incorrect harmonic one-halft to one-thirdth of the correct BPM value.
            In such case the system could for example report BPM value of 50 or 100 instead of correct BPM value of 150.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_FX_ERROR_NODECODE</term><description>The <paramref name="channel"/> is not a decoding channel. Make sure the channel was created using the BASS_STREAM_DECODE or BASS_MUSIC_DECODE flag.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The <paramref name="channel"/>'s format is not supported. Make sure the channel is either Stereo or Mono.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal parameter was specified.</description></item>
            <item><term>BASS_FX_ERROR_BPMINUSE</term><description>BPM detection, for this <paramref name="channel"/> is already in use.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the BPM value for the first 120 seconds of a track:
            <code>
            private BPMPROCESSPROC _bpmProc;
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE);
            _bpmProc = new BPMPROCESSPROC(MyBPMProc);
            float bpm = BassFx.BASS_FX_BPM_DecodeGet(stream, 0.0, 120.0, 0, BASSFXBpm.BASS_FX_BPM_BKGRND | 
                                                                            BASSFXBpm.BASS_FX_FREESOURCE | 
                                                                            BASSFXBpm.BASS_FX_BPM_MULT2, _bpmProc);
            BassFx.BASS_FX_BPM_Free(stream);
            ...
            private void MyBPMProc(int channel, float percent)
            {
              Console.Write("{0}%\r", percent);
            }
            </code>
            <code lang="vbnet">
            Private _bpmProc As BPMPROCESSPROC
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE)
            _bpmProc = New BPMPROCESSPROC(AddressOf MyBPMProc)
            Dim bpm As Single = BassFx.BASS_FX_BPM_DecodeGet(stream, 0.0, 120.0, 0, BASSFXBpm.BASS_FX_BPM_BKGRND Or 
                                                                                    BASSFXBpm.BASS_FX_FREESOURCE Or 
                                                                                    BASSFXBpm.BASS_FX_BPM_MULT2, _bpmProc)
            BassFx.BASS_FX_BPM_Free(stream)
            ...
            Private Sub MyBPMProc(channel As Integer, percent As Single)
              Console.Write("{0}%\r", percent)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatDecodeGet(System.Int32,System.Double,System.Double,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)">
            <summary>
            Enable getting Beat position in seconds of the decoded channel using a callback function.
            </summary>
            <param name="channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel.</param>
            <param name="startSec">Start detecting position in seconds.</param>
            <param name="endSec">End detecting position in seconds (&gt; 0).</param>
            <param name="flags">Use one of the following (see <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXBpm"/>):
            <list type="table">
            <item><term>BASS_FX_BPM_BKGRND</term><description>If in use, then you can do other stuff while detection's in process.</description></item>
            <item><term>BASS_FX_FREESOURCE</term><description>Free the source handle as well?</description></item>
            </list>
            </param>
            <param name="proc">User defined function to receive the beat position values (see <see cref="T:Un4seen.Bass.AddOn.Fx.BPMBEATPROC"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This method works pretty much the same as <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/> respectivly <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROCESSPROC)"/> - it is almost a mix of the two of them.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_FX_ERROR_NODECODE</term><description>The <paramref name="channel"/> is not a decoding channel. Make sure the channel was created using the BASS_STREAM_DECODE or BASS_MUSIC_DECODE flag.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal parameter was specified.</description></item>
            <item><term>BASS_FX_ERROR_BPMINUSE</term><description>Beat detection, for this <paramref name="channel"/> is already in use.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get all the beat positions of the first minute of a track:
            <code>
            private BPMBEATPROC _beatProc;
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE);
            _beatProc = new BPMBEATPROC(MyBeatProc);
            BassFx.BASS_FX_BPM_DecodeGet(stream, 0.0, 60.0, 0, BASSFXBpm.BASS_FX_BPM_BKGRND, _beatProc, IntPtr.Zero);
            BassFx.BASS_FX_BPM_BeatFree(stream);
            ...
            private void MyBeatProc(int channel, double beatpos, IntPtr user)
            {
              Console.WriteLine("Beat at: {0}", beatpos);
            }
            </code>
            <code lang="vbnet">
            Private _beatProc As BPMBEATPROC
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE)
            _beatProc = New BPMBEATPROC(AddressOf MyBeatProc)
            BassFx.BASS_FX_BPM_DecodeGet(stream, 0.0, 60.0, 0, BASSFXBpm.BASS_FX_BPM_BKGRND, _beatProc, IntPtr.Zero)
            BassFx.BASS_FX_BPM_BeatFree(stream)
            ...
            Private Sub MyBeatProc(channel As Integer, beatpos As Double, user As IntPtr)
              Console.WriteLine("Beat at: {0}", beatpos)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_Translate(System.Int32,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans)">
            <summary>
            Translate the given BPM to FREQ/PERCENT and vice versa or multiply BPM by 2.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="val2tran">Specify a value to translate to a given option (no matter if used X2).</param>
            <param name="trans">Any of the following translation options (see <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans"/>):
            <list type="table">
            <item><term>BASS_FX_BPM_TRAN_X2</term><description>Multiply the original BPM value by 2. This may be used only once, and will change the original BPM as well.</description></item>
            <item><term>BASS_FX_BPM_TRAN_2FREQ</term><description>BPM value to Frequency.</description></item>
            <item><term>BASS_FX_BPM_TRAN_FREQ2</term><description>Frequency to BPM value.</description></item>
            <item><term>BASS_FX_BPM_TRAN_2PERCENT</term><description>Percents to BPM value.</description></item>
            <item><term>BASS_FX_BPM_TRAN_PERCENT2</term><description>BPM value to Percents.</description></item>
            </list>
            </param>
            <returns>If successful, the newly calculated value is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function will not detect the BPM, it will just translate the detected original BPM value of a given handle.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal parameter was specified.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>BASS_FX_BPM_TRAN_X2 already used on this handle.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following method does a simple translation assuming you have calculated the original BPM on a source channel:
            <code>
            private float GetNewBPM(int sourceChannel, int tempoChannel)
            {
              return BassFx.BASS_FX_BPM_Translate(sourceChannel, 
                                                  BassFx.BASS_FX_TempoGetRateRatio(tempoChannel) * 100f, 
                                                  BASSFXBpmTrans.BASS_FX_BPM_PERCENT2);
            }
            </code>
            <code lang="vbnet">
            Private Function GetNewBPM(sourceChannel As Integer, tempoChannel As Integer) As Single
              Return BassFx.BASS_FX_BPM_Translate(sourceChannel, 
                                                  BassFx.BASS_FX_TempoGetRateRatio(tempoChannel) * 100F, 
                                                  BASSFXBpmTrans.BASS_FX_BPM_PERCENT2)
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_Free(System.Int32)">
            <summary>
            Frees all resources used by a given handle.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Used together with <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROCESSPROC)"/> or <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMPROC,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,System.IntPtr)"/>.
            If BASS_FX_FREESOURCE was used, this will also free the underlying decoding channel as well.
            You can't set/get this flag with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>/<see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMPROC,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,System.IntPtr)">
            <summary>
            Enable getting BPM value by period of time in seconds.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="proc">User defined function to receive the bpm value (see <see cref="T:Un4seen.Bass.AddOn.Fx.BPMPROC"/>).</param>
            <param name="period">Detection period in seconds.</param>
            <param name="minMaxBPM">Set min &amp; max bpm, e.g: <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>(LowWord, HighWord), LowWord=Min, HighWord=Max. 0 = defaults to 45/230.</param>
            <param name="flags">Use one of the following (see <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXBpm"/>):
            <list type="table">
            <item><term>BASS_FX_BPM_MULT2</term><description>If in use, then the detected BPM will be automatically multiplied by 2 if (BPM &lt; minBPM*2) - recommended setting.</description></item>
            </list>
            </param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal parameter was specified.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>BASS_FX_BPM_TRAN_X2 already used on this handle.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Getting BPM values in periods of 10 seconds:
            <code>
            private BPMPROC _bpmProc;
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE);
            _bpmProc = new BPMPROC(MyBPMProc);
            BassFx.BASS_FX_BPM_CallbackSet(stream, _bpmProc, 10.0, Utils.MakeLong(45,240), 
                                           BASSFXBpm.BASS_FX_BPM_MULT2, IntPtr.Zero);
            ...
            private void MyBPMProc(int handle, float bpm, IntPtr user)
            {
              Console.Write("BPM: {0}\r", bpm);
            }
            </code>
            <code lang="vbnet">
            Private _bpmProc As BPMPROC
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE)
            _bpmProc = New BPMPROC(MyBPMProc)
            BassFx.BASS_FX_BPM_CallbackSet(stream, _bpmProc, 10.0, Utils.MakeLong(45, 240), 
                                           BASSFXBpm.BASS_FX_BPM_MULT2, IntPtr.Zero)
            ...
            Private Sub MyBPMProc(handle As Integer, bpm As Single, user As IntPtr)
              Console.Write("BPM: {0}" + ControlChars.Cr, bpm)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackReset(System.Int32)">
            <summary>
            Reset the BPM buffers.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function flushes the internal buffers of the BPM callback. The BPM callback is automatically reset by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, except when called from a "mixtime" <see cref="T:Un4seen.Bass.SYNCPROC"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)">
            <summary>
            Enable getting Beat position in seconds in real-time.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="proc">User defined function to receive the beat position values (see <see cref="T:Un4seen.Bass.AddOn.Fx.BPMBEATPROC"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This method works on real-time (buffered) as well as on decoding channels and might also be used together with Tempo channels.
            <para><see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatFree(System.Int32)"/> must be called at the end to free the real-time beat position callback and resources.</para>
            <para>Note: You should call <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackReset(System.Int32)"/> after you have changed the position of the stream when called from a "mixtime" <see cref="T:Un4seen.Bass.SYNCPROC"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get all the beat positions of the first minute of a track:
            <code>
            private BPMBEATPROC _beatProc;
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_DEFAULT);
            _beatProc = new BPMBEATPROC(MyBeatProc);
            BassFx.BASS_FX_BPM_BeatCallbackSet(stream, _beatProc, IntPtr.Zero);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            private void MyBeatProc(int channel, double beatpos, IntPtr user)
            {
              Console.WriteLine("Beat at: {0}", beatpos);
            }
            </code>
            <code lang="vbnet">
            Private _beatProc As BPMBEATPROC
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_DEFAULT)
            _beatProc = New BPMBEATPROC(AddressOf MyBeatProc)
            BassFx.BASS_FX_BPM_BeatCallbackSet(stream, _beatProc, IntPtr.Zero)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Private Sub MyBeatProc(channel As Integer, beatpos As Double, user As IntPtr)
              Console.WriteLine("Beat at: {0}", beatpos)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackReset(System.Int32)">
            <summary>
            Resets the internal buffers.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function flushes the internal buffers of the Beat callback. The Beat callback is automatically reset by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, except when called from a "mixtime" <see cref="T:Un4seen.Bass.SYNCPROC"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatSetParameters(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Set new values for beat detection parameters.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="bandwidth">Bandwidth in Hz between 0 and samplerate/2 (-1.0f = leave current, default is 10Hz).</param>
            <param name="centerfreq">The center-frequency in Hz of the band pass filter between 0 and samplerate/2 (-1.0f = leave current, default is 90Hz).</param>
            <param name="beat_rtime">Beat release time in ms. (-1.0f = leave current, default is 20ms).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Beat detection is using a Band Pass Filter. A band-pass filter is a device that passes frequencies within a certain range and rejects (attenuates) frequencies outside that range.
            So the <paramref name="bandwidth"/> parameter defines the range around a center-frequency to include in the beat detection algo.
            The <paramref name="centerfreq"/> parameter actually defines the center-frequency of the band pass filter.
            Once a beat is detected, the <paramref name="beat_rtime"/> parameter defines the time in ms. in which no other beat will be detected after that just detected beat. 
            The background is, that often you have kind-of 'double beats' in a drum set. So the <paramref name="beat_rtime"/> should avoid, that a second (quickly repeated beat) beat is detected.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get all the beat positions of the first minute of a track:
            <code>
            private BPMBEATPROC _beatProc;
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_DEFAULT);
            _beatProc = new BPMBEATPROC(MyBeatProc);
            BassFx.BASS_FX_BPM_BeatCallbackSet(stream, _beatProc, IntPtr.Zero);
            BassFx.BASS_FX_BPM_BeatSetParameters(stream, 20f, 110f, 24f);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            private void MyBeatProc(int channel, double beatpos, IntPtr user)
            {
              Console.WriteLine("Beat at: {0}", beatpos);
            }
            </code>
            <code lang="vbnet">
            Private _beatProc As BPMBEATPROC
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_DEFAULT)
            _beatProc = New BPMBEATPROC(AddressOf MyBeatProc)
            BassFx.BASS_FX_BPM_BeatCallbackSet(stream, _beatProc, IntPtr.Zero)
            BassFx.BASS_FX_BPM_BeatSetParameters(stream, 20F, 240F, 24F)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Private Sub MyBeatProc(channel As Integer, beatpos As Double, user As IntPtr)
              Console.WriteLine("Beat at: {0}", beatpos)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatGetParameters(System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>
            Gets the current beat detection parameter values.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="bandwidth">Current bandwidth in Hz.</param>
            <param name="centerfreq">Current center-frequency in Hz of the band pass filter.</param>
            <param name="beat_rtime">Current beat release time in ms.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Beat detection is using a Band Pass Filter. A band-pass filter is a device that passes frequencies within a certain range and rejects (attenuates) frequencies outside that range.
            So the <paramref name="bandwidth"/> parameter defines the range around a center-frequency to include in the beat detection algo.
            The <paramref name="centerfreq"/> parameter actually defines the center-frequency of the band pass filter.
            Once a beat is detected, the <paramref name="beat_rtime"/> parameter defines the time in ms. in which no other beat will be detected after that just detected beat. 
            The background is, that often you have kind-of 'double beats' in a drum set. So the <paramref name="beat_rtime"/> should avoid, that a second (quickly repeated beat) beat is detected.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the current beat parameters:
            <code>
            float bandwidth = 0f;
            float centerfreq = 0f;
            float beat_rtime = 0f;
            if (BassFx.BASS_FX_BPM_BeatGetParameters(stream, ref bandwidth, ref centerfreq, ref beat_rtime))
            {
              Console.WriteLine("Bandwidth={0}, Center-Freq={1}, Release-Time={2}", bandwidth, centerfreq, beat_rtime);
            }
            </code>
            <code lang="vbnet">
            Dim bandwidth As Single = 0F
            Dim centerfreq As Single = 0F
            Dim beat_rtime As Single = 0F
            If BassFx.BASS_FX_BPM_BeatGetParameters(stream, bandwidth, centerfreq, beat_rtime) Then
              Console.WriteLine("Bandwidth={0}, Center-Freq={1}, Release-Time={2}", bandwidth, centerfreq, beat_rtime)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatGetParameters(System.Int32,System.Object,System.Object,System.Object)">
            <summary>
            Gets the current beat parameter values.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="bandwidth">Current bandwidth in Hz (NULL=don't retrieve it).</param>
            <param name="centerfreq">Current center-frequency of the band pass filter in Hz (NULL=don't retrieve it).</param>
            <param name="beat_rtime">Current beat release time in ms. (NULL=don't retrieve it).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Beat detection is using a Band Pass Filter. A band-pass filter is a device that passes frequencies within a certain range and rejects (attenuates) frequencies outside that range.
            So the <paramref name="bandwidth"/> parameter defines the range around a center-frequency to include in the beat detection algo.
            The <paramref name="centerfreq"/> parameter actually defines the center-frequency of the band pass filter.
            Once a beat is detected, the <paramref name="beat_rtime"/> parameter defines the time in ms. in which no other beat will be detected after that just detected beat. 
            The background is, that often you have kind-of 'double beats' in a drum set. So the <paramref name="beat_rtime"/> should avoid, that a second (quickly repeated beat) beat is detected.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the current beat release time only:
            <code>
            object beat_rtime = 0f;
            if (BassFx.BASS_FX_BPM_BeatGetParameters(stream, null, null, beat_rtime))
            {
              // beat_rtime must be casted back to a float
              Console.WriteLine("Release-Time={0}", (float)beat_rtime);
            }
            </code>
            <code lang="vbnet">
            Dim beat_rtime As Object = 0F
            If BassFx.BASS_FX_BPM_BeatGetParameters(stream, Nothing, Nothing, beat_rtime) Then
              ' beat_rtime must be casted back to a float
              Console.WriteLine("Release-Time={0}", CSng(beat_rtime))
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatFree(System.Int32)">
            <summary>
            Free all resources used by a given handle (decode or callback beat).
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Used together with <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatDecodeGet(System.Int32,System.Double,System.Double,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/>.
            <para>Note: If the BASS_FX_FREESOURCE flag is used, this will free the source decoding channel as well. You can't set/get this flag with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASS_FX from the application's startup path:
            <code>
            Bass.LoadMe();
            BassFx.LoadMe();
            ...
            // when not used anymore...
            BassFx.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASS_FX from a different directory:
            <code>
            Bass.LoadMe( @"C:\Development\BASS\_libs" );
            BassFx.LoadMe( @"C:\Development\BASS\_libs" );
            ...
            // when not used anymore...
            BassFx.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASSFXBpm">
            <summary>
            BASS_FX BPM/Beat options, to be used with <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROCESSPROC)"/>, <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMPROC,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,System.IntPtr)"/> resp. <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatDecodeGet(System.Int32,System.Double,System.Double,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpm.BASS_FX_BPM_DEFAULT">
            <summary>
            Decode: No option.
            </summary>
            <remarks>Caution: when used with the Translate methods this flag would be identical to BASS_FX_BPM_X2.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpm.BASS_FX_BPM_BKGRND">
            <summary>
            Decode: Do the processing in a background thread.
            </summary>
            <remarks>If in use, then you can do other stuff while detection's in process.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpm.BASS_FX_BPM_MULT2">
            <summary>
            Decode: If in use, then will auto multiply bpm by 2 (if BPM &lt; MinBPM*2)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpm.BASS_FX_FREESOURCE">
            <summary>
            Decode: Free the source handle as well?
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans">
            <summary>
            BASS_FX BPM Translation options, to be used with <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_Translate(System.Int32,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans.BASS_FX_BPM_TRAN_X2">
            <summary>
            BPM Translate: Multiply the original BPM value by 2 (may be called only once &amp; will change the original BPM as well!).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans.BASS_FX_BPM_TRAN_2FREQ">
            <summary>
            BPM Translate: BPM value to Frequency.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans.BASS_FX_BPM_TRAN_FREQ2">
            <summary>
            BPM Translate: Frequency to BPM value.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans.BASS_FX_BPM_TRAN_2PERCENT">
            <summary>
            BPM Translate: Percents to BPM value.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans.BASS_FX_BPM_TRAN_PERCENT2">
            <summary>
            BPM Translate: BPM value to Percents.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASSFXReverse">
            <summary>
            BASS_FX Reverse Playback directions, to be used with the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)">BASS_ATTRIB_REVERSE_DIR</see> attribute.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXReverse.BASS_FX_RVS_REVERSE">
            <summary>
            Playing in reverse direction.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXReverse.BASS_FX_RVS_FORWARD">
            <summary>
            Playing in forward direction.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASSFXChan">
            <summary>
            DSP channels flags.
            </summary>
            <remarks>
            <para>Multi-channel order of each channel is as follows:</para>
            <list type="table">
            <item><term>3 channels</term><description>left-front, right-front, center.</description></item>
            <item><term>4 channels</term><description>left-front, right-front, left-rear/side, right-rear/side.</description></item>
            <item><term>6 channels (5.1)</term><description>left-front, right-front, center, LFE, left-rear/side, right-rear/side.</description></item>
            <item><term>8 channels (7.1)</term><description>left-front, right-front, center, LFE, left-rear/side, right-rear/side, left-rear center, right-rear center.</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHANALL">
            <summary>
            All channels at once (as by default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHANNONE">
            <summary>
            Disable an effect for all channels.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN1">
            <summary>
            left-front channel
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN2">
            <summary>
            right-front channel
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN3">
            <summary>
            Channel 3: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN4">
            <summary>
            Channel 4: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN5">
            <summary>
            Channel 5: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN6">
            <summary>
            Channel 6: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN7">
            <summary>
            Channel 7: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN8">
            <summary>
            Channel 8: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN9">
            <summary>
            Channel 9: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN10">
            <summary>
            Channel 10: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN11">
            <summary>
            Channel 11: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN12">
            <summary>
            Channel 12: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN13">
            <summary>
            Channel 13: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN14">
            <summary>
            Channel 14: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN15">
            <summary>
            Channel 15: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN16">
            <summary>
            Channel 16: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN17">
            <summary>
            Channel 17: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN18">
            <summary>
            Channel 18: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN19">
            <summary>
            Channel 19: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN20">
            <summary>
            Channel 20: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN21">
            <summary>
            Channel 21: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN22">
            <summary>
            Channel 22: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN23">
            <summary>
            Channel 23: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN24">
            <summary>
            Channel 24: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN25">
            <summary>
            Channel 25: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN26">
            <summary>
            Channel 26: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN27">
            <summary>
            Channel 27: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN28">
            <summary>
            Channel 28: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN29">
            <summary>
            Channel 29: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN30">
            <summary>
            Channel 30: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Swap/Remap/Downmix.
            </summary>
            <remarks>
            This effect mixes those channels together which are specified in the <paramref name="lChannel"/> array.
            Where each array element represent the target channel (0=CHAN1, 1=CHAN2 etc.) it's value represents the source channels which should be mixed together.
            If you set a BASS_BFX_CHANNONE flag on a channel, then it will be muted.
            This allows you to either downmix, remap or swap any channels with/to any channel.
            <para>Example 1: Downmix Channel 1 with Channel 5 and put it in Channel 1
            <code lang="none">
            lChannel[0] = BASSFXChan.BASS_BFX_CHAN1 | BASSFXChan.BASS_BFX_CHAN5
            </code>
            </para>
            <para>Example 2: Swap channel 1 and channel 2
            <code lang="none">
            lChannel[0] = BASSFXChan.BASS_BFX_CHAN2
            lChannel[1] = BASSFXChan.BASS_BFX_CHAN1
            </code>
            </para>
            <para>Example 3: Remap channel 1 so it will be in channel 2 and 3
            <code lang="none">
            lChannel[0] = BASSFXChan.BASS_BFX_CHANNONE
            lChannel[1] = BASSFXChan.BASS_BFX_CHAN1
            lChannel[2] = BASSFXChan.BASS_BFX_CHAN1
            </code>
            </para>
            <para>Example 4: Downmix 5.1 to Stereo
            <code lang="none">
            lChannel[0] = BASSFXChan.BASS_BFX_CHAN1 | BASSFXChan.BASS_BFX_CHAN3 | BASSFXChan.BASS_BFX_CHAN5
            lChannel[1] = BASSFXChan.BASS_BFX_CHAN2 | BASSFXChan.BASS_BFX_CHAN4 | BASSFXChan.BASS_BFX_CHAN6
            lChannel[2] = BASSFXChan.BASS_BFX_CHANNONE
            lChannel[3] = BASSFXChan.BASS_BFX_CHANNONE
            lChannel[4] = BASSFXChan.BASS_BFX_CHANNONE
            lChannel[5] = BASSFXChan.BASS_BFX_CHANNONE
            </code>
            </para>
            <para>Multi-channel index is as follows:
            <list type="table">
            <item><term>Mono</term><description>0=left.</description></item>
            <item><term>Stereo</term><description>0=left, 1=right.</description></item>
            <item><term>3 channels</term><description>0=left-front, 1=right-front, 2=center.</description></item>
            <item><term>4 channels</term><description>0=left-front, 1=right-front, 2=left-rear/side, 3=right-rear/side.</description></item>
            <item><term>6 channels (5.1)</term><description>0=left-front, 1=right-front, 2=center, 3=LFE, 4=left-rear/side, 5=right-rear/side.</description></item>
            <item><term>8 channels (7.1)</term><description>0=left-front, 1=right-front, 2=center, 3=LFE, 4=left-rear/side, 5=right-rear/side, 6=left-rear center, 7=right-rear center.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX.lChannel">
            <summary>
            Array of channels to mix together using <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag's (lChannel[0]=1st=left, lChannel[0]=2nd=right channel etc.).
            </summary>
            <remarks>Each value of an element represents a <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag specifying the source channels to be mixed/used.
            Whereas the element index determines the target channel to put the mixed channels to.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX.#ctor(System.Int32)">
            <summary>
            Constructor assigning a linear 1:1 remap (0=CHAN1, 1=CHAN2 etc.).
            </summary>
            <param name="numChans">The number of channels to use.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX.#ctor(Un4seen.Bass.AddOn.Fx.BASSFXChan[])">
            <summary>
            Constructor already setting the channel order.
            </summary>
            <param name="channels">The variable list of the zero-based channel indexes (1st=0, 2nd=1,...). Each parameter will be applied in exactly this order.</param>
            <example>
            Swap channels 1 and 2:
            <code>
            BASS_BFX_MIX swap = new BASS_BFX_MIX(BASSFXChan.BASS_BFX_CHAN2, BASSFXChan.BASS_BFX_CHAN1);
            int channel = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            int fxMix = Bass.BASS_ChannelSetFX(channel, BASSFXType.BASS_FX_BFX_MIX, 0);
            Bass.BASS_FXSetParameters(fxMix, swap);
            </code>
            <code lang="vbnet">
            Dim swap As New BASS_BFX_MIX(BASSFXChan.BASS_BFX_CHAN2, BASSFXChan.BASS_BFX_CHAN1)
            Dim channel As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim fxMix As Integer = Bass.BASS_ChannelSetFX(channel, BASSFXType.BASS_FX_BFX_MIX, 0)
            Bass.BASS_FXSetParameters(fxMix, swap)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Echo.
            </summary>
            <remarks>No multi-channel option, only max. 2 channels (stereo).
            <para>This is an echo effect that replays what you have played one or more times after a period of time. It's something like the echoes you might hear shouting against a canyon wall.</para>
            <para>The fLevel is the volume of a signal. The lDelay is the delay time in ms.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO.fLevel">
            <summary>
            Echo level (0...1..n, linear). Default = 0.
            </summary>
            <remarks>Examples: 0.0 = -unlimited dB, 0.5 = -6dB, 1.0 = 0dB, 2.0 = +6dB
            <para>To convert a dB value to a 0-1 linear value, you can do this:
            <code>double linear = Math.Pow(10d, dB / 20.0);</code>
            </para>
            <para>To convert a linear value to a dB value, you can do this:
            <code>double dB = 20.0 * Math.Log10(level / 1.0);</code>
            </para>
            Or use the <see cref="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)"/> methods.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO.lDelay">
            <summary>
            Delay in ms (1200...30000). Default = 1200ms.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO.#ctor(System.Single,System.Int32)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Level">Echo level (0...1...n).</param>
            <param name="Delay">Delay in ms (1200...30000).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Flanger.
            </summary>
            <remarks>
            Flangers mix a varying delayed signal (usually about 5ms [0.005] to 15ms [0.015]) with the original to produce a series of notches in the frequency response. 
            The important difference between flanging and phasing is that a flanger produces a large number of notches that are harmonically (musically) related, while a phaser produces a small number of notches that are evenly spread across the frequency spectrum. 
            With high resonance, you get the "jet plane" effect.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.fWetDry">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal (0...1...n, linear, default=1).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.fSpeed">
            <summary>
            Flanger speed in seconds (0...0.09, [0ms - 90ms]). Default 0.01.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.#ctor(System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="WetDry">Ratio of wet (processed) signal to dry (unprocessed) signal (0...1...n).</param>
            <param name="Speed">Flanger speed in seconds (0...0.09).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.#ctor(System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="WetDry">Ratio of wet (processed) signal to dry (unprocessed) signal (0...1...n).</param>
            <param name="Speed">Flanger speed in seconds (0...0.09).</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.Preset_Default">
            <summary>
            Sets the instance members to a preset (WetDry=1, Speed=0.012).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Volume. (L/R for STEREO, L for MONO for both channels).
            </summary>
            <remarks>Global volume is set to 1.0 [0dB]. Channels volume can't be greater than global volume.
            To set a new global volume, set lChannel = 0.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect. 0 (BASS_FX_DSP_CHANNONE) for global volume control.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME.fVolume">
            <summary>
            Volume of right channel (0..1..n). Default = 1 (no amplification).
            </summary>
            <remarks>Examples: 0.0 = -unlimited dB, 0.5 = -6dB, 1.0 = 0dB, 2.0 = +6dB
            <para>To convert a dB value to a 0-1 linear value, you can do this:
            <code>double linear = Math.Pow(10d, dB / 20.0);</code>
            </para>
            <para>To convert a linear value to a dB value, you can do this:
            <code>double dB = 20.0 * Math.Log10(level / 1.0);</code>
            </para>
            Or use the <see cref="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)"/> methods.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME.#ctor(System.Single)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Volume">Volume of all channel (0..1..n).</param>
            <remarks>The volume is a float value between 0.0 (silence) and 1.0 (full volume, no amplification). A value above 1.0 indicates an amplification, which might cause distortion, if the original sound gets too lound and might needs to be clipped later.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME.#ctor(System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Volume">Volume of all channel (0..1..n).</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
            <remarks>The volume is a float value between 0.0 (silence) and 1.0 (full volume, no amplification). A value above 1.0 indicates an amplification, which might cause distortion, if the original sound gets too lound and might needs to be clipped later.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Peaking equalizer.
            </summary>
            <example>
            Setting up a multi-band EQ:
            <code>
            private int _fxEQ;
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_SAMPLE_FLOAT);
            SetBFX_EQ(stream);
            ...
            // increase the treble by +6bB
            UpdateFX(2, 6f);
            ...
            
            private void SetBFX_EQ(int channel)
            {
              // set peaking equalizer effect with no bands
              _fxEQ = Bass.BASS_ChannelSetFX(channel, BASSFXType.BASS_FX_BFX_PEAKEQ, 0);
            
              // setup the EQ bands
              BASS_BFX_PEAKEQ eq = new BASS_BFX_PEAKEQ();
              eq.fQ = 0f;
              eq.fBandwidth = 2.5f;
              eq.lChannel = BASSFXChan.BASS_BFX_CHANALL;
            
              // create 1st band for bass
              eq.lBand = 0;
              eq.fCenter = 125f;
              Bass.BASS_FXSetParameters(_fxEQ, eq);
              UpdateFX(0, 0f);
            
              // create 2nd band for mid
              eq.lBand = 1;
              eq.fCenter = 1000f;
              Bass.BASS_FXSetParameters(_fxEQ, eq);
              UpdateFX(1, 0f);
            
              // create 3rd band for treble
              eq.lBand = 2;
              eq.fCenter = 8000f;
              Bass.BASS_FXSetParameters(_fxEQ, eq);
              UpdateFX(2, 0f);
            }
            
            private void UpdateFX(int band, float gain)
            {
              BASS_BFX_PEAKEQ eq = new BASS_BFX_PEAKEQ();
              // get values of the selected band
              eq.lBand = band;
              Bass.BASS_FXGetParameters(_fxEQ, eq);
              eq.fGain = gain;
              Bass.BASS_FXSetParameters(_fxEQ, eq);
            }
            </code>
            <code lang="vbnet">
            Private _fxEQ As Integer
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L.ToUInt32(), 0L.ToUInt32(), BASSFlag.BASS_SAMPLE_FLOAT)
            SetBFX_EQ(stream)
            ...
            ' increase the treble by +6bB
            UpdateFX(2, 6F)
            ...
            
            Private Sub SetBFX_EQ(channel As Integer)
              ' set peaking equalizer effect with no bands
              _fxEQ = Bass.BASS_ChannelSetFX(channel, BASSFXType.BASS_FX_BFX_PEAKEQ, 0)
            
              ' setup the EQ bands
              Dim eq As New BASS_BFX_PEAKEQ()
              eq.fQ = 0F
              eq.fBandwidth = 2.5F
              eq.lChannel = BASSFXChan.BASS_BFX_CHANALL
            
              ' create 1st band for bass
              eq.lBand = 0
              eq.fCenter = 125F
              Bass.BASS_FXSetParameters(_fxEQ, eq)
              UpdateFX(0, 0F)
            
              ' create 2nd band for mid
              eq.lBand = 1
              eq.fCenter = 1000F
              Bass.BASS_FXSetParameters(_fxEQ, eq)
              UpdateFX(1, 0F)
            
              ' create 3rd band for treble
              eq.lBand = 2
              eq.fCenter = 8000F
              Bass.BASS_FXSetParameters(_fxEQ, eq)
              UpdateFX(2, 0F)
            End Sub
            
            Private Sub UpdateFX(band As Integer, gain As Single)
              Dim eq As New BASS_BFX_PEAKEQ()
              ' get values of the selected band
              eq.lBand = band
              Bass.BASS_FXGetParameters(_fxEQ, eq)
              eq.fGain = gain
              Bass.BASS_FXSetParameters(_fxEQ, eq)
            End Sub
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.lBand">
            <summary>
            Number of bands (0...n), more bands means more memory and cpu usage. Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.fBandwidth">
            <summary>
            Bandwidth in octaves (0.1...4...n), Q is not in use. Default = 1.
            <para>In most cases users should use the minimum of 0.5 octave.</para>
            <para>The bandwidth in octaves (between -3 dB frequencies for BPF and notch or between midpoint (dBgain/2) gain frequencies for peaking EQ).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.fQ">
            <summary>
            EE kinda definition of Q (0.1...1...n), bandwidth is not in use. Default = 0.1;
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.fCenter">
            <summary>
            Center frequency in Hz (1Hz...nHz). Default = 1000 (max. is 1/2 of the samplerate).
            </summary>
            <remarks>Use 'oldcenter*freq/oldfreq' to update the fCenter after changing the samplerate.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.fGain">
            <summary>
            Gain in dB (-15...0...+15). Default 0dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.#ctor(System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Band">Number of bands (0...n), more bands means more memory and cpu usage.</param>
            <param name="Bandwidth">Bandwidth in octaves (0.1...4), Q is not in use.</param>
            <param name="Q">EE kinda definition of Q (0...1...n), bandwidth is not in use.</param>
            <param name="Center">Center frequency in Hz (1...n).</param>
            <param name="Gain">Gain in dB (-15...0...+15).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.#ctor(System.Int32,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Band">Number of bands (0...n), more bands means more memory and cpu usage.</param>
            <param name="Bandwidth">Bandwidth in octaves (0.1...4), Q is not in use.</param>
            <param name="Q">EE kinda definition of Q )0...1...n), bandwidth is not in use.</param>
            <param name="Center">Center frequency in Hz (1...n).</param>
            <param name="Gain">Gain in dB (-15...0...+15).</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Reverb.
            </summary>
            <remarks>No multi-channel option, only max. 2 channels (stereo).
            <para>Reverb is the sound you hear in a room with hard surfaces (such as your bathroom) where sound bounces around the room for a while after the initial sound stops. This effect takes a lot of computing power to reproduce well.</para>
            <para>Reverb is actually made up of a very large number of repeats, with varying levels and tones over time. Reverbs usually offer you a choice of different algorithm to simulate different environments such as different sized rooms and halls, studio effects such as plate, chamber and reverse * reverbs, and sometimes emulations of guitar spring reverbs.</para>
            <para>The fLevel is the volume of a signal. The lDelay is the delay time in ms.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB.fLevel">
            <summary>
            Reverb level (0...1...n, linear). Default = 0.
            </summary>
            <remarks>Examples: 0.0 = -unlimited dB, 0.5 = -6dB, 1.0 = 0dB, 2.0 = +6dB
            <para>To convert a dB value to a 0-1 linear value, you can do this:
            <code>double linear = Math.Pow(10d, dB / 20.0);</code>
            </para>
            <para>To convert a linear value to a dB value, you can do this:
            <code>double dB = 20.0 * Math.Log10(level / 1.0);</code>
            </para>
            Or use the <see cref="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)"/> methods.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB.lDelay">
            <summary>
            Delay in ms (1200...10000). Default = 1200ms.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB.#ctor(System.Single,System.Int32)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Level">Reverb level (0...1...n).</param>
            <param name="Delay">Delay in ms (1200...10000).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Low pass filter.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF.fResonance">
            <summary>
            Resonance (0.01...10). Default = 2.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF.fCutOffFreq">
            <summary>
            Cut-off frequency in Hz (1...info.freq/2). Default = 200Hz.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF.#ctor(System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Resonance">Resonance (0.01...10).</param>
            <param name="CutOffFreq">Cut-off frequency in Hz (1...info.freq/2).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF.#ctor(System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Resonance">Resonance (0.01...10).</param>
            <param name="CutOffFreq">Cut-off frequency in Hz (1...info.freq/2).</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Dynamic amplification.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.fTarget">
            <summary>
            Target volume level (0&lt;...1, linear). Default = 1.0 (0dB).
            </summary>
            <remarks>Examples: 0.0 = -unlimited dB, 0.5 = -6dB, 1.0 = 0dB
            <para>To convert a dB value to a 0-1 linear value, you can do this:
            <code>double linear = Math.Pow(10d, dB / 20.0);</code>
            </para>
            <para>To convert a linear value to a dB value, you can do this:
            <code>double dB = 20.0 * Math.Log10(level / 1.0);</code>
            </para>
            Or use the <see cref="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)"/> methods.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.fQuiet">
            <summary>
            Quiet volume level (0...1, linear). Default = 0.
            </summary>
            <remarks>Examples: 0.0 = -unlimited dB, 0.5 = -6dB, 1.0 = 0dB
            <para>To convert a dB value to a 0-1 linear value, you can do this:
            <code>double linear = Math.Pow(10d, dB / 20.0);</code>
            </para>
            <para>To convert a linear value to a dB value, you can do this:
            <code>double dB = 20.0 * Math.Log10(level / 1.0);</code>
            </para>
            Or use the <see cref="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)"/> methods.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.fRate">
            <summary>
            Amplification adjustment rate (0...1, linear), e.g. 0.02. Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.fGain">
            <summary>
            Amplification level (0...1...n, linear). Default = 0.
            </summary>
            <remarks>Examples: 0.0 = -unlimited dB, 0.5 = -6dB, 1.0 = 0dB, 2.0 = +6dB
            <para>To convert a dB value to a 0-1 linear value, you can do this:
            <code>double linear = Math.Pow(10d, dB / 20.0);</code>
            </para>
            <para>To convert a linear value to a dB value, you can do this:
            <code>double dB = 20.0 * Math.Log10(level / 1.0);</code>
            </para>
            Or use the <see cref="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)"/> methods.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.fDelay">
            <summary>
            Delay in seconds before increasing level (0...n, linear). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Target">Target volume level (0&lt;...1)</param>
            <param name="Quiet">Quiet volume level (0...1)</param>
            <param name="Rate">Amplification adjustment rate (0...1)</param>
            <param name="Gain">Amplification level (0...1...n)</param>
            <param name="Delay">Delay in seconds before increasing level (0...n)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Target">Target volume level (0&lt;...1)</param>
            <param name="Quiet">Quiet volume level (0...1)</param>
            <param name="Rate">Amplification adjustment rate (0...1)</param>
            <param name="Gain">Amplification level (0...1...n)</param>
            <param name="Delay">Delay in seconds before increasing level (0...n)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.Preset_Soft">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.Preset_Medium">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.Preset_Hard">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Auto wah.
            </summary>
            <remarks>
            <para>The effect implements the auto-wah by using 4-stage phaser effect which moves a peak in the frequency response up and down the frequency spectrum by amplitude of input signal.</para>
            <para>The fDryMix is the volume of input signal and the fWetMix is the volume of delayed signal. The fFeedback sets feedback of auto wah (phaser). The fRate and fRange control how fast and far the frequency notches move. The fRate is the rate of sweep in cycles per second, fRange is the width of sweep in octaves. And the the fFreq is the base frequency of sweep.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.fRate">
            <summary>
            Rate of sweep in cycles per second (0&lt;...&lt;10). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.fRange">
            <summary>
            Sweep range in octaves (0&lt;...&lt;10). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.fFreq">
            <summary>
            Base frequency of sweep range (0&lt;...1000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2...+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2...+2)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="Rate">Rate of sweep in cycles per second (0&lt;...&lt;10)</param>
            <param name="Range">Sweep range in octaves (0&lt;...&lt;10)</param>
            <param name="Freq">Base frequency of sweep range (0&lt;...1000)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2...+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2...+2)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="Rate">Rate of sweep in cycles per second (0&lt;...&lt;10)</param>
            <param name="Range">Sweep range in octaves (0&lt;...&lt;10)</param>
            <param name="Freq">Base frequency of sweep range (0&lt;...1000)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.Preset_SlowAutoWah">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.Preset_FastAutoWah">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.Preset_HiFastAutoWah">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Echo 2.
            </summary>
            <remarks>
            <para>This is an echo effect that replays what you have played one or more times after a period of time. It's something like the echoes you might hear shouting against a canyon wall.</para>
            <para>The fDryMix is the volume of input signal and the fWetMix is the volume of delayed signal. The fDelay is the delay time in sec. The fFeedback sets how much delay is feed back to the input (for repeating delays).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.fDelay">
            <summary>
            Delay in seconds (0&lt;...6). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2..+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2..+2)</param>
            <param name="Feedback">Feedback (-1..+1)</param>
            <param name="Delay">Delay in seconds (0&lt;..6)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.#ctor(System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2..+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2..+2)</param>
            <param name="Feedback">Feedback (-1..+1)</param>
            <param name="Delay">Delay in seconds (0&lt;..6)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.Preset_SmallEcho">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.Preset_ManyEchoes">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.Preset_ReverseEchoes">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Phaser.
            </summary>
            <remarks>
            <para>Phasers use an internal low frequency oscillator to automatically move notches in the frequency response up and down the frequency spectrum. 
            An important difference between phasing and flanging is that phasers space these notches evenly across the frequency spectrum, while the notches in flanging and chorus are harmonically (musically) related. 
            You don't hear the notches as such (because they are the frequencies that are removed). 
            What you hear is the resulting frequency peaks between these notches. Phasing works by mixing the original signal with one that is phase shifted over the frequency spectrum. 
            For example, a four stage phaser signal (such as this) could be from 0 degrees at 100Hz, shifted to 720 degrees at 5Khz (these extremes are not quite possible practically, but are near enough to explain the effect). 
            This is how the term phase shifter comes about. A 4 stage phaser has 2 notches with bass response, a central peak, and treble response. 
            By using resonance to enhance the central peak, you can get a sound similar to an automatic wah. 
            Using a phaser with lots of stages and setting the resonance high can give a sound similar to flanging, although they are really quite different.</para>
            <para>The fDryMix is the volume of input signal and the fWetMix is the volume of delayed signal. 
            The fFeedback sets feedback of phaser. 
            The fRate and fRange control how fast and far the frequency notches move. 
            The fRate is the rate of sweep in cycles per second, fRange is the width of sweep in octaves. 
            And the the fFreq is the base frequency of sweep.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.fRate">
            <summary>
            Rate of sweep in cycles per second (0&lt;...&lt;10). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.fRange">
            <summary>
            Sweep range inoctaves (0&lt;...&lt;10). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.fFreq">
            <summary>
            Base frequency of sweep range (0&lt;...1000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2...+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2...+2)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="Rate">Rate of sweep in cycles per second (0&lt;...&lt;10)</param>
            <param name="Range">Sweep range inoctaves (0&lt;...&lt;10)</param>
            <param name="Freq">Base frequency of sweep range (0&lt;...1000)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2...+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2...+2)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="Rate">Rate of sweep in cycles per second (0&lt;...&lt;10)</param>
            <param name="Range">Sweep range inoctaves (0&lt;...&lt;10)</param>
            <param name="Freq">Base frequency of sweep range (0&lt;...1000)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_PhaseShift">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_SlowInvertPhaseShiftWithFeedback">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_BasicPhase">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_PhaseWithFeedback">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_MediumPhase">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_FastPhase">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_InvertWithInvertFeedback">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_TremoloWah">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Echo 3.
            </summary>
            <remarks>
            <para>This is an echo effect that replays what you have played one or more times after a period of time. It's something like the echoes you might hear shouting against a canyon wall.</para>
            <para>The fDryMix is the volume of input signal and the fWetMix is the volume of delayed signal. The fDelay is the delay time in sec.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.fDelay">
            <summary>
            Delay in seconds (0&lt;...6). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2..+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2..+2)</param>
            <param name="Delay">Delay in seconds (0&lt;..6)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.#ctor(System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2..+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2..+2)</param>
            <param name="Delay">Delay in seconds (0&lt;..6)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.Preset_SmallEcho">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.Preset_DoubleKick">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.Preset_LongEcho">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Chorus.
            </summary>
            <remarks>
            <para>True vintage chorus works the same way as flanging. 
            It mixes a varying delayed signal with the original to produce a large number of harmonically related notches in the frequency response. 
            Chorus uses a longer delay than flanging, so there is a perception of "spaciousness", although the delay is too short to hear as a distinct slap-back echo. 
            There is also little or no feedback, so the effect is more subtle.</para>
            <para>The fDryMix is the volume of input signal and the fWetMix is the volume of delayed signal. 
            The fFeedback sets feedback of chorus. 
            The fRate, fMinSweep and fMaxSweep control how fast and far the frequency notches move. 
            The fRate is the rate of delay change in millisecs per sec, fMaxSweep-fMinSweep is the range or width of sweep in ms.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.fMinSweep">
            <summary>
            Minimum delay in ms (0&lt;...6000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.fMaxSweep">
            <summary>
            Maximum delay in ms (0&lt;...6000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.fRate">
            <summary>
            Rate in ms/s (0&lt;...1000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2...+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2...+2)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="MinSweep">Minimum delay in ms (0&lt;...6000)</param>
            <param name="MaxSweep">Maximum delay in ms (0&lt;...6000)</param>
            <param name="Rate">Rate in ms/s (0&lt;...1000)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2...+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2...+2)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="MinSweep">Minimum delay in ms (0&lt;...6000)</param>
            <param name="MaxSweep">Maximum delay in ms (0&lt;...6000)</param>
            <param name="Rate">Rate in ms/s (0&lt;...1000)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_Flanger">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_ExaggeratedChorusLTMPitchSshiftedVoices">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_Motocycle">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_Devil">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_WhoSayTTNManyVoices">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_BackChipmunk">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_Water">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_ThisIsTheAirplane">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect All pass filter.
            </summary>
            <remarks>
            <para>The allpass filter has the unique property that it passes all frequencies equally. This property makes it useful in reverberator design because it increases echo density while reducing signal coloration (an allpass filter is NOT transparent to transient signals, as it does have a phase response). The structure of an allpass filter is similar to the comb filter, but it contains an additional feedforward path. In reverb applications, the delay used in an allpass filter is generally measured in milliseconds. This keeps the 'reflections' spaced apart in a similar fashion to a room's impulse response.</para>
            <para>The fDelay sets delay for all pass filter. The fGain controls the gain of all pass filter.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.fGain">
            <summary>
            Gain of the all pass filter (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.fDelay">
            <summary>
            Delay in seconds (0...6). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.#ctor(System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Gain">Gain (-1..+1)</param>
            <param name="Delay">Delay in seconds (0..6)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.#ctor(System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Gain">Gain (-1..+1)</param>
            <param name="Delay">Delay in seconds (0..6)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.Preset_SmallRever">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.Preset_RobotVoice">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.Preset_LongReverberation">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Compressor.
            </summary>
            <remarks>
            <para>Compressors are commonly used in recording to control the level, by making loud passages quieter, and quiet passages louder. 
            This is useful in allowing a vocalist to sing quiet and loud for different emphasis, and always be heard clearly in the mix. 
            Compression is generally applied to guitar to give clean sustain, where the start of a note is "squashed" with the gain automatically increased as the not fades away. 
            Compressors take a short time to react to a picked note, and it can be difficult to find settings that react quickly enough to the volume change without killing the natural attack sound of your guitar.</para>
            <para>The fThreshold sets the level above which volume is cut, and below which volume is boosted. 
            This is usually achieved simply by increasing the internal gain, so it really controls the amount of perceived sustain. 
            The fAttacktime controls how fast the unit responds to volume increases. 
            The fReleasetime controls how slowly the unit responds to decreasing volume.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.fThreshold">
            <summary>
            Compressor threshold (0...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.fAttacktime">
            <summary>
            Attack time in ms (0&lt;...1000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.fReleasetime">
            <summary>
            Release time in ms (0&lt;...5000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Threshold">Compressor threshold (0...+1)</param>
            <param name="Attacktime">Attack time in ms (0&lt;...1000)</param>
            <param name="Releasetime">Release time in ms (0&lt;...5000)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.#ctor(System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Threshold">Compressor threshold (0...+1)</param>
            <param name="Attacktime">Attack time in ms (0&lt;...1000)</param>
            <param name="Releasetime">Release time in ms (0&lt;...5000)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.Preset_50Attack15msRelease1sec">
            <summary>
            Sets the instance members to a preset.
            </summary>
            <remarks>
            <para>Threshold: -6 dB</para>
            <para>Attack: 15ms</para>
            <para>Release: 1sec</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.Preset_80Attack1msRelease05sec">
            <summary>
            Sets the instance members to a preset.
            </summary>
            <remarks>
            <para>Threshold: -2 dB</para>
            <para>Attack: 1ms</para>
            <para>Release: 500ms</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.Preset_Soft">
            <summary>
            Sets the instance members to a preset.
            </summary>
            <remarks>
            <para>Threshold: -1 dB</para>
            <para>Attack: 20ms</para>
            <para>Release: 350ms</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.Preset_SoftHigh">
            <summary>
            Sets the instance members to a preset.
            </summary>
            <remarks>
            <para>Threshold: -3 dB</para>
            <para>Attack: 10ms</para>
            <para>Release: 200ms</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.Preset_Medium">
            <summary>
            Sets the instance members to a preset.
            </summary>
            <para>Threshold: -6 dB</para>
            <para>Attack: 5ms</para>
            <para>Release: 250ms</para>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.Preset_Hard">
            <summary>
            Sets the instance members to a preset.
            </summary>
            <para>Threshold: -12 dB</para>
            <para>Attack: 2.2ms</para>
            <para>Release: 400ms</para>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Distortion.
            </summary>
            <remarks>
            <para>Similar to Pre/Post Gain and Drive controls on amps. 
            They were first introduced as a trick to added color to a guitar's tone. 
            Usually produced back then by turning the amp all the way up, or slightly pulling out a tube from its socket. 
            These tones are now today referred to as Overdrives. 
            Today, there are an almost infinite variety of these effects, and they range in 3 classes: Distortions, Fuzz, and Overdrive. 
            One common feature to mostly all of these types of pedals is a volume and drive (also noted as distortion, fuzz, gain, ...etc.). 
            Overdrives are usually a sustain and volume boosting pedal. Used by more traditional rock and country bands. 
            Next are the Distortions, which range from punk style to death metal screams. They are similar to Overdrives, but have more buzzing quality to them. 
            Finally, there are the Fuzzes which are more distorted than distortions, but are more mellow and compressed sounding. 
            Many pedals can be confused within these names, and some may be named other than what they are. 
            Towards the end of this era, the back-to-back diode pair became popular as a technique to provide soft clipping (with germanium diodes) and hard clipping (with silicon diodes). 
            Today, overdrive effects usually means soft clipping, where gain is reduced beyond the clipping point, while distortion usually means hard clipping, where the level is fixed beyond the clipping point. 
            Distortion is a little harder sound, good for rock, while overdrive gives a more natural sound.</para>
            <para>The fDrive controls the amount of overdrive. 
            The fVolume to balance the effect volume with the bypassed level. 
            It can also be used to boost the signal for solos. 
            The fDryMix is the volume of input signal and the fWetMix is the volume of distorted signal. 
            The fFeedback sets feedback of distortion.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.fDrive">
            <summary>
            Distortion drive (0...5). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-5...+5). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.fWetMix">
            <summary>
            Wet (affected) signal mix (-5...+5). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.fVolume">
            <summary>
            Distortion volume (0...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Drive">Distortion drive (0...5)</param>
            <param name="DryMix">Dry (unaffected) signal mix (-5...+5)</param>
            <param name="WetMix">Wet (affected) signal mix (-5...+5)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="Volume">Distortion volume (0...+2)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Drive">Distortion drive (0...5)</param>
            <param name="DryMix">Dry (unaffected) signal mix (-5...+5)</param>
            <param name="WetMix">Wet (affected) signal mix (-5...+5)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="Volume">Distortion volume (0...+2)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.Preset_HardDistortion">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.Preset_VeryHardDistortion">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.Preset_MediumDistortion">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BPMPROCESSPROC">
            <summary>
            User defined callback function, to get the bpm detection process in percents.
            </summary>
            <param name="channel">Channel that the <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROCESSPROC)"/> applies to.</param>
            <param name="percent">The progress of the process in percent (0%..100%).</param>
            <remarks>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BPMPROC">
            <summary>
            User defined callback function, to auto get the BPM after each period of time in seconds.
            </summary>
            <param name="handle">Handle that the <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMPROC,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,System.IntPtr)"/> applies to.</param>
            <param name="bpm">The new original bpm value.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMPROC,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BPMBEATPROC">
            <summary>
            User defined callback function, to get the Beat position in seconds.
            </summary>
            <param name="handle">Handle that the <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatDecodeGet(System.Int32,System.Double,System.Double,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/> has applied to.</param>
            <param name="beatpos">The exact beat position in seconds.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatDecodeGet(System.Int32,System.Double,System.Double,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Cd.BassCd">
            <summary>
            BASS.NET API wrapper for BASSCD.DLL
            <para>Requires: basscd.dll - CD Audio Tracks (CD) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSCD is an extension to the BASS audio library, enabling the streaming and ripping of CD audio tracks.</para>
            <para>The CD format is used in very much the same way as any of the built-in BASS stream formats - simply call the CD stream creation function instead of the BASS built-in functions. The BASS plugin system (see <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>) is also supported for CDA files.</para>
            <para>Plus there are many additional CD drive, digital as well as analog related methods.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_SetInterface(Un4seen.Bass.AddOn.Cd.BASSCDInterface)">
            <summary>
            Sets the interface to use to access CD drives
            </summary>
            <param name="iface">The interface to use, which can be one of the following (see <see cref="T:Un4seen.Bass.AddOn.Cd.BASSCDInterface"/>):
            <list type="table">
            <item><term>BASS_CD_IF_AUTO</term><description>Automatically detect an available interface. The interfaces are checked in the order that they are listed here. For example, if both SPTI and ASPI are available, SPTI will be used.</description></item>
            <item><term>BASS_CD_IF_SPTI</term><description>SCSI Pass-Through Interface. This is only available on NT-based Windows, not Windows 9x, and generally only to administrator user accounts, not limited/restricted user accounts.</description></item>
            <item><term>BASS_CD_IF_ASPI</term><description>Advanced SCSI Programming Interface. This is the only interface available on Windows 9x, and can also be installed on NT-based Windows.</description></item>
            <item><term>BASS_CD_IF_WIO</term><description>Windows I/O. Like SPTI, this is only available on NT-based Windows, but it is also available to limited/restricted user accounts. Some features are not available via this interface, notably sub-channel data reading and read speed control (except on Vista or newer). Door status detection is also affected.</description></item>
            </list>
            </param>
            <returns>If successful, the interface being used is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            The interface can be changed at any time, but any existing CD streams will be freed in doing so. 
            The current interface can also be reinitialized, to detect any newly connected drives.
            <para>Use of this function is optional. If it is not used, BASSCD will automatically detect an available interface.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="iface"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The interface is not available, or has no drives available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetInfo(System.Int32,Un4seen.Bass.AddOn.Cd.BASS_CD_INFO)">
            <summary>
            Retrieves information on a drive.
            </summary>
            <param name="drive">The drive to get info on... 0 = the first drive.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO"/> class to store the information at.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_CD_INFO info = new BASS_CD_INFO();
            if ( BassCd.BASS_CD_GetInfo(0, info) )
            	Console.WriteLine( info.ToString() );
            </code>
            <code lang="vbnet">
            Dim info As New BASS_CD_INFO()
            If BassCd.BASS_CD_GetInfo(0, info) Then
              Console.WriteLine(info.ToString())
            End If
            </code>
            Check if the first drive can read CD-TEXT:
            <code>
            bool canReadCDText = false;
            BASS_CD_INFO info = new BASS_CD_INFO();
            if (BassCd.BASS_CD_GetInfo(0, info) &amp;&amp; info.cdtext)
            {
              canReadCDText = true;
            }
            </code>
            <code lang="vbnet">
            Dim canReadCDText As Boolean = False
            Dim info As New BASS_CD_INFO()
            If BassCd.BASS_CD_GetInfo(0, info) AndAlso info.cdtext Then
              canReadCDText = True
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetInfo(System.Int32)">
            <summary>
            Retrieves information on a drive.
            </summary>
            <param name="drive">The drive to get info on... 0 = the first drive.</param>
            <returns>An instance of the <see cref="T:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO"/> class on success - or NULL on error.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_CD_INFO info = BassCd.BASS_CD_GetInfo(0);
            if ( info != null )
              Console.WriteLine( info.ToString() );
            </code>
            <code lang="vbnet">
            Dim info As BASS_CD_INFO = BassCd.BASS_CD_GetInfo(0)
            If Not (info Is Nothing) Then
              Console.WriteLine(info.ToString())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetInfos">
            <summary>
            Returns all available CD drive information.
            </summary>
            <returns>An array of <see cref="T:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO"/> representing the available CD drives.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetInfo(System.Int32,Un4seen.Bass.AddOn.Cd.BASS_CD_INFO)"/> internally.
            <para>The index of the returned information equals the drive number, which might be used with any other BassCd method.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetDriveCount">
            <summary>
            Returns the total number of available CD drives.
            </summary>
            <returns>Number of CD drives available.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetInfo(System.Int32,Un4seen.Bass.AddOn.Cd.BASS_CD_INFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Door(System.Int32,Un4seen.Bass.AddOn.Cd.BASSCDDoor)">
            <summary>
            Opens, closes, locks or unlocks a drive door.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="action">The action to perform... one of the following (see <see cref="T:Un4seen.Bass.AddOn.Cd.BASSCDDoor"/>):
            <list type="table">
            <item><term>BASS_CD_DOOR_CLOSE</term><description>Close the door.</description></item>
            <item><term>BASS_CD_DOOR_OPEN</term><description>Open the door.</description></item>
            <item><term>BASS_CD_DOOR_LOCK</term><description>Lock the door.</description></item>
            <item><term>BASS_CD_DOOR_UNLOCK</term><description>Unlock the door.</description></item>
            </list>
            </param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="action"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem! Could be that the door is locked.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Open the CD door of the first drive:
            <code>
            BassCd.BASS_CD_Door( 0, BASSCDDoor.BASS_CD_DOOR_OPEN );
            </code>
            <code lang="vbnet">
            BassCd.BASS_CD_Door( 0, BASSCDDoor.BASS_CD_DOOR_OPEN )
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_DoorIsOpen(System.Int32)">
            <summary>
            Checks if a drive door/tray is open.
            </summary>
            <param name="drive">The drive to check... 0 = the first drive.</param>
            <returns>TRUE is returned if the door is open, else FALSE is returned.</returns>
            <remarks>It is not possible to get the drive's current door status via the WIO interface. 
            So the last known status will be returned in that case, which may not be accurate if the door has been opened or closed by another application, or manually.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_DoorIsLocked(System.Int32)">
            <summary>
            Checks if a drive door/tray is locked.
            </summary>
            <param name="drive">The drive to check... 0 = the first drive.</param>
            <returns>TRUE is returned if the door is locked, else FALSE is returned.</returns>
            <remarks>It is not possible to get the drive's current door status via the WIO interface. 
            So the last known status will be returned in that case, which may not be accurate if the door has been opened or closed by another application.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Release(System.Int32)">
            <summary>
            Releases a drive to allow other applications to access it.
            </summary>
            <param name="drive">The drive to release... 0 = the first drive.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>When using the SPTI interface, some applications may require BASSCD to release a CD drive before the app is able to use it. 
            After a drive has been released, BASSCD will attempt to re-acquire it in the next BASSCD function call made on it.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The ASPI interface is being used.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetSpeed(System.Int32)">
            <summary>
            Retrieves the current read speed setting of a drive.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <returns>If successful, the read speed (in KB/s) is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Divide the speed by 176.4 to get the real-time speed multiplier, eg. 5645 / 176.4 = "32x speed".
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The read speed is unavailable.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetSpeedFactor(System.Int32)">
            <summary>
            Retrieves the current read speed factor of a drive.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <returns>If successful, the read speed factor (e.g. 32x) is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The read speed is unavailable.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_SetSpeed(System.Int32,System.Int32)">
            <summary>
            Sets the read speed of a drive in KB/s.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="speed">The speed, in KB/s.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The speed is automatically restricted (rounded down) to what's supported by the drive, so may not be exactly what was requested. <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetSpeed(System.Int32)"/> can be used to check that. 
            The maximum supported speed can be retrieved via <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetInfo(System.Int32,Un4seen.Bass.AddOn.Cd.BASS_CD_INFO)"/>.</para>
            <para>To use a real-time speed multiplier, multiply it by 176.4 (and round up) to get the KB/s speed to use with this function, eg. "32x speed" = 32 * 176.4 = 5645.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_SetSpeed(System.Int32,System.Single)">
            <summary>
            Sets the read speed of a drive.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="factor">The speed factor multiplier, e.g. 32.0 for 32x.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            The speed is automatically restricted (rounded down) to what's supported by the drive, so may not be exactly what was requested. <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetSpeed(System.Int32)"/> can be used to check that. 
            The maximum supported speed can be retrieved via <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetInfo(System.Int32,Un4seen.Bass.AddOn.Cd.BASS_CD_INFO)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetCache(System.Int32)">
            <summary>
            Gets the cache of a CD drive.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_SetCache(System.Int32,System.Boolean)">
            <summary>
            Sets the cache of a CD drive.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="enable"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_IsReady(System.Int32)">
            <summary>
            Checks if there is a CD ready in a drive.
            </summary>
            <param name="drive">The drive to check... 0 = the first drive.</param>
            <returns>If there is a CD ready in the drive, then TRUE is returned, else FALSE is returned.</returns>
            <remarks>This function only returns TRUE once there's a CD in the drive, and it's ready to be accessed.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetIDPtr(System.Int32,Un4seen.Bass.AddOn.Cd.BASSCDId)">
            <summary>
            
            </summary>
            <param name="drive"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetID(System.Int32,Un4seen.Bass.AddOn.Cd.BASSCDId)">
            <summary>
            Retrieves identification info from the CD in a drive.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="id">The identification to retrieve, one of the following (see <see cref="T:Un4seen.Bass.AddOn.Cd.BASSCDId"/>):
            <list type="table">
            <item><term>BASS_CDID_UPC</term><description>Returns the catalog number of the CD. The number uses UPC/EAN-code (BAR coding). This might not be available for all CDs.</description></item>
            <item><term>BASS_CDID_CDDB</term><description>Produces a CDDB identifier. This can be used to get details on the CD's contents from a CDDB server.</description></item>
            <item><term>BASS_CDID_CDDB2</term><description>Produces a CDDB2 identifier. This can be used to get details on the CD's contents from a CDDB2 server.</description></item>
            <item><term>BASS_CDID_CDPLAYER</term><description>Produces an identifier that can be used to lookup CD details in the CDPLAYER.INI file, located in the Windows directory.</description></item>
            <item><term>BASS_CDID_MUSICBRAINZ</term><description>Produces an identifier that can be used to get details on the CD's contents from MusicBrainz.</description></item>
            <item><term>BASS_CDID_ISRC + <i>track</i></term><description>Returns the International Standard Recording Code of the track... 0 = first track. This might not be available for all CDs.
            Use <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetISRC(System.Int32,System.Int32)"/> for a more convenient way to read the ISRC.</description></item>
            </list>
            </param>
            <returns>If an error occurs, NULL is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. If successful, the identication info is returned.</returns>
            <remarks>
            <para>BASS_CDID_TEXT is not supported with this overload (see <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetIDText(System.Int32)"/>).</para>
            <para>The returned identification string will remain in memory until the next call to this function, when it'll be overwritten by the next result. 
            If you need to keep the contents of an identification string, then you should copy it before calling this function again.</para>
            <para>When requesting CDDB identification, the string returned is what should be used in a CDDB query. The command sent to the CDDB server would be "cddb query &lt;the returned string&gt;". 
            If successful, that results in a list of matching CDs, which the contents of can be requested using the "cddb read" command. See <a href="http://www.cddb.com">www.cddb.com</a> and <a href="http://www.freedb.org">www.freedb.org</a> for more information on using a CDDB server.</para>
            <para>When requesting MUSICBRAINZ see <a href="http://www.musicbrainz.org">www.musicbrainz.org</a> for details.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOCD</term><description>There's no CD in the drive.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="id"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The CD does not have a UPC, ISRC or CD-TEXT info.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get a CDDB2 string from your first drive:
            <code>
            string cddb2 = BASS_CD_GetID(0, BASSCDId.BASS_CDID_CDDB2);
            </code>
            <code lang="vbnet">
            Dim cddb2 As String = BASS_CD_GetID(0, BASSCDId.BASS_CDID_CDDB2)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetISRC(System.Int32,System.Int32)">
            <summary>
            Returns the International Standard Recording Code of a track.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="track">The track... 0 = the first track.</param>
            <returns>If an error occurs, NULL is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. If successful, the ISRC is returned.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOCD</term><description>There's no CD in the drive.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="id"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The CD does not have a UPC, ISRC or CD-TEXT info.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetIDText(System.Int32)">
            <summary>
            Retrieves CD-Text identification info from the CD in a drive (BASS_CDID_TEXT).
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <returns>If an error occurs, NULL is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            If successful, a string array of all CD-Text tags is returned.
            <para><b>CD-TEXT tags:</b></para>
            <para>When requesting CD-TEXT, the tags are returned in the form of "tag=text". 
            The following is a list of all the possible tags. Where &lt;t&gt; is shown, that represents the track number, with "0" being the whole disc/album. For example, "TITLE0" is the album title, while "TITLE1" is the title of the first track.</para>
            <list type="table">
            <item><term>TITLE<i>&lt;t&gt;</i></term><description>The track (or album) title.</description></item>
            <item><term>PERFORMER<i>&lt;t&gt;</i></term><description>The performer(s), artist(s).</description></item>
            <item><term>SONGWRITER<i>&lt;t&gt;</i></term><description>The song writer(s).</description></item>
            <item><term>COMPOSER<i>&lt;t&gt;</i></term><description>The composer(s).</description></item>
            <item><term>ARRANGER<i>&lt;t&gt;</i></term><description>The arranger(s).</description></item>
            <item><term>MESSAGE<i>&lt;t&gt;</i></term><description>Message.</description></item>
            <item><term>GENRE<i>&lt;t&gt;</i></term><description>Genre.</description></item>
            <item><term>ISRC<i>&lt;t&gt;</i></term><description>International Standard Recording Code (ISRC) of the track... &lt;t&gt; is never 0.</description></item>
            <item><term>UPC</term><description>UPC/EAN code of the album.</description></item>
            <item><term>DISCID</term><description>Disc identification information.</description></item>
            </list>
            </returns>
            <remarks>
            <para>The returned identification string will remain in memory until the next call to this function, when it'll be overwritten by the next result. If you need to keep the contents of an identification string, then you should copy it before calling this function again.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOCD</term><description>There's no CD in the drive.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="id"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The CD does not have a UPC, ISRC or CD-TEXT info.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List all CD-Text tags of your first drive:
            <code>
            string[] cdText = BASS_CD_GetIDText(0);
            if (cdText != null)
            {
              foreach (string tag in cdText)
                Console.Writeln( tag );
            }
            </code>
            <code lang="vbnet">
            Dim cdText As String() = BASS_CD_GetIDText(0)
            If Not (cdText Is Nothing) Then
              Dim tag As String
              For Each tag In cdText
                Console.Writeln(tag)
              Next tag
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetTracks(System.Int32)">
            <summary>
            Retrieves the number of tracks on the CD in a drive.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. If successful, the number of tracks on the CD is returned.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOCD</term><description>There's no CD in the drive.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetTrackLength(System.Int32,System.Int32)">
            <summary>
            Retrieves the length (in bytes) of a track.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="track">The track to retrieve the length of... 0 = the first track.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. If successful, the length of the track is returned.</returns>
            <remarks>CD audio is always 44100hz stereo 16-bit. That's 176400 bytes per second. So dividing the track length by 176400 gives the length in seconds.
            <para>See also: <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetTrackLengthSeconds(System.Int32,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetTrackPregap(System.Int32,System.Int32)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOCD</term><description>There's no CD in the drive.</description></item>
            <item><term>BASS_ERROR_CDTRACK</term><description>The <paramref name="track"/> number is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAUDIO</term><description>The track is not an audio track.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetTrackLengthSeconds(System.Int32,System.Int32)">
            <summary>
            Retrieves the length (in seconds) of a track.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="track">The track to retrieve the length of... 0 = the first track.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. If successful, the length of the track in seconds is returned.</returns>
            <remarks>CD audio is always 44100hz stereo 16-bit. That's 176400 bytes per second.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOCD</term><description>There's no CD in the drive.</description></item>
            <item><term>BASS_ERROR_CDTRACK</term><description>The <paramref name="track"/> number is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAUDIO</term><description>The track is not an audio track.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetTrackPregap(System.Int32,System.Int32)">
            <summary>
            Retrieves the pregap length (in bytes) of a track.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="track">The track to retrieve the pregap length of... 0 = the first track.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            If successful, the pregap length of the track is returned. To translate the pregap length from bytes to frames, divide by 2352.</returns>
            <remarks>The drive needs to support sub-channel reading in order to detect all but the first pregap length. 
            The rwflags member of the <see cref="T:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO"/> structure can be used to check whether the drive can read sub-channel data.
            <para>A track's pregap is actually played as part of the preceeding track. 
            So to remove the gap from the end of a track, you would get the pregap length of the following track. 
            The gap will usually contain silence, but it doesn't have to - it could contain crowd noise in a live recording, for example.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOCD</term><description>There's no CD in the drive.</description></item>
            <item><term>BASS_ERROR_CDTRACK</term><description>The <paramref name="track"/> number is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAUDIO</term><description>The track is not an audio track.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Reading sub-channel data is not supported by the drive.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the length of track 1 minus the ending gap (pregap of track 2):
            <code>
            // get first track length
            int len = BassCd.BASS_CD_GetTrackLength(0, 0);
            // subtract the ending gap
            len -= BassCd.BASS_CD_GetTrackPregap(0, 1);
            </code>
            <code lang="vbnet">
            ' get first track length
            Dim len As Integer = BassCd.BASS_CD_GetTrackLength(0, 0)
            ' subtract the ending gap
            len -= BassCd.BASS_CD_GetTrackPregap(0, 1)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from an audio CD track.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="track">The track... 0 = the first track.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_CD_SUBCHANNEL</term><description>Read sub-channel data. 96 bytes of de-interleaved sub-channel data will be returned after each 2352 bytes of audio. This flag can not be used with the BASS_SAMPLE_FLOAT flag, and is ignored if the BASS_STREAM_DECODE flag is not used.</description></item>
            <item><term>BASS_CD_SUBCHANNEL_NOHW</term><description>Read sub-channel data, without using any hardware de-interleaving. This is identical to the BASS_CD_SUBCHANNEL flag, except that the de-interleaving is always performed by BASSCD even if the drive is apparently capable of de-interleaving itself.</description></item>
            </list>
            </param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Only one stream can exist at a time per CD drive. If a stream using the drive already exists, this function will fail, unless the BASS_CONFIG_CD_FREEOLD config option is enabled (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>). 
            Note that <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_StreamSetTrack(System.Int32,System.Int32)"/> can be used to change track without creating a new stream.</para>
            <para>The sample format of a CD audio stream is always 44100hz stereo 16-bit, unless the BASS_SAMPLE_FLOAT flag is used, in which case it's converted to 32-bit. When reading sub-channel data, the sample rate will be 45900hz, taking the additional sub-channel data into account.</para>
            <para>When reading sub-channel data, BASSCD will automatically de-interleave the data if the drive can't. You can check whether the drive can de-interleave the data itself (or even read sub-channel data at all) in the the rwflags member of <see cref="T:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO"/>.</para>
            <para>When using the BASS_STREAM_DECODE flag, it's not possible to play the stream, but seeking is still possible. Because the decoded sample data is not outputted, "decoding channels" can still be used when there is no output device (using the "no sound" device with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>A stream using this drive already exists.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The BASS_CD_SUBCHANNEL and BASS_SAMPLE_FLOAT flags can not be used together.</description></item>
            <item><term>BASS_ERROR_NOCD</term><description>There's no CD in the drive.</description></item>
            <item><term>BASS_ERROR_CDTRACK</term><description><paramref name="track"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAUDIO</term><description>The track is not an audio track.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Reading sub-channel data is not supported by the drive.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If using the BASS_SAMPLE_FLOAT flag, it could be that floating-point channels are not supported (ie. no WDM drivers).</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play an entire CD without any gap between tracks:
            <code>
            private SYNCPROC _mySync;  // make it global, so that the GC can not collect it
            ...
            // create CD stream
            int stream = BassCd.BASS_CD_StreamCreate(0, track, BASSFlag.BASS_DEFAULT | BASS_STREAM_AUTOFREE);
            _mySync = new SYNCPROC(EndSync);
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_END | BASSSync.BASS_SYNC_MIXTIME, 0, _mySync, IntPtr.Zero);
            // start playing
            Bass.BASS_ChannelPlay(stream, false);
            ...
            private void EndSync(int handle, int channel, int data, IntPtr user)
            {
              // get current track
              int track = Utils.LowWord32(BassCd.BASS_CD_StreamGetTrack(channel));
              // jump to next track
              BassCd.BASS_CD_StreamSetTrack(channel, track + 1);
            }
            </code>
            <code lang="vbnet">
            Private _mySync As SYNCPROC ' make it global, so that the GC can not collect it
            ...
            ' create CD stream
            Dim stream As Integer = BassCd.BASS_CD_StreamCreate(0, track, BASSFlag.BASS_DEFAULT Or BASS_STREAM_AUTOFREE)
            _mySync = New SYNCPROC(AddressOf EndSync)
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_END Or BASSSync.BASS_SYNC_MIXTIME, 0, _mySync, IntPtr.Zero)
            ' start playing
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Private Sub EndSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              ' get current track
              Dim track As Integer = Utils.LowWord32(BassCd.BASS_CD_StreamGetTrack(channel))
              ' jump to next track
              BassCd.BASS_CD_StreamSetTrack(channel, track + 1)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_StreamCreateFileUnicode(System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="file"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_StreamCreateFile(System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from an audio CD track, using a CDA file on the CD.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically, if not set.</para>
            </summary>
            <param name="file">The CDA filename... for example, "D:\Track01.cda".</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>:
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_CD_SUBCHANNEL</term><description>Read sub-channel data. 96 bytes of de-interleaved sub-channel data will be returned after each 2352 bytes of audio. This flag can not be used with the BASS_SAMPLE_FLOAT flag, and is ignored if the BASS_STREAM_DECODE flag is not used.</description></item>
            <item><term>BASS_CD_SUBCHANNEL_NOHW</term><description>Read sub-channel data, without using any hardware de-interleaving. This is identical to the BASS_CD_SUBCHANNEL flag, except that the de-interleaving is always performed by BASSCD even if the drive is apparently capable of de-interleaving itself.</description></item>
            <item><term>BASS_UNICODE</term><description>file is a Unicode (16-bit characters) filename (not needed with this overload).</description></item>
            </list>
            </param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Only one stream can exist at a time per CD drive. If a stream using the drive already exists, this function will fail, unless the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_CD_FREEOLD</see> config option is enabled (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>). 
            Note that <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_StreamSetTrack(System.Int32,System.Int32)"/> can be used to change track without creating a new stream.</para>
            <para>The sample format of a CD audio stream is always 44100hz stereo 16-bit, unless the BASS_SAMPLE_FLOAT flag is used, in which case it's converted to 32-bit. When reading sub-channel data, the sample rate will be 45900hz, taking the additional sub-channel data into account.</para>
            <para>When reading sub-channel data, BASSCD will automatically de-interleave the data if the drive can't. You can check whether the drive can de-interleave the data itself (or even read sub-channel data at all) in the the rwflags member of <see cref="T:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO"/>.</para>
            <para>When using the BASS_STREAM_DECODE flag, it's not possible to play the stream, but seeking is still possible. Because the decoded sample data is not outputted, "decoding channels" can still be used when there is no output device (using the "no sound" device with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file was not recognised as a CDA file.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>A stream using this drive already exists.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The BASS_CD_SUBCHANNEL and BASS_SAMPLE_FLOAT flags can not be used together.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Reading sub-channel data is not supported by the drive.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If using the BASS_SAMPLE_FLOAT flag, it could be that floating-point channels are not supported (ie. no WDM drivers).</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_StreamGetTrack(System.Int32)">
            <summary>
            Retrieves the drive and track number of a CD stream.
            </summary>
            <param name="handle">The CD stream handle.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            If successful, the track number is returned in the low word (low 16-bits), and the drive is returned in the high word (high 16-bits).</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Check if a channel is a CD stream, and then get it's drive and track number.
            <code>
            int track = BassCd.BASS_CD_StreamGetTrack(channel);
            if (track != -1)
            {
              int drive = Utils.HighWord32(track);
              track = Utils.LowWord32(track);
            }
            </code>
            <code lang="vbnet">
            Dim track As Integer = BassCd.BASS_CD_StreamGetTrack(channel)
            If track &lt;&gt; - 1 Then
              Dim drive As Integer = Utils.HighWord32(track)
              track = Utils.LowWord32(track)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_StreamSetTrack(System.Int32,System.Int32)">
            <summary>
            Changes the track of a CD stream.
            </summary>
            <param name="handle">The CD stream handle.</param>
            <param name="track">The new track... 0 = the first track.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The stream's current position is set to the start of the new track.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOCD</term><description>There's no CD in the drive.</description></item>
            <item><term>BASS_ERROR_CDTRACK</term><description><paramref name="track"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAUDIO</term><description>The track is not an audio track.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play an entire CD without any gap between tracks:
            <code>
            private SYNCPROC _mySync;  // make it global, so that the GC can not collect it
            ...
            // create CD stream
            int stream = BassCd.BASS_CD_StreamCreate(0, track, BASSFlag.BASS_DEFAULT | BASS_STREAM_AUTOFREE);
            _mySync = new SYNCPROC(EndSync);
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_END | BASSSync.BASS_SYNC_MIXTIME, 0, _mySync, IntPtr.Zero);
            // start playing
            Bass.BASS_ChannelPlay(stream, false);
            ...
            private void EndSync(int handle, int channel, int data, IntPtr user)
            {
              // get current track
              int track = Utils.LowWord32(BassCd.BASS_CD_StreamGetTrack(channel));
              // jump to next track
              BassCd.BASS_CD_StreamSetTrack(channel, track + 1);
            }
            </code>
            <code lang="vbnet">
            Private _mySync As SYNCPROC ' make it global, so that the GC can not collect it
            ...
            ' create CD stream
            Dim stream As Integer = BassCd.BASS_CD_StreamCreate(0, track, BASSFlag.BASS_DEFAULT Or BASS_STREAM_AUTOFREE)
            _mySync = New SYNCPROC(AddressOf EndSync)
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_END Or BASSSync.BASS_SYNC_MIXTIME, 0, _mySync, IntPtr.Zero)
            ' start playing
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Private Sub EndSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              ' get current track
              Dim track As Integer = Utils.LowWord32(BassCd.BASS_CD_StreamGetTrack(channel))
              ' jump to next track
              BassCd.BASS_CD_StreamSetTrack(channel, track + 1)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Analog_Play(System.Int32,System.Int32,System.Int32)">
            <summary>
            Starts analog playback of an audio CD track.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="track">The track... 0 = the first track.</param>
            <param name="pos">Position (in frames) to start playback from. There are 75 frames per second.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Some old CD drives may not be able to digitally extract audio data (or not quickly enough to sustain playback), so that it's not possible to use <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> to stream CD tracks. 
            This is where the analog playback option can come in handy.</para>
            <para>In analog playback, the sound bypasses BASS - it goes directly from the CD drive to the soundcard (assuming the drive is cabled up to the soundcard). 
            This means that BASS output does not need to be initialized to use analog playback. It also means it's not possible to apply any DSP/FX to the sound, and nor is it possible to visualise it (unless you record the sound from the soundcard).</para>
            <para>Analog playback is not possible while digital streaming is in progress - the streaming will kill the analog playback. So if you wish to switch from digital to analog playback, you should first free the stream using <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOCD</term><description>There's no CD in the drive.</description></item>
            <item><term>BASS_ERROR_CDTRACK</term><description><paramref name="track"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAUDIO</term><description>The track is not an audio track.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description><paramref name="pos"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play track 3 on drive 0, starting at the 10 second point:
            <code>
            bool ok = BassCd.BASS_CD_Analog_Play(0, 3, 10 * 75);
            </code>
            <code lang="vbnet">
            Dim ok As Boolean = BassCd.BASS_CD_Analog_Play(0, 3, 10 * 75)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Analog_Play(System.Int32,System.Int32,System.Double)">
            <summary>
            Starts analog playback of an audio CD track.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="track">The track... 0 = the first track.</param>
            <param name="seconds">Position (in seconds) to start playback from (this will automatically be converted to frames internally).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Some old CD drives may not be able to digitally extract audio data (or not quickly enough to sustain playback), so that it's not possible to use <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> to stream CD tracks. 
            This is where the analog playback option can come in handy.</para>
            <para>In analog playback, the sound bypasses BASS - it goes directly from the CD drive to the soundcard (assuming the drive is cabled up to the soundcard). 
            This means that BASS output does not need to be initialized to use analog playback. It also means it's not possible to apply any DSP/FX to the sound, and nor is it possible to visualise it (unless you record the sound from the soundcard).</para>
            <para>Analog playback is not possible while digital streaming is in progress - the streaming will kill the analog playback. So if you wish to switch from digital to analog playback, you should first free the stream using <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOCD</term><description>There's no CD in the drive.</description></item>
            <item><term>BASS_ERROR_CDTRACK</term><description><paramref name="track"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAUDIO</term><description>The track is not an audio track.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description><paramref name="pos"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play track 3 on drive 0, starting at the 10 second point:
            <code>
            bool ok = BassCd.BASS_CD_Analog_Play(0, 3, 10.0);
            </code>
            <code lang="vbnet">
            Dim ok As Boolean = BassCd.BASS_CD_Analog_Play(0, 3, 10.0)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Analog_PlayFile(System.String,System.Int32)">
            <summary>
            Starts analog playback of an audio CD track, using a CDA file on the CD.
            </summary>
            <param name="file">The CDA filename... for example, "D:\Track01.cda".</param>
            <param name="pos">Position (in frames) to start playback from. There are 75 frames per second.</param>
            <returns>If successful, the number of the drive being used is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Some old CD drives may not be able to digitally extract audio data (or not quickly enough to sustain playback), so that it's not possible to use <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> to stream CD tracks. 
            This is where the analog playback option can come in handy.</para>
            <para>In analog playback, the sound bypasses BASS - it goes directly from the CD drive to the soundcard (assuming the drive is cabled up to the soundcard). 
            This means that BASS output does not need to be initialized to use analog playback. It also means it's not possible to apply any DSP/FX to the sound, and nor is it possible to visualise it (unless you record the sound from the soundcard).</para>
            <para>Analog playback is not possible while digital streaming is in progress - the streaming will kill the analog playback. So if you wish to switch from digital to analog playback, you should first free the stream using <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file was not recognised as a CDA file.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description>The drive could not be found.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description><paramref name="pos"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play track 3 on drive D:, starting at the 10 second point:
            <code>
            int drive = BassCd.BASS_CD_Analog_PlayFile("D:\\Track03.cda", 10 * 75);
            </code>
            <code lang="vbnet">
            Dim drive As Integer = BassCd.BASS_CD_Analog_PlayFile("D:\Track03.cda", 10 * 75)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Analog_PlayFile(System.String,System.Double)">
            <summary>
            Starts analog playback of an audio CD track, using a CDA file on the CD.
            </summary>
            <param name="file">The CDA filename... for example, "D:\Track01.cda".</param>
            <param name="seconds">Position (in seconds) to start playback from (automatically converted to frames internally).</param>
            <returns>If successful, the number of the drive being used is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Some old CD drives may not be able to digitally extract audio data (or not quickly enough to sustain playback), so that it's not possible to use <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> to stream CD tracks. 
            This is where the analog playback option can come in handy.</para>
            <para>In analog playback, the sound bypasses BASS - it goes directly from the CD drive to the soundcard (assuming the drive is cabled up to the soundcard). 
            This means that BASS output does not need to be initialized to use analog playback. It also means it's not possible to apply any DSP/FX to the sound, and nor is it possible to visualise it (unless you record the sound from the soundcard).</para>
            <para>Analog playback is not possible while digital streaming is in progress - the streaming will kill the analog playback. So if you wish to switch from digital to analog playback, you should first free the stream using <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file was not recognised as a CDA file.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description>The drive could not be found.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description><paramref name="pos"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play track 3 on drive D:, starting at the 10 second point:
            <code>
            int drive = BassCd.BASS_CD_Analog_PlayFile("D:\Track03.cda", 10.0);
            </code>
            <code lang="vbnet">
            Dim drive As Integer = BassCd.BASS_CD_Analog_PlayFile("D:\Track03.cda", 10.0)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Analog_Stop(System.Int32)">
            <summary>
            Stops analog playback on a drive.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Pausing can be achieved by getting the position (<see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Analog_GetPosition(System.Int32)"/>) just before stopping, and then using that position in a call to <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Analog_Play(System.Int32,System.Int32,System.Int32)"/> to resume.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Analog_IsActive(System.Int32)">
            <summary>
            Checks if analog playback is in progress on a drive.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <returns>The return value is one of the folowing (see <see cref="T:Un4seen.Bass.BASSActive"/>):
            <list type="table">
            <item><term>BASS_ACTIVE_STOPPED</term><description>Analog playback is not in progress, or <paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ACTIVE_PLAYING</term><description>Analog playback is in progress.</description></item>
            </list>
            </returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Analog_GetPosition(System.Int32)">
            <summary>
            Retrieves the current position and track on a drive.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            If successful, the HIWORD contains the track number (0=first), and the LOWORD contains the offset (in frames).</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // get the position
            int pos = BassCd.BASS_CD_Analog_GetPosition(0);
            int track = Utils.HighWord32(pos);
            int frame = Utils.LowWord32(pos);
            double sec = frame / 75.0;
            </code>
            <code lang="vbnet">
            ' get the position
            Dim pos As Integer = BassCd.BASS_CD_Analog_GetPosition(0)
            Dim track As Integer = Utils.HighWord32(pos)
            Dim frame As Integer = Utils.LowWord32(pos)
            Dim sec As Double = frame / 75.0
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Analog_GetPosition(System.Int32,System.Int32@)">
            <summary>
            Retrieves the current position on a drive in seconds.
            </summary>
            <param name="drive">The drive... 0 = the first drive.</param>
            <param name="track">Returns the current track number being played.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            If successful, the position in seconds is returned.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="drive"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int track = 0;
            double sec = BASS_CD_Analog_GetPosition(0, ref track);
            </code>
            <code lang="vbnet">
            Dim track As Integer = 0
            Dim sec As Double = BASS_CD_Analog_GetPosition(0, track)
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BassCd.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the basscd.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BassCd.SupportedStreamName">
            <summary>
            Supported file format name of the basscd.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
            <example>
            Load BASS and BASSCD from the application's startup path:
            <code>
            Bass.LoadMe();
            BassCd.LoadMe();
            ...
            // when not used anymore...
            BassCd.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSCD from a different directory:
            <code>
            Bass.LoadMe( @"C:\Development\BASS\_libs" );
            BassCd.LoadMe( @"C:\Development\BASS\_libs" );
            ...
            // when not used anymore...
            BassCd.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BassCd.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Cd.BASSCDInterface">
            <summary>
            The interface to use to access CD drives (used with <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_SetInterface(Un4seen.Bass.AddOn.Cd.BASSCDInterface)"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDInterface.BASS_CD_IF_AUTO">
            <summary>
            Automatically detect an available interface. The interfaces are checked in the order that they are listed here. For example, if both SPTI and ASPI are available, SPTI will be used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDInterface.BASS_CD_IF_SPTI">
            <summary>
            SCSI Pass-Through Interface. This is only available on NT-based Windows, not Windows 9x, and generally only to administrator user accounts, not limited/restricted user accounts.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDInterface.BASS_CD_IF_ASPI">
            <summary>
            Advanced SCSI Programming Interface. This is the only interface available on Windows 9x, and can also be installed on NT-based Windows.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDInterface.BASS_CD_IF_WIO">
            <summary>
            Windows I/O. Like SPTI, this is only available on NT-based Windows, but it is also available to limited/restricted user accounts. Some features are not available via this interface, notably sub-channel data reading and read speed control (except on Vista or newer). Door status detection is also affected.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags">
            <summary>
            The drive's reading &amp; writing capabilities used with <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetInfo(System.Int32,Un4seen.Bass.AddOn.Cd.BASS_CD_INFO)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READCDR">
            <summary>
            The drive can read CD-R media.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READCDRW">
            <summary>
            The drive can read CD-RW media.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READCDRW2">
            <summary>
            The drive can read CD-R/RW media where the addressing type is "method 2".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READDVD">
            <summary>
            The drive can read DVD-ROM media.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READDVDR">
            <summary>
            The drive can read DVD-R media.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READDVDRAM">
            <summary>
            The drive can read DVD-RAM media.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READANALOG">
            <summary>
            The drive is capable of analog playback.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READM2F1">
            <summary>
            The drive can read in "mode 2 form 1" format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READM2F2">
            <summary>
            The drive can read in "mode 2 form 2" format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READMULTI">
            <summary>
            The drive can read multi-session discs.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READCDDA">
            <summary>
            The drive can read CD audio.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READCDDASIA">
            <summary>
            The drive supports "stream is accurate".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READSUBCHAN">
            <summary>
            The drive can read sub-channel data.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READSUBCHANDI">
            <summary>
            The drive can read sub-channel data, and de-interleave it.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READISRC">
            <summary>
            The drive can read ISRC numbers.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags.BASS_CD_RWFLAG_READUPC">
            <summary>
            The drive can read UPC numbers.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Cd.BASSCDDoor">
            <summary>
            The BASS_CD_Door actions to perform, used with <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Door(System.Int32,Un4seen.Bass.AddOn.Cd.BASSCDDoor)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDDoor.BASS_CD_DOOR_CLOSE">
            <summary>
            Close the door.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDDoor.BASS_CD_DOOR_OPEN">
            <summary>
            Open the door.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDDoor.BASS_CD_DOOR_LOCK">
            <summary>
            Lock the door.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDDoor.BASS_CD_DOOR_UNLOCK">
            <summary>
            Unlock the door.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Cd.BASSCDId">
            <summary>
            The identification to retrieve, used with <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetID(System.Int32,Un4seen.Bass.AddOn.Cd.BASSCDId)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDId.BASS_CDID_UPC">
            <summary>
            Returns the catalog number of the CD. The number uses UPC/EAN-code (BAR coding). This might not be available for all CDs.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDId.BASS_CDID_CDDB">
            <summary>
            Produces a CDDB identifier. This can be used to get details on the CD's contents from a CDDB server.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDId.BASS_CDID_CDDB2">
            <summary>
            Produces a CDDB2 identifier. This can be used to get details on the CD's contents from a CDDB2 server.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDId.BASS_CDID_TEXT">
            <summary>
            Retrieves the CD-TEXT information from the CD (see <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetID(System.Int32,Un4seen.Bass.AddOn.Cd.BASSCDId)"/> for details). CD-TEXT is not available on the majority of CDs.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDId.BASS_CDID_CDPLAYER">
            <summary>
            Produces an identifier that can be used to lookup CD details in the CDPLAYER.INI file, located in the Windows directory.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDId.BASS_CDID_MUSICBRAINZ">
            <summary>
            Produces an identifier that can be used to get details on the CD's contents from <a href="http://www.musicbrainz.org">www.musicbrainz.org</a>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASSCDId.BASS_CDID_ISRC">
            <summary>
            Use: + track#. Returns the International Standard Recording Code of the track... 0 = first track. This might not be available for all CDs.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetInfo(System.Int32,Un4seen.Bass.AddOn.Cd.BASS_CD_INFO)"/> to retrieve information on a drive.
            </summary>
            <remarks>The rwflags, maxspeed and cache members are unavailable when the WIO interface is used.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.vendor">
            <summary>
            The drive manufacturer name.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.product">
            <summary>
            The drive product/model name.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.rev">
            <summary>
            The revision number as a string.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.letter">
            <summary>
            The drive letter... -1=unknown, 0=A, 1=B, etc.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.rwflags">
            <summary>
            Read/Write capability flags (see <see cref="T:Un4seen.Bass.AddOn.Cd.BASSCDRWFlags"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.canopen">
            <summary>
            If TRUE, <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Door(System.Int32,Un4seen.Bass.AddOn.Cd.BASSCDDoor)"/> can be used and BASS_CD_DOOR_OPEN/CLOSE is supported?
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.canlock">
            <summary>
            If TRUE, <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_Door(System.Int32,Un4seen.Bass.AddOn.Cd.BASSCDDoor)"/> can be used and BASS_CD_DOOR_LOCK/UNLOCK is supported?
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.maxspeed">
            <summary>
            The maximum read speed, in kilobytes per second (KB/s). Divide by 176.4 to get the real-time speed multiplier, eg. 5645 / 176.4 = "32x speed".
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.cache">
            <summary>
            The drive's cache size, in kilobytes (KB).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.cdtext">
            <summary>
            The drive can read CD-TEXT?
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.ToString">
            <summary>
            A description of the decive info object (driver name, version, number of inputs/outputs).
            </summary>
            <returns></returns>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Cd.BASS_CD_INFO.DriveLetter">
            <summary>
            Gets the character letter of the drive.
            </summary>
            <remarks>Only available after <see cref="M:Un4seen.Bass.AddOn.Cd.BassCd.BASS_CD_GetInfo(System.Int32,Un4seen.Bass.AddOn.Cd.BASS_CD_INFO)"/> has been called with this instance.</remarks>
        </member>
        <member name="T:Ten53.Multimedia.Midi.Midi">
            <summary>
            This class represents the general Win32 MIDI Functions and Constants.
            <para>Requires: winmm.dll - Microsoft Multimedia Win32 library.</para>
            </summary>
            <remarks>The Musical Instrument Digital Interface (MIDI) is a protocol and set of commands for storing and transmitting information about music or devices. MIDI output devices for example might interpret this information and use it to synthesize music.
            <para>Querying MIDI Devices:</para>
            <para>Before playing or recording MIDI data, you must determine the capabilities of the MIDI hardware present in the system. MIDI capability can vary from one multimedia computer to the next. Applications should not make assumptions about the hardware present in a given system.</para>
            <para>The following functions are provided to determine how many MIDI devices are available for input or output in a given system: <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InGetNumDevs"/>, <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InGetDevCaps(System.Int32,Ten53.Multimedia.Midi.MIDI_INCAPS)"/>, <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutGetNumDevs"/> and <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutGetDevCaps(System.Int32,Ten53.Multimedia.Midi.MIDI_OUTCAPS)"/>.</para>
            <para>Like other audio devices, MIDI devices are identified by a device identifier, which is determined implicitly from the number of devices present in a given system. Device identifiers range from zero to the number of devices present, minus one. For example, if there are two MIDI output devices in a system, valid device identifiers are 0 and 1.
            After you determine how many MIDI input or output devices are present in a system, you can inquire about the capabilities of each device. Windows provides the following functions to determine the capabilities of audio devices.</para>
            <para> </para>
            <para>Opening and Closing Device Drivers:</para>
            <para>You must open a MIDI device before using it, and you should close the device as soon as you finish using it. The following functions are provided to open and close different types of MIDI devices: <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIINPROC,System.IntPtr,Ten53.Multimedia.Midi.MIDIFlags)"/>, <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InClose(System.IntPtr)"/>, <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIOUTPROC,System.IntPtr)"/> and <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutClose(System.IntPtr)"/>.</para>
            <para>Each function that opens a MIDI device takes as parameters a device identifier, an address of a memory location, and some parameters unique to MIDI devices. The memory location is filled with a device handle, which is used to identify the open audio device in calls to other audio functions.</para>
            <para>Many MIDI functions can accept either a device handle or a device identifier. Although you can use a device handle wherever you would use a device identifier, you cannot always use a device identifier when a handle is called for.</para>
            <para>Note: MIDI devices are not necessarily shareable, so a particular device may not be available when a user requests it. If this happens, the application should notify the user and allow the user to try to open the device again.</para>
            <para> </para>
            <para>Allocating and Preparing MIDI Data Blocks:</para>
            <para>The <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> and <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> functions require that applications to allocate data blocks to pass to the device drivers for playback or recording purposes. Each of these functions uses a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure to describe its data block.</para>
            <para>Before you use one of these functions to pass a data block to a device driver, you must allocate memory for the buffer and the header structure that describes the data block.</para>
            <para>The following functions are provided for preparing and cleaning up MIDI data blocks: <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/>, <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InUnprepareHeader(System.IntPtr,System.IntPtr)"/>, <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutPrepareHeader(System.IntPtr,System.IntPtr)"/> and <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutUnprepareHeader(System.IntPtr,System.IntPtr)"/>.</para>
            <para>Before you pass a MIDI data block to a device driver, you must prepare the buffer by passing it to the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutPrepareHeader(System.IntPtr,System.IntPtr)"/> function. When the device driver is finished with the buffer and returns it, you must clean up this preparation by passing the buffer to the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InUnprepareHeader(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutUnprepareHeader(System.IntPtr,System.IntPtr)"/> function before any allocated memory can be freed.</para>
            <para> </para>
            <para>Managing MIDI Data Blocks:</para>
            <para>Applications that use data blocks for passing system-exclusive messages (using the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> and <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> functions) and stream buffers must continually supply the device driver with data blocks until playback or recording is complete.</para>
            <para>Even if a single data block is used, an application must be able to determine when a device driver is finished with the data block so it can free the memory associated with the data block and header structure. Three methods can be used to determine when a device driver is finished with a data block:
            <list type="bullet">
            <item><description>Specify a callback function to receive a message sent by the driver when it is finished with a data block. To get time-stamped MIDI input data, you must use a callback function.</description></item>
            <item><description>Use an event callback (for output only).</description></item>
            <item><description>Use a window or thread callback to receive a message sent by the driver when it is finished with a data block. Note: This is not recommended in a .Net environment!</description></item>
            </list>
            If an application does not get a data block to the device driver when it is needed, an audible gap in playback or a loss of incoming recorded information can occur. At a minimum, an application should use a double-buffering scheme to stay at least one data block ahead of the device driver.
            </para>
            <para>You can write your own callback function to process messages sent by the device driver. To use a callback function, specify the <see cref="F:Ten53.Multimedia.Midi.MIDIFlags.MIDI_CALLBACK_FUNCTION"/> flag in the flags parameter and the address of the callback function in the proc parameter of the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIINPROC,System.IntPtr,Ten53.Multimedia.Midi.MIDIFlags)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIOUTPROC,System.IntPtr)"/> function.</para>
            <para>Sending System-Exclusive Messages:</para>
            <para>MIDI system-exclusive messages are the only MIDI messages that will not fit into a single Int32 value. System-exclusive messages can be any length. The <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> function is provided for sending system-exclusive messages to MIDI output devices. 
            To specify MIDI system-exclusive data blocks, use the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure.</para>
            <para>After you send a system-exclusive data block using <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/>, you must wait until the device driver is finished with the data block before freeing it. If you are sending multiple data blocks, you must monitor the completion of each data block so you know when to send additional blocks.</para>
            <para>Note: Any MIDI status byte other than a system-real-time message will terminate a system-exclusive message. If you are using multiple data blocks to send a single system-exclusive message, do not send any MIDI messages other than system-real-time messages between data blocks.</para>
            <para> </para>
            <para>Managing MIDI Recording:</para>
            <para>After you open a MIDI device, you can begin recording MIDI data. The following functions are provided for managing MIDI recording: <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/>, <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InReset(System.IntPtr)"/>, <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InStart(System.IntPtr)"/> and <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InStop(System.IntPtr)"/>.</para>
            <para>To send buffers to the device driver for recording system-exclusive messages, use <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/>. The application is notified as the buffers are filled with system-exclusive recorded data.</para>
            <para>The <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InStart(System.IntPtr)"/> function begins the recording process. When recording system-exclusive messages, send at least one buffer to the driver before starting recording. To stop recording, use <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InStop(System.IntPtr)"/>. Before closing the device by using the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InClose(System.IntPtr)"/> function, mark any pending data blocks as being done by calling <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InReset(System.IntPtr)"/>.</para>
            <para>Applications that require time-stamped data use a callback function to receive MIDI data.</para>
            <para>To record system-exclusive messages with applications that do not use stream buffers, you must supply the device driver with buffers. These buffers are specified by using a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure.</para>
            <para> </para>
            <para>Managing MIDI Thru:</para>
            <para>You can connect a MIDI input device directly to a MIDI output device so that when the input device receives an MIM_DATA message, the system sends a message with the same MIDI event data to the output device driver. 
            To connect a MIDI output device to a MIDI input device, use the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_Connect(System.IntPtr,System.IntPtr)"/> function.</para>
            <para>To achieve the best possible performance with multiple outputs, an application can choose to supply a special form of MIDI output driver, called a thru driver. Although the system allows only one MIDI output device to be connected to a MIDI input device, multiple MIDI output devices can be connected to a thru driver. 
            An application on such a system could connect the MIDI input device to this thru device and connect the MIDI thru device to as many MIDI output devices as needed. For more information about thru drivers, see the Windows device-driver documentation.</para>
            <para> </para>
            <para>Receiving Running-Status Messages:</para>
            <para>The Standard MIDI Files 1.0 specification allows the use of running status when a message has the same status byte as the previous message. When running status is used, the status byte of subsequent messages can be omitted. All MIDI input device drivers are required to expand messages using running status into complete messages, so that you always receive complete MIDI messages from a MIDI input device driver.</para>
            <para> </para>
            <para>Handling Errors with MIDI Functions:</para>
            <para>MIDI audio functions return a nonzero error code. For MIDI-associated errors, the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_GetErrorText(System.Boolean,System.Int32)"/> functions retrieve textual descriptions for the error codes. The application must still look at the error value itself to determine how to proceed, but it can use the error descriptions in dialog boxes to inform users of the error conditions.</para>
            <para>The only MIDI functions that do not return error codes are the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InGetNumDevs"/> and <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutGetNumDevs"/> functions. These functions return a value of zero if no devices are present in a system or if any errors are encountered by the function.</para>
            <para> </para>
            <para>This class does not implement MIDI Streams (see the <see cref="N:Un4seen.Bass.AddOn.Midi"/> add-on for real-time playback of MIDI streams)!</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_GetErrorText(System.Boolean,System.Int32)">
            <summary>
            Returns the error message for a given error code.
            </summary>
            <param name="input">Dealing with an input device? TRUE=input, FALSE=output.</param>
            <param name="errCode">The error code to get the message from.</param>
            <returns>The error message associated with the error code.</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_InGetDevCaps(System.Int32,Ten53.Multimedia.Midi.MIDI_INCAPS)">
            <summary>
            Determines the capabilities of a specified MIDI input device.
            </summary>
            <param name="deviceID">Identifier of the MIDI input device. The device identifier varies from zero to one less than the number of devices present.</param>
            <param name="caps">An instance of the <see cref="T:Ten53.Multimedia.Midi.MIDI_INCAPS"/> class that is filled with information about the capabilities of the device.</param>
            <returns>Returns 0 if successful or an error otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>To determine the number of MIDI input devices present on the system, use the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InGetNumDevs"/> function.</remarks>
            <example>
            List all Midi input devices:
            <code>
            int count = Midi.MIDI_InGetNumDevs();
            MIDI_INCAPS inCaps = new MIDI_INCAPS();
            for (int i=0; i&lt;count; i++)
            {
              Midi.MIDI_InGetDevCaps(i, inCaps);
              Console.WriteLine( inCaps.name );
            }
            </code>
            <code lang="vbnet">
            Dim count As Integer = Midi.MIDI_InGetNumDevs()
            Dim inCaps As New MIDI_INCAPS()
            Dim i As Integer
            For i = 0 To count-1
              Midi.MIDI_InGetDevCaps(i, inCaps)
              Console.WriteLine(inCaps.name)
            Next i
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_InGetNumDevs">
            <summary>
            Retrieves the number of MIDI input devices in the system.
            </summary>
            <returns>Returns the number of MIDI input devices present in the system. A return value of zero means that there are no devices (not that there is no error).</returns>
            <example>
            List all Misi input devices:
            <code>
            int count = Midi.MIDI_InGetNumDevs();
            MIDI_INCAPS inCaps = new MIDI_INCAPS();
            for (int i=0; i&lt;count; i++)
            {
            	Midi.MIDI_InGetDevCaps(i, inCaps);
            	Console.WriteLine( inCaps.name );
            }
            </code>
            <code lang="vbnet">
            Dim count As Integer = Midi.MIDI_InGetNumDevs()
            Dim inCaps As New MIDI_INCAPS()
            Dim i As Integer
            For i = 0 To count-1
            Midi.MIDI_InGetDevCaps(i, inCaps)
              Console.WriteLine(inCaps.name)
            Next i
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_OutGetDevCaps(System.Int32,Ten53.Multimedia.Midi.MIDI_OUTCAPS)">
            <summary>
            Queries a specified MIDI output device to determine its capabilities.
            </summary>
            <param name="deviceID">Identifier of the MIDI output device. The device identifier varies from zero to one less than the number of devices present.</param>
            <param name="caps">An instance of the <see cref="T:Ten53.Multimedia.Midi.MIDI_OUTCAPS"/> class that is filled with information about the capabilities of the device.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>To determine the number of MIDI output devices present on the system, use the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutGetNumDevs"/> function.</remarks>
            <example>
            List all Midi output port devices:
            <code>
            int count = Midi.MIDI_OutGetNumDevs();
            MIDI_OUTCAPS outCaps = new MIDI_OUTCAPS();
            for (int i=0; i&lt;count; i++)
            {
              Midi.MIDI_OutGetDevCaps(i, outCaps);
              if (outCaps.IsMidiPort)
                Console.WriteLine( outCaps.name );
            }
            </code>
            <code lang="vbnet">
            Dim count As Integer = Midi.MIDI_OutGetNumDevs()
            Dim outCaps As New MIDI_OUTCAPS()
            Dim i As Integer
            For i = 0 To count-1
              Midi.MIDI_OutGetDevCaps(i, outCaps)
              If outCaps.IsMidiPort Then
                Console.WriteLine(outCaps.name)
              End If
            Next i
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_OutGetNumDevs">
            <summary>
            Retrieves the number of MIDI output devices present in the system.
            </summary>
            <returns>Returns the number of MIDI output devices. A return value of zero means that there are no devices (not that there is no error).</returns>
            <example>
            List all Midi output devices:
            <code>
            int count = Midi.MIDI_OutGetNumDevs();
            MIDI_OUTCAPS outCaps = new MIDI_OUTCAPS();
            for (int i=0; i&lt;count; i++)
            {
              Midi.MIDI_OutGetDevCaps(i, outCaps);
              Console.WriteLine( outCaps.name );
            }
            </code>
            <code lang="vbnet">
            Dim count As Integer = Midi.MIDI_OutGetNumDevs()
            Dim outCaps As New MIDI_OUTCAPS()
            Dim i As Integer
            For i = 0 To count-1
              Midi.MIDI_OutGetDevCaps(i, outCaps)
              Console.WriteLine(outCaps.name)
            Next i
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_InOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIINPROC,System.IntPtr,Ten53.Multimedia.Midi.MIDIFlags)">
            <summary>
            Opens a MIDI input device.
            </summary>
            <param name="handle">Returns the MIDI input handle. The handle is used to identify the device in calls to other MIDI input functions.</param>
            <param name="deviceID">Identifier of the MIDI input device to be opened (see <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InGetDevCaps(System.Int32,Ten53.Multimedia.Midi.MIDI_INCAPS)"/> for details).</param>
            <param name="proc">The <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> callback delegate to use (which will receive all messages). For more information on the callback function, see <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/>.</param>
            <param name="user">User instance data passed to the callback function.</param>
            <param name="flags">A combination of the following (see <see cref="T:Ten53.Multimedia.Midi.MIDIFlags"/>):
            <list type="table">
            <item><term>MIDI_IO_STATUS</term><description>When this parameter is also specified with MIDI_CALLBACK_FUNCTION, then MIM_MOREDATA messages are sent to the callback function as well as MIM_DATA messages.</description></item>
            <item><term>MIDI_CALLBACK_FUNCTION</term><description>The proc parameter is a callback procedure address.</description></item>
            <item><term>MIDI_CALLBACK_NULL</term><description>There is no callback mechanism (proc must be NULL).</description></item>
            </list>
            </param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>
            <para>You only need to set the MIDI_IO_STATUS flag if needed, since the other flags are automatically set according to the given <paramref name="proc"/>.</para>
            <para>To determine the number of MIDI input devices present in the system, use the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InGetNumDevs"/> function. The device identifier specified by <paramref name="deviceID"/> varies from zero to one less than the number of devices present.</para>
            <para>If a function is chosen to receive callback information, the following messages are sent to the function to indicate the progress of MIDI input (see <see cref="T:Ten53.Multimedia.Midi.MIDIMessage"/>): MIM_OPEN, MIM_CLOSE, MIM_DATA, MIM_LONGDATA, MIM_ERROR, MIM_LONGERROR, and MIM_MOREDATA.</para>
            <para>If you use the MIDI_IO_STATUS flag with this method, the system uses the MIM_MOREDATA message to alert your application's callback function when it is not processing MIDI data fast enough to keep up with the input device driver.
            If your application processes MIDI data in a separate thread, boosting the thread's priority can have a significant impact on the application's ability to keep up with the data flow.</para>
            </remarks>
            <example>
            <code>
            private MIDIINPROC _midiProc;
            private IntPtr _midiInHandle;
            ...
            // Open the Midi device #1
            _midiProc = new MIDIINPROC(MyMidiProc);
            MIDIError ret = Midi.MIDI_InOpen(ref _midiInHandle, 1, _midiProc, IntPtr.Zero, MIDIFlags.MIDI_IO_STATUS);
            if (ret == MIDIError.MIDI_OK)
            {
              // Start the device
              ret = Midi.MIDI_InStart(_midiInHandle);
            }
            ...
            // when not needed anymore...stop the device
            Midi.MIDI_InReset(_midiInHandle);
            // and close the device
            Midi.MIDI_InClose(_midiInHandle);
            ...
            public void MyMidiProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
              // handle all Midi messages here
              if (msg == MIDIMessage.MIM_OPEN)
              {
                // nothing to do
              }
              else if (msg == MIDIMessage.MIM_CLOSE)
              {
                // handle is from now on invalid
              }
              else if (msg == MIDIMessage.MIM_DATA)
              {
                // process the message...
                int p1 = param1.ToInt32();
                int p2 = param2.ToInt32();
                ...
              }
              else if (msg == MIDIMessage.MIM_MOREDATA)
              {
                // we are not fast enough in this callback to keep up...
                // the input device is sending messages to fast
                ...
              }
              else if (msg == MIDIMessage.MIM_LONGDATA)
              {
                // process the message...
                ...
              }
              else if (msg == MIDIMessage.MIM_ERROR)
              {
                // process the invalid message...
                ...
              }
              else if (msg == MIDIMessage.MIM_LONGERROR)
              {
                // process the invalid message...
                ...
              }
            }
            </code>
            <code lang="vbnet">
            Private _midiProc As MIDIINPROC
            Private _midiInHandle As IntPtr
            ...
            ' Open the Midi device #1
            _midiProc = New MIDIINPROC(AddressOf MyMidiProc)
            Dim ret As MIDIError = Midi.MIDI_InOpen(_midiInHandle, 1, _midiProc, IntPtr.Zero, MIDIFlags.MIDI_IO_STATUS)
            If ret = MIDIError.MIDI_OK Then
              ' Start the device
              ret = Midi.MIDI_InStart(_midiInHandle)
            End If
            ...
            ' when not needed anymore...stop the device
            Midi.MIDI_InReset(_midiInHandle)
            ' and close the device
            Midi.MIDI_InClose(_midiInHandle)
            ...
            Public Sub MyMidiProc(handle As IntPtr, msg As MIDIMessage, instance As IntPtr, param1 As IntPtr, param2 As IntPtr)
              ' handle all Midi messages here
              If msg = MIDIMessage.MIM_OPEN Then
                ' nothing to do
              Else
                If msg = MIDIMessage.MIM_CLOSE Then
                  ' handle is from now on invalid
                Else
                  If msg = MIDIMessage.MIM_DATA Then
                    ' process the message...
                    Dim p1 As Integer = param1.ToInt32()
                    Dim p2 As Integer = param2.ToInt32()
                    ...
                  Else
                    If msg = MIDIMessage.MIM_MOREDATA Then
                      ' we are not fast enough in this callback to keep up...
                      ' the input device is sending messages to fast
                      ...
                    Else
                      If msg = MIDIMessage.MIM_LONGDATA Then
                        ' process the message...
                        ...
                      Else
                        If msg = MIDIMessage.MIM_ERROR Then
                          ' process the invalid message...
                          ...
                        Else
                          If msg = MIDIMessage.MIM_LONGERROR Then
                            ' process the invalid message...
                            ...
                          End If
                        End If 
                      End If
                    End If
                  End If
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_InClose(System.IntPtr)">
            <summary>
            Closes the specified MIDI input device.
            </summary>
            <param name="handle">Handle to the MIDI input device. If the function is successful, the handle is no longer valid after the call to this function.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>If there are input buffers that have been sent by using the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> function and have not been returned to the application, the close operation will fail. 
            To return all pending buffers through the callback function, use the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InReset(System.IntPtr)"/> function.
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_OutOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIOUTPROC,System.IntPtr)">
            <summary>
            Opens a MIDI output device for playback.
            </summary>
            <param name="handle">Returns the MIDI output handle. The handle is used to identify the device in calls to other MIDI output functions.</param>
            <param name="deviceID">Identifier of the MIDI output device to be opened (see <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutGetDevCaps(System.Int32,Ten53.Multimedia.Midi.MIDI_OUTCAPS)"/> for details).</param>
            <param name="proc">The <see cref="T:Ten53.Multimedia.Midi.MIDIOUTPROC"/> callback delegate to use. Called during MIDI playback to process messages related to the progress of the playback. If no callback is desired, specify NULL for this parameter. For more information on the callback function, see <see cref="T:Ten53.Multimedia.Midi.MIDIOUTPROC"/>.</param>
            <param name="user">User instance data passed to the callback function.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>
            <para>The flags are automatically set according to the given <paramref name="proc"/> (thats why this method does not contain any flags parameter).</para>
            <para>To determine the number of MIDI output devices present in the system, use the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutGetNumDevs"/> function. The device identifier specified by <paramref name="deviceID"/> varies from zero to one less than the number of devices present.</para>
            <para>If a function is chosen to receive callback information, the following messages are sent to the function to indicate the progress of MIDI output: MOM_OPEN, MOM_CLOSE, and MOM_DONE.</para>
            </remarks>
            <example>
            <code>
            private MIDIOUTPROC _midiProc;
            private IntPtr _midiOutHandle;
            ...
            // Open the Midi device #2
            _midiProc = new MIDIOUTPROC(MyMidiProc);
            MIDIError ret = Midi.MIDI_OutOpen(ref _midiOutHandle, 2, _midiProc, 0);
            if (ret == MIDIError.MIDI_OK)
            {
              // device opened and ready
            }
            ...
            // When not needed anymore...stop the device
            Midi.MIDI_OutReset(_midiOutHandle);
            // and close the device
            Midi.MIDI_OutClose(_midiOutHandle);
            ...
            private void SendShortMessage(int message)
            {
              MIDI_OutShortMsg(_midiOutHandle, message);
            }
            
            private void SendSysExMessage(byte[] data)
            {
              MIDI_HEADER header = new MIDI_HEADER(data);
              header.Prepare(false, _midiOutHandle);
              // If the header was perpared successfully.
              if (header.HeaderPtr != IntPtr.Zero)
              {
                // send a system-exclusive message to the output device
                Midi.MIDI_OutLongMsg(_midiOutHandle, header.HeaderPtr);
              }
            }
            
            public void MyMidiProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
              // handle all Midi messages here
              if (msg == MIDIMessage.MOM_OPEN)
              {
                // nothing to do
              }
              else if (msg == MIDIMessage.MOM_CLOSE)
              {
                // handle is from now on invalid
              }
              else if (msg == MIDIMessage.MOM_DONE)
              {
                // process the message...
                // param1 will contain the pointer to the MIDI_HEADER
                MIDI_HEADER header = new MIDI_HEADER(param1);
                // process the header if needed
                ...
                // and finally unprepare the header
                header.Unprepare(false, handle);
              }
            }
            </code>
            <code lang="vbnet">
            Private _midiProc As MIDIOUTPROC
            Private _midiOutHandle As IntPtr
            ...
            ' Open the Midi device #2
            _midiProc = New MIDIOUTPROC(MyMidiProc)
            Dim ret As MIDIError = Midi.MIDI_OutOpen(_midiOutHandle, 2, _midiProc, 0)
            If ret = MIDIError.MIDI_OK Then
              ' device opened and ready
            End If
            ...
            ' when not needed anymore...stop the device
            Midi.MIDI_OutReset(_midiOutHandle)
            ' and close the device
            Midi.MIDI_OutClose(_midiOutHandle)
            ...
            Private Sub SendShortMessage(message As Integer)
              MIDI_OutShortMsg(_midiOutHandle, message)
            End Sub
            
            Private Sub SendSysExMessage(data() As Byte)
              Dim header As New MIDI_HEADER(data)
              header.Prepare(False, _midiOutHandle)
              ' If the header was perpared successfully.
              If header.HeaderPtr &lt;&gt; IntPtr.Zero Then
                ' send a system-exclusive message to the output device
                Midi.MIDI_OutLongMsg(_midiOutHandle, header.HeaderPtr)
              End If
            End Sub
            
            Public Sub MyMidiProc(handle As IntPtr, msg As MIDIMessage, instance As IntPtr, param1 As IntPtr, param2 As IntPtr)
              ' handle all Midi messages here
              If msg = MIDIMessage.MOM_OPEN Then
                ' nothing to do
              Else
                If msg = MIDIMessage.MOM_CLOSE Then
                  ' handle is from now on invalid
                Else
                  If msg = MIDIMessage.MOM_DONE Then
                    ' process the message...
                    ' param1 will contain the pointer to the MIDI_HEADER
                    Dim header As New MIDI_HEADER(param1)
                    ' process the header if needed
                    ...
                    ' and finally unprepare the header
                    header.Unprepare(False, handle)
                  End If
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_OutClose(System.IntPtr)">
            <summary>
            Closes the specified MIDI output device.
            </summary>
            <param name="handle">Handle to the MIDI output device. If the function is successful, the handle is no longer valid after the call to this function.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>If there are output buffers that have been sent by using the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> function and have not been returned to the application, the close operation will fail. 
            To mark all pending buffers as being done, use the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutReset(System.IntPtr)"/> function.
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_Connect(System.IntPtr,System.IntPtr)">
            <summary>
            Connects a MIDI input device to a MIDI thru or output device, or connects a MIDI thru device to a MIDI output device. 
            </summary>
            <param name="handleA">Handle to a MIDI input device or a MIDI thru device (for thru devices, this handle must belong to a MIDI output device).</param>
            <param name="handleB">Handle to the MIDI output device or thru device.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>After calling this function, the MIDI input device receives event data in an MIM_DATA message whenever a message with the same event data is sent to the output device driver.
            <para>A thru driver is a special form of MIDI output driver. The system will allow only one MIDI output device to be connected to a MIDI input device, but multiple MIDI output devices can be connected to a MIDI thru device. 
            Whenever the given MIDI input device receives event data in an MIM_DATA message, a message with the same event data is sent to the given output device driver (or through the thru driver to the output drivers).</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_Disconnect(System.IntPtr,System.IntPtr)">
            <summary>
            Disconnects a MIDI input device from a MIDI thru or output device, or disconnects a MIDI thru device from a MIDI output device.
            </summary>
            <param name="handleA">Handle to a MIDI input device or a MIDI thru device.</param>
            <param name="handleB">Handle to the MIDI output device to be disconnected.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>MIDI input, output, and thru devices can be connected by using the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_Connect(System.IntPtr,System.IntPtr)"/> function. 
            Thereafter, whenever the MIDI input device receives event data in an MIM_DATA message, a message with the same event data is sent to the output device driver (or through the thru driver to the output drivers).
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_InStart(System.IntPtr)">
            <summary>
            Starts MIDI input on the specified MIDI input device.
            </summary>
            <param name="handle">Handle to the MIDI input device.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>
            <para>This function resets the time stamp to zero. Time stamp values for subsequently received messages are relative to the time that this function was called.</para>
            <para>All messages except system-exclusive messages are sent directly to the client when they are received. System-exclusive messages are placed in the buffers supplied by the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> function. 
            If there are no buffers in the queue, the system-exclusive data is thrown away without notification to the client and input continues. 
            Buffers are returned to the client when they are full, when a complete system-exclusive message has been received, or when the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InReset(System.IntPtr)"/> function is used. 
            The <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.Data"/> member of the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure will contain the actual data received.</para>
            <para>Calling this function when input is already started has no effect, and the function returns zero.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_InStop(System.IntPtr)">
            <summary>
            Stops MIDI input on the specified MIDI input device.
            </summary>
            <param name="handle">Handle to the MIDI input device.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>
            <para>If there are any system-exclusive messages or stream buffers in the queue, the current buffer is marked as done (the <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.Data"/> member of the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure will contain the actual data received), but any empty buffers in the queue remain there and are not marked as done.</para>
            <para>Calling this function when input is not started has no effect, and the function returns zero.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_InReset(System.IntPtr)">
            <summary>
            Stops input on a given MIDI input device.
            </summary>
            <param name="handle">Handle to the MIDI input device.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>This function returns all pending input buffers to the callback function and sets the <see cref="F:Ten53.Multimedia.Midi.MIDIHeader.MHDR_DONE"/> flag in the Flags member of the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_OutReset(System.IntPtr)">
            <summary>
            Turns off all notes on all MIDI channels for the specified MIDI output device.
            </summary>
            <param name="handle">Handle to the MIDI output device.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>
            <para>Any pending system-exclusive or stream output buffers are returned to the callback function and the MHDR_DONE flag is set in the Flags member of the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure.</para>
            <para>Terminating a system-exclusive message without sending an EOX (end-of-exclusive) byte might cause problems for the receiving device. 
            The <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutReset(System.IntPtr)"/> function does not send an EOX byte when it terminates a system-exclusive message — applications are responsible for doing this.</para>
            <para>To turn off all notes, a note-off message for each note in each channel is sent. In addition, the sustain controller is turned off for each channel.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_OutShortMsg(System.IntPtr,System.Int32)">
            <summary>
            Sends a short MIDI message to the specified MIDI output device.
            </summary>
            <param name="handle">Handle to the MIDI output device.</param>
            <param name="message">MIDI message. The message is packed into a double word value with the first byte of the message in the low-order byte. The message is packed into this parameter as follows:
            <para>High-Word: High-order byte: Not used. Low-order byte: The second byte of MIDI data (when needed).</para>
            <para>Low-Word: High-order byte: The first byte of MIDI data (when needed). Low-order byte: The MIDI status.</para>
            <para>The two MIDI data bytes are optional, depending on the MIDI status byte. When a series of messages have the same status byte, the status byte can be omitted from messages after the first one in the series, creating a running status.</para>
            </param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>
            <para>This function is used to send any MIDI message except for system-exclusive or stream messages.</para>
            <para>This function might not return until the message has been sent to the output device. You can send short messages while streams are playing on the same device (although you cannot use a running status in this case).</para>
            <para>You might used the <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> class to construct and or pack the message with it's components.</para>
            </remarks>
            <example>
            <code>
            private MIDIOUTPROC _midiProc;
            private IntPtr _midiOutHandle;
            ...
            // Open the Midi device #2
            _midiProc = new MIDIOUTPROC(MyMidiProc);
            MIDIError ret = Midi.MIDI_OutOpen(ref _midiOutHandle, 2, _midiProc, 0);
            if (ret == MIDIError.MIDI_OK)
            {
              // device opened and ready
            }
            ...
            // When not needed anymore...stop the device
            Midi.MIDI_OutReset(_midiOutHandle);
            // and close the device
            Midi.MIDI_OutClose(_midiOutHandle);
            ...
            private void SendShortMessage(int message)
            {
              MIDI_OutShortMsg(_midiOutHandle, message);
            }
            
            private void SendSysExMessage(byte[] data)
            {
              MIDI_HEADER header = new MIDI_HEADER(data);
              header.Prepare(false, _midiOutHandle);
              // If the header was perpared successfully.
              if (header.HeaderPtr != IntPtr.Zero)
              {
                // send a system-exclusive message to the output device
                Midi.MIDI_OutLongMsg(_midiOutHandle, header.HeaderPtr);
              }
            }
            
            public void MyMidiProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
              // handle all Midi messages here
              if (msg == MIDIMessage.MOM_OPEN)
              {
                // nothing to do
              }
              else if (msg == MIDIMessage.MOM_CLOSE)
              {
                // handle is from now on invalid
              }
              else if (msg == MIDIMessage.MOM_DONE)
              {
                // process the message...
                // param1 will contain the pointer to the MIDI_HEADER
                MIDI_HEADER header = new MIDI_HEADER(param1);
                // process the header if needed
                ...
                // and finally unprepare the header
                header.Unprepare(false, handle);
              }
            }
            </code>
            <code lang="vbnet">
            Private _midiProc As MIDIOUTPROC
            Private _midiOutHandle As IntPtr
            ...
            ' Open the Midi device #2
            _midiProc = New MIDIOUTPROC(MyMidiProc)
            Dim ret As MIDIError = Midi.MIDI_OutOpen(_midiOutHandle, 2, _midiProc, 0)
            If ret = MIDIError.MIDI_OK Then
              ' device opened and ready
            End If
            ...
            ' when not needed anymore...stop the device
            Midi.MIDI_OutReset(_midiOutHandle)
            ' and close the device
            Midi.MIDI_OutClose(_midiOutHandle)
            ...
            Private Sub SendShortMessage(message As Integer)
              MIDI_OutShortMsg(_midiOutHandle, message)
            End Sub
            
            Private Sub SendSysExMessage(data() As Byte)
              Dim header As New MIDI_HEADER(data)
              header.Prepare(False, _midiOutHandle)
              ' If the header was perpared successfully.
              If header.HeaderPtr &lt;&gt; IntPtr.Zero Then
                ' send a system-exclusive message to the output device
                Midi.MIDI_OutLongMsg(_midiOutHandle, header.HeaderPtr)
              End If
            End Sub
            
            Public Sub MyMidiProc(handle As IntPtr, msg As MIDIMessage, instance As IntPtr, param1 As IntPtr, param2 As IntPtr)
              ' handle all Midi messages here
              If msg = MIDIMessage.MOM_OPEN Then
                ' nothing to do
              Else
                If msg = MIDIMessage.MOM_CLOSE Then
                  ' handle is from now on invalid
                Else
                  If msg = MIDIMessage.MOM_DONE Then
                    ' process the message...
                    ' param1 will contain the pointer to the MIDI_HEADER
                    Dim header As New MIDI_HEADER(param1)
                    ' process the header if needed
                    ...
                    ' and finally unprepare the header
                    header.Unprepare(False, handle)
                  End If
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)">
            <summary>
            Sends a system-exclusive MIDI message to the specified MIDI output device.
            </summary>
            <param name="handle">Handle to the MIDI output device.</param>
            <param name="headerPtr">Pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure that identifies the MIDI buffer.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <example>
            <code>
            private MIDIOUTPROC _midiProc;
            private IntPtr _midiOutHandle;
            ...
            // Open the Midi device #2
            _midiProc = new MIDIOUTPROC(MyMidiProc);
            MIDIError ret = Midi.MIDI_OutOpen(ref _midiOutHandle, 2, _midiProc, 0);
            if (ret == MIDIError.MIDI_OK)
            {
              // device opened and ready
            }
            ...
            // When not needed anymore...stop the device
            Midi.MIDI_OutReset(_midiOutHandle);
            // and close the device
            Midi.MIDI_OutClose(_midiOutHandle);
            ...
            private void SendShortMessage(int message)
            {
              MIDI_OutShortMsg(_midiOutHandle, message);
            }
            
            private void SendSysExMessage(byte[] data)
            {
              MIDI_HEADER header = new MIDI_HEADER(data);
              header.Prepare(false, _midiOutHandle);
              // If the header was perpared successfully.
              if (header.HeaderPtr != IntPtr.Zero)
              {
                // send a system-exclusive message to the output device
                Midi.MIDI_OutLongMsg(_midiOutHandle, header.HeaderPtr);
              }
            }
            
            public void MyMidiProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
              // handle all Midi messages here
              if (msg == MIDIMessage.MOM_OPEN)
              {
                // nothing to do
              }
              else if (msg == MIDIMessage.MOM_CLOSE)
              {
                // handle is from now on invalid
              }
              else if (msg == MIDIMessage.MOM_DONE)
              {
                // process the message...
                // param1 will contain the pointer to the MIDI_HEADER
                MIDI_HEADER header = new MIDI_HEADER(param1);
                // process the header if needed
                ...
                // and finally unprepare the header
                header.Unprepare(false, handle);
              }
            }
            </code>
            <code lang="vbnet">
            Private _midiProc As MIDIOUTPROC
            Private _midiOutHandle As IntPtr
            ...
            ' Open the Midi device #2
            _midiProc = New MIDIOUTPROC(MyMidiProc)
            Dim ret As MIDIError = Midi.MIDI_OutOpen(_midiOutHandle, 2, _midiProc, 0)
            If ret = MIDIError.MIDI_OK Then
              ' device opened and ready
            End If
            ...
            ' when not needed anymore...stop the device
            Midi.MIDI_OutReset(_midiOutHandle)
            ' and close the device
            Midi.MIDI_OutClose(_midiOutHandle)
            ...
            Private Sub SendShortMessage(message As Integer)
              MIDI_OutShortMsg(_midiOutHandle, message)
            End Sub
            
            Private Sub SendSysExMessage(data() As Byte)
              Dim header As New MIDI_HEADER(data)
              header.Prepare(False, _midiOutHandle)
              ' If the header was perpared successfully.
              If header.HeaderPtr &lt;&gt; IntPtr.Zero Then
                ' send a system-exclusive message to the output device
                Midi.MIDI_OutLongMsg(_midiOutHandle, header.HeaderPtr)
              End If
            End Sub
            
            Public Sub MyMidiProc(handle As IntPtr, msg As MIDIMessage, instance As IntPtr, param1 As IntPtr, param2 As IntPtr)
              ' handle all Midi messages here
              If msg = MIDIMessage.MOM_OPEN Then
                ' nothing to do
              Else
                If msg = MIDIMessage.MOM_CLOSE Then
                  ' handle is from now on invalid
                Else
                  If msg = MIDIMessage.MOM_DONE Then
                    ' process the message...
                    ' param1 will contain the pointer to the MIDI_HEADER
                    Dim header As New MIDI_HEADER(param1)
                    ' process the header if needed
                    ...
                    ' and finally unprepare the header
                    header.Unprepare(False, handle)
                  End If
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)">
            <summary>
            Prepares a buffer for MIDI input.
            </summary>
            <param name="handle">Handle to the MIDI input device.</param>
            <param name="headerPtr">Pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure that identifies the buffer to be prepared.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>
            <para>Preparing a header that has already been prepared has no effect, and the function returns zero.</para>
            <para>After the header has been prepared, do not modify the buffer. To free the buffer, use the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InUnprepareHeader(System.IntPtr,System.IntPtr)"/> function.</para>
            <para>Before using this function, you must set the data, bufferLength, and flags members of the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure. The flags member must be set to zero.</para>
            <para>For convenience the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> might also be used, which calls the method internally and returns the header pointer in the <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/> member.</para>
            </remarks>
            <example>
            <code>
            private MIDIINPROC _midiInProc;
            private IntPtr _midiInHandle;
            ...
            private void StartRecording()
            {
              _midiInProc = new MIDIINPROC(MyMidiInProc);
              MIDIError ret = Midi.MIDI_InOpen(ref _midiInHandle, 1, _midiInProc, 0, MIDIFlags.MIDI_IO_STATUS);
              if (ret == MIDIError.MIDI_OK)
              {
                // supply the device with 2 buffers
                AddSysExBuffer(_midiInHandle, 1024);
                AddSysExBuffer(_midiInHandle, 1024);
                ret = Midi.MIDI_InStart(_midiInHandle);
              }
            }
            
            // prepare receiving system-exclusive messages
            private void AddSysExBuffer(IntPtr handle, int size)
            {
              // prepare a empty midi header
              MIDI_HEADER header = new MIDI_HEADER(size);
              header.Prepare(true, handle);
              // If the header was perpared successfully.
              if (header.HeaderPtr != IntPtr.Zero)
              {
                // Add the buffer to the InputDevice.
                Midi.MIDI_InAddBuffer(handle, header.HeaderPtr);
              }
            }
            
            private void MyMidiInProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
              // handle all Midi messages here
              if (msg == MIDIMessage.MIM_DATA)
              {
                // process the short message...
                int p1 = param1.ToInt32();
                int p2 = param2.ToInt32();
                ...
                Console.WriteLine("Msg={0}\r\nParam1={1}\r\nParam2={2}" , msg, p1, p2);
              }
              else if (msg == MIDIMessage.MIM_LONGDATA)
              {
                // process the system-exclusive message...
                MIDI_HEADER header = new MIDI_HEADER(param1);
                if (header.IsDone)
                {
                  byte[] data = header.Data;
                  ...
                  Console.WriteLine(header.ToString());
                }
                // must unprepare the processed header
                header.Unprepare(true, handle);
                // add a new buffer
                // we must constantly provide new buffers until we finished recording
                AddSysExBuffer(handle, 1024);
              }
              ...
            }
            </code>
            <code lang="vbnet">
            Private _midiInProc As MIDIINPROC
            Private _midiInHandle As IntPtr
            ...
            Private Sub StartRecording()
              _midiInProc = New MIDIINPROC(AddressOf MyMidiInProc)
              Dim ret As MIDIError = Midi.MIDI_InOpen(_midiInHandle, 1, _midiInProc, 0, MIDIFlags.MIDI_IO_STATUS)
              If ret = MIDIError.MIDI_OK Then
                ' supply the device with 2 buffers
                AddSysExBuffer(_midiInHandle, 1024)
                AddSysExBuffer(_midiInHandle, 1024)
                ret = Midi.MIDI_InStart(_midiInHandle)
              End If
            End Sub
            
            ' prepare receiving system-exclusive messages
            Private Sub AddSysExBuffer(handle As IntPtr, size As Integer)
              ' prepare a empty midi header
              Dim header As New MIDI_HEADER(size)
              header.Prepare(True, handle)
              ' If the header was perpared successfully.
              If header.HeaderPtr &lt;&gt; IntPtr.Zero Then
                ' Add the buffer to the InputDevice.
                Midi.MIDI_InAddBuffer(handle, header.HeaderPtr)
              End If
            End Sub
            
            Private Sub MyMidiInProc(handle As IntPtr, msg As MIDIMessage, instance As IntPtr, param1 As IntPtr, param2 As IntPtr)
              ' handle all Midi messages here
              If msg = MIDIMessage.MIM_DATA Then
                ' process the short message...
                Dim p1 As Integer = param1.ToInt32()
                Dim p2 As Integer = param2.ToInt32()
                ...
                Console.WriteLine("Msg={0}" + ControlChars.Cr + ControlChars.Lf + "Param1={1}" + ControlChars.Cr + ControlChars.Lf + "Param2={2}", msg, p1, p2)
              Else
                If msg = MIDIMessage.MIM_LONGDATA Then
                  ' process the system-exclusive message...
                  Dim header As New MIDI_HEADER(param1)
                  If header.IsDone Then
                    Dim data As Byte() = header.Data
                    ...
                    Console.WriteLine(header.ToString())
                  End If
                  ' must unprepare the processed header
                  header.Unprepare(True, handle)
                  ' add a new buffer
                  ' we must constantly provide new buffers until we finished recording
                  AddSysExBuffer(handle, 1024)
                End If
                ...
              End If 
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_InUnprepareHeader(System.IntPtr,System.IntPtr)">
            <summary>
            Cleans up the preparation performed by the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/> function.
            </summary>
            <param name="handle">Handle to the MIDI input device.</param>
            <param name="headerPtr">Pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure identifying the buffer to be cleaned up.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>
            <para>This function is complementary to <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/>. You must use this function before freeing the buffer. After passing a buffer to the device driver by using the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> function, you must wait until the driver is finished with the buffer before using <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InUnprepareHeader(System.IntPtr,System.IntPtr)"/>. 
            Unpreparing a buffer that has not been prepared has no effect, and the function returns 0.</para>
            <para>For convenience the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Unprepare(System.Boolean,System.IntPtr)"/> might also be used, which calls this method internally.
            In order to convert an IntPtr (e.g. as given in the <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> with the <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/> or <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGERROR"/> as param1) back to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure use the appropriate constructor overload of the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> class taking a headerPtr.</para>
            </remarks>
            <example>
            <code>
            private MIDIINPROC _midiInProc;
            private IntPtr _midiInHandle;
            ...
            private void StartRecording()
            {
            	_midiInProc = new MIDIINPROC(MyMidiInProc);
            	MIDIError ret = Midi.MIDI_InOpen(ref _midiInHandle, 1, _midiInProc, 0, MIDIFlags.MIDI_IO_STATUS);
            
            	if (ret == MIDIError.MIDI_OK)
            	{
            		// supply the device with 2 buffers
            		AddSysExBuffer(_midiInHandle, 1024);
            		AddSysExBuffer(_midiInHandle, 1024);
            	
            		ret = Midi.MIDI_InStart(_midiInHandle);
            	}
            }
            
            // prepare receiving system-exclusive messages
            public void AddSysExBuffer(IntPtr handle, int size)
            {
            	// prepare a empty midi header
            	MIDI_HEADER header = new MIDI_HEADER(size);
            	header.Prepare(true, handle);
            	// If the header was perpared successfully.
            	if (header.HeaderPtr != IntPtr.Zero)
            	{
            		// Add the buffer to the InputDevice.
            		Midi.MIDI_InAddBuffer(handle, header.HeaderPtr);
            	}
            }
            
            private void MyMidiInProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
            	// handle all Midi messages here
            	if (msg == MIDIMessage.MIM_DATA)
            	{
            		// process the short message...
            		// on Win32 system the param1 and param2 values might be converted like this:
            		int p1 = param1.ToInt32();
            		int p2 = param2.ToInt32();
            		Console.WriteLine( "Msg={0}\r\nParam1={1}\r\nParam2={2}" , msg, p1, p2);
            	}
            	else if (msg == MIDIMessage.MIM_LONGDATA)
            	{
            		// process the system-exclusive message...
            		MIDI_HEADER header = new MIDI_HEADER(param1);
            		if (header.IsDone)
            		{
            			byte[] data = header.Data;
            			...
            			Console.WriteLine( header.ToString() );
            		}
            		header.Unprepare(true, handle);
            		
            		// add a new buffer
            		// since we should constantly provide new buffers until we finished recording
            		AddSysExBuffer(handle, 1024);
            	}
            	...
            }
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)">
            <summary>
            Sends an input buffer to a specified opened MIDI input device. This function is used for system-exclusive messages.
            </summary>
            <param name="handle">Handle to the MIDI input device.</param>
            <param name="headerPtr">Pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure that identifies the buffer.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>
            <para>When the buffer is filled, it is sent back to the application (see <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/>).</para>
            <para>The buffer must be prepared by using the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/> function before it is passed to this function.</para>
            <para>For convenience the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> might also be used, which calls <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/> internally and provides the prepared header pointer in it's <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/> member.
            In order to convert an IntPtr (e.g. as given in the <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> with the <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/> or <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGERROR"/> as param1) back to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure use the appropriate constructor overload of the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> class taking a headerPtr.</para>
            </remarks>
            <example>
            <code>
            private MIDIINPROC _midiInProc;
            private IntPtr _midiInHandle;
            ...
            private void StartRecording()
            {
            	_midiInProc = new MIDIINPROC(MyMidiInProc);
            	MIDIError ret = Midi.MIDI_InOpen(ref _midiInHandle, 1, _midiInProc, 0, MIDIFlags.MIDI_IO_STATUS);
            
            	if (ret == MIDIError.MIDI_OK)
            	{
            		// supply the device with 2 buffers
            		AddSysExBuffer(_midiInHandle, 1024);
            		AddSysExBuffer(_midiInHandle, 1024);
            	
            		ret = Midi.MIDI_InStart(_midiInHandle);
            	}
            }
            
            // prepare receiving system-exclusive messages
            public void AddSysExBuffer(IntPtr handle, int size)
            {
            	// prepare a empty midi header
            	MIDI_HEADER header = new MIDI_HEADER(size);
            	header.Prepare(true, handle);
            	// If the header was perpared successfully.
            	if (header.HeaderPtr != IntPtr.Zero)
            	{
            		// Add the buffer to the InputDevice.
            		Midi.MIDI_InAddBuffer(handle, header.HeaderPtr);
            	}
            }
            
            private void MyMidiInProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
            	// handle all Midi messages here
            	if (msg == MIDIMessage.MIM_DATA)
            	{
            		// process the short message...
            		// on Win32 system the param1 and param2 values might be converted like this:
            		int p1 = param1.ToInt32();
            		int p2 = param2.ToInt32();
            		Console.WriteLine( "Msg={0}\r\nParam1={1}\r\nParam2={2}" , msg, p1, p2);
            	}
            	else if (msg == MIDIMessage.MIM_LONGDATA)
            	{
            		// process the system-exclusive message...
            		MIDI_HEADER header = new MIDI_HEADER(param1);
            		if (header.IsDone)
            		{
            			byte[] data = header.Data;
            			...
            			Console.WriteLine( header.ToString() );
            		}
            		header.Unprepare(true, handle);
            		
            		// add a new buffer
            		// since we should constantly provide new buffers until we finished recording
            		AddSysExBuffer(handle, 1024);
            	}
            	...
            }
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_OutPrepareHeader(System.IntPtr,System.IntPtr)">
            <summary>
            Prepares a MIDI system-exclusive or stream buffer for output.
            </summary>
            <param name="handle">Handle to the MIDI output device.</param>
            <param name="headerPtr">Pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure that identifies the buffer to be prepared.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>
            <para>A stream buffer cannot be larger than 64K.</para>
            <para>Preparing a header that has already been prepared has no effect, and the function returns 0.</para>
            <para>After the header has been prepared, do not modify the buffer. To free the buffer, use the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutUnprepareHeader(System.IntPtr,System.IntPtr)"/> function.</para>
            <para>Before using this function, you must set the data, bufferLength, and flags members of the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure. The flags member must be set to zero.</para>
            <para>For convenience the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> might also be used, which calls <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/> internally and provides the prepared header pointer in it's <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/> member.
            In order to convert an IntPtr (e.g. as given in the <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> with the <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/> or <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGERROR"/> as param1) back to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure use the appropriate constructor overload of the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> class taking a headerPtr.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_OutUnprepareHeader(System.IntPtr,System.IntPtr)">
            <summary>
            Cleans up the preparation performed by the midiOutPrepareHeader function.
            </summary>
            <param name="handle">Handle to the MIDI output device.</param>
            <param name="headerPtr">Pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure identifying the buffer to be cleaned up.</param>
            <returns>Returns 0 if successful or an error code otherwise. For possible error values see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/>.</returns>
            <remarks>
            <para>This function is complementary to the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutPrepareHeader(System.IntPtr,System.IntPtr)"/> function. You must call <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutUnprepareHeader(System.IntPtr,System.IntPtr)"/> before freeing the buffer. 
            After passing a buffer to the device driver with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> function, you must wait until the device driver is finished with the buffer before calling <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutUnprepareHeader(System.IntPtr,System.IntPtr)"/>.</para>
            <para>Unpreparing a buffer that has not been prepared has no effect, and the function returns 0.</para>
            <para>For convenience the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> might also be used, which calls <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/> internally and provides the prepared header pointer in it's <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/> member.
            In order to convert an IntPtr (e.g. as given in the <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> with the <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/> or <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGERROR"/> as param1) back to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure use the appropriate constructor overload of the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> class taking a headerPtr.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_InMessage(System.IntPtr,Ten53.Multimedia.Midi.MIDIMessage,System.IntPtr,System.IntPtr)">
            <summary>
            Sends a message to the MIDI device driver (input).
            </summary>
            <param name="handle">Identifier of the MIDI device that receives the message (must be a handle type).</param>
            <param name="msg">Message to send (e.g. one of the <see cref="T:Ten53.Multimedia.Midi.MIDIMessage"/> values).</param>
            <param name="param1">Message parameter 1.</param>
            <param name="param2">Message parameter 2.</param>
            <returns>Returns the value returned by the audio device driver.</returns>
            <remarks>This function is used only for driver-specific messages that are not supported by the MIDI API.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_OutMessage(System.IntPtr,Ten53.Multimedia.Midi.MIDIMessage,System.IntPtr,System.IntPtr)">
            <summary>
            Sends a message to the MIDI device driver (output).
            </summary>
            <param name="handle">Identifier of the MIDI device that receives the message (must be a handle type).</param>
            <param name="msg">Message to send (e.g. one of the <see cref="T:Ten53.Multimedia.Midi.MIDIMessage"/> values).</param>
            <param name="param1">Message parameter 1.</param>
            <param name="param2">Message parameter 2.</param>
            <returns>Returns the value returned by the audio device driver.</returns>
            <remarks>This function is used only for driver-specific messages that are not supported by the MIDI API.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.Midi.MIDI_Note2Frequency(System.Int32)">
            <summary>
            Converts a MIDI note number to its corresponding frequency.
            </summary>
            <param name="noteNumber">The number of the note to convert.</param>
            <returns>The frequency of the specified note in Hz.</returns>
            <remarks>MIDI notes will typically be numbered from 0 (C-1) to 127 (G8).
            The reference is the standard pitch (A3) which has the number 69 and represents 440 Hz.
            <para>See the <see cref="T:Ten53.Multimedia.Midi.MIDINote"/> enummeration for possible note values.</para>
            </remarks>
            <example>
            <code>
            // the following code will return 440Hz for the C
            int freq = Utils.NoteToFrequency(69);
            </code>
            <code lang="vbnet">
            ' the following code will return 440Hz for the C
            Dim freq As Integer = Utils.NoteToFrequency(69)
            </code>
            </example>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MidiShortMessage">
            <summary>
            This class represents a Midi short (data) message as for example received in a <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_DATA"/> message of a <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/>.
            </summary>
            <remarks>You might use the class to pack (encode, construct) or unpack (decode) any Midi short message.
            <para>Use this class with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutShortMsg(System.IntPtr,System.Int32)"/> method to send a message to an output device. Use the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Message"/> property in that case to get the constructed message value.</para>
            <para>Use this class with the <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_DATA"/> message of a <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> to decode the received message.</para>
            </remarks>
            <example>
            Using the MidiShortMessage with an MIDIINPROC:
            <code>
            private MIDIINPROC _midiProc;
            private int _midiInHandle;
            ...
            // Open the Midi device #2
            _midiProc = new MIDIINPROC(MyMidiProc);
            MIDIError ret = Midi.MIDI_InOpen(ref _midiInHandle, 2, _midiProc, IntPtr.Zero, MIDIFlags.MIDI_IO_STATUS);
            if (ret == MIDIError.MIDI_OK)
            {
              // supply the device with 2 buffers
              AddSysExBuffer(_midiInHandle, 1024);
              AddSysExBuffer(_midiInHandle, 1024);
              // Start the device
              ret = Midi.MIDI_InStart(_midiInHandle);
            }
            ...
            // when not needed anymore...stop the device
            Midi.MIDI_InReset(_midiInHandle);
            // and close the device
            Midi.MIDI_InClose(_midiInHandle);
            ...
            // prepare receiving system-exclusive messages
            private void AddSysExBuffer(IntPtr handle, int size)
            {
              // prepare a empty midi header
              MIDI_HEADER header = new MIDI_HEADER(size);
              header.Prepare(true, handle);
              // If the header was perpared successfully.
              if (header.HeaderPtr != IntPtr.Zero)
              {
                // Add the buffer to the InputDevice.
                Midi.MIDI_InAddBuffer(handle, header.HeaderPtr);
              }
            }
            ...
            private MidiShortMessage _shortMsg  = null;
            private MidiSysExMessage _sysExMsg  = null;
            
            public void MyMidiProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
              // handle all Midi messages here
              if(msg == MIDIMessage.MIM_OPEN)
              {
                // nothing to do
              }
              else if(msg == MIDIMessage.MIM_CLOSE)
              {
                // handle is from now on invalid
              }
              else if(msg == MIDIMessage.MIM_DATA)
              {
                // process the message...
                _shortMsg = new MidiShortMessage(param1, param2, _shortMsg);
                Console.WriteLine(_shortMsg.ToString());
              }
              else if(msg == MIDIMessage.MIM_MOREDATA)
              {
                // we are not fast enough in this callback to keep up...
                // the input device is sending messages to fast
                ...
              }
              else if(msg == MIDIMessage.MIM_LONGDATA)
              {
                // process the message...
                // param1 will contain the pointer to the MIDI_HEADER
                _sysExMsg  = new MidiSysExMessage(true, handle, param1, _sysExMsg);
                if (_sysExMsg.IsDone)
                {
                  Console.WriteLine(_sysExMsg.ToString());
                }
                // add a new buffer
                // since we must constantly provide new buffers until we finished recording
                AddSysExBuffer(handle, 1024);
              }
              else if(msg == MIDIMessage.MIM_ERROR)
              {
                // process the invalid message...
                ...
              }
              else if(msg == MIDIMessage.MIM_LONGERROR)
              {
                // process the invalid message...
                // param1 will contain the pointer to the MIDI_HEADER
                MIDI_HEADER header = new MIDI_HEADER(param1);
                header.Unprepare(true, handle);
                // add a new buffer
                // since we should constantly provide new buffers until we finished recording
                AddSysExBuffer(handle, 1024);
              }
            }
            </code>
            <code lang="vbnet">
            Private _midiInProc As MIDIINPROC
            Private _midiInHandle As IntPtr
            ...
            ' Open the Midi device #2
            _midiProc = New MIDIINPROC(AddressOf MyMidiProc)
            Dim ret As MIDIError = Midi.MIDI_InOpen(_midiInHandle, 2, _midiProc, IntPtr.Zero, MIDIFlags.MIDI_IO_STATUS)
            If ret = MIDIError.MIDI_OK Then
              ' supply the device with 2 buffers
              AddSysExBuffer(_midiInHandle, 1024)
              AddSysExBuffer(_midiInHandle, 1024)
              ' Start the device
              ret = Midi.MIDI_InStart(_midiInHandle)
            End If
            ...
            ' when not needed anymore...stop the device
            Midi.MIDI_InReset(_midiInHandle)
            ' and close the device
            Midi.MIDI_InClose(_midiInHandle)
            ...
            Private _shortMsg As MidiShortMessage = Nothing
            Private _sysExMsg As MidiSysExMessage = Nothing
            ...
            Public Sub MyMidiProc(handle As IntPtr, msg As MIDIMessage, instance As IntPtr, param1 As IntPtr, param2 As IntPtr)
              ' handle all Midi messages here
              If msg = MIDIMessage.MIM_OPEN Then
                ' nothing to do
              Else
                If msg = MIDIMessage.MIM_CLOSE Then
                  ' handle is from now on invalid
                Else
                  If msg = MIDIMessage.MIM_DATA Then
                    ' process the message...
                    _shortMsg = New MidiShortMessage(param1, param2, _shortMsg)
                    Console.WriteLine(_shortMsg.ToString())
                  Else
                    If msg = MIDIMessage.MIM_MOREDATA Then
                      ' we are not fast enough in this callback to keep up...
                      ' the input device is sending messages to fast
                      ...
                    Else
                      If msg = MIDIMessage.MIM_LONGDATA Then
                        ' process the message...
                        ' param1 will contain the pointer to the MIDI_HEADER
                        _sysExMsg = New MidiSysExMessage(True, handle, param1, _sysExMsg)
                        If _sysExMsg.IsDone Then
                          Console.WriteLine(_sysExMsg.ToString())
                        End If
                        ' add a new buffer
                        ' since we must constantly provide new buffers until we finished recording
                        AddSysExBuffer(handle, 1024)
                      Else
                        If msg = MIDIMessage.MIM_ERROR Then
                          ' process the invalid message...
                          ...
                        Else
                          If msg = MIDIMessage.MIM_LONGERROR Then
                            ' process the invalid message...
                            ' param1 will contain the pointer to the MIDI_HEADER
                            Dim header As New MIDI_HEADER(param1)
                            header.Unprepare(True, handle)
                            ' add a new buffer
                            ' since we should constantly provide new buffers until we finished recording
                            AddSysExBuffer(handle, 1024)
                          End If
                        End If
                      End If
                    End If
                  End If
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.#ctor">
            <summary>
            Default constructor.
            </summary>
            <remarks>You might use this one together with the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.BuildMessage(Ten53.Multimedia.Midi.MIDIStatus,System.Byte,System.Byte,System.Byte,System.Int64)"/> method to construct your own Midi data message.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.#ctor(System.IntPtr,System.IntPtr)">
            <summary>
            Creates a new instance of the MidiShortMessage.
            </summary>
            <param name="param1">The MIDI message that was received.</param>
            <param name="param2">The timestamp that the message was received by the input device driver.</param>
            <remarks>
            <para>You might use this constuctor for example in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> when receiving a <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_DATA"/> message.</para>
            <para>MIDI messages received from a MIDI input port have running status disabled; each message is expanded to include the MIDI status byte.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.#ctor(System.IntPtr,System.IntPtr,Ten53.Multimedia.Midi.MidiShortMessage)">
            <summary>
            Creates a new instance of the MidiShortMessage and also evaluates a previous short message..
            </summary>
            <param name="param1">The MIDI message that was received.</param>
            <param name="param2">The timestamp that the message was received by the input device driver.</param>
            <param name="previous">The previous short message received (e.g. in order to check, if a <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> message need to be paired - which is not done automatically here!).</param>
            <remarks>
            <para>You might use this constuctor for example in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> when receiving a <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_DATA"/> message.</para>
            <para>MIDI messages received from a MIDI input port have running status disabled; each message is expanded to include the MIDI status byte.</para>
            <para>Note: Some ControlChange messages might actually use two short messages (e.g. the <see cref="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelect"/>) to support paired values with a higher resolution (16384 instead of 128 values).
            In such case two messages will be send, where one contains the the LSB value (single steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte and the other on the MSB value (128th steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte.</para>
            <para>For this special case it might be useful to keep in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> handler always the current and the last (previous) message.
            Use this overload to always keep your previous message with the current short message.
            NOTE: The <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/> property will only be set in case this current message and the <paramref name="previous"/> are having the same <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> (otherwise all previous messages would be links together and memory wil simply increase and increase, since the Garbage Collector would never release any un-needed messages)!
            In case of real-time messages the the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/> will also not be set.</para>
            <para>To access the single value assigned to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/>/<see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerType"/> access the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerValue"/> property.</para>
            <para>You might use the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData(System.Byte,System.Byte)"/>, <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData2(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> resp. the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData1(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> method to retrieve a combined value from two short messages resp. two data value.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.#ctor(Ten53.Multimedia.Midi.MIDIStatus,System.Byte,System.Byte,System.Byte,System.Int64)">
            <summary>
            Creates a new instance of the MidiShortMessage.
            </summary>
            <param name="status">The <see cref="T:Ten53.Multimedia.Midi.MIDIStatus"/> status to use.</param>
            <param name="channel">The Midi channel number to use (0 to 15).</param>
            <param name="data1">The data 1 value to use.</param>
            <param name="data2">The data 2 value to use.</param>
            <param name="timestamp">The time stamp to use (expressed in milliseconds or 0).</param>
            <remarks>You might use this to construct for example a channel message.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.#ctor(System.Byte,System.Byte,System.Byte,System.Byte,System.Int64)">
            <summary>
            Creates a new instance of the MidiShortMessage.
            </summary>
            <param name="status">The Midi status byte value to use.</param>
            <param name="data1">The data 1 value to use.</param>
            <param name="data2">The data 2 value to use.</param>
            <param name="data3">The data 3 value to use (typically never used).</param>
            <param name="timestamp">The time stamp to use (expressed in milliseconds or 0 if not applicable).</param>
            <remarks>You might use this to construct for example a channel message.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.SetContinuousController(System.Boolean,System.Boolean)">
            <summary>
            Defines that this message is related to a continuous controller.
            </summary>
            <param name="thisIsMSB">Set to TRUE, if this message contains the MSB (coarse) controller value - else this message contains the LSB (fine) controller value.</param>
            <param name="previousIsMSB">Set to TRUE, if the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/> contains the MSB (coarse) controller value - else the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/> contains the LSB (fine) controller value.</param>
            <remarks>If you set both parameters to FALSE the message is not related to a continuous controller (default).
            <para>In addition this message is only set to be a continuous controller message, if the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/> exists and it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> also has a value of <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> and the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Channel"/> is the same.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData(System.Byte,System.Byte)">
            <summary>
            Returns a combined paired value from a MSB and a LSB data byte.
            </summary>
            <param name="dataMSB">The MSB (most significant) data byte value.</param>
            <param name="dataLSB">The LSB (least significant) data byte value.</param>
            <returns>The combined data value ranging from 0 to 16383 (128*128 values).</returns>
            <remarks>
            <para>The <paramref name="dataLSB"/> byte will contain the lower 7-bit value (single steps) and the <paramref name="dataMSB"/> byte the upper 7-bit value (128th steps) both ranging from 0 to 128.</para>
            <para>Some Midi data messages might actually use two sub-sequent short messages to construct a paired message representing a single value range (e.g. the <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> with a <see cref="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelect"/>).
            This to support paired values with a higher resolution (16384 instead of 128 values). The same might apply the the controller value itself.
            In such case two short messages will be send, where one contains the LSB value (single steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> or <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte and the other message contains the MSB value (128th steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> or <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.
            Typically the messages with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> of <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> and with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value between 0 and 31 (MSB) are paired with a message of a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value between 32 and 63 (LSB).
            But also a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 98 (LSB) will be paired with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 99 (MSB) as well as a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 100 (LSB) will be paired with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 101 (MSB).
            Other pairs might be hardware specific.</para>
            <para>So it might be useful to keep in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> handler always the current and the last message.</para>
            <para>The resulting combined data value will be constructed like this: dataMSB=0xxxxxxx, dataLSB=0yyyyyyy = paired=00xxxxxxxyyyyyyy.</para>
            <para>You might also use the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData1(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> resp. the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData2(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> method to retrieve a combined value from two short messages resp. two data value.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData1(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)">
            <summary>
            Returns a combined paired <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> value from a MSB and a LSB <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/>.
            </summary>
            <param name="msgMSB">The <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> containing the MSB (most significant) <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte value.</param>
            <param name="msgLSB">The <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/>containing the LSB (least significant) <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte value.</param>
            <returns>The combined data value ranging from 0 to 16383 (128*128 values).</returns>
            <remarks>
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte of the <paramref name="msgLSB"/> message will contain the lower 7-bit value (single steps) and the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte of the <paramref name="msgMSB"/> message the upper 7-bit value (128th steps) both ranging from 0 to 128.</para>
            <para>Some Midi data messages might actually use two sub-sequent short messages to construct a paired message representing a single value range (e.g. the <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> with a <see cref="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelect"/>).
            This to support paired values with a higher resolution (16384 instead of 128 values). The same might apply the the controller value itself.
            In such case two short messages will be send, where one contains the LSB value (single steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte and the other message contains the MSB value (128th steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.
            Typically the messages with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> of <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> and with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value between 0 and 31 (MSB) are paired with a message of a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value between 32 and 63 (LSB).
            But also a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 98 (LSB) will be paired with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 99 (MSB) as well as a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 100 (LSB) will be paired with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 101 (MSB).
            Other pairs might be hardware specific.</para>
            <para>So it might be useful to keep in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> handler always the current and the last message.</para>
            <para>The resulting combined data value will be constructed like this: dataMSB=0xxxxxxx, dataLSB=0yyyyyyy = paired=00xxxxxxxyyyyyyy.</para>
            <para>You might also use the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData2(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> resp. the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData(System.Byte,System.Byte)"/> method to retrieve a combined value from two short messages resp. two data value.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData2(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)">
            <summary>
            Returns a combined paired <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> value from a MSB and a LSB <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/>.
            </summary>
            <param name="msgMSB">The <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> containing the MSB (most significant) <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte value.</param>
            <param name="msgLSB">The <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/>containing the LSB (least significant) <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte value.</param>
            <returns>The combined data value ranging from 0 to 16383 (128*128 values).</returns>
            <remarks>
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte of the <paramref name="msgLSB"/> message will contain the lower 7-bit value (single steps) and the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte of the <paramref name="msgMSB"/> message the upper 7-bit value (128th steps) both ranging from 0 to 128.</para>
            <para>Some Midi data messages might actually use two sub-sequent short messages to construct a paired message representing a single value range (e.g. the <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> with a <see cref="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelect"/>).
            This to support paired values with a higher resolution (16384 instead of 128 values). The same might apply the the controller value itself.
            In such case two short messages will be send, where one contains the LSB value (single steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte and the other message contains the MSB value (128th steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte.
            Typically the messages with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> of <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> and with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value between 0 and 31 (MSB) are paired with a message of a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value between 32 and 63 (LSB).
            But also a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 98 (LSB) will be paired with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 99 (MSB) as well as a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 100 (LSB) will be paired with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 101 (MSB).
            Other pairs might be hardware specific.</para>
            <para>So it might be useful to keep in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> handler always the current and the last message.</para>
            <para>The resulting combined data value will be constructed like this: dataMSB=0xxxxxxx, dataLSB=0yyyyyyy = paired=00xxxxxxxyyyyyyy.</para>
            <para>You might also use the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData1(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> resp. the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData(System.Byte,System.Byte)"/> method to retrieve a combined value from two short messages resp. two data value.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.BuildMessage(Ten53.Multimedia.Midi.MIDIStatus,System.Byte,System.Byte,System.Byte,System.Int64)">
            <summary>
            Constructs a new Midi data message.
            </summary>
            <param name="status">The <see cref="T:Ten53.Multimedia.Midi.MIDIStatus"/> status to use.</param>
            <param name="channel">The Midi channel number to use (0 to 15).</param>
            <param name="data1">The data 1 value to use.</param>
            <param name="data2">The data 2 value to use.</param>
            <param name="timestamp">The time stamp to use (expressed in milliseconds or 0 if not applicable).</param>
            <remarks>You might use this to construct for example a channel message.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.BuildMessage(System.Byte,System.Byte,System.Byte,System.Byte,System.Int64)">
            <summary>
            Constructs a new Midi data message.
            </summary>
            <param name="status">The Midi status byte value to use.</param>
            <param name="data1">The data 1 value to use.</param>
            <param name="data2">The data 2 value to use.</param>
            <param name="data3">The data 3 value to use (typically never used).</param>
            <param name="timestamp">The time stamp to use (expressed in milliseconds or 0 if not applicable).</param>
            <remarks>You might use this to construct for example a channel message.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.BuildMessage(System.Int32,System.Int64)">
            <summary>
            Constructs a new Midi data message.
            </summary>
            <param name="message">The message value to use.</param>
            <param name="timestamp">The time stamp to use (expressed in milliseconds or 0 if not applicable).</param>
            <remarks>You might use this to construct for example a channel message.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.BuildMessage(System.Int64,System.Int64)">
            <summary>
            Constructs a new Midi data message.
            </summary>
            <param name="message">The message value to use.</param>
            <param name="timestamp">The time stamp to use (expressed in milliseconds or 0 if not applicable).</param>
            <remarks>You might use this to construct for example a channel message.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.ToString">
            <summary>
            Returns the string representation of the Midi short message.
            </summary>
            <returns>The string representing the Midi short message (same as ToString("G")).</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.ToString(System.String)">
            <summary>
            Returns the string representation of the Midi short message.
            </summary>
            <param name="format">The format to use (one of the following):
            <list type="table">
            <item><term>"G"</term><description>Combi-Format: Timestamp, Type, Channel, Status, Data in full text - same as "{T}\t{M} {C}\t{S}\t{D}" (for Channel messages) resp. "{T}\t{M}\t{S}\t{D}" (for other messages).</description></item>
            <item><term>"g"</term><description>Combi-Format: Timestamp, Type, Channel, Status, Data as numerical values - same as "{t}\t{m} {C}\t{s}\t{d}" (for Channel messages) resp. "{t}\t{m}\t{s}\t{d}" (for other messages).</description></item>
            <item><term>"X"</term><description>Combi-Format: Timespan and Message as hexadecimal values (big hex) - same as "{U} {A} {H}".</description></item>
            <item><term>"x"</term><description>Combi-Format: Timespan and Message as hexadecimal values (small hex) - same as "{u} {a} {h}".</description></item>
            <item><term>"Y"</term><description>Combi-Format: Message as hexadecimal values (big hex) - same as "{A} {H}".</description></item>
            <item><term>"y"</term><description>Combi-Format: Message as hexadecimal values (small hex) - same as "{a} {h}".</description></item>
            <item><term>"T"</term><description>Timespan only.</description></item>
            <item><term>"t"</term><description>Timestamp only.</description></item>
            <item><term>"U"</term><description>Timestamp only as hexadecimal values (big hex).</description></item>
            <item><term>"u"</term><description>Timestamp only as hexadecimal values (small hex).</description></item>
            <item><term>"M"</term><description>MessageType only in full text.</description></item>
            <item><term>"m"</term><description>MessageType as numerical values.</description></item>
            <item><term>"S"</term><description>StatusType only in full text.</description></item>
            <item><term>"s"</term><description>StatusType only as numerical value.</description></item>
            <item><term>"A"</term><description>Status only as hexadecimal values (big hex).</description></item>
            <item><term>"a"</term><description>Status only as hexadecimal values (small hex).</description></item>
            <item><term>"C"</term><description>Channel only as numerical value.</description></item>
            <item><term>"D"</term><description>Data only in full text.</description></item>
            <item><term>"d"</term><description>Data only as numerical value.</description></item>
            <item><term>"H"</term><description>Data only as hexadecimal values (big hex).</description></item>
            <item><term>"h"</term><description>Data only as hexadecimal values (small hex).</description></item>
            </list>
            <para>You might also combine the single values into a full format string when enclosed in brackets (e.g. "Time={T}: Msg={M}, Chan={C}, Status={S}, Data={D}").
            In such case all the format values enclosed in brackets will be replaced by the above value representations. This allows you to format your individual message string.</para>
            </param>
            <returns>The string representing the Midi short message.</returns>
            <example>
            <code>
            public void MyMidiProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
              if (msg == MIDIMessage.MIM_DATA)
              {
                // process the message...
                MidiShortMessage shortMsg = new MidiShortMessage(param1, param2);
                if (shortMsg.MessageType == MIDIMessageType.Channel)
                  Console.WriteLine(shortMsg.ToString("Time={T}: Msg={M}, Chan={C}, Status={S}, {D}"));
                else if (shortMsg.MessageType == MIDIMessageType.SystemCommon)
                  Console.WriteLine(shortMsg.ToString("Time={T}: Msg={M}, Status={S}, {D}"));
                else
                  Console.WriteLine(shortMsg.ToString("G"));
                ...
              }
              ...
            }
            </code>
            <code lang="vbnet">
            Public Sub MyMidiProc(handle As IntPtr, msg As MIDIMessage, instance As IntPtr, param1 As IntPtr, param2 As IntPtr)
              If msg = MIDIMessage.MIM_DATA Then
                ' process the message...
                Dim shortMsg As New MidiShortMessage(param1, param2)
                If shortMsg.MessageType = MIDIMessageType.Channel Then
                  Console.WriteLine(shortMsg.ToString("Time={T}: Msg={M}, Chan={C}, Status={S}, {D}"))
                Else
                  If shortMsg.MessageType = MIDIMessageType.SystemCommon Then
                    Console.WriteLine(shortMsg.ToString("Time={T}: Msg={M}, Status={S}, {D}"))
                  Else
                    Console.WriteLine(shortMsg.ToString("G"))
                  End If
                End If
                ...
              End If 
              ...
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiShortMessage.ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns the string representation of the Midi short message.
            </summary>
            <param name="format">The format to use (one of the following):
            <list type="table">
            <item><term>"G"</term><description>Combi-Format: Timestamp, Type, Channel, Status, Data in full text - same as "{T}\t{M} {C}\t{S}\t{D}" (for Channel messages) resp. "{T}\t{M}\t{S}\t{D}" (for other messages).</description></item>
            <item><term>"g"</term><description>Combi-Format: Timestamp, Type, Channel, Status, Data as numerical values - same as "{t}\t{m} {C}\t{s}\t{d}" (for Channel messages) resp. "{t}\t{m}\t{s}\t{d}" (for other messages).</description></item>
            <item><term>"X"</term><description>Combi-Format: Timespan and Message as hexadecimal values (big hex) - same as "{U} {A} {H}".</description></item>
            <item><term>"x"</term><description>Combi-Format: Timespan and Message as hexadecimal values (small hex) - same as "{u} {a} {h}".</description></item>
            <item><term>"Y"</term><description>Combi-Format: Message as hexadecimal values (big hex) - same as "{A} {H}".</description></item>
            <item><term>"y"</term><description>Combi-Format: Message as hexadecimal values (small hex) - same as "{a} {h}".</description></item>
            <item><term>"T"</term><description>Timespan only.</description></item>
            <item><term>"t"</term><description>Timestamp only.</description></item>
            <item><term>"U"</term><description>Timestamp only as hexadecimal values (big hex).</description></item>
            <item><term>"u"</term><description>Timestamp only as hexadecimal values (small hex).</description></item>
            <item><term>"M"</term><description>MessageType only in full text.</description></item>
            <item><term>"m"</term><description>MessageType as numerical values.</description></item>
            <item><term>"S"</term><description>StatusType only in full text.</description></item>
            <item><term>"s"</term><description>StatusType only as numerical value.</description></item>
            <item><term>"A"</term><description>Status only as hexadecimal values (big hex).</description></item>
            <item><term>"a"</term><description>Status only as hexadecimal values (small hex).</description></item>
            <item><term>"C"</term><description>Channel only as numerical value.</description></item>
            <item><term>"D"</term><description>Data only in full text.</description></item>
            <item><term>"d"</term><description>Data only as numerical value.</description></item>
            <item><term>"H"</term><description>Data only as hexadecimal values (big hex).</description></item>
            <item><term>"h"</term><description>Data only as hexadecimal values (small hex).</description></item>
            </list>
            <para>You might also combine the single values into a full format string when enclosed in brackets (e.g. "Time={T}: Msg={M}, Chan={C}, Status={S}, Data={D}").
            In such case all the format values enclosed in brackets will be replaced by the above value representations. This allows you to format your individual message string.</para>
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> which should be used or NULL if the default schema values should be used.
            </param>
            <returns>The string representing the Midi short message.</returns>
            <example>
            <code>
            public void MyMidiProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
              if (msg == MIDIMessage.MIM_DATA)
              {
                // process the message...
                MidiShortMessage shortMsg = new MidiShortMessage(param1, param2);
                if (shortMsg.MessageType == MIDIMessageType.Channel)
                  Console.WriteLine(shortMsg.ToString("Time={T}: Msg={M}, Chan={C}, Status={S}, {D}"));
                else if (shortMsg.MessageType == MIDIMessageType.SystemCommon)
                  Console.WriteLine(shortMsg.ToString("Time={T}: Msg={M}, Status={S}, {D}"));
                else
                  Console.WriteLine(shortMsg.ToString("G"));
                ...
              }
              ...
            }
            </code>
            <code lang="vbnet">
            Public Sub MyMidiProc(handle As IntPtr, msg As MIDIMessage, instance As IntPtr, param1 As IntPtr, param2 As IntPtr)
              If msg = MIDIMessage.MIM_DATA Then
                ' process the message...
                Dim shortMsg As New MidiShortMessage(param1, param2)
                If shortMsg.MessageType = MIDIMessageType.Channel Then
                  Console.WriteLine(shortMsg.ToString("Time={T}: Msg={M}, Chan={C}, Status={S}, {D}"))
                Else
                  If shortMsg.MessageType = MIDIMessageType.SystemCommon Then
                    Console.WriteLine(shortMsg.ToString("Time={T}: Msg={M}, Status={S}, {D}"))
                  Else
                    Console.WriteLine(shortMsg.ToString("G"))
                  End If
                End If
                ...
              End If 
              ...
            End Sub
            </code>
            </example>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.ID">
            <summary>
            Gets a unique overall short message ID.
            </summary>
            <remarks>The message ID is an internal counter which might be used to track the message order.
            <para>It will be incremented with every short-message created in the system. 
            So it might not be linear when using multiple devices in parallel, but it will for sure be incremental for each device, meaning each message ID generated on a device will be greater as the the previous message.</para>
            <para>But note, that the counter will be wrapped to 0 when it reaches a value of 9,223,372,036,854,775,807.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage">
            <summary>
            Gets or Sets the previous short message (preceding this short message) if set (or NULL if not set).
            </summary>
            <remarks>
            <para>Note: Some <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> messages might actually use two short messages (e.g. the <see cref="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelect"/>) to support paired values with a higher resolution (16384 instead of 128 values).
            In such case two messages will be send, where one contains the the LSB value (single steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte and the other on the MSB value (128th steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte.</para>
            <para>For this special case it might be useful to keep in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> handler always the current and the last (previous) message.
            Use this property to keep your previous message with the current short message.</para>
            <para>To access the single value assigned to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/>/<see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerType"/> access the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerValue"/> property.</para>
            <para>You might use the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData(System.Byte,System.Byte)"/>, <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData2(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> resp. the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData1(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> method to retrieve a combined value from two short messages resp. two data value.</para>
            <para>Typically the messages with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> of <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> and with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value between 0 and 31 (MSB, coarse) are paired with a message of a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value between 32 and 63 (LSB, fine).
            But also a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 98 (LSB, fine) will be paired with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 99 (MSB, coarse) as well as a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 100 (LSB, fine) will be paired with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 101 (MSB, coarse).
            Other pairs might be hardware specific.</para>
            <para>If no previous message was set (e.g. see constructor overloads) this member might return NULL.
            It is also not possible to get a series of previous messages (i.e. the previous of the previous etc.) - only the last previous message is kept here.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Status">
            <summary>
            Gets or Sets the MIDI status byte.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1">
            <summary>
            Gets or Sets the MIDI data byte 1.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2">
            <summary>
            Gets or Sets the MIDI data byte 2.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Data3">
            <summary>
            Gets or Sets the MIDI data byte 3.
            </summary>
            <remarks>This member is only used, if the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.None"/>,
            for all recognized <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/>s the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data3"/> byte is not used and has a default value of 0!
            So it is here just for completeness and will typically never be used.</remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Timespan">
            <summary>
            Gets or Sets the time that the message was received by the input device driver. The time stamp is specified as milliseconds, beginning at zero when the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InStart(System.IntPtr)"/> function was called.
            </summary>
            <remarks>The <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Timespan"/> and the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Timestamp"/> members can be used in exchange and will express the same time stamp..</remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Timestamp">
            <summary>
            Gets or Sets the time that the message was received by the input device driver. The time stamp is specified in milliseconds, beginning at zero when the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InStart(System.IntPtr)"/> function was called.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.TimestampAsIntPtr">
            <summary>
            Gets or Sets the time span value (typically the param2 of a Midi message).
            </summary>
            <remarks>See <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Timestamp"/> for details (uses the same value as <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Timestamp"/> but represented as an IntPtr).</remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Message">
            <summary>
            Gets or Sets the constructed Midi message value.
            </summary>
            <remarks>If a MIDI method requires an IntPtr instead on an Int32 value, please use the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.MessageAsIntPtr"/> property.
            <para>This property will get or set all relevant bytes: <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Status"/>, <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/>, <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> and <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data3"/>.</para>
            </remarks>
            <example>
            Sending a short message:
            <code>
            // construct a message
            MidiShortMessage msg = new MidiShortMessage(MIDIStatus.NoteOn, channel, note, velocity, 0, 0);
            // send the message
            int result = MIDI_OutShortMsg(handle, msg.Message);
            </code>
            <code lang="vbnet">
            ' construct a message
            Dim msg As New MidiShortMessage(MIDIStatus.NoteOn, channel, note, velocity, 0, 0)
            ' send the message
            Dim result As Integer = MIDI_OutShortMsg(handle, msg.Message)
            </code>
            </example>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.MessageAsIntPtr">
            <summary>
            Gets or Sets the constructed Midi message value (typically the param1 of a Midi message).
            </summary>
            <remarks>See <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Message"/> for details (uses the same value as <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Message"/> but represented as an IntPtr).</remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.MessageType">
            <summary>
            Gets or Sets the Midi message type (one of the <see cref="T:Ten53.Multimedia.Midi.MIDIMessageType"/> values) from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Status"/> byte.
            </summary>
            <remarks>Here is an overview on how the messaage type is mapped evaluating the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Status"/> byte:
            <para>Channel Message: 0x8n - 0xEn (n = any value between 0 and F). Any NoteOff, NoteOn, Aftertouch, ControlChange, ProgramChange, ChannelPressure and PitchBend message.</para>
            <para>SystemCommon Message: hex F0 (SystemMsgs), F1 (MidiTimeCode), F2 (SongPosition), F3 (SongSelect), F6 (TuneRequest) and F7 (EOX).</para>
            <para>SystemRealtime Message: F8 (Clock), F9 (Tick), FA (Start), FB (Continue), FC (Stop), FE (ActiveSense) and FF (Reset).</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType">
            <summary>
            Gets or Sets the Midi status type (one of the <see cref="T:Ten53.Multimedia.Midi.MIDIStatus"/> values) from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Status"/> byte.
            </summary>
            <remarks>The status type is kept in the 4 upper bits of the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Status"/> byte 
            and is also often called the type of the message (e.g. NoteOn, NoteOff, Aftertouch, ControlChange etc.).
            <para>If no usefull status type could be evaluated <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.None"/> will be returned (which might not reflect the actual status byte value, e.g. if the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Status"/> has a value of 0xFD there will be no useful status type associated).</para>
            <para>When assigning a status type the following will apply: If the new value is 0xF0 or above, the full <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Status"/> byte will be set with the new value, else only the 4 upper bits will be set with the new value.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Channel">
            <summary>
            Gets or Sets the channel number from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Status"/> byte.
            </summary>
            <remarks>The channel number is kept in the 4 lower bits of the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Status"/> byte 
            and is also often just called the channel of the message (between 0 and 15).
            <para>When assigning a channel number only the lower 4-bit of the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Status"/> byte will be set.</para>
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.MessageType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIMessageType.Channel"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Note">
            <summary>
            Gets or Sets the Midi note number from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.
            </summary>
            <remarks>The note number ranges from 0 to 127.
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.NoteOn"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.NoteOff"/> or <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.Aftertouch"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.NoteString">
            <summary>
            Gets the Midi note from the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte as a string representation.
            </summary>
            <remarks>Exmple is: "C-1" or "DSharp0" or "A4". The latter number represents the octave (i.e. the '-1', '0' resp. '4').
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.NoteOn"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.NoteOff"/> or <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.Aftertouch"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Velocity">
            <summary>
            Gets or Sets the velocity (key pressure speed) from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte.
            </summary>
            <remarks>The velocity ranges from 0 to 127.
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.NoteOn"/> or <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.NoteOff"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Aftertouch">
            <summary>
            Gets or Sets the polyphonic aftertouch (polyphonic key pressure) from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte.
            </summary>
            <remarks>The polyphonic aftertouch (or key pressure) ranges from 0 (no pressure) to 127 (full pressure).
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.Aftertouch"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.ChannelPressure">
            <summary>
            Gets or Sets the channel pressure (channel aftertouch) from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.
            </summary>
            <remarks>The channel pressure ranges from 0 (no pressure) to 127 (full pressure).
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ChannelPressure"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Program">
            <summary>
            Gets or Sets the changed program number from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.
            </summary>
            <remarks>The program change number ranges from 0 to 127.
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ProgramChange"/>.</para>
            <para>If multiple banks do exist a <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ProgramChange"/> command will select a new program number from the current bank only.
            A different bank will be selected with two sub-sequent <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> commands. This will also be called a Bank-Select-Command.
            For this special case it might be useful to keep in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> handler always the current and the last message.</para>
            <para>You might use the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData(System.Byte,System.Byte)"/>, <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData2(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> resp. the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData1(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> method to retrieve a combined value from two short messages resp. two data value.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.PitchBend">
            <summary>
            Gets or Sets the pitch bend value from/to <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> and <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> as a combined value.
            </summary>
            <remarks>The pitch bend value ranges from 0 to 16383 (128*128 values).
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.PitchBend"/>.</para>
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte will contain the LSB value (single steps) and the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte the MSB value (128th steps) both ranging from 0 to 128.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller">
            <summary>
            Gets or Sets the controller number from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.
            </summary>
            <remarks>The controller number ranges from 0 to 127.
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/>.</para>
            <para>Note: Some ControlChange messages might actually use two short messages (e.g. the <see cref="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelect"/>) to support paired values with a higher resolution (16384 instead of 128 values).
            In such case two messages will be send, where one contains the the LSB value (single steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte and the other on the MSB value (128th steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte.</para>
            <para>For this special case it might be useful to keep in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> handler always the current and the last message.</para>
            <para>You might use the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData(System.Byte,System.Byte)"/>, <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData2(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> resp. the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData1(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> method to retrieve a combined value from two short messages resp. two data value.</para>
            <para>To access the single value assigned to the controler access the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerValue"/> property.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerType">
            <summary>
            Gets or Sets the controller type (one of the <see cref="T:Ten53.Multimedia.Midi.MIDIControllerType"/> values) from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.
            </summary>
            <remarks>
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/>.</para>
            <para>Note: Some ControlChange messages might actually use two short messages (e.g. the <see cref="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelect"/>) to support paired values with a higher resolution (16384 instead of 128 values).
            In such case two messages will be send, where one contains the the LSB value (single steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte and the other on the MSB value (128th steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte.</para>
            <para>For this special case it might be useful to keep in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> handler always the current and the last message.</para>
            <para>You might use the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData(System.Byte,System.Byte)"/>, <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData2(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> resp. the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData1(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> method to retrieve a combined value from two short messages resp. two data value.</para>
            <para>To access the single value assigned to the controler access the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerValue"/> property.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.ThisIsMSB">
            <summary>
            Returns TRUE, if this short-message contains the MSB (coarse) <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerValue"/> and the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/> the LSB (fine) value - only in case the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.IsSetAsContinuousController"/> value is set to TRUE.
            </summary>
            <remarks>In case the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.IsSetAsContinuousController"/> value returns FALSE this property has no meaning!</remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousIsMSB">
            <summary>
            Returns TRUE, if the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/> contains the MSB (coarse) <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerValue"/> and this message the LSB (fine) value - only in case the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.IsSetAsContinuousController"/> value is set to TRUE.
            </summary>
            <remarks>In case the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.IsSetAsContinuousController"/> value returns FALSE this property has no meaning!</remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.IsSetAsContinuousController">
            <summary>
            Gets, if this message was manually set to be a continuous controller message.
            </summary>
            <remarks>
            <para>This message is only a continuous controller message, if set via <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.SetContinuousController(System.Boolean,System.Boolean)"/> and if the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/> exists and it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> also has a value of <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> and the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Channel"/> is the same.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerValue">
            <summary>
            Gets or Sets the controller value from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte (and optionally from the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/>).
            </summary>
            <remarks>The controller value normally ranges from 0 to 127.
            But if the controller is a continuous controller, this simply means that it's value can be set to any value within the range from 0 to 16384 (for 14-bit coarse/fine resolution).
            <para>To set a continuous controllers use the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.SetContinuousController(System.Boolean,System.Boolean)"/>. By default this is never set.
            In such case this property will return the combined controller value by pairing this contoller value with the one from the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/>.
            Note: You must explicitly call the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.SetContinuousController(System.Boolean,System.Boolean)"/> method in order to obtain the paired value. 
            There is also no additional check performed (except that the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/> must exist and must have a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> of value <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/>).
            Setting this member if <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.IsSetAsContinuousController"/> will in such case also modify this short-message as well as the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/>!</para>
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/>.</para>
            <para>Note: Some ControlChange messages might actually use two short messages (e.g. the <see cref="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelect"/>) to support paired values with a higher resolution (16384 instead of 128 values).
            In such case two messages will be send, where one contains the the LSB value (single steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte and the other on the MSB value (128th steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte.</para>
            <para>For this special case it might be useful to keep in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> handler always the current and the last message.</para>
            <para>You might use the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData(System.Byte,System.Byte)"/>, <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData2(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> resp. the <see cref="M:Ten53.Multimedia.Midi.MidiShortMessage.GetPairedData1(Ten53.Multimedia.Midi.MidiShortMessage,Ten53.Multimedia.Midi.MidiShortMessage)"/> method to retrieve a combined value from two short messages resp. two data value.</para>
            <para>To access the controller number using this value access the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> or <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerType"/> property.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.TimeCodeType">
            <summary>
            Gets or Sets the Midi Time Code type (one of the <see cref="T:Ten53.Multimedia.Midi.MIDIMTCType"/> values) from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.
            </summary>
            <remarks>
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.MidiTimeCode"/>.</para>
            <para>For more details about the Midi Time Code (MTC) representation see <see cref="T:Ten53.Multimedia.Midi.MIDIMTCType"/>.</para>
            <para>Setting this property will only modify the upper half of the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.TimeCodeValue">
            <summary>
            Gets or Sets the Midi Time Code value (partial) from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.
            </summary>
            <remarks>
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.MidiTimeCode"/>.</para>
            <para>For more details about the Midi Time Code (MTC) representation see <see cref="T:Ten53.Multimedia.Midi.MIDIMTCType"/>.</para>
            <para>Setting this property will only modify the lower half of the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.SongPosition">
            <summary>
            Gets or Sets the song position value from/to <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> and <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> as a combined value.
            </summary>
            <remarks>The song position value ranges from 0 to 16383 (128*128 values).
            <para>Some master device that controls sequence playback sends this message to force a slave device to cue the playback to a certain point in the song/sequence. In other words, this message sets the device's "Song Position". This message doesn't actually start the playback. It just sets up the device to be "ready to play" at a particular point in the song.</para>
            <para>This value is the also called the MIDI Beat upon which to start the song. Songs are always assumed to start on a MIDI Beat of 0. Each MIDI Beat spans 6 MIDI Clocks. In other words, each MIDI Beat is a 16th note (since there are 24 MIDI Clocks in a quarter note).</para>
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.SongPosition"/>.</para>
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte will contain the LSB value (single steps) and the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte the MSB value (128th steps) both ranging from 0 to 128.</para>
            <para>Example: 
            If a Song Position value of 8 is received, then a sequencer (or drum box) should cue playback to the third quarter note of the song. (8 MIDI beats * 6 MIDI clocks per MIDI beat = 48 MIDI Clocks. Since there are 24 MIDI Clocks in a quarter note, the first quarter occurs on a time of 0 MIDI Clocks, the second quarter note occurs upon the 24th MIDI Clock, and the third quarter note occurs on the 48th MIDI Clock).</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Song">
            <summary>
            Gets or Sets the song number from/to the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.
            </summary>
            <remarks>The song number ranges from 0 to 127.
            <para>This property should only be used when <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.SongSelect"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiShortMessage.Data">
            <summary>
            Gets or Sets the combined <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/>, <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> and possibly <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data3"/> values as an integer.
            </summary>
            <remarks>The full data value ranges from 0 to 16384 (128*128 values, default) resp. from 0 to 2097151 (128*128*128 values, in case of <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.None"/>).
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte will contain the LSB value (single steps), the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte the MSB1 value (128th steps) and the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data3"/> byte the MSB2 value (16384th steps) all ranging from 0 to 128.</para>
            <para>Only in case that the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.None"/> the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data3"/> byte will be used, since for all recognized <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/>s the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data3"/> byte will not be used and set to 0 (zero).</para>
            </remarks>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MidiSysExMessage">
            <summary>
            This class represents a Midi system-exclusive message as for example received in a <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/> message of a <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/>
            or as being used with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> and returned back in the <see cref="T:Ten53.Multimedia.Midi.MIDIOUTPROC"/> with the <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MOM_DONE"/> message.
            </summary>
            <remarks>You might use the class to pack (encode, construct) or unpack (decode) any Midi system-exclusive message.
            <para>System-Exclusive message use a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure as the transport vehicle between devices. Internally a <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer needs to be prepared when sending or providing the buffer to a device. When the device finishes with the message processing you will be notified and you'll need to unprepare the buffer.</para>
            <para>Sending system-exclusive messages to an output device:</para>
            <para>Use this class with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> method to send a message to an output device.
            Beforehand use the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> method to construct your message buffer. You might then use the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageWrite(System.Int32@,System.Byte)"/> methods to write data to the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer. When done call the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> method to prepare the data buffer and make it ready to be send to the device. Once prepared the data buffer can not be changed anymore.
            Finally use the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.MessageAsIntPtr"/> property in the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> call to get the pointer to the constructed and prepared <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure.
            After sending the message make sure to capture the <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MOM_DONE"/> message in your <see cref="T:Ten53.Multimedia.Midi.MIDIOUTPROC"/> in order to unprepare the data buffer. This is actually automatically being done within the constructor of this class when using the overload taking an IntPtr argument.</para>
            <para>Receiving system-exclusive messages at an input device:</para>
            <para>Use this class with the <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/> message of a <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> to decode the received message.
            Before you can receive system-exclusive messages you must constantly provide data buffers to the device (which will then be filled with data by the device and returned to your input). So you might use the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> method to create such empty buffer and then call <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> to prepare the data buffer and make it ready to be send to the device. Once prepared the data buffer can not be changed anymore.
            Finally use the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.MessageAsIntPtr"/> property in the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> call to get the pointer to the constructed and prepared <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure and provide the buffer to the device.
            After providing the buffer make sure to capture the <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/> resp. <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGERROR"/> message in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> in order to unprepare the data buffer. This is actually automatically being done within the constructor of this class when using the overload taking an IntPtr argument.
            You might use the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead8(System.Int32@)"/>, <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead16(System.Int32@)"/>, <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead24(System.Int32@)"/> etc. methods to fianlly read data from the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer you received and interpret it's content accordingly.</para>
            <para>The <see cref="T:Ten53.Multimedia.Midi.MidiInputDevice"/> and <see cref="T:Ten53.Multimedia.Midi.MidiOutputDevice"/> already handle most of these tasks (e.g. preparing and unpreparing of system-exclusive messages) for you.</para>
            </remarks>
            <example>
            Sending system-exclusive messages to an output device:
            <code>
            private MIDIOUTPROC _midiProc;
            private IntPtr _midiOutHandle;
            ...
            // Open the Midi device #0
            _midiProc = new MIDIOUTPROC(MyMidiOutProc);
            MIDIError ret = Midi.MIDI_OutOpen(ref _midiOutHandle, 0, _midiProc, 0);
            if (ret == MIDIError.MIDI_OK)
            {
              // output ready
            }
            ...
            private void SendSysExBuffer(IntPtr handle, byte[] data)
            {
              MidiSysExMessage msg = new MidiSysExMessage(false, handle);
              msg.CreateBuffer(data);
              if (msg.Prepare())
              {
                // if the message was perpared successfully
                // send a system-exclusive message to the output device
                Midi.MIDI_OutLongMsg(handle, msg.MessageAsIntPtr);
              }
            }
            
            public void MyMidiOutProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
              // handle all Midi messages here
              if (msg == MIDIMessage.MOM_DONE)
              {
                // process the message...
                // param1 will contain the pointer to the MIDI_HEADER
                MidiSysExMessage sysexMsg = new MidiSysExMessage(false, handle, param1);
                // the internal header is already unprepared here
                // so you can still use the data...
                Console.WriteLine( sysexMsg.ToString() );
              }
              ...
            }
            </code>
            <code lang="vbnet">
            Private _midiProc As MIDIOUTPROC
            Private _midiOutHandle As IntPtr
            ...
            ' Open the Midi device #0
            _midiProc = New MIDIOUTPROC(AddressOf MyMidiOutProc)
            Dim ret As MIDIError = Midi.MIDI_OutOpen(_midiOutHandle, 0, _midiProc, 0)
            If ret = MIDIError.MIDI_OK Then
              ' output ready
            End If
            ...
            Private Sub SendSysExBuffer(handle As IntPtr, data() As Byte)
              Dim msg As New MidiSysExMessage(False, handle)
              msg.CreateBuffer(data)
              If msg.Prepare() Then
                ' if the message was perpared successfully
                ' send a system-exclusive message to the output device
                Midi.MIDI_OutLongMsg(handle, msg.MessageAsIntPtr)
              End If
            End Sub
            
            Public Sub MyMidiOutProc(handle As IntPtr, msg As MIDIMessage, instance As IntPtr, param1 As IntPtr, param2 As IntPtr)
              ' handle all Midi messages here
              If msg = MIDIMessage.MOM_DONE Then
                ' process the message...
                ' param1 will contain the pointer to the MIDI_HEADER
                Dim sysexMsg As New MidiSysExMessage(False, handle, param1)
                ' the internal header is already unprepared here
                ' so you can still use the data...
                Console.WriteLine(sysexMsg.ToString())
              End If
            End Sub
            </code>
            Receiving system-exclusive messages at an input device:
            <code>
            private MIDIINPROC _midiProc;
            private IntPtr _midiInHandle;
            ...
            // Open the Midi device #0
            _midiProc = new MIDIINPROC(MyMidiInProc);
            MIDIError ret = Midi.MIDI_InOpen(ref _midiInHandle, 0, _midiProc, IntPtr.Zero, MIDIFlags.MIDI_IO_STATUS);
            if (ret == MIDIError.MIDI_OK)
            {
              // already supply the device with 2 buffers (each 1K)
              AddSysExBuffer(_midiInHandle, 1024);
              AddSysExBuffer(_midiInHandle, 1024);
              // Start the device
              ret = Midi.MIDI_InStart(_midiInHandle);
            }
            ...
            // prepare receiving system-exclusive messages
            private void AddSysExBuffer(IntPtr handle, int size)
            {
              MidiSysExMessage msg = new MidiSysExMessage(true, handle);
              msg.CreateBuffer(size);
              if (msg.Prepare())
              {
                // Add the buffer to the InputDevice.
                Midi.MIDI_InAddBuffer(handle, msg.MessageAsIntPtr);
              }
            }
            
            MidiSysExMessage _sysexMsg = null;
            public void MyMidiInProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
              if (msg == MIDIMessage.MIM_LONGDATA || msg == MIDIMessage.MIM_LONGERROR)
              {
                // process the sysex message...
                // param1 will contain the pointer to the MIDI_HEADER
                _sysexMsg = new MidiSysExMessage(true, handle, param1, _sysexMsg);
                if (_sysexMsg.IsDone)
                {
                  // use it...
                  Console.WriteLine( sysexMsg.ToString() );
                }
                ...
                // add a new buffer
                // since we should constantly provide new buffers until we finished recording
                AddSysExBuffer(handle, 1024);
              }
              ...
            }
            </code>
            <code lang="vbnet">
            Private _midiProc As MIDIINPROC
            Private _midiInHandle As IntPtr
            ...
            ' Open the Midi device #0
            _midiProc = New MIDIINPROC(AddressOf MyMidiInProc)
            Dim ret As MIDIError = Midi.MIDI_InOpen(_midiInHandle, 0, _midiProc, IntPtr.Zero, MIDIFlags.MIDI_IO_STATUS)
            If ret = MIDIError.MIDI_OK Then
              ' already supply the device with 2 buffers (each 1K)
              AddSysExBuffer(_midiInHandle, 1024)
              AddSysExBuffer(_midiInHandle, 1024)
              ' Start the device
              ret = Midi.MIDI_InStart(_midiInHandle)
            End If
            ...
            ' prepare receiving system-exclusive messages
            Private Sub AddSysExBuffer(handle As IntPtr, size As Integer)
              Dim msg As New MidiSysExMessage(True, handle)
              msg.CreateBuffer(size)
              If msg.Prepare() Then
                ' Add the buffer to the InputDevice.
                Midi.MIDI_InAddBuffer(handle, msg.MessageAsIntPtr)
              End If
            End Sub
            
            ' prepare sending system-exclusive messages
            Dim _sysexMsg As MidiSysExMessage = Nothing
            Public Sub MyMidiInProc(handle As IntPtr, msg As MIDIMessage, instance As IntPtr, param1 As IntPtr, param2 As IntPtr)
              If msg = MIDIMessage.MIM_LONGDATA OrElse msg = MIDIMessage.MIM_LONGERROR Then
                ' process the sysex message...
                ' param1 will contain the pointer to the MIDI_HEADER
                _sysexMsg = New MidiSysExMessage(True, handle, param1, _sysexMsg)
                If _sysexMsg.IsDone Then
                  ' use it...
                  Console.WriteLine(sysexMsg.ToString())
                End If
                ...
                ' add a new buffer
                ' since we should constantly provide new buffers until we finished recording
                AddSysExBuffer(handle, 1024)
              End If
              ...
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.#ctor(System.Boolean,System.IntPtr)">
            <summary>
            Creates a new and empty instance of the MidiSysExMessage.
            </summary>
            <param name="input">Dealing with a Midi input device? (TRUE=input, FALSE=output).</param>
            <param name="handle">The handle to the MIDI device.</param>
            <remarks>You might use this one together with the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> method to construct your own Midi system-exclusive message.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.#ctor(System.Boolean,System.IntPtr,System.IntPtr)">
            <summary>
            Creates a new instance of the MidiSysExMessage from a pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/>.
            </summary>
            <param name="input">Dealing with a Midi input device? (TRUE=input, FALSE=output).</param>
            <param name="handle">The handle to the MIDI device.</param>
            <param name="headerPtr">A pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure to use with this system-exclusive message.</param>
            <remarks>
            <para>You might use this constuctor in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> or <see cref="T:Ten53.Multimedia.Midi.MIDIOUTPROC"/> when receiving a <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGERROR"/> resp. <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MOM_DONE"/> message with the 'prarm1' value.</para>
            <para>Calling this constructor with a valid pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure will automatically unprepare the header (using <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Unprepare(System.Boolean,System.IntPtr)"/>)!
            However, that data of the header will first be copied to this class so it is still accessable.</para>
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer will only be set, if the <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.IsDone"/> flag was set - meaning the Midi device finished with the buffer.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.#ctor(System.Boolean,System.IntPtr,System.IntPtr,Ten53.Multimedia.Midi.MidiSysExMessage)">
            <summary>
            Creates a new instance of the MidiSysExMessage from a pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> and also evaluates a previous system-exclusive message.
            </summary>
            <param name="input">Dealing with a Midi input device? (TRUE=input, FALSE=output).</param>
            <param name="handle">The handle to the MIDI device.</param>
            <param name="headerPtr">A pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure to use with this system-exclusive message.</param>
            <param name="previous">The previous system-exclusive message received (in order to check, if data buffers need to be concatenated).</param>
            <remarks>
            <para>You might use this constuctor in your <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> or <see cref="T:Ten53.Multimedia.Midi.MIDIOUTPROC"/> when receiving a <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGERROR"/> resp. <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MOM_DONE"/> message with the 'prarm1' value.</para>
            <para>This overload ensures, that sub-sequent system-exclusive messages are automatically concatenated (if needed) until the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsDone"/> property is set to TRUE.
            It might be the case, that an input device needs to use more than one system-exclusive message in order to complete one message. This because for input devices your application provide empty buffers of a given size to the device. If this buffer is not large enough to keep the full message multiple system-exclusive messages are used.
            The <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsDone"/> property indicates, if the current data buffer is complete and the device driver indicates that it is finished with the buffer.
            If the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsDone"/> property is set to FALSE this would indicate, that more data is about to come and the current <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer needs to be concatenated with sub-sequent system-exclusive messages until <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsDone"/> returns TRUE.
            This overload ensures, that the current data buffer of the <paramref name="headerPtr"/> will automatically be appended to the data buffer of the <paramref name="previous"/> data buffer if the previous buffer was not finished, so that this instance will contain the data buffer of the previous and this message.
            If the <paramref name="previous"/> buffer was already done or is NULL nothing will be done and only the current data buffer will be used.
            All this only applies to input devices (<see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsInput"/> should be TRUE), since when dealing with output devices you control the amount of data to send.</para>
            <para>Calling this constructor with a valid pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure will automatically unprepare the header (using <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Unprepare(System.Boolean,System.IntPtr)"/>)!</para>
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer will only be set, if the <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.IsDone"/> flag was set - meaning the Midi device finished with the buffer.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)">
            <summary>
            Creates an empty <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer of the given size (between 2 and 65536).
            </summary>
            <param name="size">The number of byte for to buffer to use.</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>Note: The method clear all data in an existing buffer.
            Calling this method on an already prepared buffer will have no effect and FALSE will be returned.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Byte[])">
            <summary>
            Creates a <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with the given data buffer.
            </summary>
            <param name="data">The byte array to initialize the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with.</param>
            <returns>TRUE on sucess - else FALSE will be returned (e.g. data is NULL or it's length is less than 2).</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare">
            <summary>
            Prepares the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.MessageAsIntPtr"/> out of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer ready to be used with a device.
            </summary>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>After you have called this method the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> should NOT be changed!
            <para>Use the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.MessageAsIntPtr"/> property to retrieve the prepared pointer to the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> which must be used to handle any system-exclusive message.</para>
            <para>Use this property with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> method to provide a data buffer to an input device in order to receive a system-exclusive message.</para>
            <para>Use this property with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> method to send a system-exclusive message to an output device.</para>
            <para>Note: There is no 'Unprepare' method present in this class, since this will be handled automatically once you received a message back from the device and (re)create an instance of this class with the param1 IntPtr.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare(System.IntPtr)">
            <summary>
            Prepares the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.MessageAsIntPtr"/> out of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer ready to be used with a device.
            </summary>
            <param name="user">User instance data to pass to the system-exclusive message (might be later retrieved via the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.User"/> property).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>After you have called this method the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> should NOT be changed!
            <para>Use the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.MessageAsIntPtr"/> property to retrieve the prepared pointer to the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> which must be used to handle any system-exclusive message.</para>
            <para>Use this property with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> method to provide a data buffer to an input device in order to receive a system-exclusive message.</para>
            <para>Use this property with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> method to send a system-exclusive message to an output device.</para>
            <para>Note: There is no 'Unprepare' method present in this class, since this will be handled automatically once you received a message back from the device and (re)create an instance of this class with the param1 IntPtr.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.Send">
            <summary>
            Sends this system-exclusive message to the given <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Device"/>.
            </summary>
            <returns>TRUE on success (message was send successfully), else FALSE.</returns>
            <remarks>Note: Before sending this system-exclusive message it must have been prepared with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>!
            <para>This method will also fail, if the Midi <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Device"/> was not opened with <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIOUTPROC,System.IntPtr)"/> resp. <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIINPROC,System.IntPtr,Ten53.Multimedia.Midi.MIDIFlags)"/>. 
            If dealing with an input device (<see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsInput"/>) you must also start the device with <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InStart(System.IntPtr)"/>.</para>
            <para>If dealing with an input device this system-exclusive message is used to provide a buffer to the input device (<see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> is used internally).</para>
            <para>If dealing with an output device this system-exclusive message is send as a long message to the output device (<see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> is used internally).</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.Validate">
            <summary>
            Validates the given <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer to ensure it contains a valid system-exclusive message.
            </summary>
            <returns>TRUE, if the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer contains a valid system-exclusive message, else FALSE.</returns>
            <remarks>The following check is performed:
            <para>The first byte must be 0xF0 and the last byte in the buffer must be 0xF7.</para>
            <para>The data bytes in between must all having bit #7 clear, i.e. a 0 to 127 value.</para>
            <para>If you received a message and the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsDone"/> property is set to FALSE it is very likely, that the message is not valid.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.ToString">
            <summary>
            Returns the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer as a string.
            </summary>
            <returns>The string representation of the Midi data in the data buffer as hexadecimal values.</returns>
            <remarks>If no <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> to the data buffer exists NULL will be returned. If the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.MessageLength"/> is zero an empty string will be returned - 
            else a hexadecimal representation of the byte array of the data will be returned, e.g. "F0 41 00 ... F7".</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead(System.Int32@)">
            <summary>
            Reads an 8-bit value from the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer (full).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer to start reading (the offset will be automatically be increased by the number of bytes read).</param>
            <returns>The byte value (between 0 and 255) at the given position.</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageWrite(System.Int32@,System.Byte)">
            <summary>
            Writes an 8-bit value to the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer (full).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer where to start writing (the offset will be automatically be increased by the number of bytes written).</param>
            <param name="value">The full byte value to write.</param>
            <remarks>
            <para>You first need to initialize the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> before being able to write to the buffer.</para>
            <para>Do not call this method after you have prepared the message with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>, since after calling <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> this method would have no effect.</para>
            </remarks>
            <example>
            <code>
            private MIDIOUTPROC _midiOutProc;
            private IntPtr _midiOutHandle;
            ...
            _midiOutProc = new MIDIOUTPROC(MyMidiOutProc);
            Midi.MIDI_OutOpen(ref _midiOutHandle, 0, _midiOutProc, 0);
            ...
            // create a new system-exclusive message
            MidiSysExMessage sysex = new MidiSysExMessage(false, _midiOutHandle);
            // message will be 8 byte (incl. SoX and EoX)
            sysex.CreateBuffer(8);
            // write start-of-system-exclusive
            sysex.MessageWriteSoX();
            int offset = 1;
            // write 6 more bytes...
            sysex.MessageWrite8(ref offset, 65);
            sysex.MessageWrite16(ref offset, 1023);
            sysex.MessageWrite16(ref offset, 13);
            sysex.MessageWrite8(ref offset, 1);
            // write end-of-system-exclusive
            sysex.MessageWriteEoX();
            ...
            </code>
            <code lang="vbnet">
            Private _midiOutProc As MIDIOUTPROC
            Private _midiOutHandle As IntPtr
            ...
            _midiOutProc = New MIDIOUTPROC(AddressOf MyMidiOutProc)
            Midi.MIDI_OutOpen(_midiOutHandle, 0, _midiOutProc, 0)
            ...
            ' create a new system-exclusive message
            Dim sysex As New MidiSysExMessage(False, _midiOutHandle)
            ' message will be 8 byte (incl. SoX and EoX)
            sysex.CreateBuffer(8)
            ' write start-of-system-exclusive
            sysex.MessageWriteSoX()
            Dim offset As Integer = 1
            ' write 6 more bytes...
            sysex.MessageWrite8(offset, 65)
            sysex.MessageWrite16(offset, 1023)
            sysex.MessageWrite16(offset, 13)
            sysex.MessageWrite8(offset, 1)
            ' write end-of-system-exclusive
            sysex.MessageWriteEoX()
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageWriteSoX">
            <summary>
            Writes the <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.SystemMsgs"/> byte (0xF0) to the first byte of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer.
            </summary>
            <remarks>
            <para>You first need to initialize the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> before being able to write to the buffer.</para>
            <para>Do not call this method after you have prepared the message with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>, since after calling <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> this method would have no effect.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageWriteEoX">
            <summary>
            Writes the <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.EOX"/> byte (0xF7) to the last byte of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer.
            </summary>
            <remarks>
            <para>You first need to initialize the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> before being able to write to the buffer.</para>
            <para>Do not call this method after you have prepared the message with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>, since after calling <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> this method would have no effect.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead8(System.Int32@)">
            <summary>
            Reads a 7-bit value from the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer (right-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer to start reading (the offset will be automatically be increased by the number of bytes read).</param>
            <returns>The byte value (between 0 and 127) at the given position.</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageWrite8(System.Int32@,System.Byte)">
            <summary>
            Writes a 7-bit value to the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer (right-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer where to start writing (the offset will be automatically be increased by the number of bytes written).</param>
            <param name="value">The byte value (between 0 and 127) to write to the given position.</param>
            <remarks>
            <para>You first need to initialize the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> before being able to write to the buffer.</para>
            <para>Do not call this method after you have prepared the message with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>, since after calling <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> this method would have no effect.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead8Wave(System.Int32@)">
            <summary>
            Reads an 8-bit waveform value (2 bytes) from the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer  (left-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer to start reading (the offset will be automatically be increased by the number of bytes read).</param>
            <returns>The byte value (between 0 and 255) at the given position representing the waveform point.</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageWrite8Wave(System.Int32@,System.Byte)">
            <summary>
            Writes an 8-bit waveform value (2 bytes) to the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer  (left-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer where to start writing (the offset will be automatically be increased by the number of bytes written).</param>
            <param name="value">The byte value (between 0 and 255) to write to the given position representing the waveform point.</param>
            <remarks>
            <para>You first need to initialize the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> before being able to write to the buffer.</para>
            <para>Do not call this method after you have prepared the message with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>, since after calling <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> this method would have no effect.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead16(System.Int32@)">
            <summary>
            Reads a 14-bit value (2 bytes) from the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer (right-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer to start reading (the offset will be automatically be increased by the number of bytes read).</param>
            <returns>The short value (between 0 and 16384) at the given position.</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageWrite16(System.Int32@,System.Int16)">
            <summary>
            Writes a 14-bit value (2 bytes) to the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer (right-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer where to start writing (the offset will be automatically be increased by the number of bytes written).</param>
            <param name="value">The short value (between 0 and 16384) to write to the given position.</param>
            <remarks>
            <para>You first need to initialize the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> before being able to write to the buffer.</para>
            <para>Do not call this method after you have prepared the message with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>, since after calling <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> this method would have no effect.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead16Wave(System.Int32@)">
            <summary>
            Reads a 16-bit waveform value (3 bytes) from the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer  (left-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer to start reading (the offset will be automatically be increased by the number of bytes read).</param>
            <returns>The short value (between -32768 and 32767) at the given position representing the waveform point.</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageWrite16Wave(System.Int32@,System.Int16)">
            <summary>
            Writes a 16-bit waveform value (3 bytes) to the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer  (left-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer where to start writing (the offset will be automatically be increased by the number of bytes written).</param>
            <param name="value">The short value (between -32768 and 32767) to write to the given position representing the waveform point.</param>
            <remarks>
            <para>You first need to initialize the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> before being able to write to the buffer.</para>
            <para>Do not call this method after you have prepared the message with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>, since after calling <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> this method would have no effect.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead24(System.Int32@)">
            <summary>
            Reads a 21-bit value (3 bytes) from the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer (right-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer to start reading (the offset will be automatically be increased by the number of bytes read).</param>
            <returns>The int value (between 0 and 2097152) at the given position.</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageWrite24(System.Int32@,System.Int32)">
            <summary>
            Writes a 21-bit value (3 bytes) to the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer (right-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer where to start writing (the offset will be automatically be increased by the number of bytes written).</param>
            <param name="value">The int value (between 0 and 2097152) to write to the given position.</param>
            <remarks>
            <para>You first need to initialize the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> before being able to write to the buffer.</para>
            <para>Do not call this method after you have prepared the message with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>, since after calling <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> this method would have no effect.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead24Wave(System.Int32@)">
            <summary>
            Reads a 24-bit waveform value (4 bytes) from the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer  (left-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer to start reading (the offset will be automatically be increased by the number of bytes read).</param>
            <returns>The int value (between -8388608 and 8388607) at the given position representing the waveform point.</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageWrite16Wave(System.Int32@,System.Int32)">
            <summary>
            Writes a 24-bit waveform value (4 bytes) to the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer  (left-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer where to start writing (the offset will be automatically be increased by the number of bytes written).</param>
            <param name="value">The int value (between -8388608 and 8388607) to write to the given position representing the waveform point.</param>
            <remarks>
            <para>You first need to initialize the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> before being able to write to the buffer.</para>
            <para>Do not call this method after you have prepared the message with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>, since after calling <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> this method would have no effect.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead32(System.Int32@)">
            <summary>
            Reads a 28-bit value (4 bytes) from the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer (right-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer to start reading (the offset will be automatically be increased by the number of bytes read).</param>
            <returns>The int value (between 0 and 268435456) at the given position.</returns>
            <remarks>
            <para>You first need to initialize the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> before being able to write to the buffer.</para>
            <para>Do not call this method after you have prepared the message with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>, since after calling <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> this method would have no effect.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageWrite32(System.Int32@,System.Int32)">
            <summary>
            Writes a 28-bit value (4 bytes) to the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer (right-justified).
            </summary>
            <param name="offset">The zero-base offset (index) of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer where to start writing (the offset will be automatically be increased by the number of bytes written).</param>
            <param name="value">The int value (between 0 and 268435456) to write to the given position.</param>
            <remarks>
            <para>You first need to initialize the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> before being able to write to the buffer.</para>
            <para>Do not call this method after you have prepared the message with <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>, since after calling <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> this method would have no effect.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.ID">
            <summary>
            Gets a unique overall short message ID.
            </summary>
            <remarks>The message ID is an internal counter which might be used to track the message order.
            <para>It will be incremented with every short-message created in the system. 
            So it might not be linear when using multiple devices in parallel, but it will for sure be incremental for each device, meaning each message ID generated on a device will be greater as the the previous message.</para>
            <para>But note, that the counter will be wrapped to 0 when it reaches a value of 9,223,372,036,854,775,807.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsInput">
            <summary>
            Dealing with a Midi input device? (TRUE=input, FALSE=output).
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.Device">
            <summary>
            Gets the handle to the MIDI device.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsPrepared">
            <summary>
            Returns TRUE, if the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer is prepared and can not be changed anymore (else FALSE).
            </summary>
            <remarks>Once you called the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> method the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer will be prepared and sealed. It can therefore not be changed afterwards.
            Use the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.MessageAsIntPtr"/> to retrieve the prepared pointer to the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure ready to be used for sending and receiving system-exclusive messages.</remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.MessageType">
            <summary>
            Gets the Midi message type (one of the <see cref="T:Ten53.Multimedia.Midi.MIDIMessageType"/> values).
            </summary>
            <remarks>Actually always returns <see cref="F:Ten53.Multimedia.Midi.MIDIMessageType.SystemExclusive"/>.
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.MessageAsIntPtr">
            <summary>
            Gets the prepared pointer to the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure ready to be used with a Midi device.
            </summary>
            <remarks>
            <para>Use this property with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> method to provide a data buffer to an input device in order to receive a system-exclusive message.</para>
            <para>Use this property with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> method to send a system-exclusive message to an output device.</para>
            <para>Will return IntPtr.Zero, if the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer is not already prepared (see <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/>).</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message">
            <summary>
            Gets the raw data buffer bytes representing the system-exclusive message.
            </summary>
            <remarks>Once you called the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> method the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer will be prepared and sealed. It can therefore not be changed afterwards.
            Use the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.MessageAsIntPtr"/> property to retrieve a prepared pointer to the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure ready to be used with a Midi device.
            <para>You might use the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsPrepared"/> property to check, if the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer is already prepared.</para>
            <para>Use the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Validate"/> method to check, if the data buffer contains a valid system-exclusive message.</para>
            <para>To create a new system-exclusive message use the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.CreateBuffer(System.Int32)"/> method to initialize the data buffer and then call the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageWrite(System.Int32@,System.Byte)"/> methods to write the actual data to the message data buffer.</para>
            <para>To unpack and read a system-exclusive message use the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead8(System.Int32@)"/>, <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead16(System.Int32@)"/>, <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead24(System.Int32@)"/> etc. methods to retrieve data from the message data buffer (e.g. as received from an input device).</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.MessageLength">
            <summary>
            Gets the length of the system exclusive <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsDone">
            <summary>
            TRUE, if the data in the buffer is complete and contains all data (else FALSE).
            </summary>
            <remarks>This property is not mixed up with the <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.IsDone"/> property - which is set by the device driver to indicate that it is finished with the buffer and is returning it to the application.
            Instead this property validates, if the data in the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> buffer represents a full system-exclusive message starting with a <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.SystemMsgs"/> byte and ending with a <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.EOX"/> byte.
            <para>If the member is FALSE this would indicate, that more data is about to come and this <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer should be concatenated with sub-sequent system-exclusive messages until this flag returns TRUE.</para>
            <para>You might use the constructor overload of this class which takes an instance of the MidiSysExMessage in order to automatically concatenate system-exclusive messages.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.User">
            <summary>
            Gets the user instance data as passed with the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> method.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.StatusType">
            <summary>
            Gets the Midi status type (one of the <see cref="T:Ten53.Multimedia.Midi.MIDIStatus"/> values) from the first byte of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer.
            </summary>
            <remarks>The status type is kept in the first byte of the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer.
            <para>If no usefull status type could be evaluated <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.None"/> will be returned (this will also be the case, if no <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer is available).</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.Manufacturer">
            <summary>
            Gets the manufacturer ID from a system-exclusive message (or -32768 if not applicable or no <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer is present).
            </summary>
            <remarks>The first data byte (after the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.StatusType"/>), should be a Manufacturer's ID.
            <para>Since a midi data byte can't be greater than 0x7F, that means there would only be 127 IDs to dole out to manufacturers. Well, there are more than 127 manufacturers of MIDI products.</para>
            <para>MMA has assigned particular values of the ID byte to various manufacturers, so that a device can determine whether a SysEx message is intended for it. For example, a Roland device expects an ID byte of 0x41. If a Roland device receives a SysEx message whose ID byte isn't 0x41, then the device ignores all of the rest of the bytes up to and including the final 0xF7 which indicates that the SysEx message is finished.</para>
            <para>To accomodate a greater range of manufacturer IDs, the MMA decided to reserve a manufacturer ID of 0 for a special purpose. When you see a manufacturer ID of 0, then there will be two more data bytes after this. These two data bytes combine to make the real manufacturer ID. So, some manufacturers have IDs that are 3 bytes, where the first byte is always 0. Using this "trick", the range of unique manufacturer IDs is extended to accomodate over 16,000 MIDI manufacturers.</para>
            <para>For example, Microsoft's manufacturer ID consists of the 3 bytes 0x00 0x00 0x41. Note that the first byte is 0 to indicate that the real ID is 0x0041, but is still different than Roland's ID which is only the single byte of 0x41.</para>
            <para>To accomodate this and differentiate between single-digit manufacture IDs and three digit manufacture IDs, this member will return posivive values for single-digit manufacture IDs and negavive values for all three digit manufacture IDs.</para>
            <para>So in the above example Microsoft's ID would be returned as -65, wheres Roland's ID would be returned as 65.</para>
            <para>There are also three special manufacturer ID reserved: <see cref="F:Ten53.Multimedia.Midi.MIDIManufacturer.Educational"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIManufacturer.RealTime"/> and <see cref="F:Ten53.Multimedia.Midi.MIDIManufacturer.NonRealTime"/>. The later two relate to universal SysEx messages.</para>
            <para>Note: If no manufacturer ID is actually present in the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer, this member might anyhow return a value, since this property simply evaluates the first data bytes after the initial <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.StatusType"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsUniversalRealtime">
            <summary>
            TRUE, if the system-exclusive message contains a <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Manufacturer"/> ID of <see cref="F:Ten53.Multimedia.Midi.MIDIManufacturer.RealTime"/>.
            </summary>
            <remarks>
            <para>Universal SysEx messages are SysEx messages that are not for any one particular manufacturer, but rather, meant to be utilized by all manufacturer's products. For example, many manufacturers make digital samplers. It became desirable for manufacturers to allow exchange of waveform data between each others' products. So, a standard protocol was developed called MIDI Sample Dump Standard (SDS). Of course, since waveforms typically entail large amounts of data, SysEx messages (ie, containing over a hundred bytes each) were chosen as the most suitable vehicle to transmit the data over MIDI. But, it was decided not to use a particular manufacturer's ID for these SysEx messages. So, a universal ID was created. There are actually 2 IDs dedicated to Universal SysEx messages. There's a universal ID meant for realtime messages (ie, ones that need to be responded to immediately), and one for non-realtime (ie, ones which can be processed when the device gets around to it).</para>
            <para>No particular manufacturer is ever assigned an ID consisting of the single byte 0x7F or 0x7E. These are reserved for Universal SysEx messages adopted by the MMA.</para>
            <para>A general template for these two IDs was defined. After the ID byte is a SysEx Channel byte. This could be from 0 to 127 for a total of 128 SysEx channels. So, although "normal" SysEx messages have no MIDI channel like Voice Category messages do, a Universal SysEx message can be sent on one of 128 SysEx channels. This allows the musician to set various devices to ignore certain Universal SysEx messages (ie, if the device allows the musician to set its Base SysEx Channel. Most devices just set their Base Sysex channel to the same number as the Base Channel for Voice Category messages). On the other hand, a SysEx channel of 127 is actually meant to tell the device to "disregard the channel and pay attention to this message regardless".</para>
            <para>After the SysEx channel, the next two bytes are typically Sub IDs which tell what the SysEx is for. There are several Sub IDs defined for particular messages. There is a Sub ID for a Universal SysEx message to set a device's master volume. (This is different than Volume controller which sets the volume for only one particular MIDI channel). There is a Sub ID for a Universal SysEx message to set a device's Pitch Wheel bend range. There are a couple of Sub IDs for some Universal SysEx messages to implement a waveform (sample) dump over MIDI etc.</para>
            <para>Note: This member might anyhow return a valid value, since this property simply evaluates the second data byte after the initial <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.StatusType"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsUniversalNonRealtime">
            <summary>
            TRUE, if the system-exclusive message contains a <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Manufacturer"/> ID of <see cref="F:Ten53.Multimedia.Midi.MIDIManufacturer.NonRealTime"/>.
            </summary>
            <remarks>
            <para>Universal SysEx messages are SysEx messages that are not for any one particular manufacturer, but rather, meant to be utilized by all manufacturer's products. For example, many manufacturers make digital samplers. It became desirable for manufacturers to allow exchange of waveform data between each others' products. So, a standard protocol was developed called MIDI Sample Dump Standard (SDS). Of course, since waveforms typically entail large amounts of data, SysEx messages (ie, containing over a hundred bytes each) were chosen as the most suitable vehicle to transmit the data over MIDI. But, it was decided not to use a particular manufacturer's ID for these SysEx messages. So, a universal ID was created. There are actually 2 IDs dedicated to Universal SysEx messages. There's a universal ID meant for realtime messages (ie, ones that need to be responded to immediately), and one for non-realtime (ie, ones which can be processed when the device gets around to it).</para>
            <para>No particular manufacturer is ever assigned an ID consisting of the single byte 0x7F or 0x7E. These are reserved for Universal SysEx messages adopted by the MMA.</para>
            <para>A general template for these two IDs was defined. After the ID byte is a SysEx Channel byte. This could be from 0 to 127 for a total of 128 SysEx channels. So, although "normal" SysEx messages have no MIDI channel like Voice Category messages do, a Universal SysEx message can be sent on one of 128 SysEx channels. This allows the musician to set various devices to ignore certain Universal SysEx messages (ie, if the device allows the musician to set its Base SysEx Channel. Most devices just set their Base Sysex channel to the same number as the Base Channel for Voice Category messages). On the other hand, a SysEx channel of 127 is actually meant to tell the device to "disregard the channel and pay attention to this message regardless".</para>
            <para>After the SysEx channel, the next two bytes are Sub IDs which tell what the SysEx is for. There are several Sub IDs defined for particular messages. There is a Sub ID for a Universal SysEx message to set a device's master volume. (This is different than Volume controller which sets the volume for only one particular MIDI channel). There is a Sub ID for a Universal SysEx message to set a device's Pitch Wheel bend range. There are a couple of Sub IDs for some Universal SysEx messages to implement a waveform (sample) dump over MIDI etc.</para>
            <para>Note: This member might anyhow return a valid value, since this property simply evaluates the second data byte after the initial <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.StatusType"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.UniversalChannel">
            <summary>
            Gets the Universal SysEx Channel number (or 255 on error or not present).
            </summary>
            <remarks>If dealing with a Universal SysEx message the byte after the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Manufacturer"/> byte will typically contain a SysEx Channel number.
            <para>This could be from 0 to 127 for a total of 128 SysEx channels. So, although "normal" SysEx messages have no MIDI channel like Voice Category messages do, a Universal SysEx message can be sent on one of 128 SysEx channels. This allows the musician to set various devices to ignore certain Universal SysEx messages (ie, if the device allows the musician to set its Base SysEx Channel. Most devices just set their Base Sysex channel to the same number as the Base Channel for Voice Category messages). On the other hand, a SysEx channel of 127 is actually meant to tell the device to "disregard the channel and pay attention to this message regardless".</para>
            <para>Note: If not dealing with a universal SysEx 255 will be returned. This member might anyhow return a valid value, since this property simply evaluates the second data byte after the initial <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.StatusType"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.UniversalSubID">
            <summary>
            Gets the Universal SysEx Sub ID (or 255 on error or not present).
            </summary>
            <remarks>If dealing with a Universal SysEx message, the next two bytes are Sub IDs which tell what the SysEx is for. 
            There are several Sub IDs defined for particular messages. There is a Sub ID for a Universal SysEx message to set a device's master volume. (This is different than Volume controller which sets the volume for only one particular MIDI channel). 
            There is a Sub ID for a Universal SysEx message to set a device's Pitch Wheel bend range. There are a couple of Sub IDs for some Universal SysEx messages to implement a waveform (sample) dump over MIDI etc.
            <para>Note: If not dealing with a universal SysEx 255 will be returned. This member might anyhow return a valid value, since this property simply evaluates the third data byte after the initial <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.StatusType"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.UniversalSubID2">
            <summary>
            Gets the Universal SysEx Sub ID (or 255 on error or not present).
            </summary>
            <remarks>If dealing with a Universal SysEx message, the next two bytes are Sub IDs which tell what the SysEx is for. 
            There are several Sub IDs defined for particular messages. There is a Sub ID for a Universal SysEx message to set a device's master volume. (This is different than Volume controller which sets the volume for only one particular MIDI channel). 
            There is a Sub ID for a Universal SysEx message to set a device's Pitch Wheel bend range. There are a couple of Sub IDs for some Universal SysEx messages to implement a waveform (sample) dump over MIDI etc.
            <para>Note: If not dealing with a universal SysEx 255 will be returned. This member might anyhow return a valid value, since this property simply evaluates the forth data byte after the initial <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.StatusType"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.MMCDeviceID">
            <summary>
            Gets the MMC Device ID (or 255 on error or not present).
            </summary>
            <remarks>If dealing with a MIDI Machine Control (MMC) protocol the byte after the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsUniversalRealtime"/> byte will contain a device ID.
            <para>Every device which can respond to MIDI Machine Control messages should have a unique (ie, individual) ID number. For example, a hard disk recorder may have an ID of 1. A MIDI sequencer controlling the hard disk recorder's record and playback may have an ID of 2. Usually, a device will allow the user to set its individual ID, so that any conflicts between devices can be resolved. The range of allowable ID numbers is 0 to 127 inclusive. By having unique ID numbers, you can use one of these ID numbers in a System Exclusive message, and then the various devices that are all daisy-chained together via MIDI can determine which device a particular System Exclusive message is meant for. Of course, even the master controller which is being used to control the entire MIDI Machine Control network can have its own, unique ID, in case slaved controllers wish to create and send messages back to the master.</para>
            <para>NOTE: It is possible to have two (or more) devices set to the same ID number. What this means is that both devices always respond to the same MIDI Machine Control messages with that ID number, and you completely lose individual control over each. There is also no limit as to how many individual ID numbers a given device can respond to. If desired, a device can even respond to all 127 individual ID numbers, but this would be akin to a sound module that only operates in Omni mode (ie, not too useful if you have other units daisy-chained).</para>
            <para>A channel number of 127 (referred to as the "All-Call channel number") is reserved to mean "all devices respond". When a MIDI Machine Control message with a channel nummer of 127 is sent along the MIDI bus, all devices should respond to this message if appropriate (ie, if they support the particular command of that message), regardless of their individual ID numbers.</para>
            <para>Note: If not dealing with a universal real-time SysEx 255 will be returned. This member might anyhow return a valid value, since this property simply evaluates the second data byte after the initial <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.StatusType"/>.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiSysExMessage.MMCCommand">
            <summary>
            Gets the MMC Device ID (or 255 on error or not present).
            </summary>
            <remarks>If dealing with a MIDI Machine Control (MMC) protocol the third byte after the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.IsUniversalRealtime"/> byte will contain the MMC command byte.
            <para>It is typically one of the following values:
            <list type="table">
            <item><term>0x01</term><description>Stop</description></item>
            <item><term>0x02</term><description>Play</description></item>
            <item><term>0x03</term><description>Deferred Play</description></item>
            <item><term>0x04</term><description>Fast Forward</description></item>
            <item><term>0x05</term><description>Rewind</description></item>
            <item><term>0x06</term><description>Record Strobe (Punch In)</description></item>
            <item><term>0x07</term><description>Record Exit (Punch Out)</description></item>
            <item><term>0x09</term><description>Pause</description></item>
            </list>
            </para>
            <para>There are many other MMC commands existing...however you might use the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead8(System.Int32@)"/>, <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead16(System.Int32@)"/>, <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.MessageRead24(System.Int32@)"/> etc. methods to read any data from the <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Message"/> data buffer.</para>
            <para>Note: If not dealing with a universal real-time SysEx 255 will be returned. This member might anyhow return a valid value, since this property simply evaluates the forth data byte after the initial <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.StatusType"/>.</para>
            </remarks>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MidiInputDevice">
            <summary>
            This class handles all communication with a Midi input device.
            </summary>
            <remarks>Create an instance of this class and specify a <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.DeviceID"/> to be used. You might use the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.GetDeviceCount"/> and the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.GetDeviceDescriptions"/> to enumerate all available Midi input devices (use the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.GetInfo(System.Int32)"/> method to retrieve the device capabilities).
            <para>After you have called the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Open"/> method the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/> is being used. However, Midi messages are not yet recorded and received. 
            To start recording Midi messages call the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Start"/> method.</para>
            <para>It is a good idea to subscribe to the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event handler before calling <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Open"/> and <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Start"/>.
            The property <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.MessageFilter"/> might be used to supress sending certain events.
            The <see cref="T:Ten53.Multimedia.Midi.MidiMessageEventArgs"/> contains a <see cref="T:Ten53.Multimedia.Midi.MidiMessageEventType"/> which allows you to react to all possible scenarios and to process all Midi messages and events.</para>
            <para>Call the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Stop"/> method to stop recording and receiving Midi message. 
            Once you're done with the device call <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Close"/> to close the device and release it.</para>
            </remarks>
            <example>
            <code>
            using Ten53.Multimedia.Midi;
            ...
            private MidiInputDevice _inDevice;
            ...
            // open and start a certain Midi input device
            private void OpenAndStartDevice(int device)
            {
              _inDevice = new MidiInputDevice(device);
              _inDevice.AutoPairController = true;
              _inDevice.MessageFilter = MIDIMessageType.SystemRealtime | MIDIMessageType.SystemExclusive;
              _inDevice.MessageReceived += new MidiMessageEventHandler(InDevice_MessageReceived);
              if (_inDevice.Open())
              {
                if (!_inDevice.Start())
                  MessageBox.Show(this, "Midi device could not be started! Error: " + _inDevice.LastErrorCode.ToString(), "Midi Error");
              }
              else
                MessageBox.Show(this, "Midi device could not be opened! Error: " + _inDevice.LastErrorCode.ToString(), "Midi Error");
            }
            
            // stop and close the Midi input device
            private void StopAndCloseDevice()
            {
              if (_inDevice != null &amp;&amp; _inDevice.IsStarted)
              {
                _inDevice.Stop();
                _inDevice.Close();
                _inDevice.MessageReceived -= new MidiMessageEventHandler(InDevice_MessageReceived);
              }
            }
            
            private void InDevice_MessageReceived(object sender, MidiMessageEventArgs e)
            {
              if (e.IsShortMessage)
              {
                Console.WriteLine("{0} : {1}", e.ShortMessage.ID, e.ShortMessage.ToString());
              }
              else if (e.IsSysExMessage)
              {
                Console.WriteLine("{0} : {1}", e.SysExMessage.ID, e.SysExMessage.ToString());
              }
              else if (e.EventType == MidiMessageEventType.Opened)
              {
                Console.WriteLine("Midi device {0} opened.", e.DeviceID);
              }
              else if (e.EventType == MidiMessageEventType.Closed)
              {
                Console.WriteLine("Midi device {0} closed.", e.DeviceID);
              }
              else if (e.EventType == MidiMessageEventType.Started)
              {
                Console.WriteLine("Midi device {0} started.", e.DeviceID);
              }
              else if (e.EventType == MidiMessageEventType.Stopped)
              {
                Console.WriteLine("Midi device {0} stopped.", e.DeviceID);
              }
            }
            </code>
            <code lang="vbnet">
            Imports Ten53.Multimedia.Midi
            ...
            Private _inDevice As MidiInputDevice
            ...
            ' open and start a certain Midi input device
            Private Sub OpenAndStartDevice(device As Integer)
              _inDevice = New MidiInputDevice(device)
              _inDevice.AutoPairController = True
              _inDevice.MessageFilter = MIDIMessageType.SystemRealtime Or MIDIMessageType.SystemExclusive
              AddHandler _inDevice.MessageReceived, AddressOf InDevice_MessageReceived
              If _inDevice.Open() Then
                If Not _inDevice.Start() Then
                  MessageBox.Show(Me, "Midi device could not be started! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error")
                End If
              Else
                MessageBox.Show(Me, "Midi device could not be opened! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error")
              End If
            End Sub
            
            ' stop and close the Midi input device
            Private Sub StopAndCloseDevice()
              If Not (_inDevice Is Nothing) AndAlso _inDevice.IsStarted Then
                _inDevice.Stop()
                _inDevice.Close()
                _inDevice.MessageReceived -= New MidiMessageEventHandler(InDevice_MessageReceived)
              End If
            End Sub
            
            Private Sub InDevice_MessageReceived(sender As Object, e As MidiMessageEventArgs)
              If e.IsShortMessage Then
                Console.WriteLine("{0} : {1}", e.ShortMessage.ID, e.ShortMessage.ToString())
              Else
                If e.IsSysExMessage Then
                  Console.WriteLine("{0} : {1}", e.SysExMessage.ID, e.SysExMessage.ToString())
                Else
                  If e.EventType = MidiMessageEventType.Opened Then
                    Console.WriteLine("Midi device {0} opened.", e.DeviceID)
                  Else
                    If e.EventType = MidiMessageEventType.Closed Then
                      Console.WriteLine("Midi device {0} closed.", e.DeviceID)
                    Else
                      If e.EventType = MidiMessageEventType.Started Then
                        Console.WriteLine("Midi device {0} started.", e.DeviceID)
                      Else
                        If e.EventType = MidiMessageEventType.Stopped Then
                          Console.WriteLine("Midi device {0} stopped.", e.DeviceID)
                        End If
                      End If
                    End If
                  End If
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.#ctor(System.Int32)">
            <summary>
            Creates a new instance of a MidiInputDevice.
            </summary>
            <param name="deviceID">The input device number to use.</param>
            <remarks>Use the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Open"/> method to open the Midi device and call <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Start"/> to start recording messages.
            <para>To stop recording call the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Stop"/> method. When you are done with the device you might call the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Close"/> method to actually close the Midi input device.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.Dispose">
            <summary>
            Releases all managed and unmanaged resources used by this class.
            </summary>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.Finalize">
            <summary>
            Destructor of the MidiInputDevice for finalization code.
            </summary>
            <remarks>This destructor will run only if the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Dispose"/> method does not get called.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.GetDeviceCount">
            <summary>
            Returns the total number of available Midi input devices.
            </summary>
            <returns>The number of Midi input devices present in your system.</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.GetDeviceDescriptions">
            <summary>
            Returns all available Midi input device names.
            </summary>
            <returns>An array of strings representing the available devices.</returns>
            <remarks>
            <para>The index of the returned descriptions equals the deviceID, which might be used with the constructor of this class.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.GetMidiPorts">
            <summary>
            Returns all available Midi input port IDs.
            </summary>
            <returns>An array of int representing the available Midi port IDs.</returns>
            <remarks>
            <para>The values returned equals the deviceID, which might be used with the constructor of this class.</para>
            <para>This method returns all available deviceIDs representing a Midi input port. You might use each ID with the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.GetDeviceDescription(System.Int32)"/> method to retrieve the name of the respective Midi input device.</para>
            </remarks>
            <example>
            List all Midi input ports (devices which might be used with this class):
            <code>
            int[] inPorts = MidiInputDevice.GetMidiPorts();
            foreach (int port in inPorts)
            {
              string name = MidiInputDevice.GetDeviceDescription(port);
              Console.WriteLine("{0}={1}", port, name);
            }
            </code>
            <code lang="vbnet">
            Dim inPorts As Integer() = MidiInputDevice.GetMidiPorts()
            Dim port As Integer
            For Each port In  inPorts
              Dim name As String = MidiInputDevice.GetDeviceDescription(port)
              Console.WriteLine("{0}={1}", port, name)
            Next port
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.GetDeviceDescription(System.Int32)">
            <summary>
            Returns the name of the given input device ID.
            </summary>
            <param name="deviceID">Identifier of the MIDI input device. The device identifier varies from zero to one less than the number of devices present (see <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.GetDeviceCount"/>).</param>
            <returns>The name of the Midi input device.</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.GetInfo(System.Int32)">
            <summary>
            Determines the capabilities of a specified MIDI input device.
            </summary>
            <param name="deviceID">Identifier of the MIDI input device. The device identifier varies from zero to one less than the number of devices present.</param>
            <returns>An instance of the <see cref="T:Ten53.Multimedia.Midi.MIDI_INCAPS"/> structure representing the device capabilities - or NULL on error.</returns>
            <remarks>To determine the number of MIDI input devices present on the system, use the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.GetDeviceCount"/> method.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.Connect(System.IntPtr)">
            <summary>
            Connects this input device to a MIDI thru or output device. 
            </summary>
            <param name="handleTo">Handle to the MIDI output device or thru device.</param>
            <returns>TRUE on success, else FALSE will be returned.</returns>
            <remarks>After calling this function, this <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/> receives event data messages whenever a message with the same event data is sent to the output device driver.
            <para>A thru driver is a special form of MIDI output driver. The system will allow only one MIDI output device to be connected to a MIDI input device, but multiple MIDI output devices can be connected to a MIDI thru device. 
            Whenever this <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/> receives event data messages, a message with the same event data is sent to the given output device driver (or through the thru driver to the output drivers).</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.Disconnect(System.IntPtr)">
            <summary>
            Disconnects this input device from a MIDI thru or output device.
            </summary>
            <param name="handleFrom">Handle to the MIDI output device to be disconnected.</param>
            <returns>TRUE on success, else FALSE will be returned.</returns>
            <remarks>Use this method to disconnect the device you connected with the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Connect(System.IntPtr)"/> method beforehand.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.Open">
            <summary>
            Opens the Midi input device using the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.DeviceID"/>.
            </summary>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>After you have called this method the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/> is being used. However, Midi messages are not yet recorded and received. To start recording call the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Start"/> method.
            <para>When you have subscribed to the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event you'll get notified when the device is opened (<see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.Opened"/>) and closed (<see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.Closed"/>).</para>
            <para>Once you're done with the device call <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Close"/> to close the device and release it.</para>
            </remarks>
            <example>
            Opens the Midi input device #0:
            <code>
            private MidiInputDevice _inDevice;
            ...
            _inDevice = new MidiInputDevice(0);
            _inDevice.MessageReceived += new MidiMessageEventHandler(InDevice_MessageReceived);
            if (_inDevice.Open())
            {
              if (!_inDevice.Start())
                MessageBox.Show(this, "Midi device could not be started! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error");
            }
            else
              MessageBox.Show(this, "Midi device could not be opened! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error");
            ...
            // when done
            if (_inDevice.IsStarted)
              _inDevice.Stop();
            if (_inDevice.IsOpened)
              _inDevice.Close();
            ...
            private void InDevice_MessageReceived(object sender, MidiMessageEventArgs e)
            {
              if (e.IsShortMessage)
              {
                Console.WriteLine("{0} : {1}", e.ShortMessage.ID, e.ShortMessage.ToString());
              }
              else if (e.IsSysExMessage)
              {
                Console.WriteLine("{0} : {1}", e.SysExMessage.ID, e.SysExMessage.ToString());
              }
            }
            </code>
            <code lang="vbnet">
            Private _inDevice As MidiInputDevice
            ...
            _inDevice = New MidiInputDevice(0)
            AddHandler _inDevice.MessageReceived, AddressOf InDevice_MessageReceived
            If _inDevice.Open() Then
              If Not _inDevice.Start() Then
                MessageBox.Show(Me, "Midi device could not be started! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error")
              End If
            Else
              MessageBox.Show(Me, "Midi device could not be opened! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error")
            End If 
            ...
            ' when done
            If _inDevice.IsStarted Then
              _inDevice.Stop()
            End If
            If _inDevice.IsOpened Then
              _inDevice.Close()
            End If
            ...
            Private Sub InDevice_MessageReceived(sender As Object, e As MidiMessageEventArgs)
              If e.IsShortMessage Then
                Console.WriteLine("{0} : {1}", e.ShortMessage.ID, e.ShortMessage.ToString())
              Else
                If e.IsSysExMessage Then
                  Console.WriteLine("{0} : {1}", e.SysExMessage.ID, e.SysExMessage.ToString())
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.Close">
            <summary>
            Closes the Midi input device using the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.DeviceID"/>.
            </summary>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>After you have called this method the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/> is no longer valid and released.
            If the Midi Device <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.IsStarted"/> and currently recording messages this method will also <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Stop"/> recording messages.
            <para>When you have subscribed to the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event you'll get notified when the device is opened (<see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.Opened"/>) and closed (<see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.Closed"/>).</para>
            <para>After you have closed the Midi input device you might open it again using the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Open"/> method.</para>
            </remarks>
            <example>
            Opens the Midi input device #0:
            <code>
            private MidiInputDevice _inDevice;
            ...
            _inDevice = new MidiInputDevice(0);
            _inDevice.MessageReceived += new MidiMessageEventHandler(InDevice_MessageReceived);
            if (_inDevice.Open())
            {
              if (!_inDevice.Start())
                MessageBox.Show(this, "Midi device could not be started! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error");
            }
            else
              MessageBox.Show(this, "Midi device could not be opened! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error");
            ...
            // when done
            if (_inDevice.IsStarted)
              _inDevice.Stop();
            if (_inDevice.IsOpened)
              _inDevice.Close();
            ...
            private void InDevice_MessageReceived(object sender, MidiMessageEventArgs e)
            {
              if (e.IsShortMessage)
              {
                Console.WriteLine("{0} : {1}", e.ShortMessage.ID, e.ShortMessage.ToString());
              }
              else if (e.IsSysExMessage)
              {
                Console.WriteLine("{0} : {1}", e.SysExMessage.ID, e.SysExMessage.ToString());
              }
            }
            </code>
            <code lang="vbnet">
            Private _inDevice As MidiInputDevice
            ...
            _inDevice = New MidiInputDevice(0)
            AddHandler _inDevice.MessageReceived, AddressOf InDevice_MessageReceived
            If _inDevice.Open() Then
              If Not _inDevice.Start() Then
                MessageBox.Show(Me, "Midi device could not be started! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error")
              End If
            Else
              MessageBox.Show(Me, "Midi device could not be opened! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error")
            End If 
            ...
            ' when done
            If _inDevice.IsStarted Then
              _inDevice.Stop()
            End If
            If _inDevice.IsOpened Then
              _inDevice.Close()
            End If
            ...
            Private Sub InDevice_MessageReceived(sender As Object, e As MidiMessageEventArgs)
              If e.IsShortMessage Then
                Console.WriteLine("{0} : {1}", e.ShortMessage.ID, e.ShortMessage.ToString())
              Else
                If e.IsSysExMessage Then
                  Console.WriteLine("{0} : {1}", e.SysExMessage.ID, e.SysExMessage.ToString())
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.Start">
            <summary>
            Starts recording messages from the Midi input device using the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.DeviceID"/>.
            </summary>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>The <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/> must have been opened to record messages. You might use the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.IsOpened"/> property to check this. Call <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Open"/> to open the Midi input device.
            After you have called this method the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/> is being used, meaning it will receive any <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.ShortMessage"/> and <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.SysExMessage"/>.
            <para>When you have subscribed to the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event you'll get notified when a new message was received from the Midi input device.
            To stop recording messages call the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Stop"/> method.</para>
            <para>Once you're done with the device call <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Close"/> to close the device and release it.</para>
            </remarks>
            <example>
            Opens the Midi input device #0:
            <code>
            private MidiInputDevice _inDevice;
            ...
            _inDevice = new MidiInputDevice(0);
            _inDevice.MessageReceived += new MidiMessageEventHandler(InDevice_MessageReceived);
            if (_inDevice.Open())
            {
              if (!_inDevice.Start())
                MessageBox.Show(this, "Midi device could not be started! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error");
            }
            else
              MessageBox.Show(this, "Midi device could not be opened! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error");
            ...
            // when done
            if (_inDevice.IsStarted)
              _inDevice.Stop();
            if (_inDevice.IsOpened)
              _inDevice.Close();
            ...
            private void InDevice_MessageReceived(object sender, MidiMessageEventArgs e)
            {
              if (e.IsShortMessage)
              {
                Console.WriteLine("{0} : {1}", e.ShortMessage.ID, e.ShortMessage.ToString());
              }
              else if (e.IsSysExMessage)
              {
                Console.WriteLine("{0} : {1}", e.SysExMessage.ID, e.SysExMessage.ToString());
              }
            }
            </code>
            <code lang="vbnet">
            Private _inDevice As MidiInputDevice
            ...
            _inDevice = New MidiInputDevice(0)
            AddHandler _inDevice.MessageReceived, AddressOf InDevice_MessageReceived
            If _inDevice.Open() Then
              If Not _inDevice.Start() Then
                MessageBox.Show(Me, "Midi device could not be started! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error")
              End If
            Else
              MessageBox.Show(Me, "Midi device could not be opened! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error")
            End If 
            ...
            ' when done
            If _inDevice.IsStarted Then
              _inDevice.Stop()
            End If
            If _inDevice.IsOpened Then
              _inDevice.Close()
            End If
            ...
            Private Sub InDevice_MessageReceived(sender As Object, e As MidiMessageEventArgs)
              If e.IsShortMessage Then
                Console.WriteLine("{0} : {1}", e.ShortMessage.ID, e.ShortMessage.ToString())
              Else
                If e.IsSysExMessage Then
                  Console.WriteLine("{0} : {1}", e.SysExMessage.ID, e.SysExMessage.ToString())
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiInputDevice.Stop">
            <summary>
            Stops recording messages from the Midi input device using the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.DeviceID"/>.
            </summary>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>The <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/> must have been opened and started to record messages. You might use the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.IsOpened"/> and <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.IsStarted"/> properties to check this. Call <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Open"/> to open the Midi input device and <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Start"/> to start recording messages.
            After you have called this method the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/> is no longer recording and receiving any <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.ShortMessage"/> or <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.SysExMessage"/>.
            <para>When you have subscribed to the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event you'll get notified when a new message was received from the Midi input device.
            To start recording messages again call the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Start"/> method.</para>
            <para>Once you're done with the device call <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Close"/> to close the device and release it.</para>
            </remarks>
            <example>
            Opens the Midi input device #0:
            <code>
            private MidiInputDevice _inDevice;
            ...
            _inDevice = new MidiInputDevice(0);
            _inDevice.MessageReceived += new MidiMessageEventHandler(InDevice_MessageReceived);
            if (_inDevice.Open())
            {
              if (!_inDevice.Start())
                MessageBox.Show(this, "Midi device could not be started! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error");
            }
            else
              MessageBox.Show(this, "Midi device could not be opened! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error");
            ...
            // when done
            if (_inDevice.IsStarted)
              _inDevice.Stop();
            if (_inDevice.IsOpened)
              _inDevice.Close();
            ...
            private void InDevice_MessageReceived(object sender, MidiMessageEventArgs e)
            {
              if (e.IsShortMessage)
              {
                Console.WriteLine("{0} : {1}", e.ShortMessage.ID, e.ShortMessage.ToString());
              }
              else if (e.IsSysExMessage)
              {
                Console.WriteLine("{0} : {1}", e.SysExMessage.ID, e.SysExMessage.ToString());
              }
            }
            </code>
            <code lang="vbnet">
            Private _inDevice As MidiInputDevice
            ...
            _inDevice = New MidiInputDevice(0)
            AddHandler _inDevice.MessageReceived, AddressOf InDevice_MessageReceived
            If _inDevice.Open() Then
              If Not _inDevice.Start() Then
                MessageBox.Show(Me, "Midi device could not be started! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error")
              End If
            Else
              MessageBox.Show(Me, "Midi device could not be opened! Error " + _inDevice.LastErrorCode.ToString(), "Midi Error")
            End If 
            ...
            ' when done
            If _inDevice.IsStarted Then
              _inDevice.Stop()
            End If
            If _inDevice.IsOpened Then
              _inDevice.Close()
            End If
            ...
            Private Sub InDevice_MessageReceived(sender As Object, e As MidiMessageEventArgs)
              If e.IsShortMessage Then
                Console.WriteLine("{0} : {1}", e.ShortMessage.ID, e.ShortMessage.ToString())
              Else
                If e.IsSysExMessage Then
                  Console.WriteLine("{0} : {1}", e.SysExMessage.ID, e.SysExMessage.ToString())
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived">
            <summary>
            Event handler used to notify that the input device has received a message or the status has changed.
            </summary>
            <remarks>It is a good idea to subscribe to this event handler before calling <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Open"/> and <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Start"/>.
            <para>The property <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.MessageFilter"/> might be used to supress sending certain events.</para>
            <para>The <see cref="T:Ten53.Multimedia.Midi.MidiMessageEventArgs"/> contains a <see cref="T:Ten53.Multimedia.Midi.MidiMessageEventType"/> which allows you to react to all possible scenarios and to process all these events.</para>
            <para>Note: This implementation ensures, that the event will be executed in the main thread the subscriber executes in!
            So when subscribing to this event from UI thread, the specified event delegate will also be called in that UI thread.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.IsDisposed">
            <summary>
            Returns TRUE, if this class is being disposed.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.Device">
            <summary>
            Returns the device handle for this input device.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.DeviceID">
            <summary>
            Returns the device id (number) which was used to create this instance.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.SysExBufferSize">
            <summary>
            Gets or Sets the maximum buffer size for system-exclusive messages (between 2 and 65536, default is 1024).
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.User">
            <summary>
            User instance data to be used when providing system-exclusive messages.
            </summary>
            <remarks>This member will be provided back in the received <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.SysExMessage"/>.</remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.ShortMessage">
            <summary>
            Gets the current (last) <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> which was received from the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/>.
            </summary>
            <remarks>
            <pata>Might return NULL, if no message was received so far (this class must at least have received one Midi short messages before this member returns a valid message).</pata>
            <para>You might use the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/> member of this property to access the previous short message received etc.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.SysExMessage">
            <summary>
            Gets the current (last) <see cref="T:Ten53.Multimedia.Midi.MidiSysExMessage"/> which was received from the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/>.
            </summary>
            <remarks>
            <pata>Might return NULL, if no system-exclusive message was received so far (this class must at least have received one Midi system-exclusive messages before this member returns a valid message).</pata>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.IsOpened">
            <summary>
            Returns TRUE if the Midi input device is opened - else FALSE.
            </summary>
            <remarks>To open the Midi input device call the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Open"/> method. Use the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Start"/> method to start recording messages from the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/> if it is opened and use <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Stop"/> to stop recording from the device.
            When you are done with the Midi input device you might call <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Close"/> to actually close the device.
            Any <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.ShortMessage"/> as well as any <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.SysExMessage"/> event will only be received between start and stop.
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.IsStarted">
            <summary>
            Returns TRUE if the Midi input device is started and recording messages - else FALSE.
            </summary>
            <remarks>To open the Midi input device call the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Open"/> method. Use the <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Start"/> method to start recording messages from the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.Device"/> and use <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Stop"/> to stop recording from the device.
            When you are done with the Midi input device you might call <see cref="M:Ten53.Multimedia.Midi.MidiInputDevice.Close"/> to actually close the device.
            Any <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.ShortMessage"/> as well as any <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.SysExMessage"/> event will only be received between start and stop.
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.LastErrorCode">
            <summary>
            Returns the last Midi error code (see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/> for possible values).
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.AutoPairController">
            <summary>
            Gets or Sets if Channel Messages (a <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/>) with a <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> should automatically be paired (default is None).
            </summary>
            <remarks>
            <para>Some controllers are continuous controllers, which simply means that their value can be set to any value within the range from 0 to 16384 (for 14-bit coarse/fine resolution) or 0 to 127 (for 7-bit, coarse resolution).
            Setting this property to TRUE will automatically pair short-message values defined in the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.ColtrollerPairMatrix"/>.
            In such case only one <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event will be fired, containing the combined (paired, 14-bit) <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerValue"/>.</para>
            <para>In detail: Some Midi data messages might actually use two sub-sequent short messages to construct a paired message representing a single value range (e.g. the <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> with a <see cref="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelect"/>).
            This to support paired values with a higher resolution (16384 instead of 128 values).
            In such case normally two short messages will be send, where one contains the LSB value (single steps, fine) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte and the other message contains the MSB value (128th steps, coarse) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> byte.
            Typically the messages with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> of <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> and with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value between 0 and 31 (MSB, coarse) are paired with a message of a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value between 32 and 63 (LSB, fine).
            But also a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 98 (LSB, fine) will be paired with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 99 (MSB, coarse) as well as a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 100 (LSB, fine) will be paired with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 101 (MSB, coarse).
            Other pairs might be hardware specific and might be specified by using the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.ColtrollerPairMatrix"/>.</para>
            <para>The resulting combined data value will be constructed like this: dataMSB=0xxxxxxx, dataLSB=0yyyyyyy = paired=00xxxxxxxyyyyyyy.</para>
            <para>By default this property is set to FALSE meaning each individual short message will be handled and independently as a single message.
            If this member is set to TRUE and the message is a ControlChange message and is defined in the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.ColtrollerPairMatrix"/>, then only the second message will fire the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event.</para>
            <para>In case the Midi device will under certain cases not send paired messages together the non-paired message will be handled as a single message again.
            For example: It's only desirable to make fine adjustments to the Mod Wheel without changing its current coarse setting (or vice versa), a device can be sent only a controller #33 message without a preceding controller #1 message (or vice versa). 
            Thus, if a device can respond to both coarse and fine adjustments for a particular controller (ie, implements the full 14-bit resolution), it should be able to deal with either the coarse or fine controller message being sent without its counterpart following. 
            The same holds true for other continuous (ie, coarse/fine pairs of) controllers.</para>
            <para>In any case you can simply access the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerValue"/> property and you'll get in return the combined and paired 14-bit controller value or the single uncombined value without further taking care.</para>
            <para>Use the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.ColtrollerPairMatrix"/> to define the controller pairs belonging together and for more details.</para>
            <para>NOTE: ControlChannel messages are ONLY combined and paired if the messages as defined in the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.ColtrollerPairMatrix"/> are send exactly subsequently (with no other short-message in between)!</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.ColtrollerPairMatrix">
            <summary>
            Sets the controller pair matrix to automatic combine any <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.ShortMessage"/> with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> of <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/>.
            </summary>
            <remarks>
            <para>Some controllers are continuous controllers, which simply means that their value can be set to any value within the range from 0 to 16384 (for 14-bit coarse/fine resolution) or 0 to 127 (for 7-bit, coarse resolution).
            Some Midi data messages might actually use two sub-sequent short messages to construct a paired message representing a single value range (e.g. the <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> with a <see cref="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelect"/>).
            This to support paired values with a higher resolution (16384 instead of 128 values).</para>
            <para>This matrix defines how sub-sequent short-messages with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> of <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> are detected and which controller number defines the MSB (coarse) value and which defines the LSB (fine) value.
            Furthermore the matrix defines which controller number is used in the single combined and paired short-message used in the resulting <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event.</para>
            <para>When a continuous controller pair is detected (see <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.IsSetAsContinuousController"/>) by default only the last received short-message of the pair will be used when raising the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event.
            If the Midi input device follows the general rule and first sends the MSB (coarse) controller message and right after the LSB (fine) controller message this would mean, that in the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event handle you would only see the last LSB (fine) message (the previous message with the MSB, coarse value will always be suppressed).
            However, when accessing the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerValue"/> of the fired message you will receive the combined and paired 14-bit conroller value between 0 and 16384.</para>
            <para>Sometimes Midi devices do not send the paired messages in a particular order. This would mean that controller pairs can still be detected and combined, but that in such case still the last received short-message of the pair will be used when the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event is raised.
            This would result in the fact, that your application would sometimes receive the LSB short-message and sometimes the MSB short-message (see <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerType"/>).
            To handle this circumstance the ColtrollerPairMatrix keeps a value allowing you to swap or redefine the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerType"/> value being used with the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.ShortMessage"/> fired with the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event.</para>
            <para>NOTE: This property is only evaluated, if the <see cref="P:Ten53.Multimedia.Midi.MidiInputDevice.AutoPairController"/> property is set to TRUE and the ControlChannel messages are send exactly subsequently (with no other short-message in between)!</para>
            <para>So how is the ColtrollerPairMatrix defined:</para>
            <para>The matrix is defined as a two dimentional byte array meaning each element of the first dimention consists of 3 elements. Whereas the first dimention is simply the list of all defined controller pairs.</para>
            <para>The matrix layout:
            <list type="table">
            <item><term>Vertical</term><description>The list of defined controller pairs (each entry represents a controller pair to be combined).</description></item>
            <item><term>Horizontal</term><description>The definition of each controller pair:
            <para>First value : the MSB (coarse) controller number (see <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/>).</para>
            <para>Second value: the LSB (fine) controller number (see <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/>).</para>
            <para>Third value : the swap flag for the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ControllerType"/> of the forwarded message:
            	<list type="bullet">
            	<item><term>255</term><description>Leave current and previous message as is.</description></item>
            	<item><term>254</term><description>Use the LSB message value, swap previous message if needed.</description></item>
            	<item><term>253</term><description>Use the MSB message value, swap previous message if needed.</description></item>
            	<item><term>252</term><description>Use the LSB message value, leave previous message as is.</description></item>
            	<item><term>251</term><description>Use the MSB message value, leave previous message as is.</description></item>
            	<item><term>&lt;128</term><description>Overwrite and use this value, leave previous message as is.</description></item>
            	</list>
            </para>
            </description></item>
            </list>
            <code lang="none">
                  --MSB-LSB--SWAP-&gt; (definition)
                 |   0,  32, 255
                 |   1,  33, 255
                 |   2,  34, 255
                 | ...  ...  ...
                 |  99,  98, 254
                 | 101, 100, 254
                 v                  
            (Pairs)                 
                                     
            </code>
            </para>
            <para>Here is the default definition of this property:
            <code lang="null">
            byte[,] ColtrollerPairMatrix = new byte[34,3] 
            { 
            	{  0,  32, 255},
            	{  1,  33, 255},
            	{  2,  34, 255},
            	{  3,  35, 255},
            	{  4,  36, 255},
            	{  5,  37, 255},
            	{  6,  38, 255},
            	{  7,  39, 255},
            	{  8,  40, 255},
            	{  9,  41, 255},
            	{ 10,  42, 255},
            	{ 11,  43, 255},
            	{ 12,  44, 255},
            	{ 13,  45, 255},
            	{ 14,  46, 255},
            	{ 15,  47, 255},
            	{ 16,  48, 255},
            	{ 17,  49, 255},
            	{ 18,  50, 255},
            	{ 19,  51, 255},
            	{ 20,  52, 255},
            	{ 21,  53, 255},
            	{ 22,  54, 255},
            	{ 23,  55, 255},
            	{ 24,  56, 255},
            	{ 25,  57, 255},
            	{ 26,  58, 255},
            	{ 27,  59, 255},
            	{ 28,  60, 255},
            	{ 29,  61, 255},
            	{ 30,  62, 255},
            	{ 31,  63, 255},
            	{ 99,  98, 255},
            	{101, 100, 255}
            };
            </code>
            </para>
            <para>You might use the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.ThisIsMSB"/> and <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousIsMSB"/> properties to identify which message contains the coarse (MSB) or fine (LSB) controller value.
            A access the paired short-message use the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.PreviousShortMessage"/> member.</para>
            </remarks>
            <example>
            <code>
            private MidiInputDevice _inDevice = null;
            ...
            _inDevice = new MidiInputDevice(0);
            _inDevice.AutoPairController = true;
            _inDevice.MessageReceived += new MidiMessageEventHandler(InDevice_MessageReceived);
            if ( _inDevice.Open() )
              _inDevice.Start();
            ...
            private void InDevice_MessageReceived(object sender, MidiMessageEventArgs e)
            {
              if (e.IsShortMessage)
              {
                if (e.ShortMessage.IsSetAsContinuousController)
                {
                  Console.WriteLine("Continuous Controller {0}: Value={1}", 
                                    e.ShortMessage.Controller, 
                                    e.ShortMessage.ControllerValue);
                  Console.WriteLine("MSB ControllerType={0}, LSB ControllerType={1}", 
                                    e.ShortMessage.ThisIsMSB ? e.ShortMessage.ControllerType : 
                                                               e.ShortMessage.PreviousShortMessage.ControllerType,
                                    e.ShortMessage.PreviousIsMSB ? e.ShortMessage.ControllerType : 
                                                                   e.ShortMessage.PreviousShortMessage.ControllerType);
                }
                else
                  Console.WriteLine(e.ShortMessage.ToString());
              }
              ...
            }
            </code>
            <code lang="vbnet">
            Private _inDevice As MidiInputDevice = Nothing
            ...
            _inDevice = New MidiInputDevice(0)
            _inDevice.AutoPairController = True
            AddHandler _inDevice.MessageReceived, AddressOf InDevice_MessageReceived
            If _inDevice.Open() Then
              _inDevice.Start()
            End If
            ...
            Private Sub InDevice_MessageReceived(sender As Object, e As MidiMessageEventArgs)
              If e.IsShortMessage Then
                If e.ShortMessage.IsSetAsContinuousController Then
                  Console.WriteLine("Continuous Controller {0}: Value={1}", 
                                    e.ShortMessage.Controller, 
                                    e.ShortMessage.ControllerValue)
                  If e.ShortMessage.ThisIsMSB Then
                    Console.WriteLine("MSB ControllerType={0}", e.ShortMessage.ControllerType)
                  Else
                    Console.WriteLine("MSB ControllerType={0}", e.ShortMessage.PreviousShortMessage.ControllerType)
                  End If
                  If e.ShortMessage.PreviousIsMSB Then
                    Console.WriteLine("LSB ControllerType={0}", e.ShortMessage.ControllerType)
                  Else
                    Console.WriteLine("LSB ControllerType={0}", e.ShortMessage.PreviousShortMessage.ControllerType)
                  End If
                Else
                  Console.WriteLine(e.ShortMessage.ToString())
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.MessageFilter">
            <summary>
            Gets or Sets the filter to be applied (messages types which should be suppressed).
            </summary>
            <remarks>By default all <see cref="T:Ten53.Multimedia.Midi.MIDIMessageType"/> messages will raise the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event.
            <para>You might combine any value of the <see cref="T:Ten53.Multimedia.Midi.MIDIMessageType"/> enumeration in order to supresses certain messages (e.g. to not process real-time messages).</para>
            </remarks>
            <example>
            Supress all real-time and system-exclusive messages:
            <code>
            private MidiInputDevice _inDevice = null;
            ...
            _inDevice = new MidiInputDevice(0);
            _inDevice.AutoPairController = true;
            _inDevice.MessageFilter = MIDIMessageType.SystemRealtime | MIDIMessageType.SystemExclusive;
            _inDevice.MessageReceived += new MidiMessageEventHandler(InDevice_MessageReceived);
            if ( _inDevice.Open() )
            	_inDevice.Start();
            ...
            </code>
            <code lang="vbnet">
            Private _inDevice As MidiInputDevice = Nothing
            ...
            _inDevice = New MidiInputDevice(0)
            _inDevice.AutoPairController = True
            _inDevice.MessageFilter = MIDIMessageType.SystemRealtime Or MIDIMessageType.SystemExclusive
            AddHandler _inDevice.MessageReceived, AddressOf InDevice_MessageReceived
            If _inDevice.Open() Then
              _inDevice.Start()
            End If
            </code>
            </example>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiInputDevice.ProcessErrorMessages">
            <summary>
            Gets or Sets if erroneous Midi messages should also be processed.
            </summary>
            <remarks>
            Sometimes a Midi device might send invalid or erroneous Midi messages.
            This property defines, if erroneous Midi messages (see <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGERROR"/> and <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_ERROR"/>)
            should anyhow be used and raise the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> event.
            <para>If set to FALSE (default) only valid messages will be processed.</para>
            </remarks>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MidiOutputDevice">
            <summary>
            This class handles all communication with a Midi output device.
            </summary>
            <remarks>Create an instance of this class and specify a <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.DeviceID"/> to be used. You might use the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.GetDeviceCount"/> and the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.GetDeviceDescriptions"/> to enumerate all available Midi output devices (use the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.GetInfo(System.Int32)"/> method to retrieve the device capabilities).
            <para>After you have called the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open"/> method the <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> is being used.</para>
            <para>It is a good idea to subscribe to the <see cref="E:Ten53.Multimedia.Midi.MidiOutputDevice.MessageReceived"/> event handler before calling <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open"/>. However, this is generally not needed, since a for an output device there not many events being received (beside that the device is opened and closed and that the Midi output device has finished with a system-exclusive message).
            The <see cref="T:Ten53.Multimedia.Midi.MidiMessageEventArgs"/> contains a <see cref="T:Ten53.Multimedia.Midi.MidiMessageEventType"/> which allows you to react to all possible scenarios and to process all Midi messages and events.</para>
            <para>To send any short or system-exclusive message use one of the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Send(Ten53.Multimedia.Midi.MidiShortMessage)"/> overloads. You might use the <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> resp. the <see cref="T:Ten53.Multimedia.Midi.MidiSysExMessage"/> class in order to construct any message to be send.</para>
            <para>Once you're done with the device call <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Close"/> to close the device and release it.</para>
            </remarks>
            <example>
            <code>
            using Ten53.Multimedia.Midi;
            ...
            private MidiOutputDevice _outDevice;
            ...
            // open a certain Midi output device
            private void OpenDevice(int device)
            {
              _outDevice = new MidiOutputDevice(device);
              if (!_outDevice.Open())
                MessageBox.Show(this, "Midi device could not be opened! Error " + _outDevice.LastErrorCode.ToString(), "Midi Error");
              }
            }
            
            // close the Midi output device
            private void StopAndCloseDevice()
            {
              if (_outDevice != null &amp;&amp; _outDevice.IsOpened)
              {
                _outDevice.Close();
              }
            }
            ...
            // create and send a new short message to the output device
            MidiShortMessage msg = new MidiShortMessage(MIDIStatus.NoteOn, 0, 64, 65, 0);
            if ( _outDevice.Send(msg) )
              Console.WriteLine("Error sending short message!");
            ...
            // create a new system-exclusive message for the output device
            MidiSysExMessage sysex = new MidiSysExMessage(false, _outDevice.Device);
            sysex.CreateBuffer( new byte[7] {0xF0, 0x43, 0x75, 0x73, 0x12, 0x00, 0xF7} );
            // send it
            if ( _outDevice.Send(sysex) )
              Console.WriteLine("Error sending system-exclusive message!");
            ...
            </code>
            <code lang="vbnet">
            Imports Ten53.Multimedia.Midi
            ...
            Private _outDevice As MidiOutputDevice
            ...
            ' open a certain Midi output device
            Private Sub OpenDevice(device As Integer)
              _outDevice = New MidiOutputDevice(device)
              If Not _outDevice.Open() Then
                MessageBox.Show(Me, "Midi device could not be opened! Error " + _outDevice.LastErrorCode.ToString(), "Midi Error")
              End If
            End Sub
            
            ' close the Midi output device
            Private Sub StopAndCloseDevice()
              If Not (_outDevice Is Nothing) AndAlso _outDevice.IsOpened Then
                _outDevice.Close()
              End If
            End Sub
            ...
            ' create and send a new short message to the output device
            Dim msg As New MidiShortMessage(MIDIStatus.NoteOn, 0, 64, 65, 0)
              If _outDevice.Send(msg) Then
                Console.WriteLine("Error sending short message!")
              End If 
            ...
            ' create a new system-exclusive message for the output device
            Dim sysex As New MidiSysExMessage(False, _outDevice.Device)
            sysex.CreateBuffer(New Byte(7) {&amp;HF0, &amp;H43, &amp;H75, &amp;H73, &amp;H12, &amp;H0, &amp;HF7})
            ' send it
            If _outDevice.Send(sysex) Then
              Console.WriteLine("Error sending system-exclusive message!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.#ctor(System.Int32)">
            <summary>
            Creates a new instance of a MidiOutputDevice.
            </summary>
            <param name="deviceID">The output device number to use.</param>
            <remarks>Use the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open"/> method to open the Midi device.
            <para>With the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Send(Ten53.Multimedia.Midi.MidiShortMessage)"/> methods you can send any message to the output device.</para>
            <para>When you are done with the device you might call the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Close"/> method to actually close the Midi output device.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.Dispose">
            <summary>
            Releases all managed and unmanaged resources used by this class.
            </summary>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.Finalize">
            <summary>
            Destructor of the MidiOutputDevice for finalization code.
            </summary>
            <remarks>This destructor will run only if the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Dispose"/> method does not get called.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.GetDeviceCount">
            <summary>
            Returns the total number of available Midi output devices.
            </summary>
            <returns>The number of Midi output devices present in your system.</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.GetDeviceDescriptions">
            <summary>
            Returns all available Midi output device names.
            </summary>
            <returns>An array of strings representing the available devices.</returns>
            <remarks>
            <para>The index of the returned descriptions equals the deviceID, which might be used with the constructor of this class.</para>
            <para>Note: Not all Midi output devices might used when sending messages. So you should check the device capabilities (see <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.GetInfo(System.Int32)"/> - typically only Midi output devices with the <see cref="P:Ten53.Multimedia.Midi.MIDI_OUTCAPS.IsMidiPort"/> property set to TRUE should be used with this class).</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.GetMidiPorts">
            <summary>
            Returns all available Midi output port IDs.
            </summary>
            <returns>An array of int representing the available Midi port IDs.</returns>
            <remarks>
            <para>The values returned equals the deviceID, which might be used with the constructor of this class.</para>
            <para>This method returns all available deviceIDs representing a Midi output port. You might use each ID with the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.GetDeviceDescription(System.Int32)"/> method to retrieve the name of the respective Midi output device.</para>
            </remarks>
            <example>
            List all Midi output ports (devices which might be used with this class):
            <code>
            int[] outPorts = MidiOutputDevice.GetMidiPorts();
            foreach (int port in outPorts)
            {
              string name = MidiOutputDevice.GetDeviceDescription(port);
              Console.WriteLine("{0}={1}", port, name);
            }
            </code>
            <code lang="vbnet">
            Dim outPorts As Integer() = MidiOutputDevice.GetMidiPorts()
            Dim port As Integer
            For Each port In  outPorts
              Dim name As String = MidiOutputDevice.GetDeviceDescription(port)
              Console.WriteLine("{0}={1}", port, name)
            Next port
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.GetDeviceDescription(System.Int32)">
            <summary>
            Returns the name of the given output device ID.
            </summary>
            <param name="deviceID">Identifier of the MIDI output device. The device identifier varies from zero to one less than the number of devices present (see <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.GetDeviceCount"/>).</param>
            <returns>The name of the Midi output device.</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.GetInfo(System.Int32)">
            <summary>
            Determines the capabilities of a specified MIDI output device.
            </summary>
            <param name="deviceID">Identifier of the MIDI output device. The device identifier varies from zero to one less than the number of devices present.</param>
            <returns>An instance of the <see cref="T:Ten53.Multimedia.Midi.MIDI_OUTCAPS"/> structure representing the device capabilities - or NULL on error.</returns>
            <remarks>To determine the number of MIDI output devices present on the system, use the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.GetDeviceCount"/> method.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.Connect(System.IntPtr)">
            <summary>
            Connects this output device (must actually be a MIDI thru device) to a MIDI output device.
            </summary>
            <param name="handleTo">Handle to the MIDI output device.</param>
            <returns>TRUE on success, else FALSE will be returned.</returns>
            <remarks>After calling this function, this <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> receives event data messages whenever a message with the same event data is sent to the output device driver.
            <para>A thru driver is a special form of MIDI output driver. The system will allow only one MIDI output device to be connected to a MIDI input device, but multiple MIDI output devices can be connected to a MIDI thru device. 
            Whenever this <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> receives event data messages, a message with the same event data is sent to the given output device driver (or through the thru driver to the output drivers).</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.Disconnect(System.IntPtr)">
            <summary>
            Disconnects this output device (must actually be a MIDI thru device) from a MIDI output device.
            </summary>
            <param name="handleFrom">Handle to the MIDI output device to be disconnected.</param>
            <returns>TRUE on success, else FALSE will be returned.</returns>
            <remarks>Use this method to disconnect the device you connected with the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Connect(System.IntPtr)"/> method beforehand.</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open">
            <summary>
            Opens the Midi output device using the <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.DeviceID"/>.
            </summary>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>After you have called this method the <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> is being used and you might send messages to the device using the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Send(Ten53.Multimedia.Midi.MidiShortMessage)"/> methods.
            <para>When you have subscribed to the <see cref="E:Ten53.Multimedia.Midi.MidiOutputDevice.MessageReceived"/> event you'll get notified when the device is opened (<see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.Opened"/>) and closed (<see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.Closed"/>).</para>
            <para>Once you're done with the device call <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Close"/> to close the device and release it.</para>
            </remarks>
            <example>
            <code>
            private MidiOutputDevice _outDevice;
            ...
            _outDevice = new MidiOutputDevice(0);
            _outDevice.MessageReceived += new MidiMessageEventHandler(OutDevice_MessageReceived);
            if (!_outDevice.Open())
            {
              MessageBox.Show(this, "Midi device could not be opened! Error " + _outDevice.LastErrorCode.ToString(), "Midi Error");
            }
            ...
            // when done
            if (_outDevice.IsOpened)
              _outDevice.Close();
            ...
            private void OutDevice_MessageReceived(object sender, MidiMessageEventArgs e)
            {
              if (e.EventType == MidiMessageEventType.Opened)
              {
                Console.WriteLine("Midi device {0} opened.", e.DeviceID);
              }
              else if (e.EventType == MidiMessageEventType.Closed)
              {
                Console.WriteLine("Midi device {0} closed.", e.DeviceID);
              }
            }
            </code>
            <code lang="vbnet">
            Private _outDevice As MidiOutputDevice
            ...
            _outDevice = New MidiOutputDevice(0)
            AddHandler _outDevice.MessageReceived, AddressOf OutDevice_MessageReceived
            If Not _outDevice.Open() Then
              MessageBox.Show(Me, "Midi device could not be opened! Error " + _outDevice.LastErrorCode.ToString(), "Midi Error")
            End If
            ...
            ' when done
            If _outDevice.IsOpened Then
              _outDevice.Close()
            End If
            ...
            Private Sub OutDevice_MessageReceived(sender As Object, e As MidiMessageEventArgs)
              If e.EventType = MidiMessageEventType.Opened Then
               Console.WriteLine("Midi device {0} opened.", e.DeviceID)
              Else
                If e.EventType = MidiMessageEventType.Closed Then
                  Console.WriteLine("Midi device {0} closed.", e.DeviceID)
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.Close">
            <summary>
            Closes the Midi output device using the <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.DeviceID"/>.
            </summary>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>After you have called this method the <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> is no longer valid and released.
            <para>When you have subscribed to the <see cref="E:Ten53.Multimedia.Midi.MidiOutputDevice.MessageReceived"/> event you'll get notified when the device is opened (<see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.Opened"/>) and closed (<see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.Closed"/>).</para>
            <para>After you have closed the Midi output device you might open it again using the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open"/> method.</para>
            </remarks>
            <example>
            <code>
            private MidiOutputDevice _outDevice;
            ...
            _outDevice = new MidiOutputDevice(0);
            _outDevice.MessageReceived += new MidiMessageEventHandler(OutDevice_MessageReceived);
            if (!_outDevice.Open())
            {
              MessageBox.Show(this, "Midi device could not be opened! Error " + _outDevice.LastErrorCode.ToString(), "Midi Error");
            }
            ...
            // when done
            if (_outDevice.IsOpened)
              _outDevice.Close();
            ...
            private void OutDevice_MessageReceived(object sender, MidiMessageEventArgs e)
            {
              if (e.EventType == MidiMessageEventType.Opened)
              {
                Console.WriteLine("Midi device {0} opened.", e.DeviceID);
              }
              else if (e.EventType == MidiMessageEventType.Closed)
              {
                Console.WriteLine("Midi device {0} closed.", e.DeviceID);
              }
            }
            </code>
            <code lang="vbnet">
            Private _outDevice As MidiOutputDevice
            ...
            _outDevice = New MidiOutputDevice(0)
            AddHandler _outDevice.MessageReceived, AddressOf OutDevice_MessageReceived
            If Not _outDevice.Open() Then
              MessageBox.Show(Me, "Midi device could not be opened! Error " + _outDevice.LastErrorCode.ToString(), "Midi Error")
            End If
            ...
            ' when done
            If _outDevice.IsOpened Then
              _outDevice.Close()
            End If
            ...
            Private Sub OutDevice_MessageReceived(sender As Object, e As MidiMessageEventArgs)
              If e.EventType = MidiMessageEventType.Opened Then
               Console.WriteLine("Midi device {0} opened.", e.DeviceID)
              Else
                If e.EventType = MidiMessageEventType.Closed Then
                  Console.WriteLine("Midi device {0} closed.", e.DeviceID)
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.Send(Ten53.Multimedia.Midi.MidiShortMessage)">
            <summary>
            Sends a short message to the output <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/>.
            </summary>
            <param name="shortMessage">The instance of the <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> to send.</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.LastErrorCode"/> for details).</returns>
            <remarks>
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> must have been opened with the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open"/> method (or check <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.IsOpened"/>) before sending any message.</para>
            </remarks>
            <example>
            <code>
            private MidiOutputDevice _outDevice = null;
            ...
            _outDevice = new MidiOutputDevice(0);
            if (!_outDevice.Open())
              Console.WriteLine( "Could not open Midi device!" );
            
            // create and send a new short message to the output device
            MidiShortMessage msg = new MidiShortMessage(MIDIStatus.NoteOn, 0, 64, 65, 0);
            if (_outDevice.Send(msg))
              Console.WriteLine("Error sending short message!");
            </code>
            <code lang="vbnet">
            private MidiOutputDevice _outDevice = null;
            ...
            _outDevice = New MidiOutputDevice(0)
            If Not _outDevice.Open() Then
              Console.WriteLine("Could not open Midi device!")
            End If 
            
            ' create and send a new short message to the output device
            Dim msg As New MidiShortMessage(MIDIStatus.NoteOn, 0, 64, 65, 0)
            If _outDevice.Send(msg) Then
              Console.WriteLine("Error sending short message!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.Send(System.Int32)">
            <summary>
            Sends a short message to the output <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/>.
            </summary>
            <param name="shortMessage">The short message value to use.</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.LastErrorCode"/> for details).</returns>
            <remarks>
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> must have been opened with the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open"/> method (or check <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.IsOpened"/>) before sending any message.</para>
            </remarks>
            <example>
            <code>
            private MidiOutputDevice _outDevice = null;
            ...
            _outDevice = new MidiOutputDevice(0);
            if ( !_outDevice.Open() )
              Console.WriteLine( "Could not open Midi device!" );
            
            // send a new short message to the output device
            if ( _outDevice.Send(0x414090) )
              Console.WriteLine("Error sending short message!");
            </code>
            <code lang="vbnet">
            private MidiOutputDevice _outDevice = null;
            ...
            _outDevice = New MidiOutputDevice(0)
            If Not _outDevice.Open() Then
              Console.WriteLine("Could not open Midi device!")
            End If 
            
            ' send a new short message to the output device
            If _outDevice.Send(&amp;H414090) Then
              Console.WriteLine("Error sending short message!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.Send(Ten53.Multimedia.Midi.MIDIStatus,System.Byte,System.Byte,System.Byte)">
            <summary>
            Sends a short message to the output <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/>.
            </summary>
            <param name="status">The <see cref="T:Ten53.Multimedia.Midi.MIDIStatus"/> to use to construct the short message.</param>
            <param name="channel">The channel number to use to construct the short message (will be combined with the <paramref name="status"/> in lower 4-bits).</param>
            <param name="data1">The Data1 value to use to construct the short message.</param>
            <param name="data2">The Data2 value to use to construct the short message.</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.LastErrorCode"/> for details).</returns>
            <remarks>
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> must have been opened with the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open"/> method (or check <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.IsOpened"/>) before sending any message.</para>
            </remarks>
            <example>
            <code>
            private MidiOutputDevice _outDevice = null;
            ...
            _outDevice = new MidiOutputDevice(0);
            if ( !_outDevice.Open() )
              Console.WriteLine("Could not open Midi device!");
            
            // send a new short message to the output device
            if ( _outDevice.Send((byte)MIDIStatus.NoteOn, 1, 64, 65) )
              Console.WriteLine("Error sending short message!");
            </code>
            <code lang="vbnet">
            private MidiOutputDevice _outDevice = null;
            ...
            _outDevice = New MidiOutputDevice(0)
            If Not _outDevice.Open() Then
              Console.WriteLine("Could not open Midi device!")
            End If 
            
            ' send a new short message to the output device
            If _outDevice.Send(CByte(MIDIStatus.NoteOn), 1, 64, 65) Then
              Console.WriteLine("Error sending short message!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.Send(System.Byte,System.Byte,System.Byte)">
            <summary>
            Sends a short message to the output <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/>.
            </summary>
            <param name="status">The <see cref="T:Ten53.Multimedia.Midi.MIDIStatus"/> to use to construct the short message.</param>
            <param name="data1">The Data1 value to use to construct the short message.</param>
            <param name="data2">The Data2 value to use to construct the short message.</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.LastErrorCode"/> for details).</returns>
            <remarks>
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> must have been opened with the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open"/> method (or check <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.IsOpened"/>) before sending any message.</para>
            </remarks>
            <example>
            <code>
            private MidiOutputDevice _outDevice = null;
            ...
            _outDevice = new MidiOutputDevice(0);
            if ( !_outDevice.Open() )
              Console.WriteLine("Could not open Midi device!");
            
            // send a new short message to the output device
            if ( _outDevice.Send(0x90, 40, 41) )
              Console.WriteLine("Error sending short message!");
            </code>
            <code lang="vbnet">
            private MidiOutputDevice _outDevice = null;
            ...
            _outDevice = New MidiOutputDevice(0)
            If Not _outDevice.Open() Then
              Console.WriteLine("Could not open Midi device!")
            End If 
            
            ' send a new short message to the output device
            If _outDevice.Send(&amp;H90, 40, 41) Then
              Console.WriteLine("Error sending short message!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.Send(Ten53.Multimedia.Midi.MidiSysExMessage)">
            <summary>
            Sends a system-exclusive message to the output <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/>.
            </summary>
            <param name="sysexMessage">The unprepared instance of the <see cref="T:Ten53.Multimedia.Midi.MidiSysExMessage"/> to send.</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.LastErrorCode"/> for details).</returns>
            <remarks>The <see cref="T:Ten53.Multimedia.Midi.MidiSysExMessage"/> must be created for this output <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> and must be unprepared (meaning the <see cref="M:Ten53.Multimedia.Midi.MidiSysExMessage.Prepare"/> method should not have been called yet, since this will be handled inside this method).
            <para>If you created the system-exclusive message for a different <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> this method will return FALSE.</para>
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> must have been opened with the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open"/> method (or check <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.IsOpened"/>) before sending any message.</para>
            </remarks>
            <example>
            <code>
            private MidiOutputDevice _outDevice = null;
            ...
            _outDevice = new MidiOutputDevice(0);
            if ( !_outDevice.Open() )
              Console.WriteLine("Could not open Midi device!");
            
            // create a new system-exclusive message for the output device
            MidiSysExMessage sysex = new MidiSysExMessage(false, _outDevice.Device);
            sysex.CreateBuffer(new byte[7] {0xF0, 0x43, 0x75, 0x73, 0x12, 0x00, 0xF7});
            // send it
            if ( _outDevice.Send(sysex) )
              Console.WriteLine("Error sending system-exclusive message!");
            </code>
            <code lang="vbnet">
            private MidiOutputDevice _outDevice = null;
            ...
            _outDevice = New MidiOutputDevice(0)
            If Not _outDevice.Open() Then
              Console.WriteLine("Could not open Midi device!")
            End If 
            
            ' create a new system-exclusive message for the output device
            Dim sysex As New MidiSysExMessage(False, _outDevice.Device)
            sysex.CreateBuffer(New Byte(7) {&amp;HF0, &amp;H43, &amp;H75, &amp;H73, &amp;H12, &amp;H0, &amp;HF7})
            ' send it
            If _outDevice.Send(sysex) Then
              Console.WriteLine("Error sending system-exclusive message!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiOutputDevice.Send(System.Byte[])">
            <summary>
            Sends a system-exclusive message to the output <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/>.
            </summary>
            <param name="sysexMessage">The byte array containing system-exclusive message data buffer to send.</param>
            <returns>TRUE on success, else FALSE (see <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.LastErrorCode"/> for details).</returns>
            <remarks>The byte array should normally start with 0xF0 and end with 0xF7 - however, no validity check is performed on this.
            <para>The <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/> must have been opened with the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open"/> method (or check <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.IsOpened"/>) before sending any message.</para>
            </remarks>
            <example>
            <code>
            private MidiOutputDevice _outDevice = null;
            ...
            _outDevice = new MidiOutputDevice(0);
            if ( !_outDevice.Open() )
              Console.WriteLine( "Could not open Midi device!" );
            
            // send a new system-exclusive message to the output device
            if (_outDevice.Send(new byte[7] {0xF0, 0x43, 0x75, 0x73, 0x12, 0x00, 0xF7}))
              Console.WriteLine("Error sending system-exclusive message!");
            </code>
            <code lang="vbnet">
            private MidiOutputDevice _outDevice = null;
            ...
            _outDevice = New MidiOutputDevice(0)
            If Not _outDevice.Open() Then
              Console.WriteLine("Could not open Midi device!")
            End If 
            
            ' send a new system-exclusive message to the output device
            If _outDevice.Send(New Byte(7) {&amp;HF0, &amp;H43, &amp;H75, &amp;H73, &amp;H12, &amp;H0, &amp;HF7}) Then
              Console.WriteLine("Error sending system-exclusive message!")
            End If
            </code>
            </example>
        </member>
        <member name="E:Ten53.Multimedia.Midi.MidiOutputDevice.MessageReceived">
            <summary>
            Event handler used to notify that the output device has processed a message or the status has changed.
            </summary>
            <remarks>It is a good idea to subscribe to this event handler before calling <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open"/> (even if it is normally not needed to subscribe to any output device).
            <para>The <see cref="T:Ten53.Multimedia.Midi.MidiMessageEventArgs"/> contains a <see cref="T:Ten53.Multimedia.Midi.MidiMessageEventType"/> which allows you to react to all possible scenarios and to process all these events.</para>
            <para>Note: This implementation ensures, that the event will be executed in the main thread the subscriber executes in!
            So when subscribing to this event from UI thread, the specified event delegate will also be called in that UI thread.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiOutputDevice.IsDisposed">
            <summary>
            Returns TRUE, if this class is being disposed.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device">
            <summary>
            Returns the device handle for this output device.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiOutputDevice.DeviceID">
            <summary>
            Returns the device id (number) which was used to create this instance.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiOutputDevice.User">
            <summary>
            User instance data to be used when sending system-exclusive messages.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiOutputDevice.IsOpened">
            <summary>
            Returns TRUE if the Midi output device is opened - else FALSE.
            </summary>
            <remarks>To open the Midi output device call the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Open"/> method.
            When you are done with the Midi input device you might call <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Close"/> to actually close the device.
            Use the <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Send(Ten53.Multimedia.Midi.MidiShortMessage)"/> methods to send any message to the <see cref="P:Ten53.Multimedia.Midi.MidiOutputDevice.Device"/>.
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiOutputDevice.LastErrorCode">
            <summary>
            Returns the last Midi error code (see <see cref="T:Ten53.Multimedia.Midi.MIDIError"/> for possible values).
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MidiMessageEventHandler">
            <summary>
            Definition of the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> and <see cref="E:Ten53.Multimedia.Midi.MidiOutputDevice.MessageReceived"/> event handler.
            </summary>
            <param name="sender">Set to the <see cref="T:Ten53.Multimedia.Midi.MidiInputDevice"/> resp. the <see cref="T:Ten53.Multimedia.Midi.MidiOutputDevice"/> object instance that raised the event.</param>
            <param name="e">An instance of the <see cref="T:Ten53.Multimedia.Midi.MidiMessageEventArgs"/> event args containing the event details.</param>
            <remarks>
            This definition complies with the .NET Framework's standard for event handlers.
            </remarks>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MidiMessageEventType">
            <summary>
            Types of Midi message event that has occurred with the <see cref="T:Ten53.Multimedia.Midi.MidiInputDevice"/> resp. <see cref="T:Ten53.Multimedia.Midi.MidiOutputDevice"/> class.
            </summary>
            <remarks>
            A variable of this type is passed inside the <see cref="T:Ten53.Multimedia.Midi.MidiMessageEventArgs"/> object 
            for the <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> or <see cref="E:Ten53.Multimedia.Midi.MidiOutputDevice.MessageReceived"/> event.
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MidiMessageEventType.Opened">
            <summary>
            The Midi device was opened.
            </summary>
            <remarks>
            <para>Message: Not used (null).</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MidiMessageEventType.Closed">
            <summary>
            The Midi device was closed (any device handle is no longer valid from this point on).
            </summary>
            <remarks>
            <para>Message: Not used (null).</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MidiMessageEventType.Started">
            <summary>
            The Midi device was started.
            </summary>
            <remarks>
            <para>Message: The Midi device ID started (int).</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MidiMessageEventType.Stopped">
            <summary>
            The Midi device was stopped (Midi messages will no longer being send).
            </summary>
            <remarks>
            <para>Message:  The Midi device ID stopped (int).</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MidiMessageEventType.ShortMessage">
            <summary>
            A Midi short message was received by the device (only valid for a <see cref="T:Ten53.Multimedia.Midi.MidiInputDevice"/>).
            </summary>
            <remarks>
            <para>Message: <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/>.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MidiMessageEventType.SystemExclusive">
            <summary>
            A Midi system-exclusive message was received by the device (valid for a <see cref="T:Ten53.Multimedia.Midi.MidiInputDevice"/> and a <see cref="T:Ten53.Multimedia.Midi.MidiOutputDevice"/>).
            </summary>
            <remarks>
            <para>Message: <see cref="T:Ten53.Multimedia.Midi.MidiSysExMessage"/>.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MidiMessageEventType.ShortMessageError">
            <summary>
            An invalid Midi short message was received by the device (only valid for a <see cref="T:Ten53.Multimedia.Midi.MidiInputDevice"/>).
            </summary>
            <remarks>
            <para>Message: <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> (constructed even if invalid).</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MidiMessageEventType.SystemExclusiveError">
            <summary>
            An invalid Midi system-exclusive message was received by the device (valid for a <see cref="T:Ten53.Multimedia.Midi.MidiInputDevice"/> and a <see cref="T:Ten53.Multimedia.Midi.MidiOutputDevice"/>).
            </summary>
            <remarks>
            <para>Message: <see cref="T:Ten53.Multimedia.Midi.MidiSysExMessage"/> (constructed even if invalid).</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MidiMessageEventType.SystemExclusiveDone">
            <summary>
            A Midi system-exclusive message was processed by the output device (valid for a <see cref="T:Ten53.Multimedia.Midi.MidiOutputDevice"/> only).
            </summary>
            <remarks>
            <para>Message: <see cref="T:Ten53.Multimedia.Midi.MidiSysExMessage"/> (as send via <see cref="M:Ten53.Multimedia.Midi.MidiOutputDevice.Send(Ten53.Multimedia.Midi.MidiShortMessage)"/>).</para>
            </remarks>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MidiMessageEventArgs">
            <summary>
            EventArgs class to be passed as the second parameter of a <see cref="E:Ten53.Multimedia.Midi.MidiInputDevice.MessageReceived"/> or <see cref="E:Ten53.Multimedia.Midi.MidiOutputDevice.MessageReceived"/> event handler.
            </summary>
            <remarks>
            This class provides all the information relevant to a Midi message event which might occur to a <see cref="T:Ten53.Multimedia.Midi.MidiInputDevice"/> or <see cref="T:Ten53.Multimedia.Midi.MidiOutputDevice"/> class.
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MidiMessageEventArgs.#ctor(Ten53.Multimedia.Midi.MidiMessageEventType,System.Int32,System.IntPtr,System.Object)">
            <summary>
            Initializes a new instance of the MidiMessageEventArgs class by initializing all of its properties.
            </summary>
            <param name="pEventType">The type of event which occurred (see <see cref="T:Ten53.Multimedia.Midi.MidiMessageEventArgs"/>).</param>
            <param name="pDeviceID">The Midi device ID associated to this event.</param>
            <param name="pDevice">The Midi device handle associated to this event.</param>
            <param name="pMessage">The data which should be passed along with the message event (depending on the event type this could be a <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/>, <see cref="T:Ten53.Multimedia.Midi.MidiSysExMessage"/> or NULL).</param>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiMessageEventArgs.EventType">
            <summary>
            Gets the type of event which occurred.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiMessageEventArgs.DeviceID">
            <summary>
            Gets the Midi device ID on which the event occurred.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiMessageEventArgs.Device">
            <summary>
            Gets the Midi device handle on which the event occurred.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiMessageEventArgs.ShortMessage">
            <summary>
            Gets the Midi short message which was passed along with the event.
            </summary>
            <remarks>Should only be used, if the <see cref="P:Ten53.Multimedia.Midi.MidiMessageEventArgs.EventType"/> is <see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.ShortMessage"/> or <see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.ShortMessageError"/>.
            For other event types this property will return NULL.
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiMessageEventArgs.IsShortMessage">
            <summary>
            Returns TRUE, if a Midi short message was passed along with the event (else FALSE).
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiMessageEventArgs.SysExMessage">
            <summary>
            Gets the Midi system-exclusive message which was passed along with the event.
            </summary>
            <remarks>Should only be used, if the <see cref="P:Ten53.Multimedia.Midi.MidiMessageEventArgs.EventType"/> is <see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.SystemExclusive"/>, <see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.SystemExclusiveError"/> or <see cref="F:Ten53.Multimedia.Midi.MidiMessageEventType.SystemExclusiveDone"/>.
            For other event types this property will return NULL.
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MidiMessageEventArgs.IsSysExMessage">
            <summary>
            Returns TRUE, if a Midi system-exclusive message which was passed along with the event (else FALSE).
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIError">
            <summary>
            General list of Midi Error Codes.
            </summary>
            <remarks>In order to retrieve a textual description of the error code use <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_GetErrorText(System.Boolean,System.Int32)"/>.</remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_OK">
            <summary>
            no error
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_ERROR">
            <summary>
            unspecified error
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_BADDEVICEID">
            <summary>
            device ID out of range
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_NOTENABLED">
            <summary>
            driver failed enable
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_ALLOCATED">
            <summary>
            device already allocated
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_INVALHANDLE">
            <summary>
            device handle is invalid
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_NODRIVER">
            <summary>
            no device driver present
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_NOMEM">
            <summary>
            memory allocation error
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_NOTSUPPORTED">
            <summary>
            function isn't supported
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_BADERRNUM">
            <summary>
            error value out of range
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_INVALFLAG">
            <summary>
            invalid flag passed
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_INVALPARAM">
            <summary>
            invalid parameter passed
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_HANDLEBUSY">
            <summary>
            handle being used
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_INVALIDALIAS">
            <summary>
            specified alias not found
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_BADDB">
            <summary>
            bad registry database
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_KEYNOTFOUND">
            <summary>
            registry key not found
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_READERROR">
            <summary>
            registry read error
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_WRITEERROR">
            <summary>
            registry write error
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_DELETEERROR">
            <summary>
            registry delete error
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_VALNOTFOUND">
            <summary>
            registry value not found
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_NODRIVERCB">
            <summary>
            driver does not call DriverCallback
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_UNPREPARED">
            <summary>
            header not prepared
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_STILLPLAYING">
            <summary>
            still something playing
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_NOMAP">
            <summary>
            no configured instruments
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_NOTREADY">
            <summary>
            hardware is still busy
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_NODEVICE">
            <summary>
            port no longer connected
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_INVALIDSETUP">
            <summary>
            invalid MIF
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_BADOPENMODE">
            <summary>
            operation unsupported w/ open mode
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIError.MIDI_ERROR_DONT_CONTINUE">
            <summary>
            thru device 'eating' a message
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIFlags">
            <summary>
            General Midi Flags.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIFlags.MIDI_CALLBACK_NULL">
            <summary>
            No callback.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIFlags.MIDI_CALLBACK_FUNCTION">
            <summary>
            To be used with <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIINPROC,System.IntPtr,Ten53.Multimedia.Midi.MIDIFlags)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIOUTPROC,System.IntPtr)"/> to define the general Midi callback procedure address.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIFlags.MIDI_IO_STATUS">
            <summary>
            When this parameter is also specified with the MIDI_CALLBACK_FUNCTION, then MIM_MOREDATA messages are sent to the callback function as well as MIM_DATA messages.
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIMessage">
            <summary>
            Midi Message Types.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_OPEN">
            <summary>
            The MIM_OPEN message is sent to a MIDI input callback function when a MIDI input device is opened.
            </summary>
            <remarks>
            <list type="table">
            <listheader><term>Parameters:</term><description></description></listheader>
            <item><term><paramref name="param1"/></term><description>Not used.</description></item>
            <item><term><paramref name="param2"/></term><description>Not used.</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_CLOSE">
            <summary>
            The MIM_CLOSE message is sent to a MIDI input callback function when a MIDI input device is closed.
            </summary>
            <remarks>
            <list type="table">
            <listheader><term>Parameters:</term><description></description></listheader>
            <item><term><paramref name="param1"/></term><description>Not used.</description></item>
            <item><term><paramref name="param2"/></term><description>Not used.</description></item>
            </list>
            <para>The device handle is no longer valid after this message has been sent.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_DATA">
            <summary>
            The MIM_DATA message is sent to a MIDI input callback function when a MIDI message is received by a MIDI input device.
            </summary>
            <remarks>
            <list type="table">
            <listheader><term>Parameters:</term><description></description></listheader>
            <item><term><paramref name="param1"/></term><description>MIDI message that was received. The message is packed into a doubleword value as follows:
            <para>High word: High-order byte: Not used. Low-order byte: Contains a second byte of MIDI data (when needed).</para>
            <para>Low word: High-order byte: Contains the first byte of MIDI data (when needed). Low-order byte: Contains the MIDI status.</para>
            <para>The two MIDI data bytes are optional, depending on the MIDI status byte.</para>
            </description></item>
            <item><term><paramref name="param2"/></term><description>Time that the message was received by the input device driver. The time stamp is specified in milliseconds, beginning at zero when the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InStart(System.IntPtr)"/> function was called.</description></item>
            </list>
            <para>MIDI messages received from a MIDI input port have running status disabled; each message is expanded to include the MIDI status byte.</para>
            <para>This message is not sent when a MIDI system-exclusive message is received.</para>
            <para>You might used the <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> class to construct and or unpack the message into it's components.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA">
            <summary>
            The MIM_LONGDATA message is sent to a MIDI input callback function when a system-exclusive buffer has been filled with data and is being returned to the application.
            </summary>
            <remarks>
            <list type="table">
            <listheader><term>Parameters:</term><description></description></listheader>
            <item><term><paramref name="param1"/></term><description>Pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure identifying the input buffer.</description></item>
            <item><term><paramref name="param2"/></term><description>Time that the message was received by the input device driver. The time stamp is specified in milliseconds, beginning at zero when the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InStart(System.IntPtr)"/> function was called.</description></item>
            </list>
            <para>The returned buffer might not be full. To determine the number of bytes recorded into the returned buffer, use the <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.Data"/> member of the MIDI_HEADER structure specified by param1.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_ERROR">
            <summary>
            The MIM_ERROR message is sent to a MIDI input callback function when an invalid MIDI message is received.
            </summary>
            <remarks>
            <list type="table">
            <listheader><term>Parameters:</term><description></description></listheader>
            <item><term><paramref name="param1"/></term><description>Invalid MIDI message that was received. The message is packed into a doubleword value with the first byte of the message in the low-order byte.</description></item>
            <item><term><paramref name="param2"/></term><description>Time that the message was received by the input device driver. The time stamp is specified in milliseconds, beginning at zero when the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InStart(System.IntPtr)"/> function was called.</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGERROR">
            <summary>
            The MIM_LONGERROR message is sent to a MIDI input callback function when an invalid or incomplete MIDI system-exclusive message is received.
            </summary>
            <remarks>
            <list type="table">
            <listheader><term>Parameters:</term><description></description></listheader>
            <item><term><paramref name="param1"/></term><description>Pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure identifying the buffer containing the invalid message.</description></item>
            <item><term><paramref name="param2"/></term><description>Time that the message was received by the input device driver. The time stamp is specified in milliseconds, beginning at zero when the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InStart(System.IntPtr)"/> function was called.</description></item>
            </list>
            <para>The returned buffer might not be full. To determine the number of bytes recorded into the returned buffer, use the <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.Data"/> member of the MIDI_HEADER structure specified by param1.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_MOREDATA">
            <summary>
            The MIM_MOREDATA message is sent to a MIDI input callback function when a MIDI message is received by a MIDI input device but the application is not processing MIM_DATA messages fast enough to keep up with the input device driver. The callback function receives this message only when the application specifies MIDI_IO_STATUS in the call to the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIINPROC,System.IntPtr,Ten53.Multimedia.Midi.MIDIFlags)"/> function.
            </summary>
            <remarks>
            <list type="table">
            <listheader><term>Parameters:</term><description></description></listheader>
            <item><term><paramref name="param1"/></term><description>MIDI message that was received. The message is packed into a doubleword value as follows:
            <para>High word: High-order byte: Not used. Low-order byte: Contains a second byte of MIDI data (when needed).</para>
            <para>Low word: High-order byte: Contains the first byte of MIDI data (when needed). Low-order byte: Contains the MIDI status.</para>
            <para>The two MIDI data bytes are optional, depending on the MIDI status byte.</para>
            </description></item>
            <item><term><paramref name="param2"/></term><description>Time that the message was received by the input device driver. The time stamp is specified in milliseconds, beginning at zero when the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InStart(System.IntPtr)"/> function was called.</description></item>
            </list>
            <para>An application should do only a minimal amount of processing of MIM_MOREDATA messages. (In particular, applications should not call the PostMessage function while processing MIM_MOREDATA.) Instead, the application should place the event data into a buffer and then return.</para>
            <para>When an application receives an MIM_DATA message after a series of MIM_MOREDATA messages, it has caught up with incoming MIDI events and can safely call time-intensive functions.</para>
            <para>MIDI messages received from a MIDI input port have running status disabled; each message is expanded to include the MIDI status byte.</para>
            <para>This message is not sent when a MIDI system-exclusive message is received.</para>
            <para>You might used the <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> class to construct and or unpack the message into it's components.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessage.MOM_OPEN">
            <summary>
            The MOM_OPEN message is sent to a MIDI output callback function when a MIDI output device is opened.
            </summary>
            <remarks>
            <list type="table">
            <listheader><term>Parameters:</term><description></description></listheader>
            <item><term><paramref name="param1"/></term><description>Not used.</description></item>
            <item><term><paramref name="param2"/></term><description>Not used.</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessage.MOM_CLOSE">
            <summary>
            The MOM_CLOSE message is sent to a MIDI output callback function when a MIDI output device is closed.
            </summary>
            <remarks>
            <list type="table">
            <listheader><term>Parameters:</term><description></description></listheader>
            <item><term><paramref name="param1"/></term><description>Not used.</description></item>
            <item><term><paramref name="param2"/></term><description>Not used.</description></item>
            </list>
            <para>The device handle is no longer valid after this message has been sent.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessage.MOM_DONE">
            <summary>
            The MOM_DONE message is sent to a MIDI output callback function when the specified system-exclusive or stream buffer has been played and is being returned to the application.
            </summary>
            <remarks>
            <list type="table">
            <listheader><term>Parameters:</term><description></description></listheader>
            <item><term><paramref name="param1"/></term><description>Pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure identifying the input buffer.</description></item>
            <item><term><paramref name="param2"/></term><description>Not used.</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIDevice">
            <summary>
            Type of the MIDI output device, to be used with the <see cref="F:Ten53.Multimedia.Midi.MIDI_OUTCAPS.technology"/> flag field.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIDevice.MOD_UNKNOWN">
            <summary>
            Unknown MIDI device.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIDevice.MOD_MIDIPORT">
            <summary>
            MIDI hardware port.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIDevice.MOD_SYNTH">
            <summary>
            Synthesizer.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIDevice.MOD_SQSYNTH">
            <summary>
            Square wave synthesizer.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIDevice.MOD_FMSYNTH">
            <summary>
            FM synthesizer.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIDevice.MOD_MAPPER">
            <summary>
            Microsoft MIDI mapper.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIDevice.MOD_WAVETABLE">
            <summary>
            Hardware wavetable synthesizer.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIDevice.MOD_SWSYNTH">
            <summary>
            Software synthesizer.
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIHeader">
            <summary>
            Flag of the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> flags property.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHeader.MHDR_NONE">
            <summary>
            Unprepared. No flags set.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHeader.MHDR_DONE">
            <summary>
            Set by the device driver to indicate that it is finished with the buffer and is returning it to the application.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHeader.MHDR_PREPARED">
            <summary>
            Set by Windows to indicate that the buffer has been prepared by using the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutPrepareHeader(System.IntPtr,System.IntPtr)"/> function.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHeader.MHDR_INQUEUE">
            <summary>
            Set by Windows to indicate that the buffer is queued for playback.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHeader.MHDR_ISSTRM">
            <summary>
            Set to indicate that the buffer is a stream buffer.
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIMessageType">
            <summary>
            Defines constants representing MIDI message types.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessageType.Unknown">
            <summary>
            Unknown Message type (see <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/>).
            </summary>
            <remarks>All messages, which do not conform a <see cref="F:Ten53.Multimedia.Midi.MIDIMessageType.Channel"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIMessageType.SystemCommon"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIMessageType.SystemRealtime"/> or <see cref="F:Ten53.Multimedia.Midi.MIDIMessageType.SystemExclusive"/> message are considered as unknown.
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessageType.Channel">
            <summary>
            A Channel Message (see <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/>).
            </summary>
            <remarks>The status byte is split into two halfs (the 4 high-bits contains the type and the 4 lower-bits contain the controler channel number).
            <para>The data byte 1 and data byte 2 might be used. Some messages occure in pairs meaning a second message will provide additional data bytes.</para>
            <para>The following status is recognized as Channel messages: <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.NoteOn"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.NoteOff"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.Aftertouch"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ChannelPressure"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ProgramChange"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.PitchBend"/> and <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/>.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessageType.SystemCommon">
            <summary>
            A SystemCommon Message (see <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/>).
            </summary>
            <remarks>The status byte contains the message type itself.
            <para>The data byte 1 and data byte 2 might be used. Some messages are spaned over multiple messages to provide additional data bytes.</para>
            <para>The following status is recognized as SystemCommon messages: <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.MidiTimeCode"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.SongPosition"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.SongSelect"/> and <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.TuneRequest"/>.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessageType.SystemRealtime">
            <summary>
            A SystemRealtime Message (see <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/>).
            </summary>
            <remarks>The status byte contains the message type itself.
            <para>No data bytes are used with SystemRealtime messages.</para>
            <para>The following status is recognized as SystemRealtime messages: <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.Clock"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.Tick"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.Start"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.Continue"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.Stop"/>, <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ActiveSense"/> and <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.Reset"/>.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMessageType.SystemExclusive">
            <summary>
            A SystemExclusive Message (see <see cref="T:Ten53.Multimedia.Midi.MidiSysExMessage"/>).
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIStatus">
            <summary>
            Defines constants for Midi message status. 
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.None">
            <summary>
            No status.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.NoteOff">
            <summary>
            Channel Message: Note Off.
            </summary>
            <remarks>
            <para>Status: 0x80 to 0x8F where the low nibble is the MIDI channel.</para>
            <para>Data1: The first data is the note number. There are 128 possible notes on a MIDI device, numbered 0 to 127 (where Middle C is note number 60). This indicates which note should be released.</para>
            <para>Data2: The second data byte is the velocity, a value from 0 to 127. This indicates how quickly the note should be released (where 127 is the fastest). It's up to a MIDI device how it uses velocity information. Often velocity will be used to tailor the VCA release time. MIDI devices that can generate Note Off messages, but don't implement velocity features, will transmit Note Off messages with a preset velocity of 64.</para>
            <para>This status might also be used, if the Midi message actually returned 'NoteOn' but with a velocity (data2) of 0. The <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> class already translates those messages to NoteOff (see <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/>).</para>
            <para>An 'AllNotesOff' ControlChange message can be used to turn off all notes for which a device received NoteOn messages (without having received respective Note Off messages).</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.NoteOn">
            <summary>
            Channel Message: Note On.
            </summary>
            <remarks>
            <para>Status: 0x90 to 0x9F where the low nibble is the MIDI channel.</para>
            <para>Data1: The first data is the note number. There are 128 possible notes on a MIDI device, numbered 0 to 127 (where Middle C is note number 60). This indicates which note should be played.</para>
            <para>Data2: The second data byte is the velocity, a value from 0 to 127. This indicates with how much force the note should be played (where 127 is the most force). It's up to a MIDI device how it uses velocity information. Often velocity is be used to tailor the VCA attack time and/or attack level (and therefore the overall volume of the note). MIDI devices that can generate Note On messages, but don't implement velocity features, will transmit Note On messages with a preset velocity of 64.</para>
            <para>NoteOn message that has a velocity of 0 is considered to actually be a NoteOff message!, and the respective note is therefore released. The <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> class already translates those messages to NoteOff (see <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/>).</para>
            <para>An 'AllNotesOff' ControlChange message can be used to turn off all notes for which a device received NoteOn messages (without having received respective Note Off messages).</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.Aftertouch">
            <summary>
            Channel Message: Polyphonic Aftertouch (Polyphonic Pressure).
            </summary>
            <remarks>
            <para>Status: 0xA0 to 0xAF where the low nibble is the MIDI channel.</para>
            <para>Data1: The first data is the note number. There are 128 possible notes on a MIDI device, numbered 0 to 127 (where Middle C is note number 60). This indicates to which note the pressure is being applied.</para>
            <para>Data2: The second data byte is the pressure amount, a value from 0 to 127 (where 127 is the most pressure).</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange">
            <summary>
            Channel Message: Control Change.
            </summary>
            <remarks>
            <para>Status: 0xB0 to 0xBF where the low nibble is the MIDI channel.</para>
            <para>Data1: The first data is the controller number (0 to 127). This indicates which controller is affected by the received MIDI message.</para>
            <para>Data2: The second data byte is the value to which the controller should be set, a value from 0 to 127.</para>
            <para>Some Midi data messages might actually use two sub-sequent short messages to construct a paired message representing a single value range (e.g. the <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> with a <see cref="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelect"/>).
            This to support paired values with a higher resolution (16384 instead of 128 values). The same might apply the the controller value itself.
            In such case two short messages will be send, where one contains the LSB value (single steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> or <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte and the other message contains the MSB value (128th steps) in it's <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data2"/> or <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Data1"/> byte.
            Typically the messages with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> of <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> and with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value between 0 and 31 (MSB) are paired with a message of a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value between 32 and 63 (LSB).
            But also a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 98 (LSB) will be paired with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 99 (MSB) as well as a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 100 (LSB) will be paired with a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.Controller"/> value of 101 (MSB).
            Other pairs might be hardware specific.</para>
            <para>An 'AllControllersOff' ControlChange message can be used to reset all controllers (that a MIDI device implements) to default values.
            See the <see cref="T:Ten53.Multimedia.Midi.MIDIControllerType"/> for a list of defined controller numbers for more information about particular controllers.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.ProgramChange">
            <summary>
            Channel Message: Program Change.
            </summary>
            <remarks>
            <para>Status: 0xC0 to 0xCF where the low nibble is the MIDI channel.</para>
            <para>Data1: The program number to change to, a number from 0 to 127.</para>
            <para>Data2: not used.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.ChannelPressure">
            <summary>
            Channel Message: Channel Pressure (Channel Aftertouch).
            </summary>
            <remarks>
            <para>Status: 0xC0 to 0xCF where the low nibble is the MIDI channel.</para>
            <para>Data1: The program number to change to, a number from 0 to 127.</para>
            <para>Data2: not used.</para>
            <para>If multiple banks do exist a ProgramChange command will select a new program number from the current bank only.
            A different bank will be selected with two sub-sequent <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.ControlChange"/> commands. This will also be called a BankSelect command.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.PitchBend">
            <summary>
            Channel Message: Pitch Bend.
            </summary>
            <remarks>
            <para>Status: 0xE0 to 0xEF where the low nibble is the MIDI channel.</para>
            <para>Data1: The first data byte's bits 0 to 6 are bits 0 to 6 of the 14-bit value.</para>
            <para>Data2: The second data byte's bits 0 to 6 are really bits 7 to 13 of the 14-bit value.</para>
            <para>The two data bytes should be combined together to form a single 14-bit value.</para>
            <para>A combined value of 0x2000 is meant to indicate that the Pitch Wheel is centered (ie, the sounding notes aren't being transposed up or down). Higher values transpose pitch up, and lower values transpose pitch down.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.SystemMsgs">
            <summary>
            SystemExclusive Message: Start of system-exclusive message.
            </summary>
            <remarks>
            <para>Status: 0xF0.</para>
            <para>Various data bytes will follow, finally ending with an <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.EOX"/>.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.MidiTimeCode">
            <summary>
            SystemCommon Message: MIDI Time Code (see <see cref="T:Ten53.Multimedia.Midi.MIDIMTCType"/> for details).
            </summary>
            <remarks>
            <para>Status: 0xF1.</para>
            <para>Data1: It's the time code value, a number from 0 to 127.</para>
            <para>Data2: not used.</para>
            <para>The two data bytes should be combined together to form a single 14-bit value.</para>
            <para>See the <see cref="T:Ten53.Multimedia.Midi.MIDIMTCType"/> for details.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.SongPosition">
            <summary>
            SystemCommon Message: Song Position Pointer.
            </summary>
            <remarks>
            <para>Status: 0xF2.</para>
            <para>Data1: The first data byte's bits 0 to 6 are bits 0 to 6 of the 14-bit value.</para>
            <para>Data2: The second data byte's bits 0 to 6 are really bits 7 to 13 of the 14-bit value.</para>
            <para>The two data bytes should be combined together to form a single 14-bit value.
            This 14-bit value is the MIDI Beat upon which to start the song. Songs are always assumed to start on a MIDI Beat of 0. Each MIDI Beat spans 6 MIDI Clocks. In other words, each MIDI Beat is a 16th note (since there are 24 MIDI Clocks in a quarter note).</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.SongSelect">
            <summary>
            SystemCommon Message: Song Select.
            </summary>
            <remarks>
            <para>Status: 0xF3.</para>
            <para>Data1: The song number, a value from 0 to 127.</para>
            <para>Data2: not used.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.TuneRequest">
            <summary>
            SystemCommon Message: Tune Request.
            </summary>
            <remarks>
            <para>Status: 0xF6.</para>
            <para>Data1: not used.</para>
            <para>Data2: not used.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.EOX">
            <summary>
            SystemExclusive Message: End of system-exclusive message.
            </summary>
            <remarks>
            <para>Status: 0xF7.</para>
            <para>No data bytes should follow.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.Clock">
            <summary>
            SystemRealtime Message: Timing Clock.
            </summary>
            <remarks>
            <para>Status: 0xF8.</para>
            <para>Data1: not used.</para>
            <para>Data2: not used.</para>
            <para>There are 24 MIDI Clocks in every quarter note. (12 MIDI Clocks in an eighth note, 6 MIDI Clocks in a 16th, etc). Therefore, when a slave device counts down the receipt of 24 MIDI Clock messages, it knows that one quarter note has passed.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.Tick">
            <summary>
            SystemRealtime Message: Tick System Realtime.
            </summary>
            <remarks>
            <para>Status: 0xF9.</para>
            <para>Data1: not used.</para>
            <para>Data2: not used.</para>
            <para>While a master device's 'Clock' is playing back, it will send a continuous stream of MIDI Tick events at a rate of one per every 10 milliseconds.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.Start">
            <summary>
            SystemRealtime Message: Start.
            </summary>
            <remarks>
            <para>Status: 0xFA.</para>
            <para>Data1: not used.</para>
            <para>Data2: not used.</para>
            <para>MIDI Start always begins playback at MIDI Beat 0 (ie, the very beginning of the song). So, when a slave device receives a MIDI Start, it automatically resets its "Song Position" to 0. If the device needs to start playback at some other point (either set by a previous Song Position Pointer message, or manually by the musician), then MIDI Continue is used instead of MIDI Start.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.Continue">
            <summary>
            SystemRealtime Message: Continue.
            </summary>
            <remarks>
            <para>Status: 0xFB.</para>
            <para>Data1: not used.</para>
            <para>Data2: not used.</para>
            <para>Often, the slave device has its playback tempo synced to the master via MIDI Clock.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.Stop">
            <summary>
            SystemRealtime Message: Stop.
            </summary>
            <remarks>
            <para>Status: 0xFC.</para>
            <para>Data1: not used.</para>
            <para>Data2: not used.</para>
            <para>When a device receives a MIDI Stop, it should keep track of the point at which it stopped playback (ie, its stopped "Song Position"), in the anticipation that a MIDI Continue might be received next.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.ActiveSense">
            <summary>
            SystemRealtime Message: Active Sense.
            </summary>
            <remarks>
            <para>Status: 0xFE.</para>
            <para>Data1: not used.</para>
            <para>Data2: not used.</para>
            <para>A device sends out an Active Sense message (at least once) every 300 milliseconds if there has been no other activity on the MIDI buss, to let other devices know that there is still a good MIDI connection between the devices.
            This is an optional feature that only a few devices implement. Many devices don't ever initiate this minimal "safety" feature.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIStatus.Reset">
            <summary>
            SystemRealtime Message: System Reset.
            </summary>
            <remarks>
            <para>Status: 0xFF.</para>
            <para>Data1: not used.</para>
            <para>Data2: not used.</para>
            <para>A Reset message should never be sent automatically by any MIDI device. Rather, this should only be sent when a musician specifically tells a device to do so.</para>
            </remarks>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIControllerType">
            <summary>
            Defines constants for controller types.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelect">
            <summary>
            Controller-Pair: The Bank Select coarse (0=MSB, 32=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.Modulation">
            <summary>
            Controller-Pair: The Modulation Wheel coarse (1=MSB, 33=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.BreathControl">
            <summary>
            Controller-Pair: The Breath Control coarse (2=MSB, 34=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User3">
            <summary>
            Controller-Pair: Un- or User defined controller 3 (3=MSB, 35=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.FootControl">
            <summary>
            Controller-Pair: The Foot Pedal coarse (4=MSB, 36=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.PortamentoTime">
            <summary>
            Controller-Pair: The Portamento Time coarse (5=MSB, 37=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.DataEntry">
            <summary>
            Controller-Pair: The Data Entry Slider coarse (6=MSB, 38=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.MainVolume">
            <summary>
            Controller-Pair: The Volume coarse (7=MSB, 39=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.Balance">
            <summary>
            Controller-Pair: The Balance coarse (8=MSB, 40=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User9">
            <summary>
            Controller-Pair: Un- or User defined controller 9 (9=MSB, 41=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.Panorama">
            <summary>
            Controller-Pair: The Pan position coarse (10=MSB, 42=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.Expression">
            <summary>
            Controller-Pair: The Expression coarse (11=MSB, 43=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.EffectControl1">
            <summary>
            Controller-Pair: The Effect Control 1 coarse (12=MSB, 44=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.EffectControl2">
            <summary>
            Controller-Pair: The Effect Control 2 coarse (13=MSB, 45=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User14">
            <summary>
            Controller-Pair: Un- or User defined controller 14 (14=MSB, 46=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User15">
            <summary>
            Controller-Pair: Un- or User defined controller 15 (15=MSB, 47=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurpose1">
            <summary>
            Controller-Pair: The General Puprose Slider 1 (16=MSB, 48=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurpose2">
            <summary>
            Controller-Pair: The General Puprose Slider 2 (17=MSB, 49=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurpose3">
            <summary>
            Controller-Pair: The General Puprose Slider 3 (18=MSB, 50=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurpose4">
            <summary>
            Controller-Pair: The General Puprose Slider 4 (19=MSB, 51=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User20">
            <summary>
            Controller-Pair: Un- or User defined controller 20 (20=MSB, 52=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User21">
            <summary>
            Controller-Pair: Un- or User defined controller 21 (21=MSB, 53=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User22">
            <summary>
            Controller-Pair: Un- or User defined controller 22 (22=MSB, 54=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User23">
            <summary>
            Controller-Pair: Un- or User defined controller 23 (23=MSB, 55=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User24">
            <summary>
            Controller-Pair: Un- or User defined controller 24 (24=MSB, 56=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User25">
            <summary>
            Controller-Pair: Un- or User defined controller 25 (25=MSB, 57=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User26">
            <summary>
            Controller-Pair: Un- or User defined controller 26 (26=MSB, 58=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User27">
            <summary>
            Controller-Pair: Un- or User defined controller 27 (27=MSB, 59=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User28">
            <summary>
            Controller-Pair: Un- or User defined controller 28 (28=MSB, 60=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User29">
            <summary>
            Controller-Pair: Un- or User defined controller 29 (29=MSB, 61=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User30">
            <summary>
            Controller-Pair: Un- or User defined controller 30 (30=MSB, 62=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User31">
            <summary>
            Controller-Pair: Un- or User defined controller 31 (31=MSB, 63=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.BankSelectFine">
            <summary>
            Controller-Pair: The Bank Select coarse (0=MSB, 32=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.ModulationFine">
            <summary>
            Controller-Pair: The Modulation Wheel coarse (1=MSB, 33=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.BreathControlFine">
            <summary>
            Controller-Pair: The Breath Control coarse (2=MSB, 34=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User3Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 3 (3=MSB, 35=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.FootControlFine">
            <summary>
            Controller-Pair: The Foot Pedal coarse (4=MSB, 36=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.PortamentoTimeFine">
            <summary>
            Controller-Pair: The Portamento Time coarse (5=MSB, 37=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.DataEntryFine">
            <summary>
            Controller-Pair: The Data Entry Slider coarse (6=MSB, 38=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.MainVolumeFine">
            <summary>
            Controller-Pair: The Volume coarse (7=MSB, 39=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.BalanceFine">
            <summary>
            Controller-Pair: The Balance coarse (8=MSB, 40=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User9Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 9 (9=MSB, 41=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.PanoramaFine">
            <summary>
            Controller-Pair: The Pan position coarse (10=MSB, 42=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.ExpressionFine">
            <summary>
            Controller-Pair: The Expression coarse (11=MSB, 43=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.EffectControl1Fine">
            <summary>
            Controller-Pair: The Effect Control 1 coarse (12=MSB, 44=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.EffectControl2Fine">
            <summary>
            Controller-Pair: The Effect Control 2 coarse (13=MSB, 45=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User14Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 14 (14=MSB, 46=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User15Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 15 (15=MSB, 47=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurpose1Fine">
            <summary>
            Controller-Pair: The General Puprose Slider 1 (16=MSB, 48=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurpose2Fine">
            <summary>
            Controller-Pair: The General Puprose Slider 2 (17=MSB, 49=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurpose3Fine">
            <summary>
            Controller-Pair: The General Puprose Slider 3 (18=MSB, 50=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurpose4Fine">
            <summary>
            Controller-Pair: The General Puprose Slider 4 (19=MSB, 51=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User20Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 20 (20=MSB, 52=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User21Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 21 (21=MSB, 53=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User22Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 22 (22=MSB, 54=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User23Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 23 (23=MSB, 55=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User24Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 24 (24=MSB, 56=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User25Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 25 (25=MSB, 57=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User26Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 26 (26=MSB, 58=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User27Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 27 (27=MSB, 59=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User28Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 28 (28=MSB, 60=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User29Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 29 (29=MSB, 61=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User30Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 30 (30=MSB, 62=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User31Fine">
            <summary>
            Controller-Pair: Un- or User defined controller 31 (31=MSB, 63=LSB).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.HoldPedal1">
            <summary>
            Non-Continuous: The Hold Pedal 1.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.Portamento">
            <summary>
            Non-Continuous: The Portamento.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.SustenutoPedal">
            <summary>
            Non-Continuous: The Sustenuto Pedal.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.SoftPedal">
            <summary>
            Non-Continuous: The Soft Pedal.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.LegatoPedal">
            <summary>
            Non-Continuous: The Legato Pedal.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.HoldPedal2">
            <summary>
            Non-Continuous: The Hold Pedal 2.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.SoundVariation">
            <summary>
            The Sound Variation.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.SoundTimbre">
            <summary>
            The Sound Timbre.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.SoundReleaseTime">
            <summary>
            The Sound Release Time.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.SoundAttackTime">
            <summary>
            The Sound Attack Time.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.SoundBrightness">
            <summary>
            The Sound Brightness.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.SoundControl6">
            <summary>
            The Sound Control 6.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.SoundControl7">
            <summary>
            The Sound Control 7.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.SoundControl8">
            <summary>
            The Sound Control 8.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.SoundControl9">
            <summary>
            The Sound Control 9.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.SoundControl10">
            <summary>
            The Sound Control 10.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurposeButton1">
            <summary>
            The General Purpose Button 1.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurposeButton2">
            <summary>
            The General Purpose Button 2.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurposeButton3">
            <summary>
            The General Purpose Button 3.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurposeButton4">
            <summary>
            The General Purpose Button 4.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurposeButton5">
            <summary>
            The General Purpose Button 5.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurposeButton6">
            <summary>
            The General Purpose Button 6.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurposeButton7">
            <summary>
            The General Purpose Button 7.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurposeButton8">
            <summary>
            The General Purpose Button 8.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurposeButton9">
            <summary>
            The General Purpose Button 9.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurposeButton10">
            <summary>
            The General Purpose Button 10.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.GeneralPurposeButton11">
            <summary>
            The General Purpose Button 11.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.EffectsLevel">
            <summary>
            The Effects Level.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.TremeloLevel">
            <summary>
            The Tremelo Level.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.ChorusLevel">
            <summary>
            The Chorus Level.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.CelesteLevel">
            <summary>
            The Celeste Level.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.PhaserLevel">
            <summary>
            The Phaser Level.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.DataButtonIncrement">
            <summary>
            The Data Button Increment.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.DataButtonDecrement">
            <summary>
            The Data Button Decrement.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.NonRegisteredParameterFine">
            <summary>
            Controller-Pair: The NonRegistered Parameter Fine.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.NonRegisteredParameterCoarse">
            <summary>
            Controller-Pair: The NonRegistered Parameter Coarse.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.RegisteredParameterFine">
            <summary>
            Controller-Pair: The Registered Parameter Fine.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.RegisteredParameterCoarse">
            <summary>
            Controller-Pair: The Registered Parameter Coarse.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User102">
            <summary>
            User Controller 102.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User103">
            <summary>
            User Controller 103.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User104">
            <summary>
            User Controller 104.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User105">
            <summary>
            User Controller 105.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User106">
            <summary>
            User Controller 106.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User107">
            <summary>
            User Controller 107.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User108">
            <summary>
            User Controller 108.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User109">
            <summary>
            User Controller 109.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User110">
            <summary>
            User Controller 110.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User111">
            <summary>
            User Controller 111.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User112">
            <summary>
            User Controller 112.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User113">
            <summary>
            User Controller 113.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User114">
            <summary>
            User Controller 114.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User115">
            <summary>
            User Controller 115.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User116">
            <summary>
            User Controller 116.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User117">
            <summary>
            User Controller 117.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User118">
            <summary>
            User Controller 118.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.User119">
            <summary>
            User Controller 119.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.AllSoundOff">
            <summary>
            ChannelMode: The All Sound Off.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.AllControllerReset">
            <summary>
            ChannelMode: Reset all controllers to default.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.LocalKeyboard">
            <summary>
            ChannelMode: The Local Keyboard.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.AllNotesOff">
            <summary>
            ChannelMode: The All Notes Off.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.OmniModeOff">
            <summary>
            ChannelMode: The Omni Mode Off.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.OmniModeOn">
            <summary>
            ChannelMode: The Omni Mode On.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.MonoOperation">
            <summary>
            ChannelMode:The Mono Operation (mono mode on and poly mode off).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIControllerType.PolyOperation">
            <summary>
            ChannelMode: The Poly Operation (mono mode off and poly mode on).
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDINote">
            <summary>
            Defines constants representing the 12 Note of the chromatic scale.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.C">
            <summary>
            C natural.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.CSharp">
            <summary>
            C sharp.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.D">
            <summary>
            D natural.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.DSharp">
            <summary>
            D sharp.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.E">
            <summary>
            E natural.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.F">
            <summary>
            F natural.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.FSharp">
            <summary>
            F sharp.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.G">
            <summary>
            G natural.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.GSharp">
            <summary>
            G sharp.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.A">
            <summary>
            A natural.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.ASharp">
            <summary>
            A sharp.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.B">
            <summary>
            B natural.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.NOTE_LOW_KEYBOARD88">
            <summary>
            Lowest note on a 88th keyboard (A-1).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.NOTE_LOW_KEYBOARD76">
            <summary>
            Lowest note on a 76th keyboard (E0).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.NOTE_LOW_KEYBOARD61">
            <summary>
            Lowest note on a 61th keyboard (C1).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.NOTE_MIDDLE_C">
            <summary>
            Middle C (C3).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.NOTE_STANDARDPITCH">
            <summary>
            Standard Pitch (A3).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.NOTE_HIGH_KEYBOARD61">
            <summary>
            Highest note on a 61th keyboard (C6).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.NOTE_HIGH_KEYBOARD76">
            <summary>
            Highest note on a 76th keyboard (G6).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.NOTE_HIGH_KEYBOARD88">
            <summary>
            Highest note on a 88th keyboard (C7).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDINote.NOTE_HIGHEST">
            <summary>
            Highest Midi note (G8).
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIMTCType">
            <summary>
            Defines constants representing the Midi Time Code (MTC) type used by the <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.MidiTimeCode"/> status given in a <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> member (also see <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.TimeCodeType"/> and <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.TimeCodeValue"/>).
            </summary>
            <remarks>
            <para>MIDI Time Code (MTC) is a sub-protocol within MIDI, and is used to keep 2 devices that control some sort of timed performance (ie, maybe a sequencer and a video deck) in sync. MTC messages are an alternative to using MIDI Clocks and Song Position Pointer messages. MTC is essentially SMPTE mutated for transmission over MIDI. SMPTE timing is referenced from an absolute "time of day". On the other hand, MIDI Clocks and Song Position Pointer are based upon musical beats from the start of a song, played at a specific Tempo. For many (non-musical) cues, it's easier for humans to reference time in some absolute way rather than based upon musical beats at a certain tempo.</para>
            <para>The Midi Time Code is used by the <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> if the <see cref="P:Ten53.Multimedia.Midi.MidiShortMessage.StatusType"/> is <see cref="F:Ten53.Multimedia.Midi.MIDIStatus.MidiTimeCode"/>. It is also often called the Quarter Frame message.</para>
            <para>It has a status of 0xF1, and one subsequent data byte. This message is sent periodically to keep track of the running SMPTE time. It's analogous to the MIDI Clock message. The Quarter Frame messages are sent at a rate of 4 per each SMPTE Frame. In other words, by the time that a slave has received 4 Quarter Frame messages, a SMPTE Frame has passed. So, the Quarter Frame messages provide a "sub-frame" clock reference. (With 30 fps SMPTE, this "clock tick" happens every 8.3 milliseconds).</para>
            <para>But the Quarter Frame is more than just a quarter frame "clock tick". The Quarter Frame message's data byte contains the SMPTE time (ie, hours, minutes, seconds, and frames). SMPTE time is normally expressed in 80 bits. Obviously, this is too many bits to be contained in 1 8-bit data byte. So, each Quarter Frame message contains just one piece of the time (for example, one Quarter Frame may contain only the hours). In order to get the entire SMPTE time at any given point, a slave needs to receive several Quarter Frame messages, and piece the current SMPTE time together from those messages. It takes 8 Quarter Frame messages to convey the current SMPTE time. In other words, by the time that a slave can piece together the current SMPTE time, two SMPTE frames have passed (ie, since there are 4 Quarter Frame messages in each frame). So, MTC's version of SMPTE time actually counts in increments of 2 SMPTE Frames per each update of the current SMPTE time.</para>
            <para>The first (of 8) Quarter Frame message contains the low nibble (ie, bits 0 to 3) of the Frame Time. The second Quarter Frame message contains the high nibble (ie, bits 4 to 7) of the Frame Time. The third and fourth messages contain the low and high nibbles of the Seconds Time. The fifth and sixth messages contain the low and high nibbles of the Minutes Time. The seventh and eighth messages contain the low and high nibbles of the Hours Time. The eighth message also contains the SMPTE frames-per-second Type (ie, 24, 25, 30 drop, or 30 fps). If you were to break up the Quarter Frame's data byte into its 7 bits, the format is:</para>
            <para>"0nnn dddd" (8-bits).</para>
            <para>Where 'nnn' is one of 7 possible values which tell you what 'dddd' represents. This enummeration represents the 7 values, and what each causes 'dddd' to represent.</para>
            <para> </para>
            <para>When MTC is running in the forward direction (ie, time is advancing), the Quarter Frame messages are sent in the order of Frames Low Nibble to Hours High Nibble. In other words, the order looks something like this:</para>
            <para>0xF1 0x0n : where n is the current Frames Low Nibble.</para>
            <para>0xF1 0x1n : where n is the current Frames High Nibble.</para>
            <para>0xF1 0x2n : where n is the current Seconds Low Nibble.</para>
            <para>0xF1 0x3n : where n is the current Seconds High Nibble.</para>
            <para>0xF1 0x4n : where n is the current Minutes Low Nibble.</para>
            <para>0xF1 0x5n : where n is the current Minutes High Nibble.</para>
            <para>0xF1 0x6n : where n is the current Hours Low Nibble.</para>
            <para>0xF1 0x7n : where n is the current Hours High Nibble and SMPTE Type.</para>
            <para>When MTC is running in reverse (ie, time is going backwards), these are sent in the opposite order, ie, the Hours High Nibble is sent first and the Frames Low Nibble is last.</para>
            <para>The arrival of the 0xF1 0x0n and 0xF1 0x4n messages always denote where SMPTE Frames actually occur in realtime.</para>
            <para>Since 8 Quarter Frame messages are required to piece together the current SMPTE time, timing lock can't be achieved until the slave has received all 8 messages. This will take from 2 to 4 SMPTE Frames, depending upon when the slave comes online.</para>
            <para>The Frame number (contained in the first 2 Quarter Frame messages) is the SMPTE Frames Time for when the first Quarter Frame message is sent. But, because it takes 7 more Quarter Frames to piece together the current SMPTE Time, when the slave does finally piece the time together, it is actually 2 SMPTE Frames behind the real current time. So, for display purposes, the slave should always add 2 frames to the current time.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMTCType.FramesLSB">
            <summary>
            Current Frames Low Nibble.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMTCType.FramesMSB">
            <summary>
            Current Frames High Nibble.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMTCType.SecondsLSB">
            <summary>
            Current Seconds Low Nibble.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMTCType.SecondsMSB">
            <summary>
            Current Seconds High Nibble.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMTCType.MinutesLSB">
            <summary>
            Current Minutes Low Nibble.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMTCType.MinutesMSB">
            <summary>
            Current Minutes High Nibble.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMTCType.HoursLSB">
            <summary>
            Current Hours Low Nibble.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIMTCType.HoursMSB">
            <summary>
            Current Hours High Nibble and SMPTE Type.
            </summary>
            <remarks>In the data byte for the Hours High Nibble and SMPTE Type, the bits are interpreted as follows:
            <para>"0nnn x yy d" (8-bits).</para>
            <para>Where 'nnn' is 7. 'x' is unused and set to 0. 'd' is bit 4 of the Hours Time. 'yy' tells the SMPTE Type as follows:</para>
            <para>0 = 24 fps, 1 = 25 fps, 2 = 30 fps (Drop-Frame), 3 = 30 fps</para>
            </remarks>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDITimeType">
            <summary>
            Defines constants representing the Midi timing format used by the <see cref="T:Ten53.Multimedia.Midi.MIDI_TIME"/> structure.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_MS">
            <summary>
            Time in milliseconds.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_SAMPLES">
            <summary>
            Number of waveform-audio samples.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_BYTES">
            <summary>
            Current byte offset from beginning of the file.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_SMPTE">
            <summary>
            SMPTE (Society of Motion Picture and Television Engineers) time.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_MIDI">
            <summary>
            MIDI time.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_TICKS">
            <summary>
            Ticks within a MIDI stream.
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIManufacturer">
            <summary>
            Defines constants representing the special Midi ManufacturerID within a system-exclusive message (see <see cref="P:Ten53.Multimedia.Midi.MidiSysExMessage.Manufacturer"/> for details).
            </summary>
            <remarks>This list does NOT define the real manufacturer id's but only special purpose manufacturer IDs!</remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIManufacturer.Extended">
            <summary>
            To accomodate a greater range of manufacturer IDs, the MMA decided to reserve a manufacturer ID of 0 for a special purpose. 
            When you see a manufacturer ID of 0, then there will be two more data bytes after this. These two data bytes combine to make the real manufacturer ID. 
            So, some manufacturers have IDs that are 3 bytes, where the first byte is always 0. 
            Using this "trick", the range of unique manufacturer IDs is extended to accomodate over 16,000 MIDI manufacturers.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIManufacturer.Educational">
            <summary>
            A manufacturer must get a registered ID from the MMA if he wants to define his own SysEx messages, or use this one.
            </summary>
            <remarks>This ID is for educational or development use only, and should never appear in a commercial design.</remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIManufacturer.RealTime">
            <summary>
            Universal SysEx messages: realtime messages (ie, ones that need to be responded to immediately).
            </summary>
            <remarks>
            <para>After the ID byte is a SysEx Channel byte. This could be from 0 to 127 for a total of 128 SysEx channels. 
            So, although "normal" SysEx messages have no MIDI channel like Voice Category messages do, a Universal SysEx message can be sent on one of 128 SysEx channels. 
            This allows the musician to set various devices to ignore certain Universal SysEx messages (ie, if the device allows the musician to set its Base SysEx Channel. 
            Most devices just set their Base SysEx channel to the same number as the Base Channel for Voice Category messages). 
            On the other hand, a SysEx channel of 127 is actually meant to tell the device to "disregard the channel and pay attention to this message regardless".</para>
            <para>After the SysEx channel, the next two bytes are Sub IDs which tell what the SysEx is for. 
            There are several Sub IDs defined for particular messages. There is a Sub ID for a Universal SysEx message to set a device's master volume. (This is different than Volume controller which sets the volume for only one particular MIDI channel). 
            There is a Sub ID for a Universal SysEx message to set a device's Pitch Wheel bend range. There are a couple of Sub IDs for some Universal SysEx messages to implement a waveform (sample) dump over MIDI etc.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIManufacturer.NonRealTime">
            <summary>
            Universal SysEx messages: non-realtime (ie, ones which can be processed when the device gets around to it).
            </summary>
            <remarks>
            <para>After the ID byte is a SysEx Channel byte. This could be from 0 to 127 for a total of 128 SysEx channels. 
            So, although "normal" SysEx messages have no MIDI channel like Voice Category messages do, a Universal SysEx message can be sent on one of 128 SysEx channels. 
            This allows the musician to set various devices to ignore certain Universal SysEx messages (ie, if the device allows the musician to set its Base SysEx Channel. 
            Most devices just set their Base SysEx channel to the same number as the Base Channel for Voice Category messages). 
            On the other hand, a SysEx channel of 127 is actually meant to tell the device to "disregard the channel and pay attention to this message regardless".</para>
            <para>After the SysEx channel, the next two bytes are Sub IDs which tell what the SysEx is for. 
            There are several Sub IDs defined for particular messages. There is a Sub ID for a Universal SysEx message to set a device's master volume. (This is different than Volume controller which sets the volume for only one particular MIDI channel). 
            There is a Sub ID for a Universal SysEx message to set a device's Pitch Wheel bend range. There are a couple of Sub IDs for some Universal SysEx messages to implement a waveform (sample) dump over MIDI etc.</para>
            </remarks>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDI_INCAPS">
            <summary>
            Represents MIDI input device capabilities as returned by the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InGetDevCaps(System.Int32,Ten53.Multimedia.Midi.MIDI_INCAPS)"/> method.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_INCAPS.mid">
            <summary>
            Manufacturer identifier of the device driver for the MIDI input device.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_INCAPS.pid">
            <summary>
            Product identifier of the MIDI input device.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_INCAPS.driverVersion">
            <summary>
            Version number of the device driver for the MIDI input device.
            </summary>
            <remarks>The high-order byte is the major version number, and the low-order byte is the minor version number.</remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_INCAPS.name">
            <summary>
            Product name in a null-terminated string.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_INCAPS.support">
            <summary>
            Reserved; must be zero.
            </summary>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDI_INCAPS.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDI_INCAPS.ToString">
            <summary>
            Returns the name of the Midi input device.
            </summary>
            <returns>The name of the input device.</returns>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDI_OUTCAPS">
            <summary>
            Represents MIDI output device capabilities as returned by the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutGetDevCaps(System.Int32,Ten53.Multimedia.Midi.MIDI_OUTCAPS)"/> method.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_OUTCAPS.mid">
            <summary>
            Manufacturer identifier of the device driver for the MIDI output device.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_OUTCAPS.pid">
            <summary>
            Product identifier of the MIDI output device.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_OUTCAPS.driverVersion">
            <summary>
            Version number of the device driver for the MIDI output device.
            </summary>
            <remarks>The high-order byte is the major version number, and the low-order byte is the minor version number.</remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_OUTCAPS.name">
            <summary>
            Product name in a null-terminated string.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_OUTCAPS.technology">
            <summary>
            Type of the MIDI output device.
            </summary>
            <remarks>This value can be one of the <see cref="T:Ten53.Multimedia.Midi.MIDIDevice"/> values.</remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_OUTCAPS.voices">
            <summary>
            Number of voices supported by an internal synthesizer device. 
            </summary>
            <remarks>If the device is a port, this member is not meaningful and is set to 0.</remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_OUTCAPS.notes">
            <summary>
            Maximum number of simultaneous notes that can be played by an internal synthesizer device.
            </summary>
            <remarks>If the device is a port, this member is not meaningful and is set to 0.</remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_OUTCAPS.channelMask">
            <summary>
            Channels that an internal synthesizer device responds to.
            </summary>
            <remarks>
            <para>The least significant bit refers to channel 0 and the most significant bit to channel 15.</para>
            <para>Port devices that transmit on all channels set this member to 0xFFFF.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_OUTCAPS.support">
            <summary>
            Optional functionality supported by the device.
            </summary>
            <remarks>It can be one or more of the following:
            <para>MIDICAPS_CACHE (0x0004) : Supports patch caching.</para>
            <para>MIDICAPS_LRVOLUME (0x0002) : Supports separate left and right volume control.</para>
            <para>MIDICAPS_STREAM (0x0008) : Provides direct support for the StreamOut function.</para>
            <para>MIDICAPS_VOLUME (0x0001) : Supports volume control.</para>
            <para>If a device supports volume changes, the MIDICAPS_VOLUME flag will be set for the support member. If a device supports separate volume changes on the left and right channels, both the MIDICAPS_VOLUME and the MIDICAPS_LRVOLUME flags will be set for this member.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDI_OUTCAPS.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDI_OUTCAPS.ToString">
            <summary>
            Returns the name of the Midi output device.
            </summary>
            <returns>The name of the output device.</returns>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_OUTCAPS.SupportsCache">
            <summary>
            Supports patch caching?
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_OUTCAPS.SupportsLRVolume">
            <summary>
            Supports separate left and right volume control?
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_OUTCAPS.SupportsVolume">
            <summary>
            Supports volume control?
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_OUTCAPS.SupportsStream">
            <summary>
            Provides direct support for the StreamOut function?
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_OUTCAPS.IsMidiPort">
            <summary>
            Is the device a Midi output port?
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_OUTCAPS.IsMidiMapper">
            <summary>
            Is the device a Midi mapper?
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIHDR">
            <summary>
            Represents the Windows Multimedia MIDIHDR structure.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHDR.data">
            <summary>
            Pointer to MIDI data.
            </summary>
            <remarks>Typically a pointer to a byte array containing the data or a null-terminated string of 8-bit Windows (ANSI) characters.</remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHDR.bufferLength">
            <summary>
            Size of the buffer.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHDR.bytesRecorded">
            <summary>
            Actual amount of data in the buffer.
            </summary>
            <remarks>This value should be less than or equal to the value given in the <see cref="F:Ten53.Multimedia.Midi.MIDIHDR.bufferLength"/> member.</remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHDR.user">
            <summary>
            Custom user data.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHDR.flags">
            <summary>
            Flags giving information about the buffer (see <see cref="T:Ten53.Multimedia.Midi.MIDIHeader"/> for more information).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHDR.next">
            <summary>
            Reserved for driver (do not use).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHDR.reserved">
            <summary>
            Reserved for driver (do not use).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHDR.offset">
            <summary>
            Offset into the buffer when a callback is performed.
            </summary>
            <remarks>This callback is generated because the MEVT_F_CALLBACK flag is set in the event member of the MidiEventArgs structure.
            <para>This offset enables an application to determine which event caused the callback.</para>
            </remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDIHDR.reservedArray">
            <summary>
            Reserved for MMSYSTEM (do not use).
            </summary>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDIHDR.#ctor">
            <summary>
            Initializes a new instance of the MIDI_HEADER.
            </summary>
            <remarks>
            <para>In order to use the MIDIHDR with a Midi function (e.g. <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/>) you must first call the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/>/<see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutPrepareHeader(System.IntPtr,System.IntPtr)"/> methods.</para>
            <para>Make sure, that you always call <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InUnprepareHeader(System.IntPtr,System.IntPtr)"/>/<see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutUnprepareHeader(System.IntPtr,System.IntPtr)"/> once you prepared the header in order to release all unmanaged recourses!</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDIHDR.ToString">
            <summary>
            Returns the recorded data buffer as a string.
            </summary>
            <returns>The string representation of the Midi data in the header buffer.</returns>
            <remarks>If no pointer to the data exists NULL will be returned. If the bytesRecorded is zero an empty string will be returned - 
            else a hexadecimal representation of the byte array of the data will be returned, e.g. "F0 41 00 ... F7".</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDIHDR.GetData">
            <summary>
            Returns the Midi data member as a byte array.
            </summary>
            <returns>The available data as a byte[] (will return IntPtr.Zero if no data is present or an empty array, if the bytesRecorded member is zero).</returns>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDIHDR.Reset">
            <summary>
            Resets all internal values.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDIHDR.IsDone">
            <summary>
            Indicate if the device driver is finished with the buffer and is returning it to the application.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDIHDR.IsPrepared">
            <summary>
            Indicate if the buffer has been prepared by using the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutPrepareHeader(System.IntPtr,System.IntPtr)"/> function.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDIHDR.IsStreamBuffer">
            <summary>
            Indicate if the buffer is a stream buffer.
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDI_HEADER">
            <summary>
            Represents a wrapper for the Windows Multimedia MIDIHDR structure.
            </summary>
            <remarks>
            <para>In order to use the MIDI_HEADER with a Midi function (e.g. <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/>) you must first call the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> method which provides a <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/> to be used.</para>
            <para>After you send a system-exclusive data block, you must wait until the device driver is finished with the data block before freeing it. If you are sending multiple data blocks, you must monitor the completion of each data block so you know when to send additional blocks.</para>
            <para>Once the MIDI_HEADER is used, your application will be notified with a callback procedure (see <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> or <see cref="T:Ten53.Multimedia.Midi.MIDIOUTPROC"/>) when a system-exclusive buffer has been filled with data and is being returned to the application.
            The <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/> message is sent to a MIDI input callback function - the <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MOM_DONE"/> message is sent to a MIDI output callback function in such case. 
            The param1 parameter of the callback will give you the pointer to the MIDI_HEADER structure identifying the input buffer.
            Use the constructor taking a headerPtr to create a MIDI_HEADER from such pointer!</para>
            <para>Make sure, that you always call <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Unprepare(System.Boolean,System.IntPtr)"/> once you prepared the header with the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> method in order to release all unmanaged recourses (this is at best done within the callback procedure)!</para>
            <para>Internally the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> and <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Unprepare(System.Boolean,System.IntPtr)"/> methods will use the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/>, <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutPrepareHeader(System.IntPtr,System.IntPtr)"/> resp. <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InUnprepareHeader(System.IntPtr,System.IntPtr)"/>, <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutUnprepareHeader(System.IntPtr,System.IntPtr)"/>.</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDI_HEADER.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the MIDI_HEADER with an empty data buffer of the given size.
            </summary>
            <param name="size">The number of bytes for the data buffer (between 2 and 65536).</param>
            <remarks>
            <para>If a <paramref name="size"/> is given outside the range of 2 and 65536 the default size of 256 will be used.</para>
            <para>In order to use the MIDI_HEADER with a Midi function (e.g. <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/>) you must first call the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> method which provides a <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/> to be used.</para>
            <para>Make sure, that you always call <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Unprepare(System.Boolean,System.IntPtr)"/> once you prepared the header with the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> method and received back the header from the Midi device in order to release all unmanaged recourses!</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDI_HEADER.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the MIDI_HEADER with the given data buffer.
            </summary>
            <param name="data">The byte array to use as the data buffer.</param>
            <remarks>
            <para>In order to use the MIDI_HEADER with a Midi function (e.g. <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/>) you must first call the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> method which provides a <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/> to be used.</para>
            <para>Make sure, that you always call <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Unprepare(System.Boolean,System.IntPtr)"/> once you prepared the header with the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> method and received back the header from the Midi device in order to release all unmanaged recourses!</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDI_HEADER.#ctor(System.String)">
            <summary>
            Initializes a new instance of the MIDI_HEADER with the string as the data buffer.
            </summary>
            <param name="data">The string to use as the data buffer (the string characters will be copied to the <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.Data"/> buffer as byte values plus a final terminating null-byte).</param>
            <remarks>
            <para>In order to use the MIDI_HEADER with a Midi function (e.g. <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/>) you must first call the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> method which provides a <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/> to be used.</para>
            <para>Make sure, that you always call <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Unprepare(System.Boolean,System.IntPtr)"/> once you prepared the header with the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> method and received back the header from the Midi device in order to release all unmanaged recourses!</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDI_HEADER.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the MIDI_HEADER from a given Midi header pointer.
            </summary>
            <param name="headerPtr">The pointer to the MIDIHDR structure (e.g. as received in a <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> or <see cref="T:Ten53.Multimedia.Midi.MIDIOUTPROC"/>).</param>
            <remarks>
            <para>In order to use the MIDI_HEADER with a Midi function (e.g. <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/>) you must first call the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> method which provides a <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/> to be used.</para>
            <para>After you send a system-exclusive data block, you must wait until the device driver is finished with the data block before freeing it. If you are sending multiple data blocks, you must monitor the completion of each data block so you know when to send additional blocks.</para>
            <para>Once the MIDI_HEADER is used, your application will be notified with a callback procedure (see <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> or <see cref="T:Ten53.Multimedia.Midi.MIDIOUTPROC"/>) when a system-exclusive buffer has been filled with data and is being returned to the application.
            The <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/> message is sent to a MIDI input callback function - the <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MOM_DONE"/> message is sent to a MIDI output callback function in such case. 
            The param1 parameter of the callback will give you the pointer to the MIDI_HEADER structure identifying the input buffer.
            Use this method to create a MIDI_HEADER from such pointer!</para>
            <para>Make sure, that you always call <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Unprepare(System.Boolean,System.IntPtr)"/> in order to release all unmanaged recourses (this is at best done within the callback procedure)!</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDI_HEADER.ToString">
            <summary>
            Returns the <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.Data"/> buffer as a string.
            </summary>
            <returns>The string representation of the Midi data in the header buffer.</returns>
            <remarks>If no data exists an empty string will be returned - else a hexadecimal representation of the byte array of the data will be returned, e.g. "F0 41 00 ... F7".</remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)">
            <summary>
            Prepares the MIDI_HEADER structure and sets the <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/> member.
            </summary>
            <param name="input">Dealing with a Midi input device? (TRUE=input, FALSE=output).</param>
            <param name="handle">The handle to the MIDI device.</param>
            <returns>TRUE on success (use the <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/> to access the prepared MIDIHDR structure) - else FALSE.</returns>
            <remarks>
            <para>The returned <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/> can be used e.g. with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> methods.</para>
            <para>Internally the MIDIHDR (see <see cref="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr"/>) will be prepared using the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InPrepareHeader(System.IntPtr,System.IntPtr)"/> resp. <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutPrepareHeader(System.IntPtr,System.IntPtr)"/> depending on the <paramref name="input"/> parameter.</para>
            <para>Note: This method allocates unmanaged memory and copies this MIDI_HEADER structure to that memory. 
            So there is no need to keep a reference to the MIDI_HEADER instance in your application, since you will be notified in a <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> or <see cref="T:Ten53.Multimedia.Midi.MIDIOUTPROC"/> when the Midi device has finished with the buffer and provides back a pointer to the MIDIHDR structure.
            You might then use the constructor overload taking a headerPtr to (re)create an instance of this class.</para>
            <para>Make sure, that you always call <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Unprepare(System.Boolean,System.IntPtr)"/> in order to release all unmanaged recourses (this is at best done within the callback procedure)!</para>
            </remarks>
        </member>
        <member name="M:Ten53.Multimedia.Midi.MIDI_HEADER.Unprepare(System.Boolean,System.IntPtr)">
            <summary>
            Unprepares the MIDI_HEADER structure and frees all used resources.
            </summary>
            <param name="input">Dealing with a Midi input device? (TRUE=input, FALSE=output).</param>
            <param name="handle">The handle to the MIDI device.</param>
            <remarks>This function is complementary to <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/>. You must call this method in order to free all uses and allocated resources. 
            After passing a MIDIHDR structure to a Midi device by using the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/> function, you must wait until the driver is finished with the MIDIHDR before using <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InUnprepareHeader(System.IntPtr,System.IntPtr)"/> (this is at best done within the callback procedure <see cref="T:Ten53.Multimedia.Midi.MIDIINPROC"/> resp. <see cref="T:Ten53.Multimedia.Midi.MIDIOUTPROC"/>).
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_HEADER.Data">
            <summary>
            The MIDI data buffer.
            </summary>
            <remarks>Typically a byte array containing the data or a null-terminated string of 8-bit Windows (ANSI) characters.
            <para>Once you prepared the data buffer with <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> you might not change the buffer.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_HEADER.User">
            <summary>
            Custom user data.
            </summary>
            <remarks>
            <para>Once you prepared the data buffer with <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> you might not change the user data.</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_HEADER.Flags">
            <summary>
            Gets the flags giving information about the buffer (see <see cref="T:Ten53.Multimedia.Midi.MIDIHeader"/> for more information).
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_HEADER.HeaderPtr">
            <summary>
            Gets the pointer to the prepared MIDIHDR structure (or IntPtr.Zero if the header was not prepared).
            </summary>
            <remarks>Access this member to retrieve a pointer to the MIDIHDR structure.
            <para>In order to use the MIDI_HEADER with a Midi function (e.g. <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InAddBuffer(System.IntPtr,System.IntPtr)"/> or <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/>) you must first call the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> method which provides this member.</para>
            <para>Make sure, that you always call <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Unprepare(System.Boolean,System.IntPtr)"/> once you prepared the header with the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> method and received back the header from the Midi device in order to release all unmanaged recourses!</para>
            </remarks>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_HEADER.IsDone">
            <summary>
            Indicates if the device driver is finished with the buffer and is returning it to the application.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_HEADER.IsPrepared">
            <summary>
            Indicates if the buffer has been prepared by using the <see cref="M:Ten53.Multimedia.Midi.MIDI_HEADER.Prepare(System.Boolean,System.IntPtr)"/> method.
            </summary>
        </member>
        <member name="P:Ten53.Multimedia.Midi.MIDI_HEADER.IsStreamBuffer">
            <summary>
            Indicates if the buffer is a stream buffer.
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDI_TIME">
            <summary>
            Represents the Windows Multimedia MMTIME structure.
            </summary>
            <remarks>The MIDI_TIME structure contains timing information for different types of multimedia data.</remarks>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.type">
            <summary>
            Time format. It can be one of the following values (see <see cref="T:Ten53.Multimedia.Midi.MIDITimeType"/>).
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.ms">
            <summary>
            Number of milliseconds. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_MS"/>.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.sample">
            <summary>
            Number of samples. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_SAMPLES"/>.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.cb">
            <summary>
            Byte count. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_BYTES"/>.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.ticks">
            <summary>
            Ticks in MIDI stream. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_TICKS"/>.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.hour">
            <summary>
            Hours - SMPTE time structure. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_SMPTE"/>.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.min">
            <summary>
            Minutes - SMPTE time structure. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_SMPTE"/>.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.sec">
            <summary>
            Seconds - SMPTE time structure. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_SMPTE"/>.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.frame">
            <summary>
            Frames - SMPTE time structure. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_SMPTE"/>.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.fps">
            <summary>
            Frames per second (24, 25, 29 (30 drop), or 30) - SMPTE time structure. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_SMPTE"/>.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.dummy">
            <summary>
            Dummy byte for alignment - SMPTE time structure. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_SMPTE"/>.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.pad1">
            <summary>
            Padding1 - SMPTE time structure. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_SMPTE"/>.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.pad2">
            <summary>
            Padding2 - SMPTE time structure. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_SMPTE"/>.
            </summary>
        </member>
        <member name="F:Ten53.Multimedia.Midi.MIDI_TIME.songptrpos">
            <summary>
            Song pointer position. MIDI time structure. Used when type is <see cref="F:Ten53.Multimedia.Midi.MIDITimeType.TIME_MIDI"/>.
            </summary>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIOUTPROC">
            <summary>
            Represents the general callback delegate for handling Midi Output messages.
            </summary>
            <param name="handle">Handle to the MIDI output device.</param>
            <param name="msg">MIDI output message (one of the <see cref="T:Ten53.Multimedia.Midi.MIDIMessage"/>).</param>
            <param name="instance">Instance data supplied with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIOUTPROC,System.IntPtr)"/> method.</param>
            <param name="param1">Message parameter 1.</param>
            <param name="param2">Message parameter 2.</param>
            <remarks>
            <para>NOTE: <paramref name="instance"/>, <paramref name="param1"/> and <paramref name="param2"/> are implemented here as IntPtr values for maximum Win32 and Win64 compatibility.
            If the parameters are actually numerial values you might use the ToInt32() resp. ToInt64() members to convert to these values.</para>
            <para>The meaning of the <paramref name="param1"/> and <paramref name="param2"/> parameters is specific to the message type.
            The <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MOM_DONE"/> message might be used with the <see cref="T:Ten53.Multimedia.Midi.MidiSysExMessage"/> class to construct and unpack the message into it's components.</para>
            <para>If param1 contains a pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure you might use the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> constructor overload taking a headerPtr in order to create an instance of a MIDI_HEADER in such case.</para>
            <para>Applications should not call any system-defined functions from inside a callback function, except for <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/>, <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutShortMsg(System.IntPtr,System.Int32)"/>. Calling other wave functions will cause deadlock.</para>
            <para>Also note, that you should not make any GUI control changes within this procedure. If needed use an Invoke to make sure to execute GUI changes in the related GUI thread.</para>
            </remarks>
            <example>
            <code>
            private MIDIOUTPROC _midiProc;
            private IntPtr _midiOutHandle;
            ...
            // Open the Midi device #2
            _midiProc = new MIDIOUTPROC(MyMidiProc);
            MIDIError ret = Midi.MIDI_OutOpen(ref _midiOutHandle, 2, _midiProc, 0);
            if (ret == MIDIError.MIDI_OK)
            {
              // output ready
            }
            ...
            // when not needed anymore...stop the device
            Midi.MIDI_OutReset(_midiOutHandle);
            // and close the device
            Midi.MIDI_OutClose(_midiOutHandle);
            ...
            
            private void Send(int handle, int message)
            {
              int result = MIDI_OutShortMsg(handle, message);
            }
            
            private void SendSysExBuffer(IntPtr handle, byte[] data)
            {
              MIDI_HEADER header = new MIDI_HEADER(data);
              header.Prepare(false, handle);
              // If the header was perpared successfully.
              if (header.HeaderPtr != IntPtr.Zero)
              {
                // send a system-exclusive message to the output device
                Midi.MIDI_OutLongMsg(handle, header.HeaderPtr);
              }
            }
            
            public void MyMidiProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
              // handle all Midi messages here
              if(msg == MIDIMessage.MOM_OPEN)
              {
                // nothing to do
              }
              else if (msg == MIDIMessage.MOM_CLOSE)
              {
                // handle is from now on invalid
              }
              else if (msg == MIDIMessage.MOM_DONE)
              {
                // process the message...
                // param1 will contain the pointer to the MIDI_HEADER
                MIDI_HEADER header = new MIDI_HEADER(param1);
                byte[] data = header.Data;
                header.Unprepare(false, handle);
                ...
                // or
                MidiSysExMessage sysExMsg = new MidiSysExMessage(false, handle, param1);
                ...
              }
            }
            </code>
            <code lang="vbnet">
            Private _midiProc As MIDIOUTPROC
            Private _midiOutHandle As IntPtr
            ...
            ' Open the Midi device #2
            _midiProc = New MIDIOUTPROC(AddressOf MyMidiProc)
            Dim ret As MIDIError = Midi.MIDI_OutOpen(_midiOutHandle, 2, _midiProc, 0)
            If ret = MIDIError.MIDI_OK Then
              ' output ready
            End If
            ...
            ' when not needed anymore...stop the device
            Midi.MIDI_OutReset(_midiOutHandle)
            ' and close the device
            Midi.MIDI_OutClose(_midiOutHandle)
            ...
            
            Private Sub Send(handle As Integer, message As Integer)
              Dim result As Integer = MIDI_OutShortMsg(handle, message)
            End Sub
            
            Private Sub SendSysExBuffer(handle As IntPtr, data() As Byte)
              Dim header As New MIDI_HEADER(data)
              header.Prepare(False, handle)
              ' If the header was perpared successfully.
              If header.HeaderPtr &lt;&gt; IntPtr.Zero Then
                ' send a system-exclusive message to the output device
                Midi.MIDI_OutLongMsg(handle, header.HeaderPtr)
              End If
            End Sub
            
            Public Sub MyMidiProc(handle As IntPtr, msg As MIDIMessage, instance As IntPtr, param1 As IntPtr, param2 As IntPtr)
              ' handle all Midi messages here
              If msg = MIDIMessage.MOM_OPEN Then
                ' nothing to do
              Else
                If msg = MIDIMessage.MOM_CLOSE Then
                  ' handle is from now on invalid
                Else
                  If msg = MIDIMessage.MOM_DONE Then
                    ' process the message...
                    ' param1 will contain the pointer to the MIDI_HEADER
                    Dim header As New MIDI_HEADER(param1)
                    Dim data As Byte() = header.Data
                    header.Unprepare(False, handle)
                    ...
                    ' or
                    Dim sysExMsg As New MidiSysExMessage(False, handle, param1)
                    ...
                  End If 
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="T:Ten53.Multimedia.Midi.MIDIINPROC">
            <summary>
            Represents the general callback delegate for handling Midi Input messages.
            </summary>
            <param name="handle">Handle to the MIDI input device.</param>
            <param name="msg">MIDI input message (one of the MIM_xxx values, see <see cref="T:Ten53.Multimedia.Midi.MIDIMessage"/>).</param>
            <param name="instance">Instance data supplied with the <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_InOpen(System.IntPtr@,System.Int32,Ten53.Multimedia.Midi.MIDIINPROC,System.IntPtr,Ten53.Multimedia.Midi.MIDIFlags)"/> method.</param>
            <param name="param1">Message parameter 1.</param>
            <param name="param2">Message parameter 2.</param>
            <remarks>
            <para>NOTE: <paramref name="instance"/>, <paramref name="param1"/> and <paramref name="param2"/> are implemented here as IntPtr values for maximum Win32 and Win64 compatibility.
            If the parameters are actually numerial values you might use the ToInt32() resp. ToInt64() members to convert to these values.</para>
            <para>The meaning of the <paramref name="param1"/> and <paramref name="param2"/> parameters is specific to the message type. For more info see <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_DATA"/>.
            The <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_DATA"/> or <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_ERROR"/> message might be used with the <see cref="T:Ten53.Multimedia.Midi.MidiShortMessage"/> class to construct and unpack the message into it's components.
            The <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGDATA"/> or <see cref="F:Ten53.Multimedia.Midi.MIDIMessage.MIM_LONGERROR"/> message might be used with the <see cref="T:Ten53.Multimedia.Midi.MidiSysExMessage"/> class to construct and unpack the message into it's components.</para>
            <para>If param1 contains a pointer to a <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> structure you might use the <see cref="T:Ten53.Multimedia.Midi.MIDI_HEADER"/> constructor overload taking a headerPtr in order to create an instance of a MIDI_HEADER in such case.</para>
            <para>Applications should not call any system-defined functions from inside a callback function, except for <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutLongMsg(System.IntPtr,System.IntPtr)"/>, <see cref="M:Ten53.Multimedia.Midi.Midi.MIDI_OutShortMsg(System.IntPtr,System.Int32)"/>.</para>
            <para>Also note, that you should not make any GUI control changes within this procedure. If needed use an Invoke to make sure to execute GUI changes in the related GUI thread.</para>
            </remarks>
            <example>
            <code>
            private MIDIINPROC _midiProc;
            private IntPtr _midiInHandle;
            ...
            // Open the Midi device #2
            _midiProc = new MIDIINPROC(MyMidiProc);
            MIDIError ret = Midi.MIDI_InOpen(ref _midiInHandle, 2, _midiProc, IntPtr.Zero, MIDIFlags.MIDI_IO_STATUS);
            if (ret == MIDIError.MIDI_OK)
            {
              // supply the device with 2 buffers
              AddSysExBuffer(_midiInHandle, 1024);
              AddSysExBuffer(_midiInHandle, 1024);
              // Start the device
              ret = Midi.MIDI_InStart(_midiInHandle);
            }
            ...
            // Stop the device
            Midi.MIDI_InReset(_midiInHandle);
            // when not needed anymore...close the device
            Midi.MIDI_InClose(_midiInHandle);
            ...
            // prepare receiving system-exclusive messages
            private void AddSysExBuffer(IntPtr handle, int size)
            {
              // prepare a empty midi header
              MIDI_HEADER header = new MIDI_HEADER(size);
              header.Prepare(true, handle);
              // If the header was perpared successfully.
              if (header.HeaderPtr != IntPtr.Zero)
              {
                // Add the buffer to the InputDevice.
                Midi.MIDI_InAddBuffer(handle, header.HeaderPtr);
              }
            }
            
            public void MyMidiProc(IntPtr handle, MIDIMessage msg, IntPtr instance, IntPtr param1, IntPtr param2)
            {
              // handle all Midi messages here
              if (msg == MIDIMessage.MIM_OPEN)
              {
                // nothing to do
              }
              else if (msg == MIDIMessage.MIM_CLOSE)
              {
                // handle is from now on invalid
              }
              else if (msg == MIDIMessage.MIM_DATA)
              {
                // process the message...
                int p1 = param1.ToInt32();
                int p2 = param2.ToInt32();
                ...
                // or
                MidiShortMessage shortMsg = new MidiShortMessage(param1, param2);
                ...
              }
              else if (msg == MIDIMessage.MIM_MOREDATA)
              {
                // we are not fast enough in this callback to keep up
                // the input device is sending messages to fast
                ...
              }
              else if (msg == MIDIMessage.MIM_LONGDATA)
              {
                // process the message...
                // param1 will contain the pointer to the MIDI_HEADER
                MIDI_HEADER header = MIDI_HEADER(param1);
                byte[] data = header.Data;
                ...
                header.Unprepare(true, handle);
                // add a new buffer
                // since we should constantly provide new buffers until we finished recording
                AddSysExBuffer(handle, 1024);
              }
              else if (msg == MIDIMessage.MIM_ERROR)
              {
                // process the invalid message...
                MidiShortMessage errorMsg = new MidiShortMessage(param1, param2);
                ...
              }
              else if (msg == MIDIMessage.MIM_LONGERROR)
              {
                // process the invalid message...
                // param1 will contain the pointer to the MIDI_HEADER
                MidiSysExMessage errorSysExMsg = new MidiSysExMessage(true, handle, param1);
                ...
                // add a new buffer
                // since we should constantly provide new buffers until we finished recording
                AddSysExBuffer(handle, 1024);
              }
            }
            </code>
            <code lang="vbnet">
            Private _midiProc As MIDIINPROC
            Private _midiInHandle As IntPtr
            ...
            ' Open the Midi device #2
            _midiProc = New MIDIINPROC(AddressOf MyMidiProc)
            Dim ret As MIDIError = Midi.MIDI_InOpen(_midiInHandle, 2, _midiProc, IntPtr.Zero, MIDIFlags.MIDI_IO_STATUS)
            If ret = MIDIError.MIDI_OK Then
              ' supply the device with 2 buffers
              AddSysExBuffer(_midiInHandle, 1024)
              AddSysExBuffer(_midiInHandle, 1024)
              ' Start the device
              ret = Midi.MIDI_InStart(_midiInHandle)
            End If
            ...
            ' Stop the device
            Midi.MIDI_InReset(_midiInHandle)
            ' when not needed anymore...close the device
            Midi.MIDI_InClose(_midiInHandle)
            ...
            ' prepare receiving system-exclusive messages
            Private Sub AddSysExBuffer(handle As IntPtr, size As Integer)
              ' prepare a empty midi header
              Dim header As New MIDI_HEADER(size)
              header.Prepare(True, handle)
              ' If the header was perpared successfully.
              If header.HeaderPtr &lt;&gt; IntPtr.Zero Then
                ' Add the buffer to the InputDevice.
                Midi.MIDI_InAddBuffer(handle, header.HeaderPtr)
              End If
            End Sub
            
            Public Sub MyMidiProc(handle As IntPtr, msg As MIDIMessage, instance As IntPtr, param1 As IntPtr, param2 As IntPtr)
              ' handle all Midi messages here
              If msg = MIDIMessage.MIM_OPEN Then
                ' nothing to do
              Else
                If msg = MIDIMessage.MIM_CLOSE Then
                  ' handle is from now on invalid
                Else
                  If msg = MIDIMessage.MIM_DATA Then
                    ' process the message...
                    Dim p1 As Integer = param1.ToInt32()
                    Dim p2 As Integer = param2.ToInt32()
                    ...
                    ' or
                    Dim shortMsg As New MidiShortMessage(param1, param2)
                    ...
                  Else
                    If msg = MIDIMessage.MIM_MOREDATA Then
                      ' we are not fast enough in this callback to keep up
                      ' the input device is sending messages to fast
                      ...
                    Else
                      If msg = MIDIMessage.MIM_LONGDATA Then
                        ' process the message...
                        ' param1 will contain the pointer to the MIDI_HEADER
                        Dim header As MIDI_HEADER = MIDI_HEADER(param1)
                        Dim data As Byte() = header.Data
                        ...
                        header.Unprepare(True, handle)
                        ' add a new buffer
                        ' since we should constantly provide new buffers until we finished recording
                        AddSysExBuffer(handle, 1024)
                      Else
                        If msg = MIDIMessage.MIM_ERROR Then
                          ' process the invalid message...
                          Dim errorMsg As New MidiShortMessage(param1, param2)
                          ...
                        Else
                          If msg = MIDIMessage.MIM_LONGERROR Then
                            ' process the invalid message...
                            ' param1 will contain the pointer to the MIDI_HEADER
                            Dim errorSysExMsg As New MidiSysExMessage(True, handle, param1)
                            ...
                            ' add a new buffer
                            ' since we should constantly provide new buffers until we finished recording
                            AddSysExBuffer(handle, 1024)
                          End If
                        End If
                      End If
                    End If
                  End If
                End If
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.Misc.Visuals">
            <summary>
            Provides general visualisation methods to generate spectrum analyzers etc.
            <para>Requires: bass.dll - available @ www.un4seen.com</para>
            </summary>
            <remarks>
            <para>The Visuals class is an internal implementation of the BASS.NET API and does not require any additional extension or add-on to the BASS audio library, meaning only bass.dll is required.</para>
            <para>There is the need to create an instance of the class in order to use it!</para>
            <para>Most create spectrum methods have two overloads. One which directly creates a bitmap image (e.g. to be used with a PictureBox) and one which receives a Graphics GDI+ object (e.g. to be used when you build your own custom components).</para>
            <para>Take a look at the Simple.cs demo code for a list of all spectrum graphs available. All methods accept a long list of parameters to even customize each spectrum graph.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.#ctor">
            <summary>
            Default constructor. Simply create an instance and use it.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.Visuals._fft">
            <summary>
            Global FFT sample buffer
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.GetFrequencyFromPosX(System.Int32,System.Int32)">
            <summary>
            Returns the frequency in Hz represented by the given X coordinate position of a visual control.
            </summary>
            <param name="x">The X coordinate from which to get the frequency (between 0 and control.Width-1).</param>
            <param name="samplerate">The current samplerate of the channel which was used to render the visual (e.g. use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve the current samplerate of the respective channel).</param>
            <returns>The frequency in Hz which is represented by the X coordinate of the visual.</returns>
            <remarks>The X coordinate position represents the zero based pixel number of the visual control being rendered.</remarks>
            <example>
            In the following example a pictureBox control is assumed being used:
            <code>
            private void pictureBoxSpectrum_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
            {
              if (_vis == null)
                 return;
              int freq = _vis.GetFrequencyFromPosX(e.X, 44100);
              float amp = _vis.GetAmplitudeFromPosY(e.Y, this.pictureBoxSpectrum.Height);
              this.labelVis.Text = String.Format( "Freq={0}Hz, Amp={1}", freq, amp );
            }
            </code>
            <code lang="vbnet">
            Private Sub pictureBoxSpectrum_MouseMove(sender As Object, e As System.Windows.Forms.MouseEventArgs)
              If _vis Is Nothing Then
                Return
              End If
              Dim freq As Integer = _vis.GetFrequencyFromPosX(e.X, 44100)
              Dim amp As Single = _vis.GetAmplitudeFromPosY(e.Y, Me.pictureBoxSpectrum.Height)
              Me.labelVis.Text = [String].Format("Freq={0}Hz, Amp={1}", freq, amp)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.GetAmplitudeFromPosY(System.Int32,System.Int32)">
            <summary>
            Returns the amplitude (power) as a float value which is represented by the given Y coordinate position of a visual control.
            </summary>
            <param name="y">The Y coordinate from which to get the amplitude (between 0 and control.Height-1).</param>
            <param name="height">The maximum height of the visual control which was used to display the visual (e.g. pictureBox.Height).</param>
            <returns>The amplitude or power as a float value (between 0.0 and 1.0) which is represented by the Y coordinate of the visual.</returns>
            <remarks>The Y coordinate position represents the zero based pixel number of the visual control being rendered.</remarks>
            <example>
            In the following example a pictureBox control is assumed being used:
            <code>
            private void pictureBoxSpectrum_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
            {
              if (_vis == null)
                return;
              int freq = _vis.GetFrequencyFromPosX(e.X, 44100);
              float amp = _vis.GetAmplitudeFromPosY(e.Y, this.pictureBoxSpectrum.Height);
              this.labelVis.Text = String.Format( "Freq={0}Hz, Amp={1}", freq, amp );
            }
            </code>
            <code lang="vbnet">
            Private Sub pictureBoxSpectrum_MouseMove(sender As Object, e As System.Windows.Forms.MouseEventArgs)
              If _vis Is Nothing Then
                Return
              End If
              Dim freq As Integer = _vis.GetFrequencyFromPosX(e.X, 44100)
              Dim amp As Single = _vis.GetAmplitudeFromPosY(e.Y, Me.pictureBoxSpectrum.Height)
              Me.labelVis.Text = [String].Format("Freq={0}Hz, Amp={1}", freq, amp)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrum(System.Int32,System.Int32,System.Int32,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a bitmap representing a FFT spectrum graph.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="width">The width (in pixel) of the image to create.</param>
            <param name="height">The height (in pixel) of the image to create.</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>The created bitmap image representing the spectrum.</returns>
            <example>
            Using the following code in a timer routine (e.g. updated every 50ms):
            <code>
            this.pictureBoxSpectrum.Image = Un4seen.Bass.Misc.Visuals.CreateSpectrum(_stream, 
                                              this.pictureBoxSpectrum.Width, 
                                              this.pictureBoxSpectrum.Height, 
                                              Color.Lime, Color.Red, Color.Black, 
                                              false, false, false);
            </code>
            <code lang="vbnet">
            Me.pictureBoxSpectrum.Image = Un4seen.Bass.Misc.Visuals.CreateSpectrum(_stream, 
                                            Me.pictureBoxSpectrum.Width, 
                                            Me.pictureBoxSpectrum.Height, 
                                            Color.Lime, Color.Red, Color.Black, 
                                            False, False, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrum(System.Int32,System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Draws the spectrum graph directly on the provided GDI+ graphics.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="g">The GDI+ graphics object where to draw the wave form (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="clipRectangle">The rectangle describing the size of the wave form to draw (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>TRUE, if successfully painted, else FALSE.</returns>
            <remarks>This overload is most useful when you are developing your own custom control. You might use it directly within your paint overload implementation.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumLine(System.Int32,System.Int32,System.Int32,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a bitmap representing a FFT spectrum line graph.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="width">The width (in pixel) of the image to create.</param>
            <param name="height">The height (in pixel) of the image to create.</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="linewidth">The thickness of the line (in pixel).</param>
            <param name="distance">The distance between the lines (in pixel).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>The created bitmap image representing the spectrum.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumLine(System.Int32,System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Draws the spectrum line graph directly on the provided GDI+ graphics.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="g">The GDI+ graphics object where to draw the wave form (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="clipRectangle">The rectangle describing the size of the wave form to draw (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="linewidth">The thickness of the line (in pixel).</param>
            <param name="distance">The distance between the lines (in pixel).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>TRUE, if successfully painted, else FALSE.</returns>
            <remarks>This overload is most useful when you are developing your own custom control. You might use it directly within your paint overload implementation.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumEllipse(System.Int32,System.Int32,System.Int32,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a bitmap representing a FFT spectrum ellipse graph.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="width">The width (in pixel) of the image to create.</param>
            <param name="height">The height (in pixel) of the image to create.</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="linewidth">The thickness of the line (in pixel).</param>
            <param name="distance">The distance between the ellipses (in pixel).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>The created bitmap image representing the spectrum.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumEllipse(System.Int32,System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Draws the spectrum ellipse graph directly on the provided GDI+ graphics.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="g">The GDI+ graphics object where to draw the wave form (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="clipRectangle">The rectangle describing the size of the wave form to draw (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="linewidth">The thickness of the line (in pixel).</param>
            <param name="distance">The distance between the ellipses (in pixel).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>TRUE, if successfully painted, else FALSE.</returns>
            <remarks>This overload is most useful when you are developing your own custom control. You might use it directly within your paint overload implementation.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumDot(System.Int32,System.Int32,System.Int32,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a bitmap representing a FFT spectrum dot graph.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="width">The width (in pixel) of the image to create.</param>
            <param name="height">The height (in pixel) of the image to create.</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="dotwidth">The thickness of the dot (in pixel).</param>
            <param name="distance">The distance between the dots (in pixel).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>The created bitmap image representing the spectrum.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumDot(System.Int32,System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Draws the spectrum line graph directly on the provided GDI+ graphics.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="g">The GDI+ graphics object where to draw the wave form (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="clipRectangle">The rectangle describing the size of the wave form to draw (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="dotwidth">The thickness of the dot (in pixel).</param>
            <param name="distance">The distance between the dots (in pixel).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>TRUE, if successfully painted, else FALSE.</returns>
            <remarks>This overload is most useful when you are developing your own custom control. You might use it directly within your paint overload implementation.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumLinePeak(System.Int32,System.Int32,System.Int32,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a bitmap representing a FFT spectrum line graph with peak hold.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="width">The width (in pixel) of the image to create.</param>
            <param name="height">The height (in pixel) of the image to create.</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="color3">The peak hold color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="linewidth">The thickness of the line (in pixel).</param>
            <param name="peakwidth">The thickness of the peak line (in pixel).</param>
            <param name="distance">The distance between the lines (in pixel).</param>
            <param name="peakdelay">The delay how fast the peaks should fall (0=no delay, the higher the value, the slower the peaks will fall).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>The created bitmap image representing the spectrum.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumLinePeak(System.Int32,System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Draws the spectrum line graph with peak hold directly on the provided GDI+ graphics.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="g">The GDI+ graphics object where to draw the wave form (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="clipRectangle">The rectangle describing the size of the wave form to draw (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="color3">The peak hold color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="linewidth">The thickness of the line (in pixel).</param>
            <param name="distance">The distance between the lines (in pixel).</param>
            <param name="peakdelay">The delay how fast the peaks should fall (0=no delay, the higher the value, the slower the peaks will fall).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>TRUE, if successfully painted, else FALSE.</returns>
            <remarks>This overload is most useful when you are developing your own custom control. You might use it directly within your paint overload implementation.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.ClearPeaks">
            <summary>
            Clears all last peak values. This is needed, if you changed from one peak spectrum to another or if you change a channel, to make sure no old history data is present.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumWave(System.Int32,System.Int32,System.Int32,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a bitmap representing a FFT spectrum wave graph.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="width">The width (in pixel) of the image to create.</param>
            <param name="height">The height (in pixel) of the image to create.</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="linewidth">The thickness of the line (in pixel).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>The created bitmap image representing the spectrum.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumWave(System.Int32,System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Draws the spectrum wave graph directly on the provided GDI+ graphics.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="g">The GDI+ graphics object where to draw the wave form (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="clipRectangle">The rectangle describing the size of the wave form to draw (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="linewidth">The thickness of the line (in pixel).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>TRUE, if successfully painted, else FALSE.</returns>
            <remarks>This overload is most useful when you are developing your own custom control. You might use it directly within your paint overload implementation.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateWaveForm(System.Int32,System.Int32,System.Int32,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a bitmap representing a sample data wave form graph.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="width">The width (in pixel) of the image to create.</param>
            <param name="height">The height (in pixel) of the image to create.</param>
            <param name="color1">The left signal color for the sample data.</param>
            <param name="color2">The right signal color for the sample data.</param>
            <param name="color3">The median color (null line).</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="linewidth">The thickness of the line (in pixel).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="mono">TRUE, if a mono signal show be used (else a stereo signal is being used).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>The created bitmap image representing the spectrum.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateWaveForm(System.Int32,System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Draws the sample data wave form graph directly on the provided GDI+ graphics.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="g">The GDI+ graphics object where to draw the wave form (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="clipRectangle">The rectangle describing the size of the wave form to draw (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="color1">The left signal color for the sample data.</param>
            <param name="color2">The right signal color for the sample data.</param>
            <param name="color3">The median color (null line).</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="linewidth">The thickness of the line (in pixel).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="mono">TRUE, if a mono signal show be used (else a stereo signal is being used).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>TRUE, if successfully painted, else FALSE.</returns>
            <remarks>This overload is most useful when you are developing your own custom control. You might use it directly within your paint overload implementation.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumBean(System.Int32,System.Int32,System.Int32,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a bitmap representing a FFT spectrum dancing beans graph.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="width">The width (in pixel) of the image to create.</param>
            <param name="height">The height (in pixel) of the image to create.</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="beanwidth">The thickness of the beans (in pixel).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>The created bitmap image representing the spectrum.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumBean(System.Int32,System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Draws the spectrum dancing beans graph directly on the provided GDI+ graphics.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="g">The GDI+ graphics object where to draw the wave form (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="clipRectangle">The rectangle describing the size of the wave form to draw (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="beanwidth">The thickness of the beans (in pixel).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>TRUE, if successfully painted, else FALSE.</returns>
            <remarks>This overload is most useful when you are developing your own custom control. You might use it directly within your paint overload implementation.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumText(System.Int32,System.Int32,System.Int32,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a bitmap representing a FFT spectrum dancing text graph.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="width">The width (in pixel) of the image to create.</param>
            <param name="height">The height (in pixel) of the image to create.</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="text">The text characters to draw.</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>The created bitmap image representing the spectrum.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrumText(System.Int32,System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Draws the spectrum dancing text graph directly on the provided GDI+ graphics.
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="g">The GDI+ graphics object where to draw the wave form (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="clipRectangle">The rectangle describing the size of the wave form to draw (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="color1">The base color (normal) for the FFT data.</param>
            <param name="color2">The peak color for the FFT data.</param>
            <param name="background">The background color to be used when drawing the image.</param>
            <param name="text">The text characters to draw.</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>TRUE, if successfully painted, else FALSE.</returns>
            <remarks>This overload is most useful when you are developing your own custom control. You might use it directly within your paint overload implementation.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.DetectFrequency(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets the interpolated amplification value for a given frequency band.
            </summary>
            <param name="channel">The channel for which to detect the presence of the frequency band.</param>
            <param name="freq1">The lower bound of the frequency band (in Hz).</param>
            <param name="freq2">The upper bound of the frequency band (in Hz).</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <returns>The interpolated amplification level of the given frequency band. Note: The level is scaled either linerar or by Sqr, meaning values above 1.0 can be returned.
            </returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.DetectPeakFrequency(System.Int32,System.Single@)">
            <summary>
            Returns the frequency (in Hz) containing the maximum energy within the current FFT data when calling this method.
            </summary>
            <param name="channel">The channel for which to detect the peak frequency.</param>
            <param name="energy">Returns the energy (amplitude level) of the detected peak frequency.</param>
            <returns>The frequency (in Hz) containing the most energy. Or 0, if an error occurred.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.Visuals.CreateSpectrum3DVoicePrint(System.Int32,System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Color,System.Drawing.Color,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Draws one line of a 3D voice print spectrum at the given position.
            <para>horizontal=time, vertical=frequency, color=amplitude</para>
            </summary>
            <param name="channel">The channel for which to create the spectrum graph.</param>
            <param name="g">The GDI+ graphics object where to draw the wave form (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/> or can be created using <see cref="M:System.Drawing.Graphics.FromHwnd(System.IntPtr)"/>).</param>
            <param name="clipRectangle">The rectangle describing the size of the wave form to draw (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="color1">The base color of the 3D voice print (only the RED component is taken).</param>
            <param name="color2">The color of the position marker.</param>
            <param name="pos">The position where to plot the 3D line</param>
            <param name="linear">TRUE, if linear scaling (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear"/>) should be applied to the FFT data. FALSE, to scale by Sqr (see <see cref="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr"/>) to make low values more visible (recommended).</param>
            <param name="fullSpectrum">TRUE, if the full frequency spectrum should be shown (across the whole width of the image).
            FALSE, if the width of the image should be use (in this case as much frequencies are shown - starting with the lower values - as fit into the width).</param>
            <returns>TRUE, if successfully painted, else FALSE.</returns>
            <remarks>You need to call this method frequently and increase the position by 1 every time in order to plot the voice print over time.
            <para>The amplitude color (GREEN and BLUE component) is calculated from the FFT sample data (RED component is taken from the color1 parameter).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.Visuals.ChannelIsMixerSource">
            <summary>
            Gets or Sets, if the channel being used in one of the Create methods (e.g. <see cref="M:Un4seen.Bass.Misc.Visuals.CreateSpectrum(System.Int32,System.Int32,System.Int32,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Boolean,System.Boolean,System.Boolean)"/>) is a buffered mixer source channel. (Default=FALSE).
            </summary>
            <remarks>When setting this property to TRUE, the BASS_MIXER_BUFFER flag must have been used on the channel.
            And such instead of call BASS_ChannelGetData, BASS_Mixer_ChannelGetData will be called internaly to query the FFT data.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.Visuals.ScaleFactorLinear">
            <summary>
            Gets or Sets the scaling factor to apply when linear spectrum drawing is selected. (Default=9).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.Visuals.ScaleFactorSqr">
            <summary>
            Gets or Sets the scaling factor to apply when non-linear spectrum drawing is selected to make low values more visible. (Default=4).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.Visuals.MaxFFTData">
            <summary>
            Gets the number of FFT data used (see <see cref="P:Un4seen.Bass.Misc.Visuals.MaxFFT"/> (Defaut is 4096).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.Visuals.MaxFFTSampleIndex">
            <summary>
            Gets the maximum FFT data index which can be used (according to <see cref="P:Un4seen.Bass.Misc.Visuals.MaxFFT"/>, default is 2047).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.Visuals.MaxFFT">
            <summary>
            Gets or Sets the number of FFT data to get (can be either <see cref="F:Un4seen.Bass.BASSData.BASS_DATA_FFT512"/>, <see cref="F:Un4seen.Bass.BASSData.BASS_DATA_FFT1024"/>, <see cref="F:Un4seen.Bass.BASSData.BASS_DATA_FFT2048"/> or <see cref="F:Un4seen.Bass.BASSData.BASS_DATA_FFT4096"/> (Default is 4096).
            </summary>
            <remarks>The higher the resolution, the more sample data is needed and the more complex the FFT calculation is.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.Visuals.MaxFrequencySpectrum">
            <summary>
            Gets or Sets the maximum number of samples to use when the fullSpectrum option is used (Default=2047 - all).
            <para>By default the full spectrum is drawn, which are 2047 samples. With this option you might limit this, since very high frequencies are often not much relevant for a visual display.
            You might use the <see cref="M:Un4seen.Bass.Utils.FFTFrequency2Index(System.Int32,System.Int32,System.Int32)"/> method with a length value of <see cref="P:Un4seen.Bass.Misc.Visuals.MaxFFTData"/> here to calculate an index for a desired upper limit frequency.
            E.g. if you want to limit the full spectrum display to an upper limit of around 11843Hz with a stream having a sampling rate of 44100Hz you might set this value to 1100.</para>
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BassNet">
            <summary>
            Bass.Net registration class.
            <para>Used to register your BASS.NET API license and to optionally supress the splash screen.</para>
            </summary>
            <remarks>Not needed when using the freeware version of BASS.NET.
            <para>When you purchased a valid license for BASS.NET you will obtain a 'Registration-Key' together with your 'eMail'.
            Call the <see cref="M:Un4seen.Bass.BassNet.Registration(System.String,System.String)"/> method prior to any other BASS method with these 2 parameters in order to suppress the BASS.NET freeware splash screen.</para>
            <para>If you like to support BASS.NET anyhow, you might call the <see cref="M:Un4seen.Bass.BassNet.ShowSplash(System.Windows.Forms.Form,System.Int32,System.Double,System.Int32)"/> method manually.</para>
            </remarks>
            <example>
            Register BASS.NET:
            <code>
            BassNet.Registration("your emai", "your registration code");
            ...
            Bass.Init(...);
            </code>
            Register BASS.NET, but show splash anyhow (for 30sec., center parent, 5% transparent):
            <code>
            BassNet.Registration("your email", "your registration code");
            BassNet.ShowSplash(this, 30000, 0.95, 2);
            ...
            Bass.Init(...);
            </code>
            <code lang="vbnet">
            BassNet.Registration("your email", "your registration code") 
            BassNet.ShowSplash(Me, 30000, 0.95, 2) 
            ...
            Bass.Init(...) 
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.BassNet.#ctor">
            <summary>
            NOT needed - all members are static.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BassNet.Registration(System.String,System.String)">
            <summary>
            Registers your BASS.NET version and suppresses the freeware splash screen.
            </summary>
            <param name="eMail">Your eMail address for which you obtained a license.</param>
            <param name="registrationKey">The Registration-Key as obtained with the license.</param>
            <remarks>IMPORTANT: Make sure to call this method prior to any other BASS method!</remarks>
        </member>
        <member name="M:Un4seen.Bass.BassNet.ShowSplash(System.Windows.Forms.Form,System.Int32,System.Double,System.Int32)">
            <summary>
            Shows the splash screen, even if you have registered BASS.NET.
            </summary>
            <param name="owner">The owner of the splash screen (or NULL).</param>
            <param name="wait">The number of milliseconds to show the splash screen (use -1 to show infinit until the uses closes the splash or pressed ESC).</param>
            <param name="opacity">The opacity of the splash screen (1.0 = no opacity, 0.0 = fully transparent).</param>
            <param name="pos">Defines where the splash screen should be shown:
            <para>0 = CenterScreen</para>
            <para>1 = WindowsDefaultLocation</para>
            <para>2 = CenterParent</para>
            </param>
            <example>
            Register BASS.NET, but show splash anyhow (for 30sec., center parent, 5% transparent):
            <code>
            BassNet.Registration("your email", "your registration code");
            BassNet.ShowSplash(this, 30000, 0.95, 2);
            ...
            Bass.Init(...);
            </code>
            Show splash (infinit until closed, center screen):
            <code>
            BassNet.Registration("your email", "your registration code");
            BassNet.ShowSplash(null, -1, 1.0, 0);
            ...
            Bass.Init(...);
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.BassNet.ShowAbout(System.Windows.Forms.Form)">
            <summary>
            Shows a BASS.NET about dialog.
            </summary>
            <param name="owner">The owner of the modal about dialog (or NULL).</param>
        </member>
        <member name="T:Un4seen.Bass.Bass">
            <summary>
            BASS.NET API wrapper for BASS.DLL
            <para>Requires: bass.dll - Bass Audio Library - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS is an audio library for use in Windows and MacOSX software. It's purpose is to provide the most powerful and efficient (yet easy to use),
            sample, stream, MOD music, and recording functions. All in a tiny DLL, under 100KB in size.</para>
            <para>BASS requires DirectX 3 or above for output. BASS does not require that a	soundcard with DirectSound/DirectSound3D hardware accelerated drivers is
            installed, but it does improve performance if there is one. BASS also takes advantage of MMX, which improves the performance of the MOD music playback</para>
            <para>There is no guarantee that all future BASS versions will be compatible with all previous versions, so your program should use <see cref="M:Un4seen.Bass.Bass.BASS_GetVersion"/> to check the version that is loaded. 
            This also means that you should put the BASS module in the same directory as your executable (not just somewhere in the path), to avoid the possibility of a wrong version being loaded.</para>
            <para>There is no need to create an instance of this class, since all Bass methods are declared as static.</para>
            </remarks>
            <example>My first BASS application:
            <code>
            using System;
            using Un4seen.Bass;
            
            namespace MyFirstBass
            {
              class Program
              {
                static void Main(string[] args)
                {
                  // init BASS using the default output device
                  if ( Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, null) )
                  {
                    // create a stream channel from a file
                    int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_DEFAULT);
                    if (stream != 0)
                    {
                      // play the stream channel
                      Bass.BASS_ChannelPlay(stream, false);
                    }
                    else
                    {
                      // error creating the stream
                      Console.WriteLine("Stream error: {0}", Bass.BASS_ErrorGetCode());
                    }
            
                    // wait for a key
                    Console.WriteLine("Press any key to exit");
                    Console.ReadKey(false);
            
                    // free the stream
                    Bass.BASS_StreamFree(stream);
                    // free BASS
                    Bass.BASS_Free();
                  }
                }
              }
            }
            </code>
            <code lang="vbnet">
            Imports System
            Imports Un4seen.Bass
            
            Namespace MyFirstBass
              Class Program
                Shared  Sub Main(ByVal args() As String)
                  ' init BASS using the default output device
                  If Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, Nothing) Then
                    ' create a stream channel from a file
                    Dim stream As Integer =  Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_DEFAULT) 
                    If stream &lt;&gt; 0 Then
                      ' play the stream channel
                      Bass.BASS_ChannelPlay(stream, False)
                    Else 
                      ' error creating the stream
                      Console.WriteLine("Stream error: {0}", Bass.BASS_ErrorGetCode())
                    End If
            
                    ' wait for a key
                    Console.WriteLine("Press any key to exit")
                    Console.ReadKey(False)
            
                    ' free the stream
                    Bass.BASS_StreamFree(stream)
                    ' free BASS
                    Bass.BASS_Free()
                  End If
                End Sub
              End Class
            End Namespace
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.Bass.BASSVERSION">
            <summary>
            Current BASS version (without minor revision).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Bass.FALSE">
            <summary>
            The BASS way to say FALSE = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Bass.TRUE">
            <summary>
            The BASS way to say TRUE = 1.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Bass.ERROR">
            <summary>
            The BASS way to say ERROR = -1.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Bass.#cctor">
            <summary>
            Base static contructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)">
            <summary>
            Initializes an output device.
            </summary>
            <param name="device">The device to use... -1 = default device, 0 = no sound, 1 = first real output device.
            <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceCount"/> can be used to get the total number of devices.
            </param>
            <param name="freq">Output sample rate.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSInit"/>):
            <list type="table">
            <item><term>BASS_DEVICE_8BITS</term><description>Use 8-bit resolution, else 16-bit.</description></item>
            <item><term>BASS_DEVICE_MONO</term><description>Use mono, else stereo.</description></item>
            <item><term>BASS_DEVICE_3D</term><description>Enable 3D functionality. If this flag is not specified, then the BASS_SAMPLE_3D flag is ignored when loading/creating a sample/stream/music.</description></item>
            <item><term>BASS_DEVICE_LATENCY</term><description>Calculates the latency of the device, that is the delay between requesting a sound to play and it acually being heard. A recommended minimum buffer length is also calculated. Both values are retrievable in the BASS_INFO structure (latency and minbuf members). These calculations can increase the time taken by this function by 1-3 seconds.</description></item>
            <item><term>BASS_DEVICE_SPEAKERS</term><description>Force the enabling of speaker assignment. With some devices/drivers, the number of speakers BASS detects may be 2, when the device in fact supports more than 2 speakers. This flag forces the enabling of assignment to all 8 possible speakers. This flag has no effect with non-WDM drivers.</description></item>
            <item><term>BASS_DEVICE_CPSPEAKER</term><description>Use the Windows control panel setting to detect the number of speakers. Soundcards generally have their own control panel to set the speaker config, so the Windows control panel setting may not be accurate unless it matches that. This flag has no effect on Vista, as the speakers are already accurately detected.</description></item>
            <item><term>BASS_DEVICE_NOSPEAKER</term><description>Ignore speaker arrangement. This flag tells BASS not to make any special consideration for speaker arrangements when using the SPEAKER flags, eg. swapping the CENLFE and REAR speaker channels in 5/7.1 speaker output. This flag should be used with plain multi-channel (rather than 5/7.1) devices.</description></item>
            </list>
            </param>
            <param name="win">The application's main window... IntPtr.Zero = the current foreground window (use this for console applications).</param>
            <param name="clsid">Class identifier of the object to create, that will be used to initialize DirectSound... NULL = use default</param>
            <returns>If the device was successfully initialized, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function must be successfully called before using any sample, stream or MOD music functions. The recording functions may be used without having called this function.</para>
            <para>The "no sound" device allows loading and playing of MOD musics, but most other functions will fail. This is so that you can still use MOD musics as synchronizers when there is no soundcard present (or without DirectX installed). Decoding channels can also still be used with the "no sound" device. When using the "no sound" device, you should still set the other parameters as you would do normally.</para>
            <para>The format (sample rate, etc...) specified when calling this function only actually has effect on the device's output with VxD drivers. 
            With WDM drivers, the output format is automatically set depending on the format of the channels that are played and what the device supports. 
            While in Vista, the output format is determined by the user's choice in the control panel - <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> can be used to check what that is. 
            For reference... Windows XP/2000 use only WDM drivers. Windows Me/98SE can use either WDM or the older VxD driver model. Windows 98/95 only use VxD drivers.</para>
            <para>When specifying a class identifier (clsid), after successful initialization, you can use <see cref="M:Un4seen.Bass.Bass.BASS_GetDSoundObject(System.Int32)"/> to retrieve the DirectSound object, and through that access any special interfaces that the object may provide.</para>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/> is used to switch the current device. When successful, BASS_Init automatically sets the current thread's device to the one that was just initialized.</para>
            <para>When using the default device (device = -1), <see cref="M:Un4seen.Bass.Bass.BASS_GetDevice"/> can be used to find out which device it was mapped to. On Windows, it'll always be the first device.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The device has already been initialized. You must call <see cref="M:Un4seen.Bass.Bass.BASS_Free"/> before you can initialize it again.</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>There is no available device driver... the device may already be in use.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The specified format is not supported by the device. Try changing the <paramref name="freq"/> and <paramref name="flags"/> parameters.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device has no 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Initialize BASS with the current form window handle:
            <code>
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle, null);
            </code>
            <code lang="vbnet">
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle, null)
            </code>
            Initialize BASS/DirectSound with A3D
            <code>
            Guid clsidA3d = new Guid(0xd8f1eee0, 0xf634, 0x11cf, 0x87, 0x0, 0x0, 0xa0, 0x24, 0x5d, 0x91, 0x8b);
            Bass.BASS_Init(-1, 44100, 0, this.Handle, clsidA3d);
            </code>
            <code lang="vbnet">
            Dim clsidA3d As Guid =  New Guid(0xd8f1eee0, 0xf634, 0x11cf, 0x87, 0x0, 0x0, 0xa0, 0x24, 0x5d, 0x91, 0x8b) 
            Bass.BASS_Init(-1, 44100, 0, Me.Handle, clsidA3d)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Object)">
            <summary>
            Initializes an output device.
            </summary>
            <param name="device">The device to use... -1 = default device, 0 = no sound, 1 = first real output device.
            <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceCount"/> can be used to get the total number of devices.
            </param>
            <param name="freq">Output sample rate.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSInit"/>):
            <list type="table">
            <item><term>BASS_DEVICE_8BITS</term><description>Use 8-bit resolution, else 16-bit.</description></item>
            <item><term>BASS_DEVICE_MONO</term><description>Use mono, else stereo.</description></item>
            <item><term>BASS_DEVICE_3D</term><description>Enable 3D functionality. If this flag is not specified, then the BASS_SAMPLE_3D flag is ignored when loading/creating a sample/stream/music.</description></item>
            <item><term>BASS_DEVICE_LATENCY</term><description>Calculates the latency of the device, that is the delay between requesting a sound to play and it acually being heard. A recommended minimum buffer length is also calculated. Both values are retrievable in the BASS_INFO structure (latency and minbuf members). These calculations can increase the time taken by this function by 1-3 seconds.</description></item>
            <item><term>BASS_DEVICE_SPEAKERS</term><description>Force the enabling of speaker assignment. With some devices/drivers, the number of speakers BASS detects may be 2, when the device in fact supports more than 2 speakers. This flag forces the enabling of assignment to all 8 possible speakers. This flag has no effect with non-WDM drivers.</description></item>
            <item><term>BASS_DEVICE_NOSPEAKER</term><description>Ignore speaker arrangement. This flag tells BASS not to make any special consideration for speaker arrangements when using the SPEAKER flags, eg. swapping the CENLFE and REAR speaker channels in 5/7.1 speaker output. This flag should be used with plain multi-channel (rather than 5/7.1) devices.</description></item>
            </list>
            </param>
            <param name="win">The application's main window... IntPtr.Zero = the current foreground window (use this for console applications).</param>
            <param name="clsid">Class identifier of the object to create, that will be used to initialize DirectSound... NULL = use default</param>
            <returns>If the device was successfully initialized, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function must be successfully called before using any sample, stream or MOD music functions. The recording functions may be used without having called this function.</para>
            <para>The "no sound" device allows loading and playing of MOD musics, but most other functions will fail. This is so that you can still use MOD musics as synchronizers when there is no soundcard present (or without DirectX installed). Decoding channels can also still be used with the "no sound" device. When using the "no sound" device, you should still set the other parameters as you would do normally.</para>
            <para>The format (sample rate, etc...) specified when calling this function only actually has effect on the device's output with VxD drivers. 
            With WDM drivers, the output format is automatically set depending on the format of the channels that are played and what the device supports. 
            While in Vista, the output format is determined by the user's choice in the control panel - <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> can be used to check what that is. 
            For reference... Windows XP/2000 use only WDM drivers. Windows Me/98SE can use either WDM or the older VxD driver model. Windows 98/95 only use VxD drivers.</para>
            <para>When specifying a class identifier (clsid), after successful initialization, you can use <see cref="M:Un4seen.Bass.Bass.BASS_GetDSoundObject(System.Int32)"/> to retrieve the DirectSound object, and through that access any special interfaces that the object may provide.</para>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/> is used to switch the current device. When successful, BASS_Init automatically sets the current thread's device to the one that was just initialized.</para>
            <para>When using the default device (device = -1), <see cref="M:Un4seen.Bass.Bass.BASS_GetDevice"/> can be used to find out which device it was mapped to. On Windows, it'll always be the first device.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The device has already been initialized. You must call <see cref="M:Un4seen.Bass.Bass.BASS_Free"/> before you can initialize it again.</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>There is no available device driver... the device may already be in use.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The specified format is not supported by the device. Try changing the <paramref name="freq"/> and <paramref name="flags"/> parameters.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device has no 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Initialize BASS with the current form window handle:
            <code>
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle, null);
            </code>
            <code lang="vbnet">
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle, null)
            </code>
            Initialize BASS/DirectSound with A3D
            <code>
            Guid clsidA3d = new Guid(0xd8f1eee0, 0xf634, 0x11cf, 0x87, 0x0, 0x0, 0xa0, 0x24, 0x5d, 0x91, 0x8b);
            Bass.BASS_Init(-1, 44100, 0, this.Handle, clsidA3d);
            </code>
            <code lang="vbnet">
            Dim clsidA3d As Guid =  New Guid(0xd8f1eee0, 0xf634, 0x11cf, 0x87, 0x0, 0x0, 0xa0, 0x24, 0x5d, 0x91, 0x8b) 
            Bass.BASS_Init(-1, 44100, 0, Me.Handle, clsidA3d)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDeviceInfoInternal(System.Int32,Un4seen.Bass.BASS_DEVICEINFO_INTERNAL@)">
            <summary>
            
            </summary>
            <param name="device"></param>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)">
            <summary>
            Retrieves information on an output device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> class to store the information at.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available devices for a setup dialog. 
            Device 0 is always the "no sound" device, so if you should start at device 1 if you only want to list real devices.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List all available devices:
            <code>
            BASS_DEVICEINFO info = new BASS_DEVICEINFO();
            for (int n=0; Bass.BASS_GetDeviceInfo(n, info); n++)
            {
              Console.WriteLine(info.ToString());
            }
            </code>
            <code lang="vbnet">
            Dim n As Integer = 0
            Dim info As New BASS_DEVICEINFO()
            While (Bass.BASS_GetDeviceInfo(n, info))
              Console.WriteLine(info.ToString())
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on an output device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <returns>If successful, then an instance of the <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> class is returned, else NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available devices for a setup dialog. 
            Device 0 is always the "no sound" device, so if you should start at device 1 if you only want to list real devices.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Find the system default device:
            <code>
            int defDevice = -1;
            BASS_DEVICEINFO info;
            for (int n = 0; (info = Bass.BASS_GetDeviceInfo(n)) != null; n++)
            {
              if (info.IsDefault)
              {
                defDevice = n;
                break;
              }
            }
            </code>
            <code lang="vbnet">
            Dim defDevice As Integer = -1
            Dim n As Integer = 0
            Dim info As New BASS_DEVICEINFO()
            While Not (info Is Nothing)
              info = Bass.BASS_GetDeviceDescription(n)
              If Not (info Is Nothing) And info.IsDefault Then
                defDevice = n
                Exit While
              End If
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDeviceInfos">
            <summary>
            Returns all available output devices.
            </summary>
            <returns>An array of <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> elements representing the available output devices.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDeviceCount">
            <summary>
            Returns the total number of available output devices.
            </summary>
            <returns>Number of real output devices available.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)">
            <summary>
            Retrieves information on the device being used.
            </summary>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.BASS_INFO"/> class to store the information at.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            if ( Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle, null) )
            {
              BASS_INFO info = new BASS_INFO();
              if (Bass.BASS_GetInfo(info))
                Console.WriteLine( info.ToString() );
            }
            </code>
            <code lang="vbnet">
            If Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle, Nothing) Then
              Dim info As New BASS_INFO()
              If Bass.BASS_GetInfo(info) Then
                Console.WriteLine(info.ToString())
              End If
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetInfo">
            <summary>
            Retrieves information on the device being used.
            </summary>
            <returns>An instance of the <see cref="T:Un4seen.Bass.BASS_INFO"/> class on success - or NULL on error.</returns>
            <remarks>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            if ( Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle, null) )
            {
              BASS_INFO info = Bass.BASS_GetInfo();
              if (info != null)
                Console.WriteLine(info.ToString());
            }
            </code>
            <code lang="vbnet">
            If Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle, Nothing) Then
              Dim info As BASS_INFO = Bass.BASS_GetInfo()
              If Not (info Is Nothing) Then
                Console.WriteLine(info.ToString())
              End If
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ErrorGetCode">
            <summary>
            Retrieves the error code for the most recent BASS function call in the current thread.
            </summary>
            <returns>If no error occured during the last BASS function call then BASS_OK is returned, else one of the <see cref="T:Un4seen.Bass.BASSError"/> values is returned. 
            See the function description for an explanation of what the error code means.</returns>
            <remarks>Error codes are stored for each thread. So if you happen to call 2 or more BASS functions at the same time, they will not interfere with eachother's error codes.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Stop">
            <summary>
            Stops the output, stopping all musics/samples/streams.
            </summary>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function can be used after <see cref="M:Un4seen.Bass.Bass.BASS_Pause"/> to stop the paused channels, so that they will not be resumed the next time <see cref="M:Un4seen.Bass.Bass.BASS_Start"/> is called.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Free">
            <summary>
            Frees all resources used by the output device, including all it's samples, streams, and MOD musics.
            </summary>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function should be called for all initialized devices before your program exits. It's not necessary to individually free the samples/streams/musics as these are all automatically freed by this function.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // init device 1 and 2
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle, null);
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle, null);
            ...
            // create the stream for device 1
            Bass.BASS_SetDevice(1);
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            ...
            // create the stream for device 2
            Bass.BASS_SetDevice(2);
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            ...
            // free any initialized device
            Bass.BASS_SetDevice(1);
            Bass.BASS_Free();
            Bass.BASS_SetDevice(2);
            Bass.BASS_Free();
            </code>
            <code lang="vbnet">
            ' init device 1 and 2
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle, Nothing)
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle, Nothing)
            ...
            ' create the stream for device 1
            Bass.BASS_SetDevice(1)
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            ' create the stream for device 2
            Bass.BASS_SetDevice(2)
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            ...
            ' free any initialized device
            Bass.BASS_SetDevice(1)
            Bass.BASS_Free()
            Bass.BASS_SetDevice(2)
            Bass.BASS_Free()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetVersion">
            <summary>
            Retrieves the version number of the BASS.DLL that is loaded.
            </summary>
            <returns>The BASS version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASS supports all the BASS functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.Bass.BASSVERSION"/> to check the major revision.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(Bass.BASS_GetVersion()) != Bass.BASSVERSION )
            {
              MessageBox.Show(this, "Wrong Bass Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(Bass.BASS_GetVersion()) &lt;&gt; Bass.BASSVERSION Then
              MessageBox.Show(Me, "Wrong Bass Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (Bass.BASS_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong Bass Version!");
            }
            </code>
            <code lang="vbnet">
            If Bass.BASS_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong Bass Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASS.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASS version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASS supports all the BASS functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.</remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (Bass.BASS_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong Bass Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If Bass.BASS_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong Bass Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)">
            <summary>
            Sets the device to use for subsequent calls in the current thread.
            </summary>
            <param name="device">The device to use... 0 = no sound, 1 = first real output device.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.</para>
            <para>The functions that use the device selection are the following: 
            <see cref="M:Un4seen.Bass.Bass.BASS_Free"/>, <see cref="M:Un4seen.Bass.Bass.BASS_GetDSoundObject(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Start"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Pause"/>, <see cref="M:Un4seen.Bass.Bass.BASS_SetVolume(System.Single)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_GetVolume"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Set3DFactors(System.Single,System.Single,System.Single)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Get3DFactors(System.Single@,System.Single@,System.Single@)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Set3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Get3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_SetEAXParameters(Un4seen.Bass.EAXEnvironment,System.Single,System.Single,System.Single)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_GetEAXParameters(Un4seen.Bass.EAXEnvironment@,System.Single@,System.Single@,System.Single@)"/>. 
            It also determines which device is used by a new sample/stream/music: <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.String,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, etc...</para>
            <para>When one of the above functions (or <see cref="M:Un4seen.Bass.Bass.BASS_GetDevice"/>) is called, BASS will check the current thread's device setting, and if no device is selected (or the selected device is not initialized), BASS will automatically select the lowest device that is initialized. This means that when using a single device, there is no need to use this function - BASS will automatically use the device that's initialized. Even if you free the device, and initialize another, BASS will automatically switch to the one that is initialized.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="device"/> is invalid.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The device has not been initialized.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // init device 1 and 2
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle, null);
            // now device 1 is the current one
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle, null);
            // now device 2 is the current one
            ...
            // create the stream for device 1
            Bass.BASS_SetDevice(1);
            // now device 1 is the current one
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            ...
            // create the stream for device 2
            Bass.BASS_SetDevice(2);
            // now device 2 is the current one
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            ...
            // free any initialized device
            Bass.BASS_SetDevice(1);
            Bass.BASS_Free();
            Bass.BASS_SetDevice(2);
            Bass.BASS_Free();
            </code>
            <code lang="vbnet">
            ' init device 1 and 2
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle, Nothing)
            ' now device 1 is the current one
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle, Nothing)
            ' now device 2 is the current one
            ...
            ' create the stream for device 1
            Bass.BASS_SetDevice(1)
            ' now device 1 is the current one
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            ' create the stream for device 2
            Bass.BASS_SetDevice(2)
            ' now device 2 is the current one
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            ...
            ' free any initialized device
            Bass.BASS_SetDevice(1)
            Bass.BASS_Free()
            Bass.BASS_SetDevice(2)
            Bass.BASS_Free()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDevice">
            <summary>
            Retrieves the device setting in the current thread.
            </summary>
            <returns>If successful, the device number is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/>to get the error code.</returns>
            <remarks>See also <seealso cref="M:Un4seen.Bass.Bass.BASS_ChannelGetDevice(System.Int32)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called - there are no initialized devices.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDSoundObject(System.Int32)">
            <summary>
            Retrieves a pointer to a DirectSound object interface.
            <para>Not recommended to be used by managed applications!</para>
            </summary>
            <param name="handle">The interface to retrieve.
            <para>This can be a HMUSIC / HSTREAM / HCHANNEL handle, in which case an IDirectSoundBuffer interface is returned, or one of the following (see <see cref="T:Un4seen.Bass.BASSDirectSound"/>):</para>
            <list type="table">
            <item><term>BASS_OBJECT_DS</term><description>Retrieve the IDirectSound interface.</description></item>
            <item><term>BASS_OBJECT_DS3DL</term><description>Retrieve the IDirectSound3DListener interface.</description></item>
            </list>
            </param>
            <returns>If succesful, then a pointer to the requested object is returned, otherwise NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function allows those that are familiar with DirectSound to access the internal DirectSound object interfaces, so that extra external functionality can be "plugged" into BASS. If you create any objects through a retrieved interface, make sure you release the objects before calling <see cref="M:Un4seen.Bass.Bass.BASS_Free"/>.</para>
            <para>See the DirectX SDK for information on the DirectSound interfaces.</para>
            <para>When using multiple devices, and requesting either the BASS_OBJECT_DS or BASS_OBJECT_DS3DL object interfaces, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="handle"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested object is not available with the current device.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDSoundObject(Un4seen.Bass.BASSDirectSound)">
            <summary>
            Retrieves a pointer to a DirectSound object interface.
            <para>Not recommended to be used by managed applications!</para>
            </summary>
            <param name="dsobject">The interface to retrieve.
            <para>This can be a HMUSIC / HSTREAM / HCHANNEL handle, in which case an IDirectSoundBuffer interface is returned, or one of the following (see <see cref="T:Un4seen.Bass.BASSDirectSound"/>):</para>
            <list type="table">
            <item><term>BASS_OBJECT_DS</term><description>Retrieve the IDirectSound interface.</description></item>
            <item><term>BASS_OBJECT_DS3DL</term><description>Retrieve the IDirectSound3DListener interface.</description></item>
            </list>
            </param>
            <returns>If succesful, then a pointer to the requested object is returned, otherwise NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function allows those that are familiar with DirectSound to access the internal DirectSound object interfaces, so that extra external functionality can be "plugged" into BASS. If you create any objects through a retrieved interface, make sure you release the objects before calling <see cref="M:Un4seen.Bass.Bass.BASS_Free"/>.</para>
            <para>See the DirectX SDK for information on the DirectSound interfaces.</para>
            <para>When using multiple devices, and requesting either the BASS_OBJECT_DS or BASS_OBJECT_DS3DL object interfaces, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="dsobject"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested object is not available with the current device.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)">
            <summary>
            "Manually" updates the HSTREAM and HMUSIC channel buffers.
            </summary>
            <param name="length">The amount to render, in milliseconds.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When automatic updating is disabled, this function (or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/>) needs to be called to keep the playback buffers updated. 
            The length parameter should include some safety margin, in case the next update cycle gets delayed. 
            For example, if calling this function every 100ms, 200 would be a reasonable length parameter.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Updating is already in progress.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetCPU">
            <summary>
            Retrieves the current CPU usage of BASS.
            </summary>
            <returns>The BASS CPU usage as a percentage of total CPU time.</returns>
            <remarks>
            <para>This function includes the time taken to decode and mix the stream (HSTREAM) and MOD music (HMUSIC) channels during playback. It also includes the time taken by any DSP functions. It does not include plain sample (HSAMPLE) mixing which is done by the output device (hardware accelerated) or DirectSound (emulated).</para>
            <para>For add-on played formats, see the documentation for whether the CPU usage is included in this function's return value.</para>
            <para>If automatic updating is disabled, then the value returned by this function is only updated after each call to <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Start">
            <summary>
            Starts (or resumes) the output.
            </summary>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The output is automatically started by <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>, so there is no need to use this function unless you've stopped or paused the output.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Pause">
            <summary>
            Stops the output, pausing all musics/samples/streams.
            </summary>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_Start"/> to resume the output and paused channels.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetVolume(System.Single)">
            <summary>
            Sets the output master volume.
            </summary>
            <param name="volume">The volume level... 0 (silent) to 1 (max).</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            The actual volume level may not be exactly the same as requested, due to underlying precision differences. 
            <see cref="M:Un4seen.Bass.Bass.BASS_GetVolume"/> can be used to confirm what the volume is.
            <para>This function affects the volume level of all applications using the same output device. 
            If you wish to only affect the level of your app's sounds, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/> and/or the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_GVOL_MUSIC / BASS_CONFIG_GVOL_SAMPLE / BASS_CONFIG_GVOL_STREAM</see> config options should be used instead.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no volume control when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="volume"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetVolume">
            <summary>
            Retrieves the current master volume level.
            </summary>
            <returns>If successful, the volume level is returned, else -1.0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The volume level... 0 (silent) to 1 (max) will be returned.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no volume control when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">
            <summary>
            Sets the value of a config option.
            </summary>
            <param name="option">The option to set the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <param name="newvalue">The new option value (as an int). See the option's documentation for details on the possible values.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_3DALGORITHM</term><description>The 3D algorithm for software mixed 3D channels.
            <para>newvalue (int): Use one of these algorithms <see cref="T:Un4seen.Bass.BASS3DAlgorithm"/></para>
            <para>These algorithms only affect 3D channels that are being mixed in software. You can check if a channel is being software mixed with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.</para>
            <para>This config option allows you to use higher quality 3D processing on more powerful CPUs, and more efficient 3D processing on less powerful CPUs. Changing the algorithm only affects subsequently created or loaded samples, musics or streams, it does not affect those that already exist.</para>
            </description></item>
            <item><term>BASS_CONFIG_BUFFER</term><description>Playback buffer length.
            <para>newvalue (int): The buffer length in milliseconds. The minimum length is 1ms above the update period (BASS_CONFIG_UPDATEPERIOD), the maximum is 5000 milliseconds. If the length specified is outside this range, it is automatically capped.</para>
            <para>The default buffer length is 500 milliseconds. Increasing the length, decreases the chance of the sound possibly breaking-up on slower computers, but also increases the latency for DSP/FX.</para>
            <para>Small buffer lengths are only required if the sound is going to be changing in real-time, for example, in a soft-synth. If you need to use a small buffer, then the minbuf member of BASS_INFO should be used to get the recommended minimum buffer length supported by the device and it's drivers. Even at this default length, it's still possible that the sound could break up on some systems, it's also possible that smaller buffers may be fine. So when using small buffers, you should have an option in your software for the user to finetune the length used, for optimal performance.</para>
            <para>Using this config option only affects the HMUSIC/HSTREAM channels that you create afterwards, not the ones that have already been created. So you can have channels with differing buffer lengths by using this config option each time before creating them.</para>
            <para>If automatic updating is disabled, make sure you call BASS_Update frequently enough to keep the buffers updated.</para>
            </description></item>
            <item><term>BASS_CONFIG_CURVE_VOL</term><description>Volume translation curve.
            <para>newvalue (bool): Volume curve... FALSE = linear, TRUE = logarithmic.</para>
            <para>DirectSound uses logarithmic volume and panning curves, which can be awkward to work with. 
            For example, with a logarithmic curve, the audible difference between 10000 and 9000, is not the same as between 9000 and 8000. 
            With a linear "curve" the audible difference is spread equally across the whole range of values, so in the previous example the audible difference between 10000 and 9000, and between 9000 and 8000 would be identical.</para>
            <para>When using the linear curve, the volume range is from 0% (silent) to 100% (full). 
            When using the logarithmic curve, the volume range is from -100 dB (effectively silent) to 0 dB (full). For example, a volume level of 0.5 is 50% linear or -50 dB logarithmic.</para>
            <para>The linear curve is used by default.</para>
            </description></item>
            <item><term>BASS_CONFIG_CURVE_PAN</term><description>Panning translation curve.
            <para>newvalue (bool): Panning curve... FALSE = linear, TRUE = logarithmic.</para>
            <para>The panning curve affects panning in exactly the same way as the volume curve (BASS_CONFIG_CURVE_VOL) affects the volume.</para>
            <para>The linear curve is used by default.</para>
            </description></item>
            <item><term>BASS_CONFIG_FLOATDSP</term><description>Pass 32-bit floating-point sample data to all DSP functions?
            <para>newvalue (bool): If TRUE, 32-bit floating-point sample data is passed to all <see cref="T:Un4seen.Bass.DSPPROC"/> callback functions.</para>
            <para>Normally DSP functions receive sample data in whatever format the channel is using, ie. it can be 8, 16 or 32-bit. But using this config option, BASS will convert 8/16-bit sample data to 32-bit floating-point before passing it to DSP functions, and then convert it back after all the DSP functions are done. As well as simplifying the DSP code (no need for 8/16-bit processing), this also means that there is no degradation of quality as sample data passes through a chain of DSP.</para>
            <para>This option also affects DX8 effects when using the "without FX flag" DX8 effect implementation. Note that floating-point FX processing requires DX9 or above.</para>
            </description></item>
            <item><term>BASS_CONFIG_GVOL_MUSIC</term><description>Global music volume.
            <para>newvalue (int): MOD music global volume level... 0 (silent) - 10000 (full).</para>
            <para>This config option allows you to have control over the volume levels of all the MOD musics, which is useful for setup options (eg. separate music and fx volume controls).</para>
            <para>A channel's final volume = channel volume * global volume / max volume. So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000, then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).</para>
            </description></item>
            <item><term>BASS_CONFIG_GVOL_SAMPLE</term><description>Global sample volume.
            <para>newvalue (int): Sample global volume level... 0 (silent) - 10000 (full).</para>
            <para>This config option allows you to have control over the volume levels of all the samples, which is useful for setup options (eg. separate music and fx volume controls).</para>
            <para>A channel's final volume = channel volume * global volume / max volume. So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000, then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).</para>
            </description></item>
            <item><term>BASS_CONFIG_GVOL_STREAM</term><description>Global stream volume.
            <para>newvalue (int): Stream global volume level... 0 (silent) - 10000 (full).</para>
            <para>This config option allows you to have control over the volume levels of all the streams, which is useful for setup options (eg. separate music and fx volume controls).</para>
            <para>A channel's final volume = channel volume * global volume / max volume. So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000, then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).</para>
            </description></item>
            <item><term>BASS_CONFIG_MP3_CODEC</term><description>The MP3 decoder to use.
            <para>newvalue (int): The MP3 decoder to use... 0 = BASS, 1 = Windows.</para>
            <para>Most Windows users will have an MP3 codec installed - it comes preinstalled with modern Windows (ME/2K/XP), and can be installed on older Windows, eg. with Windows Media Player. By default, BASS will use it's own built-in MP3 decoder, as it provides better performance, but the Windows codec can be used instead.</para>
            <para>When using the Windows codec, BASS still does the file processing, so all the usual features are still supported, including streaming, tag reading, pre-scanning, gapless playback, etc...</para>
            <para>If the Windows codec option is chosen, but an MP3 codec is not installed, then MP3 files/streams will not be playable and the stream/sample creation functions will produce a BASS_ERROR_CODEC error.</para>
            </description></item>
            <item><term>BASS_CONFIG_MUSIC_VIRTUAL</term><description>The maximum number of virtual channels to use in the rendering of IT files.
            <para>newvalue (int): The number of virtual channels... 1 (min) - 512 (max). If the value specified is outside this range, it is automatically capped.</para>
            <para>This setting only affects IT files, as the other MOD music formats do not have virtual channels. The default setting is 64. Changes only apply to subsequently loaded files, not any that are already loaded.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_PLAYLIST</term><description>Process URLs in PLS and M3U playlists?
            <para>newvalue (int): When to process URLs in PLS and M3U playlists... 0 = never, 1 = in <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> only, 2 = in <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> too.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_BUFFER</term><description>Internet download buffer length.
            <para>newvalue (int): The buffer length, in milliseconds.</para>
            <para>Increasing the buffer length decreases the chance of the stream stalling, but also increases the time taken by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> to create the stream, as it has to pre-buffer more data (adjustable via the BASS_CONFIG_NET_PREBUF config option). Aside from the pre-buffering, this setting has no effect on streams without either the BASS_STREAM_BLOCK or BASS_STREAM_RESTRATE flags.</para>
            <para>When streaming in blocks, this option determines the download buffer length. The effective buffer length can actually be a bit more than that specified, including data that's been read from the buffer by the decoder but not been used yet.</para>
            <para>This config option also determines the buffering used by "buffered" user file streams created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            <para>The default buffer length is 5 seconds (5000 milliseconds). The net buffer length should be larger than the length of the playback buffer (BASS_CONFIG_BUFFER), otherwise the stream is likely to briefly stall soon after starting playback.</para>
            <para>Using this config option only affects streams created afterwards, not any that have already been created.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_PASSIVE</term><description>Use passive mode in FTP connections?
            <para>passive (bool): If TRUE, passive mode is used, otherwise normal/active mode is used.</para>
            <para>Changes take effect from the next internet stream creation call. By default, passive mode is disabled.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_PREBUF</term><description>Amount to pre-buffer when opening internet streams.
            <para>newvalue (int): Amount (percentage) to pre-buffer.</para>
            <para>This setting determines what percentage of the buffer length (BASS_CONFIG_NET_BUFFER) should be filled by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>. The default is 75%. Setting this lower (eg. 0) is useful if you want to display a "buffering progress" (using <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/>) when opening internet streams, but note that this setting is just a minimum - BASS will always pre-download a certain amount to verify the stream</para>
            <para>As well as internet streams, this config setting also applies to "buffered" user file streams created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_TIMEOUT</term><description>Time to wait for a server to respond to a connection request.
            <para>newvalue (int): The time to wait, in milliseconds.</para>
            <para>The default timeout is 5 seconds (5000 milliseconds).</para>
            </description></item>
            <item><term>BASS_CONFIG_PAUSE_NOPLAY</term><description>Prevent channels being played when the output is paused?
            <para>newvalue (bool): If TRUE, channels can't be played while the output is paused.</para>
            <para>When the output is paused using <see cref="M:Un4seen.Bass.Bass.BASS_Pause"/>, and this config option is enabled, channels can't be played until the output is resumed using <see cref="M:Un4seen.Bass.Bass.BASS_Start"/>. Attempts to play a channel will give a BASS_ERROR_START error.</para>
            </description></item>
            <item><term>BASS_CONFIG_REC_BUFFER </term><description>The buffer length for recording channels.
            <para>newvalue (int): The buffer length in milliseconds... 1000 (min) - 5000 (max). If the length specified is outside this range, it is automatically capped.</para>
            <para>Unlike a playback buffer, where the aim is to keep the buffer full, a recording buffer is kept as empty as possible and so this setting has no effect on latency. The default recording buffer length is 2000 milliseconds. Unless processing of the recorded data could cause significant delays, or you want to use a large recording period with <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>, there should be no need to increase this.</para>
            <para>Using this config option only affects the recording channels that are created afterwards, not any that have already been created. So it is possible to have channels with differing buffer lengths by using this config option each time before creating them.</para>
            </description></item>
            <item><term>BASS_CONFIG_UPDATEPERIOD</term><description>Update period of playback buffers.
            <para>newvalue (int): The update period in milliseconds... 0 = disable automatic updating. The minimum period is 5ms, the maximum is 100ms. If the period specified is outside this range, it is automatically capped.</para>
            <para>The update period is the amount of time between updates of the playback buffers of HSTREAM/HMUSIC channels. Shorter update periods allow smaller buffers to be set with the BASS_CONFIG_BUFFER config option, but as the rate of updates increases, so the overhead of setting up the updates becomes a greater part of the CPU usage. The update period only affects HSTREAM and HMUSIC channels, it does not affect samples. Nor does it have any effect on decoding channels, as they are not played.</para>
            <para>BASS creates a thread specifically to perform the updating, except when automatic updating is disabled (period=0) - then you must regularly call <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> instead. This allows you to synchronize BASS's CPU usage with your program's. For example, in a game loop you could call <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> once per frame, which keeps all the processing in sync so that the frame rate is as smooth as possible. <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> should be called at least around 8 times per second, even more often if the BASS_CONFIG_BUFFER config option is used to set smaller buffers.</para>
            <para>The update period can be altered at any time, including during playback. The default period is 100ms.</para>
            </description></item>
            <item><term>BASS_CONFIG_UPDATETHREADS</term><description>Number of update threads.
            <para>newvalue (int): The number of threads to use... 0 = disable automatic updating.</para>
            <para>The number of update threads determines how many HSTREAM/HMUSIC channel playback buffers can be updated in parallel; each thread can process one channel at a time. The default is to use a single thread, but additional threads can be used to take advantage of multiple CPU cores. There is generally nothing much to be gained by creating more threads than there are CPU cores, but one benefit of using multiple threads even with a single CPU core is that a slow updating channel need not delay the updating of other channels.</para>
            <para>When automatic updating is disabled (threads = 0), <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> should be used instead.</para>
            <para>The number of update threads can be changed at any time, including during playback.</para>
            </description></item>
            <item><term>BASS_CONFIG_VERIFY</term><description>The amount of data to check in order to verify/detect the file format.
            <para>length (int): The amount of data to check, in bytes... 1000 (min) to 100000 (max). If the value specified is outside this range, it is automatically capped.</para>
            <para>Of the file formats supported as standard, this setting only affects the detection of MP3/MP2/MP1 formats, 
            but it may also be used by add-ons (see the documentation). For internet (and "buffered" user file) streams, a quarter of the length is used, up to a minimum of 1000 bytes.</para>
            <para>The verification length excludes any tags that may be at the start of the file. The default length is 16000 bytes.</para>
            </description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Setting the playback buffer to 100ms and the update period to 20ms:
            <code>
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_BUFFER, 100);
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 20);
            </code>
            <code lang="vbnet">
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_BUFFER, 100)
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 20)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Boolean)">
            <summary>
            Sets the value of a config option.
            </summary>
            <param name="option">The option to set the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <param name="newvalue">The new option value (as a bool). See the option's documentation for details on the possible values.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_CURVE_VOL</term><description>Volume translation curve.
            <para>newvalue (bool): Volume curve... FALSE = linear, TRUE = logarithmic.</para>
            <para>DirectSound uses logarithmic volume and panning curves, which can be awkward to work with. 
            For example, with a logarithmic curve, the audible difference between 10000 and 9000, is not the same as between 9000 and 8000. 
            With a linear "curve" the audible difference is spread equally across the whole range of values, so in the previous example the audible difference between 10000 and 9000, and between 9000 and 8000 would be identical.</para>
            <para>When using the linear curve, the volume range is from 0% (silent) to 100% (full). 
            When using the logarithmic curve, the volume range is from -100 dB (effectively silent) to 0 dB (full). For example, a volume level of 0.5 is 50% linear or -50 dB logarithmic.</para>
            <para>The linear curve is used by default.</para>
            </description></item>
            <item><term>BASS_CONFIG_CURVE_PAN</term><description>Panning translation curve.
            <para>newvalue (bool): Panning curve... FALSE = linear, TRUE = logarithmic.</para>
            <para>The panning curve affects panning in exactly the same way as the volume curve (BASS_CONFIG_CURVE_VOL) affects the volume.</para>
            <para>The linear curve is used by default.</para>
            </description></item>
            <item><term>BASS_CONFIG_FLOATDSP</term><description>Pass 32-bit floating-point sample data to all DSP functions?
            <para>newvalue (bool): If TRUE, 32-bit floating-point sample data is passed to all <see cref="T:Un4seen.Bass.DSPPROC"/> callback functions.</para>
            <para>Normally DSP functions receive sample data in whatever format the channel is using, ie. it can be 8, 16 or 32-bit. But using this config option, BASS will convert 8/16-bit sample data to 32-bit floating-point before passing it to DSP functions, and then convert it back after all the DSP functions are done. As well as simplifying the DSP code (no need for 8/16-bit processing), this also means that there is no degradation of quality as sample data passes through a chain of DSP.</para>
            <para>This option also affects DX8 effects when using the "without FX flag" DX8 effect implementation. Note that floating-point FX processing requires DX9 or above.</para>
            </description></item>
            <item><term>BASS_CONFIG_MP3_CODEC</term><description>The MP3 decoder to use.
            <para>newvalue (bool): The MP3 decoder to use... FALSE = BASS, TRUE = Windows.</para>
            <para>Most Windows users will have an MP3 codec installed - it comes preinstalled with modern Windows (ME/2K/XP), and can be installed on older Windows, eg. with Windows Media Player. By default, BASS will use it's own built-in MP3 decoder, as it provides better performance, but the Windows codec can be used instead.</para>
            <para>When using the Windows codec, BASS still does the file processing, so all the usual features are still supported, including streaming, tag reading, pre-scanning, gapless playback, etc...</para>
            <para>If the Windows codec option is chosen, but an MP3 codec is not installed, then MP3 files/streams will not be playable and the stream/sample creation functions will produce a BASS_ERROR_CODEC error.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_PASSIVE</term><description>Use passive mode in FTP connections?
            <para>passive (bool): If TRUE, passive mode is used, otherwise normal/active mode is used.</para>
            <para>Changes take effect from the next internet stream creation call. By default, passive mode is disabled.</para>
            </description></item>
            <item><term>BASS_CONFIG_PAUSE_NOPLAY</term><description>Prevent channels being played when the output is paused?
            <para>newvalue (bool): If TRUE, channels can't be played while the output is paused.</para>
            <para>When the output is paused using <see cref="M:Un4seen.Bass.Bass.BASS_Pause"/>, and this config option is enabled, channels can't be played until the output is resumed using <see cref="M:Un4seen.Bass.Bass.BASS_Start"/>. Attempts to play a channel will give a BASS_ERROR_START error.</para>
            </description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Setting the DSP processing to 32-bit float:
            <code>
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_FLOATDSP, true);
            </code>
            <code lang="vbnet">
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_FLOATDSP, True)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetConfigPtr(Un4seen.Bass.BASSConfig,System.IntPtr)">
            <summary>
            Sets the value of a pointer config option.
            </summary>
            <param name="option">The option to set the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <param name="newvalue">The new option value (as an IntPtr). See the option's documentation for details on the possible values.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_NET_AGENT</term><description>"User-Agent" header.
            <para>newvalue (IntPtr): The "User-Agent" header.</para>
            <para>BASS does not make a copy of the header string, so it must reside in the heap (not the stack), eg. a global variable - see example below!
            This also means that the agent setting can subsequently be changed at that location without having to call this function again.</para>
            <para>Changes take effect from the next internet stream creation call.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_PROXY</term><description>Proxy server settings.
            <para>newvalue (IntPtr): The "User-Agent" header.</para>
            <para>The proxy server settings, in the form of "user:pass@server:port"... NULL = don't use a proxy. "" (empty string) = use the default proxy settings. 
            If only the "user:pass@" part is specified, then those authorization credentials are used with the default proxy server. 
            If only the "server:port" part is specified, then that proxy server is used without any authorization credentials.</para>
            <para>BASS does not make a copy of the proxy string, so it must reside in the heap (not the stack), eg. a global variable - see example below!
            This also means that the proxy setting can subsequently be changed at that location without having to call this function again.</para>
            <para>Changes take effect from the next internet stream creation call. By default, BASS will use the Windows proxy settings, as set in the Internet Properties control panel.</para>
            </description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            As the BASS_CONFIG_NET_PROXY and BASS_CONFIG_NET_AGENT options take a pointer to an ANSI string 
            as an argument you must first marshal a string to a heap pointer and pin it, so that the garbage collector can not re-locate it.
            <para>The following example copies the contents of a managed String into unmanaged memory:</para>
            <code>
            public IntPtr _myUserAgentPtr;
            ...
            // create an unmanaged pointer containing a copy of the string
            _myUserAgentPtr = Marshal.StringToHGlobalAnsi("radio42");
            Bass.BASS_SetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT, _myUserAgentPtr);
            ...
            // make sure to free the myUserAgentPtr!!! 
            // e.g. when you dispose your class or application
            Marshal.FreeHGlobal(_myUserAgentPtr);
            </code>
            <code lang="vbnet">
            Public _myUserAgentPtr As IntPtr
            ...
            ' create an unmanaged pointer containing a copy of the string
            _myUserAgentPtr = Marshal.StringToHGlobalAnsi("radio42")
            Bass.BASS_SetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT, _myUserAgentPtr)
            ...
            ' make sure to free the myUserAgentPtr!!! 
            ' e.g. when you dispose your class or application
            Marshal.FreeHGlobal(_myUserAgentPtr)
            </code>
            If you need to dynamically change the BASS_CONFIG_NET_PROXY or BASS_CONFIG_NET_AGENT option, 
            you will need to call <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> each time again!
            <code>
            public static string _myUserAgent = "radio42";
            public IntPtr _myUserAgentPtr;
            ...
            // create an unmanaged pointer containing a copy of the string
            _myUserAgentPtr = Marshal.StringToHGlobalAnsi(_myUserAgent);
            Bass.BASS_SetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT, _myUserAgentPtr);
            ...
            // change it to a new value,
            // but first free the previous one
            Marshal.FreeHGlobal(_myUserAgentPtr);
            // then assign the new value
            _myUserAgent = "new value";
            _myUserAgentPtr = Marshal.StringToHGlobalAnsi(_myUserAgent);
            Bass.BASS_SetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT, _myUserAgentPtr);
            ...
            // make sure to free the myUserAgentPtr!!! 
            // e.g. when you dispose your class or application
            Marshal.FreeHGlobal(_myUserAgentPtr);
            </code>
            <code lang="vbnet">
            Public Shared _myUserAgent As String =  "radio42" 
            Public _myUserAgentPtr As IntPtr
            ...
            ' create an unmanaged pointer containing a copy of the string
            _myUserAgentPtr = Marshal.StringToHGlobalAnsi(_myUserAgent)
            Bass.BASS_SetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT, _myUserAgentPtr)
            ...
            ' change it to a new value,
            ' but first free the previous one
            Marshal.FreeHGlobal(_myUserAgentPtr)
            ' then assign the new value
            _myUserAgent = "new value"
            _myUserAgentPtr = Marshal.StringToHGlobalAnsi(_myUserAgent)
            Bass.BASS_SetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT, _myUserAgentPtr)
            ...
            ' make sure to free the myUserAgentPtr!!! 
            ' e.g. when you dispose your class or application
            Marshal.FreeHGlobal(_myUserAgentPtr)
            </code>
            An alternative way of creating a pointer to a managed object and pinning it
            is the use of GCHandle:
            <code>
            private GCHandle _userAgentGCH;
            ...
            string userAgent = "BASS.NET";
            byte[] userAgentBytes = Encoding.ASCII.GetBytes(userAgent);
            // create a pinned handle to our managed object
            _userAgentGCH = GCHandle.Alloc(userAgentBytes, GCHandleType.Pinned);
            // use the pointer to the string
            Bass.BASS_SetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT, _userAgentGCH.AddrOfPinnedObject());
            ...
            // make sure to free the handle when you don't need it anymore!
            // e.g. when you dispose your class or application
            _userAgentGCH.Free();
            </code>
            <code lang="vbnet">
            Private _userAgentGCH As GCHandle
            ...
            Dim userAgent As String = "BASS.NET"
            Dim userAgentBytes As Byte() = Encoding.ASCII.GetBytes(userAgent)
            ' create a pinned handle to our managed object
            _userAgentGCH = GCHandle.Alloc(userAgentBytes, GCHandleType.Pinned)
            ' use the pointer to the string
            Bass.BASS_SetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT, _userAgentGCH.AddrOfPinnedObject())
            ...
            ' make sure to free the handle when you don't need it anymore!
            ' e.g. when you dispose your class or application
            _userAgentGCH.Free()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)">
            <summary>
            Retrieves the value of a config option.
            </summary>
            <param name="option">The option to get the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <returns>If successful, the value of the requested config option is returned (as an int), else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_3DALGORITHM</term><description>The 3D algorithm for software mixed 3D channels.</description></item>
            <item><term>BASS_CONFIG_BUFFER</term><description>Playback buffer length.</description></item>
            <item><term>BASS_CONFIG_CURVE_VOL</term><description>Volume translation curve.</description></item>
            <item><term>BASS_CONFIG_CURVE_PAN</term><description>Panning translation curve.</description></item>
            <item><term>BASS_CONFIG_FLOATDSP</term><description>Pass 32-bit floating-point sample data to all DSP functions?</description></item>
            <item><term>BASS_CONFIG_GVOL_MUSIC</term><description>Global music volume.</description></item>
            <item><term>BASS_CONFIG_GVOL_SAMPLE</term><description>Global sample volume.</description></item>
            <item><term>BASS_CONFIG_GVOL_STREAM</term><description>Global stream volume.</description></item>
            <item><term>BASS_CONFIG_MP3_CODEC</term><description>The MP3 decoder to use... 0 = BASS, 1 = Windows.</description></item>
            <item><term>BASS_CONFIG_MUSIC_VIRTUAL</term><description>The maximum number of virtual channels to use in the rendering of IT files.</description></item>
            <item><term>BASS_CONFIG_NET_PLAYLIST</term><description>Process URLs in PLS and M3U playlists?</description></item>
            <item><term>BASS_CONFIG_NET_BUFFER</term><description>Internet download buffer length.</description></item>
            <item><term>BASS_CONFIG_NET_PROXY</term><description>Proxy server settings.</description></item>
            <item><term>BASS_CONFIG_NET_PASSIVE</term><description>Use passive mode in FTP connections?</description></item>
            <item><term>BASS_CONFIG_NET_PREBUF</term><description>Amount to pre-buffer when opening internet streams.</description></item>
            <item><term>BASS_CONFIG_NET_TIMEOUT</term><description>Time to wait for a server to respond to a connection request.</description></item>
            <item><term>BASS_CONFIG_PAUSE_NOPLAY</term><description>Prevent channels being played when the output is paused?</description></item>
            <item><term>BASS_CONFIG_REC_BUFFER</term><description>Recording buffer length.</description></item>
            <item><term>BASS_CONFIG_UPDATEPERIOD</term><description>Update period of playback buffers.</description></item>
            <item><term>BASS_CONFIG_UPDATETHREADS</term><description>Number of update threads.</description></item>
            <item><term>BASS_CONFIG_VERIFY</term><description>File format verification length.</description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the current playback buffer length:
            <code>
            int bufLen = Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_BUFFER);
            </code>
            <code lang="vbnet">
            Dim bufLen As Integer = Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_BUFFER)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetConfigBool(Un4seen.Bass.BASSConfig)">
            <summary>
            Retrieves the value of a config option as a bool.
            </summary>
            <param name="option">The option to get the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <returns>If successful, the value of the requested config option is returned (as a bool). Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_CURVE_VOL</term><description>Volume translation curve.</description></item>
            <item><term>BASS_CONFIG_CURVE_PAN</term><description>Panning translation curve.</description></item>
            <item><term>BASS_CONFIG_FLOATDSP</term><description>Pass 32-bit floating-point sample data to all DSP functions?</description></item>
            <item><term>BASS_CONFIG_MP3_CODEC</term><description>The MP3 decoder to use... FALSE = BASS, TRUE = Windows.</description></item>
            <item><term>BASS_CONFIG_NET_PASSIVE</term><description>Use passive mode in FTP connections?</description></item>
            <item><term>BASS_CONFIG_PAUSE_NOPLAY</term><description>Prevent channels being played when the output is paused?</description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the DSP processing option:
            <code>
            bool floatDSP = Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_FLOATDSP);
            </code>
            <code lang="vbnet">
            Dim floatDSP As Boolean = Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_FLOATDSP)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetConfigPtr(Un4seen.Bass.BASSConfig)">
            <summary>
            Retrieves the value of a pointer config option.
            </summary>
            <param name="option">The option to get the value of...(see <see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <returns>If successful, the value of the requested config option is returned (as an IntPtr). Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_NET_AGENT</term><description>"User-Agent" header.</description></item>
            <item><term>BASS_CONFIG_NET_PROXY</term><description>Proxy server settings.</description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the current user agent header:
            <code>
            string userAgent = String.Empty;
            IntPtr p = Bass.BASS_GetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT);
            if (p != IntPtr.Zero)
            {
              userAgent = Marshal.PtrToStringAnsi(p);
            }
            </code>
            <code lang="vbnet">
            Dim userAgent As String = [String].Empty
            Dim p As IntPtr = Bass.BASS_GetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT)
            If p &lt;&gt; IntPtr.Zero Then
              userAgent = Marshal.PtrToStringAnsi(p)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetConfigString(Un4seen.Bass.BASSConfig)">
            <summary>
            Retrieves the value of a pointer config option as an Ansi string.
            </summary>
            <param name="option">The option to get the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <returns>If successful, the value of the requested config option is returned (as an Ansi String). Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_NET_AGENT</term><description>"User-Agent" header.</description></item>
            <item><term>BASS_CONFIG_NET_PROXY</term><description>Proxy server settings.</description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the current user agent header:
            <code>
            string userAgent = Bass.BASS_GetConfigString(BASSConfig.BASS_CONFIG_NET_AGENT);
            if (userAgent != null)
            {
              ...
            }
            </code>
            <code lang="vbnet">
            Dim userAgent As String = Bass.BASS_GetConfigString(BASSConfig.BASS_CONFIG_NET_AGENT)
            If Not (userAgent Is Nothing) Then
              ...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginLoadUnicode(System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="file"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)">
            <summary>
            Plugs on "add-on" into the standard stream and sample creation functions.
            <para>This overload implements the Unicode version for the file name.</para>
            </summary>
            <param name="file">Filename of the add-on/plugin.</param>
            <returns>If successful, the loaded plugin's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Support for additional file formats is available via add-ons, which can be downloaded from the BASS website: <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            <para>There are 2 ways in which add-ons can provide support for additional formats. They can provide dedicated functions to create streams of the specific format(s) they support and/or they can plug into the standard stream creation functions - <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>. 
            This function enables the latter method. Both methods can be used side by side. The obvious advantage of the plugin system is convenience, while the dedicated functions can provide extra options that are not possible via the shared function interfaces. See an add-on's documentation for more specific details on it.</para>
            <para>As well as the stream creation functions, plugins also add their additional format support to <see cref="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.String,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>.</para>
            <para>When using multiple plugins, the stream/sample creation functions will try each of them in the order that they were loaded via this function, until one that accepts the file is found.</para>
            <para>When an add-on is already loaded (eg. if you're using functions from it), the plugin system will use the same instance (the reference count will just be incremented), ie. there won't be 2 copies of the add-on in memory.</para>
            <para>Note: Only stream/music add-ons are loaded (e.g. bass_fx.dll or bass_vis.dll are NOT loaded).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The <paramref name="file"/> could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The <paramref name="file"/> is not a plugin.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The <paramref name="file"/> is already plugged in.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Add-On residing in same directory:
            <code>
            // load the FLAC add-on
            int pluginFlac = Bass.BASS_PluginLoad("bassflac.dll");
            ...
            // use the add-on
            int stream = Bass.BASS_StreamCreateFile("file.flac", 0, 0, BASSFlag.BASS_DEFAULT);
            ...
            // un-load the FLAC add-on
            Bass.BASS_PluginFree(pluginFlac);
            </code>
            <code lang="vbnet">
            ' load the FLAC add-on
            Dim pluginFlac As Integer = Bass.BASS_PluginLoad("bassflac.dll")
            ...
            ' use the add-on
            Dim stream As Integer = Bass.BASS_StreamCreateFile("file.flac", 0, 0, BASSFlag.BASS_DEFAULT)
            ...
            ' un-load the FLAC add-on
            Bass.BASS_PluginFree(pluginFlac)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginFree(System.Int32)">
            <summary>
            Unplugs an add-on.
            </summary>
            <param name="handle">The plugin handle... 0 = all plugins.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>If there are streams created by a plugin in existence when it is being freed, the streams will automatically be freed too. Samples loaded by the plugin are unaffected as the plugin has nothing to do with them once they are loaded (the sample data is already fully decoded).
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Add-On residing in same directory:
            <code>
            // load the FLAC add-on
            int pluginFlac = Bass.BASS_PluginLoad("bassflac.dll");
            ...
            // use the add-on
            int stream = Bass.BASS_StreamCreateFile("file.flac", 0, 0, BASSFlag.BASS_DEFAULT);
            ...
            // un-load the FLAC add-on
            Bass.BASS_PluginFree(pluginFlac);
            </code>
            <code lang="vbnet">
            ' load the FLAC add-on
            Dim pluginFlac As Integer = Bass.BASS_PluginLoad("bassflac.dll")
            ...
            ' use the add-on
            Dim stream As Integer = Bass.BASS_StreamCreateFile("file.flac", 0, 0, BASSFlag.BASS_DEFAULT)
            ...
            ' un-load the FLAC add-on
            Bass.BASS_PluginFree(pluginFlac)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)">
            <summary>
            Tries to loads all BASS add-ons (bass*.dll) contained in the specified directory.
            </summary>
            <param name="dir">The directory in which to search for BASS add-ons (bass*.dll).</param>
            <returns>A hash table containing all successfully loaded BASS add-ons.
            <para>The hash table will be constructed as: Key=pluginHandle and Value=filename.</para>
            <para>Note: Only stream/music add-ons are loaded (e.g. bass_fx.dll or bassenc.dll are NOT loaded).</para>
            </returns>
            <remarks>Internally the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> method will be used to load all add-ons contained in the specified directory folder (sub-folders are not scanned as well).</remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory("C:\\BASS");
            if (loadedPlugIns != null)
            {
              foreach (string file in loadedPlugIns.Values)
                Console.Writeln( file );
            }
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory("C:\BASS")
            If Not (loadedPlugIns Is Nothing) Then
              Dim file As String
              For Each file In loadedPlugIns.Values
                Console.Writeln(file)
              Next file
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginGetInfoPtr(System.Int32)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)">
            <summary>
            Retrieves information on a plugin.
            </summary>
            <param name="handle">The plugin handle - or 0 to retrieve native BASS information.</param>
            <returns>If successful, an instance of <see cref="T:Un4seen.Bass.BASS_PLUGININFO"/> is returned, else NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The plugin information does not change, so the returned info remains valid for as long as the plugin is loaded.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>List the formats supported by a plugin:
            <code>
            int pluginFlac = Bass.BASS_PluginLoad("bassflac.dll");
            BASS_PLUGININFO info = Bass.BASS_PluginGetInfo(pluginFlac);
            foreach (BASS_PLUGINFORM f in info.formats)
              Console.WriteLine("Type={0}, Name={1}, Exts={2}", f.ctype, f.name, f.exts);
            </code>
            <code lang="vbnet">
            Dim pluginFlac As Integer = Bass.BASS_PluginLoad("bassflac.dll")
            Dim info As BASS_PLUGININFO = Bass.BASS_PluginGetInfo(pluginFlac)
            Dim f As BASS_PLUGINFORM
            For Each f In info.formats
              Console.WriteLine("Type={0}, Name={1}, Exts={2}", f.ctype, f.name, f.exts)
            Next f
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetEAXParameters(Un4seen.Bass.EAXEnvironment@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Retrieves the current type of EAX environment and it's parameters.
            </summary>
            <param name="env">The EAX environment to get (one of the <see cref="T:Un4seen.Bass.EAXEnvironment"/> values).</param>
            <param name="vol">The volume of the reverb.</param>
            <param name="decay">The decay duration.</param>
            <param name="damp">The damping.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOEAX</term><description>The current device does not support EAX.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the current EAX environment and all it's settings:
            <code>
            EAXEnvironment env = EAXEnvironment.EAX_ENVIRONMENT_LEAVECURRENT;
            float vol = 0f;
            float decay = 0f;
            float damp = 0f;
            if (Bass.BASS_GetEAXParameters(ref env, ref vol, ref decay, ref damp))
              Console.WriteLine("Env={0}, Vol={1}, Decay={2}, Damp={3}", env, vol, decay, damp);
            </code>
            <code lang="vbnet">
            Dim env As EAXEnvironment = EAXEnvironment.EAX_ENVIRONMENT_LEAVECURRENT
            Dim vol As Single = 0F
            Dim decay As Single = 0F
            Dim damp As Single = 0F
            If Bass.BASS_GetEAXParameters(env, vol, decay, damp) Then
              Console.WriteLine("Env={0}, Vol={1}, Decay={2}, Damp={3}", env, vol, decay, damp)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetEAXParameters(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Retrieves the current type of EAX environment and it's parameters.
            Note: This is a generic overload using object references, so that you can pass NULL values as in the C++ interface.
            So make sure to pass object references of the currect type into this method and cast the return value back to the correct data types!
            </summary>
            <param name="env">The EAX environment (int)... NULL = don't retrieve it. See <see cref="M:Un4seen.Bass.Bass.BASS_SetEAXParameters(Un4seen.Bass.EAXEnvironment,System.Single,System.Single,System.Single)"/> for a list of the possible environments (or use one of these <see cref="T:Un4seen.Bass.EAXEnvironment"/> values, which need to be casted into an (object) here).</param>
            <param name="vol">The volume of the reverb (float)... NULL = don't retrieve it.</param>
            <param name="decay">The decay duration (float)... NULL = don't retrieve it.</param>
            <param name="damp">The damping (float)... NULL = don't retrieve it.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOEAX</term><description>The current device does not support EAX.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the current environment setting and volume:
            <code>
            object env = EAXEnvironment.EAX_ENVIRONMENT_LEAVECURRENT;
            object vol = 0f;
            if ( Bass.BASS_GetEAXParameters( env, vol, null, null ) )
            {
              // env needs to be casted back to an EAXEnvironment
              // vol needs to be casted back to float
              Console.WriteLine( "Env={0}, Vol={1}", (EAXEnvironment)env, (float)vol );
            }
            else
            	Console.WriteLine( "Bass_Init error OR Device does not support EAX!" );
            </code>
            <code lang="vbnet">
            Dim env As Object = EAXEnvironment.EAX_ENVIRONMENT_LEAVECURRENT
            Dim vol As Object = 0F
            If Bass.BASS_GetEAXParameters(env, vol, Nothing, Nothing) Then
              ' env needs to be casted back to an EAXEnvironment
              ' vol needs to be casted back to float
              Console.WriteLine("Env={0}, Vol={1}", CType(env, EAXEnvironment), CSng(vol))
            Else
              Console.WriteLine("Bass_Init error OR Device does not support EAX!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetEAXParameters(Un4seen.Bass.EAXEnvironment,System.Single,System.Single,System.Single)">
            <summary>
            Sets the type of EAX environment and it's parameters.
            </summary>
            <param name="env">The EAX environment... -1 = leave current, or one of the these <see cref="T:Un4seen.Bass.EAXEnvironment"/>.</param>
            <param name="vol">The volume of the reverb... 0.0 (off) - 1.0 (max), less than 0.0 = leave current.</param>
            <param name="decay">The time in seconds it takes the reverb to diminish by 60dB... 0.1 (min) - 20.0 (max), less than 0.0 = leave current.</param>
            <param name="damp">The damping, high or low frequencies decay faster... 0.0 = high decays quickest, 1.0 = low/high decay equally, 2.0 = low decays quickest, less than 0.0 = leave current.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Obviously, EAX functions have no effect if no EAX supporting device is used. You can use <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> to check if the current device suports EAX. EAX only affects 3D channels, but EAX functions do NOT require <see cref="M:Un4seen.Bass.Bass.BASS_Apply3D"/> to apply the changes.</para>
            <para>Presets are provided for all the EAX environments. To use a preset, simply call <see cref="M:Un4seen.Bass.Bass.BASS_SetEAXParameters(Un4seen.Bass.EAXEnvironment,System.Single,System.Single,System.Single)"/>, with the 'preset' overload set to one of these <see cref="T:Un4seen.Bass.EAXPreset"/> values.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOEAX</term><description>The current device does not support EAX.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Leave the currect environment and damping, but set the volume and decay duration:
            <code>
            Bass.BASS_SetEAXParameters( EAXEnvironment.EAX_ENVIRONMENT_LEAVECURRENT, 0.3f, 1f, -1f );
            </code>
            <code lang="vbnet">
            Bass.BASS_SetEAXParameters( EAXEnvironment.EAX_ENVIRONMENT_LEAVECURRENT, 0.3F, 1F, -1F )
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetEAXParameters(Un4seen.Bass.EAXPreset)">
            <summary>
            Overload implementing the use of <see cref="T:Un4seen.Bass.EAXPreset"/>.
            A preset already sets prediefined values for "vol", "decay" and "damp".
            </summary>
            <param name="preset">The <see cref="T:Un4seen.Bass.EAXPreset"/> to use and set.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Obviously, EAX functions have no effect if no EAX supporting device is used. You can use <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> to check if the current device suports EAX. EAX only affects 3D channels, but EAX functions do NOT require <see cref="M:Un4seen.Bass.Bass.BASS_Apply3D"/> to apply the changes.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOEAX</term><description>The current device does not support EAX.</description></item>
            </list>
            </para>
            </remarks>
            <example>Use the EAX_PRESET_ARENA preset:
            <code>
            Bass.BASS_SetEAXParameters(EAXPreset.EAX_PRESET_ARENA);
            </code>
            <code lang="vbnet">
            Bass.BASS_SetEAXParameters(EAXPreset.EAX_PRESET_ARENA)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Apply3D">
            <summary>
            Applies changes made to the 3D system.
            </summary>
            <remarks>
            <para>This must be called to apply any changes made with <see cref="M:Un4seen.Bass.Bass.BASS_Set3DFactors(System.Single,System.Single,System.Single)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Set3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DPosition(System.Int32,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>. 
            It improves performance to have DirectSound do all the required recalculating at the same time like this, rather than recalculating after every little change is made.</para>
            <para>This function applies 3D changes on all the initialized devices - there's no need to re-call it for each individual device when using multiple devices.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Set3DFactors(System.Single,System.Single,System.Single)">
            <summary>
            Sets the factors that affect the calculations of 3D sound.
            </summary>
            <param name="distf">The distance factor... less than 0.0 = leave current... examples: 1.0 = use meters, 0.9144 = use yards, 0.3048 = use feet. By default BASS measures distances in meters, you can change this setting if you are using a different unit of measurement.</param>
            <param name="rollf">The rolloff factor, how fast the sound quietens with distance... 0.0 (min) - 10.0 (max), less than 0.0 = leave current... examples: 0.0 = no rolloff, 1.0 = real world, 2.0 = 2x real.</param>
            <param name="doppf">The doppler factor... 0.0 (min) - 10.0 (max), less than 0.0 = leave current... examples: 0.0 = no doppler, 1.0 = real world, 2.0 = 2x real. The doppler effect is the way a sound appears to change pitch when it is moving towards or away from you (say hello to Einstein!). The listener and sound velocity settings are used to calculate this effect, this doppf value can be used to lessen or exaggerate the effect.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As with all 3D functions, use <see cref="M:Un4seen.Bass.Bass.BASS_Apply3D"/> to apply the changes.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device was not initialized with 3D support.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            To use yards as the distance measurement unit, while leaving the current rolloff and doppler factors untouched:
            <code>
            Bass.BASS_Set3DFactors(0.9144f, -1f, -1f);
            Bass.BASS_Apply3D(); // apply the change
            </code>
            <code lang="vbnet">
            Bass.BASS_Set3DFactors(0.9144F, -1F, -1F)
            Bass.BASS_Apply3D() ' apply the change
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Get3DFactors(System.Single@,System.Single@,System.Single@)">
            <summary>
            Retrieves the factors that affect the calculations of 3D sound.
            <para>This overload allows you to only get all three values at a time.</para>
            </summary>
            <param name="distf">The distance factor.</param>
            <param name="rollf">The rolloff factor.</param>
            <param name="doppf">The doppler factor.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device was not initialized with 3D support.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            float distf = 0f;
            float rollf = 0f;
            float doppf = 0f;
            Bass.BASS_Get3DFactors(ref distf, ref rollf, ref doppf);
            </code>
            <code lang="vbnet">
            Dim distf As Single = 0F
            Dim rollf As Single = 0F
            Dim doppf As Single = 0F
            Bass.BASS_Get3DFactors(distf, rollf, doppf)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Get3DFactors(System.Object,System.Object,System.Object)">
            <summary>
            Retrieves the factors that affect the calculations of 3D sound.
            <para>This overload uses objects (so you can pass NULL in order to NOT retrieve a value). However a requested return value needs to be casted back into a float after getting it.</para>
            </summary>
            <param name="distf">The distance factor... NULL = don't retrieve it.</param>
            <param name="rollf">The rolloff factor... NULL = don't retrieve it.</param>
            <param name="doppf">The doppler factor... NULL = don't retrieve it.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device was not initialized with 3D support.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Only get the distance factor:
            <code>
            object distf = 0f;
            Bass.BASS_Get3DFactors(distf, null, null);
            float distanceFactor = (float)distf;
            </code>
            <code lang="vbnet">
            Dim distf As Object = 0F
            Bass.BASS_Get3DFactors(distf, Nothing, Nothing)
            Dim distanceFactor As Single = CSng(distf)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Set3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)">
            <summary>
            Retrieves the position, velocity, and orientation of the listener.
            </summary>
            <param name="pos">The position of the listener... NULL = don't retrieve it.</param>
            <param name="vel">The listener's velocity... NULL = don't retrieve it.</param>
            <param name="front">The direction that the listener's front is pointing... NULL=don't retrieve it.</param>
            <param name="top">The direction that the listener's top is pointing... NULL = don't retrieve it.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The <paramref name="front"/> and <paramref name="top"/> parameters must both be retrieved in a single call, they can not be retrieved individually.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device was not initialized with 3D support.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set the current listener position only:
            <code>
            BASS_3DVECTOR pos = new BASS_3DVECTOR();
            Bass.BASS_Set3DPosition(pos, null, null, null);
            </code>
            <code lang="vbnet">
            Dim pos As New BASS_3DVECTOR()
            Bass.BASS_Set3DPosition(pos, Nothing, Nothing, Nothing)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Get3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)">
            <summary>
            Retrieves the position, velocity, and orientation of the listener.
            </summary>
            <param name="pos">The position of the listener... NULL = don't retrieve it.</param>
            <param name="vel">The listener's velocity... NULL = don't retrieve it.</param>
            <param name="front">The direction that the listener's front is pointing... NULL=don't retrieve it.</param>
            <param name="top">The direction that the listener's top is pointing... NULL = don't retrieve it.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The <paramref name="front"/> and <paramref name="top"/> parameters must both be retrieved in a single call, they can not be retrieved individually.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device was not initialized with 3D support.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the current listener position only:
            <code>
            BASS_3DVECTOR pos = new BASS_3DVECTOR();
            Bass.BASS_Get3DPosition(pos, null, null, null);
            </code>
            <code lang="vbnet">
            Dim pos As New BASS_3DVECTOR()
            Bass.BASS_Get3DPosition(pos, Nothing, Nothing, Nothing)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleLoadUnicode(System.Boolean,System.String,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="max"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.String,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Loads a WAV, AIFF, MP3, MP2, MP1, OGG or plugin supported sample.
            <para>This overload uses Unicode file names! A BASS_UNICODE flag will automatically be added.</para>
            </summary>
            <param name="file">The file name to load the sample from.</param>
            <param name="offset">File offset to load the sample from.</param>
            <param name="length">Data length... 0 = use all data up to the end of file. If length over-runs the end of the file, it'll automatically be lowered to the end of the file.</param>
            <param name="max">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the BASS_SAMPLE_OVER flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data (not really recommended for samples). WDM drivers are required to use this flag in Windows. See Floating-point channels for more info.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped? Note that only complete sample loops are allowed, you can't loop just a part of the sample. More fancy looping can be achieved by streaming the file.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Convert the sample (MP3/MP2/MP1 only) to mono, if it's not already. This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the sample to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_VAM</term><description>requires DirectX 7 or above: Enables the DX7 voice allocation and management features on the sample, which allows the sample to be played in software or hardware. This flag is ignored if the BASS_SAMPLE_SOFTWARE flag is also specified.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D samples must be mono.</description></item>
            <item><term>BASS_SAMPLE_MUTEMAX</term><description>Mute the sample when it is at (or beyond) it's max distance (3D samples only).</description></item>
            <item><term>BASS_SAMPLE_OVER_VOL</term><description>Override: the channel with the lowest volume is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_POS</term><description>Override: the longest playing channel is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_DIST</term><description>Override: the channel furthest away (from the listener) is overriden (3D samples only).</description></item>
            <item><term>BASS_UNICODE</term><description>file is a Unicode (16-bit characters) filename (no need to set this for this overload).</description></item>
            </list>
            </param>
            <returns>If successful, the loaded sample's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>WAV files can be in standard PCM format or they can be compressed with any ACM codec, but the codec is required to be installed on the user's computer for the WAV to be decoded. So, you should either distribute the codec with your software, or use a codec that comes with Windows (eg. Microsoft ADPCM). Additional format support is available via the plugin system (see <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>).</para>
            <para>Unless the BASS_SAMPLE_SOFTWARE flag is used, the sample will use hardware mixing if hardware resources are available. Use <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware. 
            The BASS_SAMPLE_VAM flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded. A sample's VAM options are set via <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.</para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/>, which can then be played using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Sample functions are not available when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="max"/> and/or <paramref name="length"/> is invalid. The <paramref name="length"/> must be specified when loading from memory.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The <paramref name="file"/> could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The <paramref name="file"/>'s format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the sample is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play a sample with it's default settings:
            <code>
            int sample = Bass.BASS_SampleLoad("test.wav", 0L, 0, 1, BASSFlag.BASS_DEFAULT);
            int channel = Bass.BASS_SampleGetChannel(sample, false); // get a sample channel
            Bass.BASS_ChannelPlay(channel, false); // play it
            </code>
            <code lang="vbnet">
            Dim sample As Integer = Bass.BASS_SampleLoad("test.wav", 0L.ToUInt32(), 0, 1, BASSFlag.BASS_DEFAULT)
            Dim channel As Integer = Bass.BASS_SampleGetChannel(sample, False) ' get a sample channel
            Bass.BASS_ChannelPlay(channel, False) ' play it
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleLoadMemory(System.Boolean,System.IntPtr,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="max"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.IntPtr,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Loads a WAV, AIFF, MP3, MP2, MP1, OGG or plugin supported sample.
            <para>This overload uses an unmanaged IntPtr and implements loading a sample from memory.</para>
            </summary>
            <param name="memory">An unmanaged IntPtr to the allocated memory block at which the sample data resides.</param>
            <param name="offset">File offset to load the sample from (NOT used here!).</param>
            <param name="length">Data length. Should be set to the length of the data contained in memory.</param>
            <param name="max">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the BASS_SAMPLE_OVER flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data (not really recommended for samples). WDM drivers are required to use this flag in Windows. See Floating-point channels for more info.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped? Note that only complete sample loops are allowed, you can't loop just a part of the sample. More fancy looping can be achieved by streaming the file.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Convert the sample (MP3/MP2/MP1 only) to mono, if it's not already. This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the sample to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_VAM</term><description>requires DirectX 7 or above: Enables the DX7 voice allocation and management features on the sample, which allows the sample to be played in software or hardware. This flag is ignored if the BASS_SAMPLE_SOFTWARE flag is also specified.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D samples must be mono.</description></item>
            <item><term>BASS_SAMPLE_MUTEMAX</term><description>Mute the sample when it is at (or beyond) it's max distance (3D samples only).</description></item>
            <item><term>BASS_SAMPLE_OVER_VOL</term><description>Override: the channel with the lowest volume is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_POS</term><description>Override: the longest playing channel is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_DIST</term><description>Override: the channel furthest away (from the listener) is overriden (3D samples only).</description></item>
            </list>
            </param>
            <returns>If successful, the loaded sample's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>WAV files can be in standard PCM format or they can be compressed with any ACM codec, but the codec is required to be installed on the user's computer for the WAV to be decoded. So, you should either distribute the codec with your software, or use a codec that comes with Windows (eg. Microsoft ADPCM). Additional format support is available via the plugin system (see <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>).</para>
            <para>Unless the BASS_SAMPLE_SOFTWARE flag is used, the sample will use hardware mixing if hardware resources are available. Use <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware. 
            The BASS_SAMPLE_VAM flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded. A sample's VAM options are set via <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.</para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/>, which can then be played using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>.</para>
            <para>There is no need to pin the memory buffer for this method, since BASS creates a copy of the data internally, 
            so the buffer provided will not be used anymore when the method returns.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Sample functions are not available when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="max"/> and/or <paramref name="length"/> is invalid. The <paramref name="length"/> must be specified when loading from memory.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The <paramref name="file"/> could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The <paramref name="file"/>'s format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the sample is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            See <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>for examples on how to load data from memory.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleLoadMemory(System.Boolean,System.Byte[],System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="max"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.Byte[],System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Loads a WAV, AIFF, MP3, MP2, MP1, OGG or plugin supported sample.
            <para>This overload uses an unmanaged IntPtr and implements loading a sample from memory.</para>
            </summary>
            <param name="memory">A managed byte[] containing the sample data to load.</param>
            <param name="offset">File offset to load the sample from (NOT used here!).</param>
            <param name="length">Data length. Should be set to the length of the data contained in memory.</param>
            <param name="max">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the BASS_SAMPLE_OVER flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data (not really recommended for samples). WDM drivers are required to use this flag in Windows. See Floating-point channels for more info.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped? Note that only complete sample loops are allowed, you can't loop just a part of the sample. More fancy looping can be achieved by streaming the file.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Convert the sample (MP3/MP2/MP1 only) to mono, if it's not already. This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the sample to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_VAM</term><description>requires DirectX 7 or above: Enables the DX7 voice allocation and management features on the sample, which allows the sample to be played in software or hardware. This flag is ignored if the BASS_SAMPLE_SOFTWARE flag is also specified.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D samples must be mono.</description></item>
            <item><term>BASS_SAMPLE_MUTEMAX</term><description>Mute the sample when it is at (or beyond) it's max distance (3D samples only).</description></item>
            <item><term>BASS_SAMPLE_OVER_VOL</term><description>Override: the channel with the lowest volume is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_POS</term><description>Override: the longest playing channel is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_DIST</term><description>Override: the channel furthest away (from the listener) is overriden (3D samples only).</description></item>
            </list>
            </param>
            <returns>If successful, the loaded sample's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>WAV files can be in standard PCM format or they can be compressed with any ACM codec, but the codec is required to be installed on the user's computer for the WAV to be decoded. So, you should either distribute the codec with your software, or use a codec that comes with Windows (eg. Microsoft ADPCM). Additional format support is available via the plugin system (see <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>).</para>
            <para>Unless the BASS_SAMPLE_SOFTWARE flag is used, the sample will use hardware mixing if hardware resources are available. Use <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware. 
            The BASS_SAMPLE_VAM flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded. A sample's VAM options are set via <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.</para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/>, which can then be played using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>.</para>
            <para>There is no need to pin the memory buffer for this method, since BASS creates a copy of the data internally, 
            so the buffer provided will not be used anymore when the method returns.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Sample functions are not available when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="max"/> and/or <paramref name="length"/> is invalid. The <paramref name="length"/> must be specified when loading from memory.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The <paramref name="file"/> could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The <paramref name="file"/>'s format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the sample is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            See <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> for examples on how to load data from memory.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Initiates the creation of a user generated sample.
            </summary>
            <param name="length">The sample's length, in bytes.</param>
            <param name="freq">The default sample rate... 100 (min) - 100000 (max).</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, etc... More than stereo requires WDM drivers in Windows.</param>
            <param name="max">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the BASS_SAMPLE_OVER flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="flags">A combination of these flags (<see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data (not really recommended for samples). WDM drivers are required to use this flag in Windows. See Floating-point channels for more info.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped? Note that only complete sample loops are allowed, you can't loop just a part of the sample. More fancy looping can be achieved via streaming.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the sample to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_VAM</term><description>requires DirectX 7 or above: Enables the DX7 voice allocation and management features on the sample, which allows the sample to be played in software or hardware. This flag is ignored if the BASS_SAMPLE_SOFTWARE flag is also specified.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D samples must be mono (use BASS_SAMPLE_MONO).</description></item>
            <item><term>BASS_SAMPLE_MUTEMAX</term><description>Mute the sample when it is at (or beyond) it's max distance (software 3D samples only).</description></item>
            <item><term>BASS_SAMPLE_OVER_VOL</term><description>Override: the channel with the lowest volume is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_POS</term><description>Override: the longest playing channel is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_DIST</term><description>Override: the channel furthest away (from the listener) is overriden (3D samples only).</description></item>
            </list>
            </param>
            <returns>If successful, the new sample's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The sample's initial content is undefined. <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetData(System.Int32,System.IntPtr)"/> should be used to set the sample's data.</para>
            <para>Unless the BASS_SAMPLE_SOFTWARE flag is used, the sample will use hardware mixing if hardware resources are available. 
            Use <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware. 
            The BASS_SAMPLE_VAM flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded. 
            A sample's VAM options are set via <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.</para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/>, which can then be played using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Sample functions are not available when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="max"/> is invalid..</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the sample is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Create a 440Hz sine-wave, 16-bit, mono:
            <code>
            // create the sample
            int sample = Bass.BASS_SampleCreate(256, 28160, 1, 1, 
                              BASSFlag.BASS_SAMPLE_LOOP | BASSFlag.BASS_SAMPLE_OVER_POS );
            // the data buffer (256 byte = 128 Int16)
            short[] data = new short[128];
            // create the sine wave
            for (int a=0; a&lt;128; a++)
              data[a] = (short)(32767.0 * Math.Sin((double)a * 6.283185 / 64d));
            // set the sample's data 
            Bass.BASS_SampleSetData(sample, data);
            // get a sample channel
            int channel = Bass.BASS_SampleGetChannel(sample, false);
            // play it
            Bass.BASS_ChannelPlay(channel, false);
            </code>
            <code lang="vbnet">
            ' create the sample
            Dim sample As Integer = Bass.BASS_SampleCreate(256, 28160, 1, 1, BASSFlag.BASS_SAMPLE_LOOP Or BASSFlag.BASS_SAMPLE_OVER_POS)
            ' the data buffer (256 byte = 128 Int16)
            Dim data(128) As Short
            ' create the sine wave
            Dim a As Integer
            For a = 0 To 127
              data(a) = CShort(32767.0 * Math.Sin((CDbl(a) * 6.283185 / 64.0)))
            Next a 
            ' set the sample's data 
            Bass.BASS_SampleSetData(sample, data)
            ' get a sample channel
            Dim channel As Integer = Bass.BASS_SampleGetChannel(sample, False)
            ' play it
            Bass.BASS_ChannelPlay(channel, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleSetData(System.Int32,System.IntPtr)">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">Pointer to the data to set.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The required length and format of the data can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>A sample's data can be set at any time, including during playback.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleSetData(System.Int32,System.Single[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array of float values representing the sample data to set.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The required length and format of the data can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>A sample's data can be set at any time, including during playback.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleSetData(System.Int32,System.Int32[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array of Int32 values representing the sample data to set (Caution: Int32=2xInt16, so this overload can e.g. be used to provide a stereo sample containing of two 16-bit values).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The required length and format of the data can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>A sample's data can be set at any time, including during playback.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleSetData(System.Int32,System.Int16[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array of Int16 values representing the sample data to set.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The required length and format of the data can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>A sample's data can be set at any time, including during playback.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleSetData(System.Int32,System.Byte[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array of byte values representing the sample data to set.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The required length and format of the data can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>A sample's data can be set at any time, including during playback.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetData(System.Int32,System.IntPtr)">
            <summary>
            Retrieves a copy of a sample's data.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">Pointer to a buffer to receive the data.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetData(System.Int32,System.Single[])">
            <summary>
            Retrieves a copy of a sample's data.
            <para>This overload uses a managed float[] to reference the buffer data as 32-bit!
            SHOULD ONLY BE USED, if the sample was created with BASS_SAMPLE_FLOAT!</para>
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array (float[]) to receive the data, use BASS_SAMPLE_FLOAT when creating the sample!</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_SAMPLE info = Bass.BASS_SampleGetInfo(sample);
            float[] buffer = new float[info.length/4];
            Bass.BASS_SampleGetData(sample, buffer);
            </code>
            <code lang="vbnet">
            Dim info As BASS_SAMPLE = Bass.BASS_SampleGetInfo(sample)
            Dim buffer(info.length/4) As Single
            Bass.BASS_SampleGetData(sample, buffer)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetData(System.Int32,System.Int32[])">
            <summary>
            Retrieves a copy of a sample's data.
            <para>This overload uses a managed int[] to reference the buffer data (Note: if we expect to receive 16-bit data, a single Int32 value will contain 2 x 16-bit, left and right channel)!
            SHOULD ONLY BE USED, if the sample was created WITHOUT BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS!</para>
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array (int[]) to receive the data, e.g. when creating the sample with default setting, meaning 16-bit samples, an Int32 value contains 2 channels (left and right)!</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetData(System.Int32,System.Int16[])">
            <summary>
            Retrieves a copy of a sample's data.
            <para>This overload uses a managed short[] to reference the buffer data as 16-bit!
            SHOULD ONLY BE USED, if the sample was created WITHOUT BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS!</para>
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array (short[]) to receive the data, do not use BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS when creating the sample!</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_SAMPLE info = Bass.BASS_SampleGetInfo(sample);
            short[] buffer = new short[info.length/2];
            Bass.BASS_SampleGetData(sample, buffer);
            </code>
            <code lang="vbnet">
            Dim info As BASS_SAMPLE = Bass.BASS_SampleGetInfo(sample)
            Dim buffer(info.length/2) As Short
            Bass.BASS_SampleGetData(sample, buffer)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetData(System.Int32,System.Byte[])">
            <summary>
            Retrieves a copy of a sample's data.
            <para>This overload uses a managed byte[] to reference the buffer data as 8-bit!
            SHOULD ONLY BE USED, if the sample was created with or BASS_SAMPLE_8BITS!</para>
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array array (byte[]) to receive the data, use or BASS_SAMPLE_8BITS when creating the sample!</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_SAMPLE info = Bass.BASS_SampleGetInfo(sample);
            byte[] buffer = new byte[info.length];
            Bass.BASS_SampleGetData(sample, buffer);
            </code>
            <code lang="vbnet">
            Dim info As BASS_SAMPLE = Bass.BASS_SampleGetInfo(sample)
            Dim buffer(info.length) As Byte
            Bass.BASS_SampleGetData(sample, buffer)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleFree(System.Int32)">
            <summary>
            Frees a sample's resources.
            </summary>
            <param name="handle">The sample handle.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play a sample with it's default settings:
            <code>
            int sample = Bass.BASS_SampleLoad("test.wav", 0L, 0, 1, BASSFlag.BASS_DEFAULT);
            int channel = Bass.BASS_SampleGetChannel(sample, false); // get a sample channel
            Bass.BASS_ChannelPlay(channel, false); // play it
            ...
            // when done
            Bass.BASS_SampleFree(sample);
            </code>
            <code lang="vbnet">
            Dim sample As Integer = Bass.BASS_SampleLoad("test.wav", 0L.ToUInt32(), 0, 1, BASSFlag.BASS_DEFAULT)
            Dim channel As Integer = Bass.BASS_SampleGetChannel(sample, False) ' get a sample channel
            Bass.BASS_ChannelPlay(channel, False) ' play it
            ...
            ' when done
            Bass.BASS_SampleFree(sample)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)">
            <summary>
            Retrieves a sample's default attributes and other information.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.BASS_SAMPLE"/> class to store the sample information at.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_SAMPLE info = new BASS_SAMPLE();
            bool ok = Bass.BASS_SampleGetInfo(sample, info);
            </code>
            <code lang="vbnet">
            Dim info As New BASS_SAMPLE()
            Dim ok As Boolean = Bass.BASS_SampleGetInfo(sample, info)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32)">
            <summary>
            Retrieves a sample's default attributes and other information.
            </summary>
            <param name="handle">The sample handle.</param>
            <returns>An instance of the <see cref="T:Un4seen.Bass.BASS_SAMPLE"/> class on success - else NULL.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_SAMPLE info = Bass.BASS_SampleGetInfo(sample);
            </code>
            <code lang="vbnet">
            Dim info As BASS_SAMPLE = Bass.BASS_SampleGetInfo(sample)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)">
            <summary>
            Sets a sample's default attributes.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.BASS_SAMPLE"/> class containing the sample information to set.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Use this function and <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/> to edit a sample's default attributes. 
            Changing a sample's default attributes does not affect any existing channels, it only affects channels subsequently created via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/>. 
            The exception is the VAM settings, changes to that apply to all the sample's channels at their next playback (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>). 
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)"/> to change the attributes of an existing sample channel.</para>
            <para>The <i>length</i>, <i>max</i>, <i>origres</i> and <i>chans</i> members of the <see cref="T:Un4seen.Bass.BASS_SAMPLE"/> structure can't be modified - any changes are ignored. 
            The BASS_SAMPLE_8BITS, BASS_SAMPLE_MONO, BASS_SAMPLE_3D, BASS_SAMPLE_MUTEMAX and BASS_SAMPLE_SOFTWARE flags also can't be changed.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Use one of the BASS_SAMPLE constructors to set the values:
            <code>
            BASS_SAMPLE info = new BASS_SAMPLE(44100, 100, 0, ...);
            bool ok = Bass.BASS_SampleSetInfo(sample, info);
            </code>
            <code lang="vbnet">
            Dim info As New BASS_SAMPLE(44100, 100, 0, ...)
            Dim ok As Boolean = Bass.BASS_SampleSetInfo(sample, info)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)">
            <summary>
            Creates/initializes a playback channel for a sample.
            </summary>
            <param name="handle">Handle of the sample to play.</param>
            <param name="onlynew">Do not recycle/override one of the sample's existing channels?</param>
            <returns>If successful, the handle of the new channel is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/> to set a sample's default attributes, which are used when creating a channel. 
            After creation, a channel's attributes can be changed via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DPosition(System.Int32,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>. 
            <see cref="M:Un4seen.Bass.Bass.BASS_Apply3D"/> should be called before starting playback of a 3D sample, even if you just want to use the default settings.</para>
            <para>If a sample has a maximum number of simultaneous playbacks of 1 (the max parameter was 1 when calling <see cref="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.String,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>), then the HCHANNEL handle returned will be identical to the HSAMPLE handle. 
            That means you can use the HSAMPLE handle with functions that usually require a HCHANNEL handle, but you must still call this function first to initialize the channel.</para>
            <para>A sample channel is automatically freed when it's overridden by a new channel, or when stopped manually via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_SampleStop(System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>. 
            If you wish to stop a channel and re-use it, it should be paused (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPause(System.Int32)"/>) instead of stopped. 
            Determining whether a channel still exists can be done by trying to use the handle in a function call, eg. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/>.</para>
            <para>All of a sample's channels share the same sample data, and just have their own individual playback state information (volume/position/etc).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid sample handle.</description></item>
            <item><term>BASS_ERROR_NOCHAN</term><description>The sample has no free channels... the maximum number of simultaneous playbacks has been reached, and no BASS_SAMPLE_OVER flag was specified for the sample or onlynew = TRUE.</description></item>
            <item><term>BASS_ERROR_TIMEOUT</term><description>The sample's minimum time gap (<see cref="T:Un4seen.Bass.BASS_SAMPLE"/>) has not yet passed since the last channel was created.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play a sample with it's default settings:
            <code>
            int sample = Bass.BASS_SampleLoad("test.wav", 0L, 0, 1, BASSFlag.BASS_DEFAULT);
            int channel = Bass.BASS_SampleGetChannel(sample, false); // get a sample channel
            Bass.BASS_ChannelPlay(channel, false); // play it
            </code>
            <code lang="vbnet">
            Dim sample As Integer = Bass.BASS_SampleLoad("test.wav", 0L.ToUInt32(), 0, 1, BASSFlag.BASS_DEFAULT)
            Dim channel As Integer = Bass.BASS_SampleGetChannel(sample, False) ' get a sample channel
            Bass.BASS_ChannelPlay(channel, False) ' play it
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetChannels(System.Int32,System.Int32[])">
            <summary>
            Retrieves all a sample's existing channels.
            </summary>
            <param name="handle">Handle of the sample.</param>
            <param name="channels">The array (int[])to put the sample's channel handles in. The array should be the same size as the sample's max setting when the sample was created, which can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>. 
            NULL can be used to just check how many channels exist.</param>
            <returns>If successful, the number of existing channels is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>For ease of use you might also use the second overload, which directly returns an integer array to get the channels directly.
            <para>If you need to determine whether a particular sample channel still exists, it is simplest to just try it in a function call, eg. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid sample handle.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set the sample rate of all a sample's channels to 10000Hz:
            <code>
            // get sample info for "max" value
            BASS_SAMPLE info = Bass.BASS_SampleGetInfo(handle);
            // allocate channels array
            int[] chans = new int[info.max];
            // get the channels
            int count = Bass.BASS_SampleGetChannels(handle, chans);
            // go through them all and...
            for (int a=0; a&lt;count; a++)
            {
              // set the sample rate to 10000
              Bass.BASS_ChannelSetAttribute(chans[a], BASSAttribute.BASS_ATTRIB_FREQ, 10000f);
            }
            </code>
            <code lang="vbnet">
            ' get sample info for "max" value
            Dim info As BASS_SAMPLE = Bass.BASS_SampleGetInfo(handle)
            ' allocate channels array
            Dim chans(info.max) As Integer
            ' get the channels
            Dim count As Integer = Bass.BASS_SampleGetChannels(handle, hGC.AddrOfPinnedObject())
            ' go through them all and...
            Dim a As Integer
            For a = 0 To count - 1
              ' set the sample rate to 10000
              Bass.BASS_ChannelSetAttribute(chans(a), BASSAttribute.BASS_ATTRIB_FREQ, 10000F)
            Next a
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetChannels(System.Int32)">
            <summary>
            Retrieves all a sample's existing channels.
            </summary>
            <param name="handle">Handle of the sample.</param>
            <returns>If successful, the array of existing channels is returned (which might have zero elements), else NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This overload only returns the existing channels in the array.
            <para>If you need to determine whether a particular sample channel still exists, it is simplest to just try it in a function call, eg. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid sample handle.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set the sample rate of all a sample's channels to 10000hz:
            <code>
            int[] chans = Bass.BASS_SampleGetChannels(handle);
            if (chans != null)
            {
              // go through them all and...
              for (int a=0; a&lt;chans.Length; a++)
              {
                // set the sample rate to 10000
                Bass.BASS_ChannelSetAttribute(chans[a], BASSAttribute.BASS_ATTRIB_FREQ, 10000f);
              }
            }
            </code>
            <code lang="vbnet">
            Dim chans As Integer() = Bass.BASS_SampleGetChannels(handle)
            If Not (chans Is Nothing) Then
              ' go through them all and...
              Dim a As Integer
              For a = 0 To chans.Length - 1
                ' set the sample rate to 10000
                Bass.BASS_ChannelSetAttribute(chans(a), BASSAttribute.BASS_ATTRIB_FREQ, 10000F)
              Next a
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetChannelCount(System.Int32)">
            <summary>
            Retrieves the number of existing sample's channels.
            </summary>
            <param name="handle">Handle of the sample.</param>
            <returns>If successful, the number of existing channels is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>If you need to determine whether a particular sample channel still exists, it is simplest to just try it in a function call, eg. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid sample handle.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleStop(System.Int32)">
            <summary>
            Stops all instances of a sample.
            </summary>
            <param name="handle">The sample handle.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>If a sample is playing simultaneously multiple times, calling this function will stop them all, which is obviously simpler than calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> multiple times.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid sample handle.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)">
            <summary>
            Creates a user sample stream.
            </summary>
            <param name="freq">The default sample rate. The sample rate can be changed using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers, and the SPEAKER flags are ignored.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            </list>
            </param>
            <param name="proc">The user defined stream writing function (see <see cref="T:Un4seen.Bass.STREAMPROC"/>).
            <para>To create a DUMMY stream use the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateDummy(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/> method.</para>
            <para>To create a PUSH stream use the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/> method.</para>
            </param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Sample streams allow any sample data to be played through BASS, and are particularly useful for playing a large amount of sample data without requiring a large amount of memory.
            If you wish to play a sample format that BASS does not support, then you can create a stream and decode the sample data into it.</para>
            <para>BASS can automatically stream MP3, MP2, MP1, OGG, WAV and AIFF files, using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, and also from HTTP and FTP servers, 
            using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> allows streaming from other sources too.</para>
            <para>However, the callback method must deliver PCM sample data as specified, so opening an MP3 file and just passing that file data will not work here.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            A callback function to stream a file, in 44100hz 16-bit stereo:
            <code>
            private STREAMPROC _myStreamCreate;  // make it global, so that the GC can not remove it
            private byte[] _data = null; // our local buffer
            ...
            _myStreamCreate = new STREAMPROC(MyFileProc);
            FileStream fs = File.OpenRead("test.raw");
            int channel = Bass.BASS_StreamCreate(44100, 2, 
                               BASSFlag.BASS_DEFAULT, _myStreamCreate, IntPtr.Zero);
            Bass.BASS_ChannelPlay(channel, false);
            ...
            private int MyFileProc(int handle, IntPtr buffer, int length, IntPtr user)
            {
              // implementing the callback for BASS_StreamCreate...
              // here we need to deliver PCM sample data
            
              // increase the data buffer as needed
              if (_data == null || _data.Length &lt; length)
                _data = new byte[length];
            
              int bytesread = _fs.Read( _data, 0, length ); 
              Marshal.Copy( _data, 0, buffer, bytesread );
              if ( bytesread &lt; length )
              {
                // set indicator flag
                bytesread |= (int)BASSStreamProc.BASS_STREAMPROC_END;
                _fs.Close();
              }
              return bytesread;
            }
            </code>
            <code lang="vbnet">
            Private _myStreamCreate As STREAMPROC  ' make it global, so that the GC can not remove it
            Private _data As Byte() = Nothing  ' our local buffer
            ...
            _myStreamCreate = New STREAMPROC(AddressOf MyFileProc)
            Dim fs As FileStream =  File.OpenRead("test.raw")
            Dim channel As Integer =  Bass.BASS_StreamCreate(44100, 2, 
                                           BASSFlag.BASS_DEFAULT, _myStreamCreate, IntPtr.Zero) 
            Bass.BASS_ChannelPlay(channel, False)
            ...
            Private Function MyFileProc(ByVal handle As Integer, ByVal buffer As IntPtr, 
                                        ByVal length As Integer, ByVal user As IntPtr) As Integer
              ' implementing the callback for BASS_StreamCreate...
              ' here we need to deliver PCM sample data
            
              ' increase the data buffer as needed
              If _data = Nothing OrElse _data.Length &lt; length Then
                _data = New Byte(length) {}
              End If
            
              Dim bytesread As Integer = _fs.Read(_data, 0, length) 
              Marshal.Copy(_data, 0, buffer, bytesread)
              If bytesread &lt; length Then
                bytesread = bytesread Or CInt(BASSStreamProc.BASS_STREAMPROC_END) ' set indicator flag
                _fs.Close()
              EndIf
              Return bytesread
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreatePtr(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="freq"></param>
            <param name="chans"></param>
            <param name="flags"></param>
            <param name="procPtr"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateDummy(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)">
            <summary>
            Creates a "dummy" stream.
            </summary>
            <param name="freq">The default sample rate. The sample rate can be changed using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers, and the SPEAKER flags are ignored.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            </list>
            </param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>A dummy stream doesn't have any sample data of its own, but a decoding dummy stream (with BASS_STREAM_DECODE flag) can be used to apply DSP/FX processing to any sample data, 
            by setting DSP/FX on the stream and feeding the data through <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>. 
            <para>The dummy stream should have the same sample format as the data being fed through it.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)">
            <summary>
            Creates a "push" stream.
            </summary>
            <param name="freq">The default sample rate. The sample rate can be changed using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers, and the SPEAKER flags are ignored.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            </list>
            </param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Instead of BASS pulling data from a <see cref="T:Un4seen.Bass.STREAMPROC"/> function, data is pushed to BASS via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.IntPtr,System.Int32)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Creating a stream duplicate:
            <code>
            private DSPPROC _dupCallback;
            ...
            // create stream on device 1
            Bass.BASS_SetDevice(1);
            int orig = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP);
            Bass.BASS_ChannelPlay(orig, false);
            ...
            // create a clone on device 2
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            Bass.BASS_SetDevice(2);
            int clone = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero);
            // pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream);
            int c = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, (int)BASSData.BASS_DATA_AVAILABLE);
            byte[] buf = new byte[c];
            Bass.BASS_ChannelGetData(stream, buf, c);
            Bass.BASS_StreamPutData(clone, buf, c);
            // set DSP to copy new data from source stream
            _dupCallback = new DSPPROC(DupDSP);
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, new IntPtr(clone), 0);
            Bass.BASS_ChannelPlay(orig, false); // resume source
            Bass.BASS_ChannelPlay(clone, false); // play clone
            ...
            private void DupDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _dupCallback As DSPPROC
            ...
            ' create stream on device 1
            Bass.BASS_SetDevice(1)
            Dim orig As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP)
            Bass.BASS_ChannelPlay(orig, False)
            ...
            ' create a clone on device 2
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            Bass.BASS_SetDevice(2)
            Dim clone As Integer = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero)
            ' pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream)
            Dim c As Integer = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, CInt(BASSData.BASS_DATA_AVAILABLE))
            Dim buf(c) As Byte
            Bass.BASS_ChannelGetData(stream, buf, c)
            Bass.BASS_StreamPutData(clone, buf, c)
            ' set DSP to copy new data from source stream
            _dupCallback = New DSPPROC(DupDSP)
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, New IntPtr(clone), 0)
            Bass.BASS_ChannelPlay(orig, False) ' resume source
            Bass.BASS_ChannelPlay(clone, False) ' play clone
            ...
            Private Sub DupDSP(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file via user callback functions.
            </summary>
            <param name="system">File system to use (one of the <see cref="T:Un4seen.Bass.BASSStreamSystem"/>):
            <list type="table">
            <item><term>STREAMFILE_NOBUFFER</term><description>Unbuffered.</description></item>
            <item><term>STREAMFILE_BUFFER</term><description>Buffered.</description></item>
            <item><term>STREAMFILE_BUFFERPUSH</term><description>Buffered, with the data pushed to BASS via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)"/>.</description></item>
            </list>
            </param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_PRESCAN</term><description>Enable pin-point accurate seeking (to the exact byte) on the MP3/MP2/MP1 stream. This also increases the time taken to create the stream, due to the entire file being pre-scanned for the seek points. This flag is ignored with "buffered" streams (buffered=TRUE).</description></item>
            <item><term>BASS_STREAM_RESTRATE</term><description>Restrict the download rate of the file to the rate required to sustain playback. If this flag is not used, then the file will be downloaded as quickly as possible. This flag has no effect on "unbuffered" streams (buffered=FALSE).</description></item>
            <item><term>BASS_STREAM_BLOCK</term><description>Download and play the file in smaller chunks. Uses a lot less memory than otherwise, but it's not possible to seek or loop the stream - once it's ended, the file must be opened again to play it again. This flag will automatically be applied when the file length is unknown. This flag also has the effect of resticting the download rate. This flag has no effect on "unbuffered" streams (buffered=FALSE).</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            </list>
            </param>
            <param name="procs">The user defined file function (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The buffered file system (STREAMFILE_BUFFER) is what is used by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>. As the name suggests, data from the file is buffered so that it's readily available for decoding - BASS creates a thread dedicated to "downloading" the data. This is ideal for when the data is coming from a source that has high latency, like the internet. It's not possible to seek in buffered file streams, until the download has reached the requested position - it's not possible to seek at all if it's being streamed in blocks.</para>
            <para>The push buffered file system (STREAMFILE_BUFFERPUSH) is the same, except that instead of the file data being pulled from the <see cref="T:Un4seen.Bass.FILEREADPROC"/> function in a "download" thread, the data is pushed to BASS via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)"/>. A <see cref="T:Un4seen.Bass.FILEREADPROC"/> function is still required, to get the initial data used in the creation of the stream.</para>
            <para>The unbuffered file system (STREAMFILE_NOBUFFER) is what is used by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>. In this system, BASS does not do any intermediate buffering - it simply requests data from the file as and when it needs it. This means that reading (<see cref="T:Un4seen.Bass.FILEREADPROC"/>) must be quick, otherwise the decoding will be delayed and playback buffer underruns (old data repeated) are a possibility. It's not so important for seeking (<see cref="T:Un4seen.Bass.FILESEEKPROC"/>) to be fast, as that is generally not required during decoding, except when looping a file.</para>
            <para>In all cases, BASS will automatically stall playback of the stream when insufficient data is available, and resume it when enough data does become available.</para>
            <para>A copy is made of the procs callback function table, so it does not have to persist beyond this function call. 
            This means it is not required to pin the <paramref name="procs"/> instance, but it is still required to keep a reference as long as BASS uses the callback delegates in order to prevent the callbacks from being garbage collected.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="system"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Only used internal! See the file overload of <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> for details!
            </summary>
            <param name="mem">Needs to be set to TRUE</param>
            <param name="file">The file name to open</param>
            <param name="offset">Set to 0 to start the stream from the beginning</param>
            <param name="length">Data length... 0 = use all data</param>
            <param name="flags">See <see cref="T:Un4seen.Bass.BASSFlag"/> for possible flags</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags <see cref="T:Un4seen.Bass.BASSFlag"/>:
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_PRESCAN</term><description>Enable pin-point accurate seeking (to the exact byte) on the MP3/MP2/MP1 stream. This also increases the time taken to create the stream, due to the entire file being pre-scanned for the seek points.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_UNICODE</term><description>file is a Unicode (16-bit characters) filename (automatically set with this overload).</description></item>
            </list>
            </param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>BASS has built-in support for MPEG, OGG, WAV and AIFF files. Support for additional formats is available via add-ons, which can be downloaded from the BASS website: <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            <para>MPEG 1.0, 2.0 and 2.5 layer 3 (MP3) files are supported, layers 1 (MP1) and 2 (MP2) are also supported. WAV files can be in standard Windows PCM format or they can be compressed with any CODEC, but the CODEC is required to be installed on the user's computer for the WAV to be decoded. So you should either distribute the CODEC with your software, or use a CODEC that comes with Windows (eg. Microsoft ADPCM). All PCM formats from 8 to 32-bit are supported in WAV and AIFF files, but the output will be restricted to 16-bit unless the BASS_SAMPLE_FLOAT flag is used. The file's original resolution is available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.</para>
            <para>Multi-channel (ie. more than stereo) OGG, WAV and AIFF files are supported.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>.</para>
            <para>If length = 0 (use all data up to the end of the file), and the file length increases after creating the stream (ie. the file is still being written), then BASS will play the extra data too, but the length returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> will not be updated until the end is reached. The <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> return values will be updated during playback of the extra data though.</para>
            <para>To stream a file from the internet, use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>. To stream from other locations, see <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="length"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example demonstrates how to stream from a file (floating-point):
            <code>
            // Init Bass
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, 0, null);
            // create the stream
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                              BASSFlag.BASS_SAMPLE_FLOAT | BASSFlag.BASS_STREAM_PRESCAN);
            if (stream != 0 &amp;&amp; Bass.BASS_ChannelPlay(stream, false) )
            {
              // playing
            }
            else
            {
              Console.WriteLine("Error={0}", Bass.BASS_ErrorGetCode());
            }
            </code>
            <code lang="vbnet">
            ' Init Bass
            Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, 0, Nothing)
            ' create the stream
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                                         BASSFlag.BASS_SAMPLE_FLOAT Or BASSFlag.BASS_STREAM_PRESCAN)
            If stream &lt;&gt; 0 AndAlso Bass.BASS_ChannelPlay(stream, False) Then
              ' playing
            Else
              Console.WriteLine("Error={0}", Bass.BASS_ErrorGetCode())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Only used internal! See the memory overload of <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> for details!
            </summary>
            <param name="mem">Needs to be set to TRUE</param>
            <param name="memory">The IntPtr to the unmananged buffer containing the stream data</param>
            <param name="offset">Set to 0 to start the stream from the beginning</param>
            <param name="length">Needs to be set to the total length of the buffer data</param>
            <param name="flags">See <see cref="T:Un4seen.Bass.BASSFlag"/> for possible flags</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory stream in bytes which should be played).</param>
            <param name="flags">Any combination of these flags <see cref="T:Un4seen.Bass.BASSFlag"/>, needs to casted into an (int) because we needed another method signature here.
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_PRESCAN</term><description>Enable pin-point accurate seeking (to the exact byte) on the MP3/MP2/MP1 stream. This also increases the time taken to create the stream, due to the entire file being pre-scanned for the seek points.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            </list>
            </param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>BASS has built-in support for MPEG, OGG, WAV and AIFF files. Support for additional formats is available via add-ons, which can be downloaded from the BASS website: <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            <para>MPEG 1.0, 2.0 and 2.5 layer 3 (MP3) files are supported, layers 1 (MP1) and 2 (MP2) are also supported. WAV files can be in standard Windows PCM format or they can be compressed with any CODEC, but the CODEC is required to be installed on the user's computer for the WAV to be decoded. So you should either distribute the CODEC with your software, or use a CODEC that comes with Windows (eg. Microsoft ADPCM). All PCM formats from 8 to 32-bit are supported in WAV and AIFF files, but the output will be restricted to 16-bit unless the BASS_SAMPLE_FLOAT flag is used. The file's original resolution is available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.</para>
            <para>Multi-channel (ie. more than stereo) OGG, WAV and AIFF files are supported.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>.</para>
            <para>If length = 0 (use all data up to the end of the file), and the file length increases after creating the stream (ie. the file is still being written), then BASS will play the extra data too, but the length returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> will not be updated until the end is reached. The <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> return values will be updated during playback of the extra data though.</para>
            <para>To stream a file from the internet, use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>. To stream from other locations, see <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            <para>Don't forget to pin your memory object when using this overload.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="length"/> must be specified when streaming from memory.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example demontrates how to stream from memory:
            <code>
            private GCHandle _hGCFile;
            ...
            // open a file
            FileStream fs = File.OpenRead( "test.mp3" );
            // get the legth of the file
            long length = fs.Length;
            // create the buffer which will keep the file in memory
            byte[] buffer = new byte[length];
            // read the file into the buffer
            fs.Read(buffer, 0, length);
            // buffer is filled, file can be closed
            fs.Close();
            
            // now create a pinned handle, so that the Garbage Collector will not move this object
            _hGCFile = GCHandle.Alloc( buffer, GCHandleType.Pinned );
            // create the stream (AddrOfPinnedObject delivers the necessary IntPtr)
            int stream = Bass.BASS_StreamCreateFile(_hGCFile.AddrOfPinnedObject(),
                              0L, length, BASSFlag.BASS_SAMPLE_FLOAT);
            
            if (stream != 0 &amp;&amp; Bass.BASS_ChannelPlay(stream, false) )
            {
            	// playing...
            }
            else
            {
            	Console.WriteLine("Error = {0}", Bass.BASS_ErrorGetCode());
            }
            ...
            // when playback has ended and the pinned object is not needed anymore, 
            // we need to free the handle!
            // Note: calling this method to early will crash the application, 
            // since the buffer would be stolen from BASS while still playing!
            _hGCFile.Free();
            </code>
            <code lang="vbnet">
            Private _hGCFile As GCHandle
            ...
            ' open a file
            Dim fs As FileStream = File.OpenRead("test.mp3")
            ' get the legth of the file
            Dim length As Long = fs.Length
            ' create the buffer which will keep the file in memory
            Dim buffer(length) As Byte
            ' read the file into the buffer
            fs.Read(buffer, 0, length)
            ' buffer is filled, file can be closed
            fs.Close()
            
            ' now create a pinned handle, so that the Garbage Collector will not move this object
            _hGCFile = GCHandle.Alloc(buffer, GCHandleType.Pinned)
            ' create the stream (AddrOfPinnedObject delivers the necessary IntPtr)
            Dim stream As Integer = Bass.BASS_StreamCreateFile(_hGCFile.AddrOfPinnedObject(),
                                         0L, length, BASSFlag.BASS_SAMPLE_FLOAT)
            
            If stream &lt;&gt; 0 AndAlso Bass.BASS_ChannelPlay(stream, False) Then
              ' playing...
            Else
              Console.WriteLine("Error = {0}", Bass.BASS_ErrorGetCode())
            End If
            ...
            ' when playback has ended and the pinned object is not needed anymore, 
            ' we need to free the handle!
            ' Note: calling this method to early will crash the application, 
            ' since the buffer would be stolen from BASS while still playing!
            _hGCFile.Free()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
            <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown, for example a Shout/Icecast server.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_RESTRATE</term><description>Restrict the download rate of the file to the rate required to sustain playback. If this flag is not used, then the file will be downloaded as quickly as the user's internet connection allows.</description></item>
            <item><term>BASS_STREAM_BLOCK</term><description>Download and play the file in smaller chunks. Uses a lot less memory than otherwise, but it's not possible to seek or loop the stream - once it's ended, the file must be opened again to play it again. This flag will automatically be applied when the file length is unknown, for example with Shout/Icecast streams. This flag also has the effect of resticting the download rate.</description></item>
            <item><term>BASS_STREAM_STATUS</term><description>Pass status info (HTTP/ICY tags) from the server to the <see cref="T:Un4seen.Bass.DOWNLOADPROC"/> callback during connection. This can be useful to determine the reason for a failure.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            </list>
            </param>
            <param name="proc">Callback function to receive the file as it is downloaded... NULL = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>.</para>
            <para>When playing the stream, BASS will stall the playback if there is insufficient data to continue playing. Playback will automatically be resumed when sufficient data has been downloaded. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if the playback is stalled, and the progress of the file download can be checked with <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/>.</para>
            <para>When streaming in blocks (BASS_STREAM_BLOCK flag), be careful not to stop/pause the stream for too long, otherwise the connection may timeout due to there being no activity and the stream will end prematurely.</para>
            <para>When streaming from Shoutcast servers, metadata (track titles) may be sent by the server. The data can be retrieved with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>. A sync can also be set (using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>) so that you are informed when metadata is received.</para>
            <para>When using an offset, the file length returned by <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> can be used to check that it was successful by comparing it with the original file length. Another way to check is to inspect the HTTP headers retrieved with BASS_ChannelGetTags.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_NONET</term><description>No internet connection could be opened. Can be caused by a bad <see cref="T:Un4seen.Bass.BASSConfig">proxy setting</see>.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="url"/> is not a valid URL.</description></item>
            <item><term>BASS_ERROR_TIMEOUT</term><description>The server did not respond to the request within the timeout period, as set with the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_NET_TIMEOUT</see> config option.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, null);
            int channel = Bass.BASS_StreamCreateURL("http://someurl.com:8000", 0, 
                               BASSFlag.BASS_DEFAULT, null, IntPtr.Zero);
            Bass.BASS_ChannelPlay(channel, false);
            </code>
            <code lang="vbnet">
            Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, Nothing)
            Dim channel As Integer = Bass.BASS_StreamCreateURL("http://someurl.com:8000", 0, 
                                          BASSFlag.BASS_DEFAULT, Nothing, IntPtr.Zero)
            Bass.BASS_ChannelPlay(channel, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)">
            <summary>
            Retrieves the decoding/download/end position of a file stream.
            </summary>
            <param name="handle">The stream's handle.</param>
            <param name="mode">The file position to retrieve. One of the following (<see cref="T:Un4seen.Bass.BASSStreamFilePosition"/>):
            <list type="table">
            <item><term>BASS_FILEPOS_CURRENT</term><description>Position that is to be decoded for playback next. This will be a bit ahead of the position actually being heard due to buffering.</description></item>
            <item><term>BASS_FILEPOS_END</term><description>End of the file, in other words the file length. When streaming in blocks, the file length is unknown, so the download buffer length is returned instead.</description></item>
            <item><term>BASS_FILEPOS_START</term><description>Start of stream data in the file.</description></item>
            <item><term>BASS_FILEPOS_DOWNLOAD</term><description>Download progress of an internet file stream or "buffered" user file stream.</description></item>
            <item><term>BASS_FILEPOS_CONNECTED</term><description>Internet file stream or "buffered" user file stream is still connected? 0 = no, 1 = yes.</description></item>
            <item><term>BASS_FILEPOS_BUFFER</term><description>The amount of data in the buffer of an internet file stream or "buffered" user file stream. Unless streaming in blocks, this is the same as BASS_FILEPOS_DOWNLOAD.</description></item>
            </list>
            <i>Other modes may be supported by add-ons, see the documentation.</i>
            </param>
            <returns>If succesful, then the requested file position is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>ID3 tags (both v1 and v2) and WAVE headers, as well as any other rubbish at the start of the file, are excluded from the calculations of this function.</para>
            <para>This is useful for average bitrate calculations, but it means that the BASS_FILEPOS_CURRENT position may not be the actual file position - the BASS_FILEPOS_START position can be added to it to get the actual file position.</para>
            <para>It's unwise to use this function (with mode = BASS_FILEPOS_CURRENT) for syncing purposes because it returns the position that's being decoded, not the position that's being heard.
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> for syncing instead.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested file position/status is not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the percentage downloaded of an internet file stream, 
            or the buffering progress when streaming in blocks:
            <code>
            float progress;
            // file length
            int len = Bass.BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_END);
            // download progress
            int down = Bass.BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_DOWNLOAD);
            // get channel info
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            // streaming in blocks?
            if (info.flags &amp; BASSFlag.BASS_STREAM_BLOCK != BASSFlag.BASS_DEFAULT)
            { 
              // decode position
              int dec = BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_CURRENT);
              // percentage of buffer used
              progress = (down-dec)*100f / len;
              if (progress &gt; 100)
                progress = 100; // restrict to 100 (can be higher)
            } 
            else
            {
              // percentage of file downloaded
              progress = down*100f / len;
            }
            </code>
            <code lang="vbnet">
            Dim progress As Single
            ' file length
            Dim len As Integer = Bass.BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_END)
            ' download progress
            Dim down As Integer = Bass.BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_DOWNLOAD)
            ' get channel info
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            ' streaming in blocks?
            If info.flags And BASSFlag.BASS_STREAM_BLOCK &lt;&gt; BASSFlag.BASS_DEFAULT Then
              ' decode position
              Dim dec As Integer = BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_CURRENT)
              ' percentage of buffer used
              progress =(down - dec) * 100F / len
              If progress &gt; 100 Then
                progress = 100 ' restrict to 100 (can be higher)
              End If
            Else
              ' percentage of file downloaded
              progress = down * 100F / len
            End If
            </code>
            Get the average bitrate of a file:
            <code>
            // playback duration
            double time = Bass.BASS_ChannelBytes2Seconds(stream, Bass.BASS_ChannelGetLength(stream));
            // file length
            long len = Bass.BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_END);
            // bitrate (kbps)
            int bitrate = (int)(len/(125*time)+0.5d);
            </code>
            <code lang="vbnet">
            ' playback duration
            Dim time As Double = Bass.BASS_ChannelBytes2Seconds(stream, Bass.BASS_ChannelGetLength(stream))
            ' file length
            Dim len As Long = Bass.BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_END)
            ' bitrate (kbps)
            Dim bitrate As Integer = CInt(len /(125 * time) + 0.5)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)">
            <summary>
            Frees a sample stream's resources, including any sync/DSP/FX it has.
            </summary>
            <param name="handle"> The stream handle.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/>).</param>
            <param name="buffer">Pointer to the sample data.</param>
            <param name="length">The amount of data in bytes, optionally using the <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played. 
            With a decoding channel, there is no playback buffer, so all data is queued in that case. There is no limit to the amount of data that can be queued, besides available memory.</para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> call in the case of a decoding channel.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, BASS will automatically stall playback of the stream, until more data is provided. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled. 
            A BASS_SYNC_STALL sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the push system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Creating a stream duplicate:
            <code>
            private DSPPROC _dupCallback;
            ...
            // create stream on device 1
            Bass.BASS_SetDevice(1);
            int orig = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP);
            Bass.BASS_ChannelPlay(orig, false);
            ...
            // create a clone on device 2
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            Bass.BASS_SetDevice(2);
            int clone = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero);
            // pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream);
            int c = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, (int)BASSData.BASS_DATA_AVAILABLE);
            byte[] buf = new byte[c];
            Bass.BASS_ChannelGetData(stream, buf, c);
            Bass.BASS_StreamPutData(clone, buf, c);
            // set DSP to copy new data from source stream
            _dupCallback = new DSPPROC(DupDSP);
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, new IntPtr(clone), 0);
            Bass.BASS_ChannelPlay(orig, false); // resume source
            Bass.BASS_ChannelPlay(clone, false); // play clone
            ...
            private void DupDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _dupCallback As DSPPROC
            ...
            ' create stream on device 1
            Bass.BASS_SetDevice(1)
            Dim orig As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP)
            Bass.BASS_ChannelPlay(orig, False)
            ...
            ' create a clone on device 2
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            Bass.BASS_SetDevice(2)
            Dim clone As Integer = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero)
            ' pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream)
            Dim c As Integer = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, CInt(BASSData.BASS_DATA_AVAILABLE))
            Dim buf(c) As Byte
            Bass.BASS_ChannelGetData(stream, buf, c)
            Bass.BASS_StreamPutData(clone, buf, c)
            ' set DSP to copy new data from source stream
            _dupCallback = New DSPPROC(DupDSP)
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, New IntPtr(clone), 0)
            Bass.BASS_ChannelPlay(orig, False) ' resume source
            Bass.BASS_ChannelPlay(clone, False) ' play clone
            ...
            Private Sub DupDSP(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/>).</param>
            <param name="buffer">The array of float sample data to provide.</param>
            <param name="length">The amount of data in bytes! (buffer.Length/4), optionally using the <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played. 
            With a decoding channel, there is no playback buffer, so all data is queued in that case. There is no limit to the amount of data that can be queued, besides available memory.</para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> call in the case of a decoding channel.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, BASS will automatically stall playback of the stream, until more data is provided. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled. 
            A BASS_SYNC_STALL sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the push system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Creating a stream duplicate:
            <code>
            private DSPPROC _dupCallback;
            ...
            // create stream on device 1
            Bass.BASS_SetDevice(1);
            int orig = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP);
            Bass.BASS_ChannelPlay(orig, false);
            ...
            // create a clone on device 2
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            Bass.BASS_SetDevice(2);
            int clone = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero);
            // pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream);
            int c = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, (int)BASSData.BASS_DATA_AVAILABLE);
            byte[] buf = new byte[c];
            Bass.BASS_ChannelGetData(stream, buf, c);
            Bass.BASS_StreamPutData(clone, buf, c);
            // set DSP to copy new data from source stream
            _dupCallback = new DSPPROC(DupDSP);
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, new IntPtr(clone), 0);
            Bass.BASS_ChannelPlay(orig, false); // resume source
            Bass.BASS_ChannelPlay(clone, false); // play clone
            ...
            private void DupDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _dupCallback As DSPPROC
            ...
            ' create stream on device 1
            Bass.BASS_SetDevice(1)
            Dim orig As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP)
            Bass.BASS_ChannelPlay(orig, False)
            ...
            ' create a clone on device 2
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            Bass.BASS_SetDevice(2)
            Dim clone As Integer = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero)
            ' pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream)
            Dim c As Integer = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, CInt(BASSData.BASS_DATA_AVAILABLE))
            Dim buf(c) As Byte
            Bass.BASS_ChannelGetData(stream, buf, c)
            Bass.BASS_StreamPutData(clone, buf, c)
            ' set DSP to copy new data from source stream
            _dupCallback = New DSPPROC(DupDSP)
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, New IntPtr(clone), 0)
            Bass.BASS_ChannelPlay(orig, False) ' resume source
            Bass.BASS_ChannelPlay(clone, False) ' play clone
            ...
            Private Sub DupDSP(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/>).</param>
            <param name="buffer">The array of Int32 sample data to provide (Caution: Int32=2xInt16, so this overload can e.g. be used to provide a stereo sample containing of two 16-bit values).</param>
            <param name="length">The amount of data in bytes! (buffer.Length/4), optionally using the <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played. 
            With a decoding channel, there is no playback buffer, so all data is queued in that case. There is no limit to the amount of data that can be queued, besides available memory.</para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> call in the case of a decoding channel.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, BASS will automatically stall playback of the stream, until more data is provided. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled. 
            A BASS_SYNC_STALL sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the push system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Creating a stream duplicate:
            <code>
            private DSPPROC _dupCallback;
            ...
            // create stream on device 1
            Bass.BASS_SetDevice(1);
            int orig = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP);
            Bass.BASS_ChannelPlay(orig, false);
            ...
            // create a clone on device 2
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            Bass.BASS_SetDevice(2);
            int clone = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero);
            // pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream);
            int c = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, (int)BASSData.BASS_DATA_AVAILABLE);
            byte[] buf = new byte[c];
            Bass.BASS_ChannelGetData(stream, buf, c);
            Bass.BASS_StreamPutData(clone, buf, c);
            // set DSP to copy new data from source stream
            _dupCallback = new DSPPROC(DupDSP);
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, new IntPtr(clone), 0);
            Bass.BASS_ChannelPlay(orig, false); // resume source
            Bass.BASS_ChannelPlay(clone, false); // play clone
            ...
            private void DupDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _dupCallback As DSPPROC
            ...
            ' create stream on device 1
            Bass.BASS_SetDevice(1)
            Dim orig As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP)
            Bass.BASS_ChannelPlay(orig, False)
            ...
            ' create a clone on device 2
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            Bass.BASS_SetDevice(2)
            Dim clone As Integer = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero)
            ' pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream)
            Dim c As Integer = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, CInt(BASSData.BASS_DATA_AVAILABLE))
            Dim buf(c) As Byte
            Bass.BASS_ChannelGetData(stream, buf, c)
            Bass.BASS_StreamPutData(clone, buf, c)
            ' set DSP to copy new data from source stream
            _dupCallback = New DSPPROC(DupDSP)
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, New IntPtr(clone), 0)
            Bass.BASS_ChannelPlay(orig, False) ' resume source
            Bass.BASS_ChannelPlay(clone, False) ' play clone
            ...
            Private Sub DupDSP(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/>).</param>
            <param name="buffer">The array of Int16 sample data to provide.</param>
            <param name="length">The amount of data in bytes! (buffer.Length/2), optionally using the <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played. 
            With a decoding channel, there is no playback buffer, so all data is queued in that case. There is no limit to the amount of data that can be queued, besides available memory.</para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> call in the case of a decoding channel.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, BASS will automatically stall playback of the stream, until more data is provided. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled. 
            A BASS_SYNC_STALL sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            </remarks>
            <example>
            Creating a stream duplicate:
            <code>
            private DSPPROC _dupCallback;
            ...
            // create stream on device 1
            Bass.BASS_SetDevice(1);
            int orig = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP);
            Bass.BASS_ChannelPlay(orig, false);
            ...
            // create a clone on device 2
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            Bass.BASS_SetDevice(2);
            int clone = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero);
            // pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream);
            int c = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, (int)BASSData.BASS_DATA_AVAILABLE);
            byte[] buf = new byte[c];
            Bass.BASS_ChannelGetData(stream, buf, c);
            Bass.BASS_StreamPutData(clone, buf, c);
            // set DSP to copy new data from source stream
            _dupCallback = new DSPPROC(DupDSP);
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, new IntPtr(clone), 0);
            Bass.BASS_ChannelPlay(orig, false); // resume source
            Bass.BASS_ChannelPlay(clone, false); // play clone
            ...
            private void DupDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _dupCallback As DSPPROC
            ...
            ' create stream on device 1
            Bass.BASS_SetDevice(1)
            Dim orig As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP)
            Bass.BASS_ChannelPlay(orig, False)
            ...
            ' create a clone on device 2
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            Bass.BASS_SetDevice(2)
            Dim clone As Integer = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero)
            ' pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream)
            Dim c As Integer = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, CInt(BASSData.BASS_DATA_AVAILABLE))
            Dim buf(c) As Byte
            Bass.BASS_ChannelGetData(stream, buf, c)
            Bass.BASS_StreamPutData(clone, buf, c)
            ' set DSP to copy new data from source stream
            _dupCallback = New DSPPROC(DupDSP)
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, New IntPtr(clone), 0)
            Bass.BASS_ChannelPlay(orig, False) ' resume source
            Bass.BASS_ChannelPlay(clone, False) ' play clone
            ...
            Private Sub DupDSP(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/>).</param>
            <param name="buffer">The array of byte sample data to provide.</param>
            <param name="length">The amount of data in bytes, optionally using the <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played. 
            With a decoding channel, there is no playback buffer, so all data is queued in that case. There is no limit to the amount of data that can be queued, besides available memory.</para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> call in the case of a decoding channel.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, BASS will automatically stall playback of the stream, until more data is provided. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled. 
            A BASS_SYNC_STALL sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the push system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Creating a stream duplicate:
            <code>
            private DSPPROC _dupCallback;
            ...
            // create stream on device 1
            Bass.BASS_SetDevice(1);
            int orig = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP);
            Bass.BASS_ChannelPlay(orig, false);
            ...
            // create a clone on device 2
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            Bass.BASS_SetDevice(2);
            int clone = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero);
            // pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream);
            int c = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, (int)BASSData.BASS_DATA_AVAILABLE);
            byte[] buf = new byte[c];
            Bass.BASS_ChannelGetData(stream, buf, c);
            Bass.BASS_StreamPutData(clone, buf, c);
            // set DSP to copy new data from source stream
            _dupCallback = new DSPPROC(DupDSP);
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, new IntPtr(clone), 0);
            Bass.BASS_ChannelPlay(orig, false); // resume source
            Bass.BASS_ChannelPlay(clone, false); // play clone
            ...
            private void DupDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _dupCallback As DSPPROC
            ...
            ' create stream on device 1
            Bass.BASS_SetDevice(1)
            Dim orig As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP)
            Bass.BASS_ChannelPlay(orig, False)
            ...
            ' create a clone on device 2
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            Bass.BASS_SetDevice(2)
            Dim clone As Integer = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero)
            ' pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream)
            Dim c As Integer = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, CInt(BASSData.BASS_DATA_AVAILABLE))
            Dim buf(c) As Byte
            Bass.BASS_ChannelGetData(stream, buf, c)
            Bass.BASS_StreamPutData(clone, buf, c)
            ' set DSP to copy new data from source stream
            _dupCallback = New DSPPROC(DupDSP)
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, New IntPtr(clone), 0)
            Bass.BASS_ChannelPlay(orig, False) ' resume source
            Bass.BASS_ChannelPlay(clone, False) ' play clone
            ...
            Private Sub DupDSP(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> and the STREAMFILE_BUFFERPUSH system flag.).</param>
            <param name="buffer">Pointer to the file data.</param>
            <param name="length">The amount of data in bytes, or <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> can be used to check the amount of space in the buffer.</para>
            <para>File data should be provided at a rate sufficent to sustain playback. If there is insufficient file data, and the playback buffer is subsequently exhausted, BASS will automatically stall playback of the stream, until more data is available. A BASS_SYNC_STALL sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the STREAMFILE_BUFFERPUSH file system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> and the STREAMFILE_BUFFERPUSH system flag.).</param>
            <param name="buffer">The array of float values to provide to the file data.</param>
            <param name="length">The amount of data in bytes! (buffer.Length/4), or <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> can be used to check the amount of space in the buffer.</para>
            <para>File data should be provided at a rate sufficent to sustain playback. If there is insufficient file data, and the playback buffer is subsequently exhausted, BASS will automatically stall playback of the stream, until more data is available. A BASS_SYNC_STALL sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the STREAMFILE_BUFFERPUSH file system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> and the STREAMFILE_BUFFERPUSH system flag.).</param>
            <param name="buffer">The array of Int32 values to provide to the file data (Caution: Int32=2xInt16, so this overload can e.g. be used to provide a stereo sample containing of two 16-bit values).</param>
            <param name="length">The amount of data in bytes! (buffer.Length/4), or <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> can be used to check the amount of space in the buffer.</para>
            <para>File data should be provided at a rate sufficent to sustain playback. If there is insufficient file data, and the playback buffer is subsequently exhausted, BASS will automatically stall playback of the stream, until more data is available. A BASS_SYNC_STALL sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the STREAMFILE_BUFFERPUSH file system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> and the STREAMFILE_BUFFERPUSH system flag.).</param>
            <param name="buffer">The array of Int16 values to provide to the file data.</param>
            <param name="length">The amount of data in bytes! (buffer.Length/2), or <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> can be used to check the amount of space in the buffer.</para>
            <para>File data should be provided at a rate sufficent to sustain playback. If there is insufficient file data, and the playback buffer is subsequently exhausted, BASS will automatically stall playback of the stream, until more data is available. A BASS_SYNC_STALL sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the STREAMFILE_BUFFERPUSH file system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> and the STREAMFILE_BUFFERPUSH system flag.).</param>
            <param name="buffer">The array of byte values to provide to the file data.</param>
            <param name="length">The amount of data in bytes, or <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> can be used to check the amount of space in the buffer.</para>
            <para>File data should be provided at a rate sufficent to sustain playback. If there is insufficient file data, and the playback buffer is subsequently exhausted, BASS will automatically stall playback of the stream, until more data is available. A BASS_SYNC_STALL sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the STREAMFILE_BUFFERPUSH file system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicLoadUnicode(System.Boolean,System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Only used internally! See the file overload of <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> for details!
            </summary>
            <param name="mem">Needs to be set to FALSE</param>
            <param name="file">The filename to load.</param>
            <param name="offset">File offset to load the MOD music from.</param>
            <param name="length">Data length... 0 = use all data up to the end of file.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>).</param>
            <param name="freq">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Loads a MOD music file - MO3 / IT / XM / S3M / MTM / MOD / UMX formats.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="file">The file name from where to load the music.</param>
            <param name="offset">File offset to load the MOD music from.</param>
            <param name="length">Data length... 0 = use all data up to the end of file. If length over-runs the end of the file, it'll automatically be lowered to the end of the file.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_MUSIC_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the MOD music in mono (uses less CPU than stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the MOD music to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Enable 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D channels are mono, so BASS_SAMPLE_MONO is automatically applied. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the music.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the music.</description></item>
            <item><term>BASS_MUSIC_RAMP</term><description>Use "normal" ramping (as used in FastTracker 2).</description></item>
            <item><term>BASS_MUSIC_RAMPS</term><description>Use "sensitive" ramping".</description></item>
            <item><term>BASS_MUSIC_NONINTER</term><description>Use non-interpolated mixing. This generally reduces the sound quality, but can be good for chip-tunes.</description></item>
            <item><term>BASS_MUSIC_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires quite a bit more processing. If neither this or the BASS_MUSIC_NONINTER flag is specified, linear interpolation is used.</description></item>
            <item><term>BASS_MUSIC_FT2MOD</term><description>Play .MOD file as FastTracker 2 would.</description></item>
            <item><term>BASS_MUSIC_PT1MOD</term><description>Play .MOD file as ProTracker 1 would.</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>Stop all notes when seeking (using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>).</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>Stop all notes and reset bpm/etc when seeking.</description></item>
            <item><term>BASS_MUSIC_SURROUND</term><description>Apply XMPlay's surround sound to the music (ignored in mono).</description></item>
            <item><term>BASS_MUSIC_SURROUND2</term><description>Apply XMPlay's surround sound mode 2 to the music (ignored in mono).</description></item>
            <item><term>BASS_MUSIC_STOPBACK</term><description>Stop the music when a backward jump effect is played. This stops musics that never reach the end from going into endless loops. Some MOD musics are designed to jump all over the place, so this flag would cause those to be stopped prematurely. If this flag is used together with the BASS_SAMPLE_LOOP flag, then the music would not be stopped but any BASS_SYNC_END sync would be triggered.</description></item>
            <item><term>BASS_MUSIC_PRESCAN</term><description>Calculate the playback length of the music, and enable seeking in bytes. This slightly increases the time taken to load the music, depending on how long it is. In the case of musics that loop, the length until the loop occurs is calculated. Use BASS_ChannelGetLength to retrieve the length.</description></item>
            <item><term>BASS_MUSIC_NOSAMPLE</term><description>Don't load the samples. This reduces the time taken to load the music, notably with MO3 files, which is useful if you just want to get the name and length of the music without playing it.</description></item>
            <item><term>BASS_MUSIC_AUTOFREE</term><description>Automatically free the music when it ends. This allows you to play a music and forget about it, as BASS will automatically free the music's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called. Note that some musics never actually end on their own (ie. without you stopping them).</description></item>
            <item><term>BASS_MUSIC_DECODE</term><description>Decode the music into sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. BASS_SAMPLE_SOFTWARE/3D/FX/AUTOFREE are ignored when using this flag, as are the SPEAKER flags.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>. The BASS_SAMPLE_MONO flag is automatically applied when using a mono speaker assignment flag.</description></item>
            <item><term>BASS_UNICODE</term><description>file is a Unicode (16-bit characters) filename (not needed with this overload).</description></item>
            </list>
            </param>
            <param name="freq">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>BASS uses the same code as XMPlay for it's MOD music support, giving the most accurate reproduction of MO3 / IT / XM / S3M / MTM / MOD / UMX files available from any sound system.</para>
            <para>MO3s are treated and used in exactly the same way as normal MOD musics. The advantage of MO3s is that they can be a lot smaller with virtually identical quality. Playing a MO3 does not use any more CPU power than playing the original MOD version does. The only difference is a slightly longer load time as the samples are being decoded. MO3 files are created using the MO3 encoder available at the BASS website.</para>
            <para>DMO effects (the same as available with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>) can be used in IT and XM files (and MO3 versions of them) created with Modplug Tracker. This allows effects to be added to a track without having to resort to an MP3 or OGG version, so it can remain small and still sound fancy. Of course, the effects require some CPU, so should not be used carelessly if performance is key. DirectX 8 (or above) is required for the effects to be heard - without that, the music can still be played, but the effects are disabled.</para>
            <para>Ramping doesn't take a lot of extra processing and improves the sound quality by removing "clicks". Sensitive ramping leaves sharp attacked samples, while normal ramping can cause them to lose a-bit of their impact. Generally, normal ramping is recommended for XMs, and sensitive ramping for the other formats. But, some XMs may also sound better using sensitive ramping.</para>
            <para>When loading a MOD music from memory, BASS does not use the memory after it's loaded the MOD music. So you can do whatever you want with the memory after calling this function.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_MUSIC_AUTOFREE flag is unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int music = Bass.BASS_MusicLoad("test.mod", 0, 0, BASSFlag.BASS_DEFAULT, 0);
            </code>
            <code lang="vbnet">
            Dim music As Integer = Bass.BASS_MusicLoad("test.mod", 0, 0, BASSFlag.BASS_DEFAULT, 0)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicLoadMemory(System.Boolean,System.IntPtr,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Only used internally! See the file overload of <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> for details!
            </summary>
            <param name="mem">Needs to be set to TRUE</param>
            <param name="memory">An IntPtr to the memory block.</param>
            <param name="offset">File offset to load the MOD music from.</param>
            <param name="length">Needs to be set to the length of the buffer data which should be played.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>).</param>
            <param name="freq">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.IntPtr,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Loads a MOD music file - MO3 / IT / XM / S3M / MTM / MOD / UMX formats.
            <para>This overload implements loading from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">File offset to load the MOD music from.</param>
            <param name="length">Data length... 0 = use all data up to the end of file. If length over-runs the end of the file, it'll automatically be lowered to the end of the file.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_MUSIC_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the MOD music in mono (uses less CPU than stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the MOD music to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Enable 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D channels are mono, so BASS_SAMPLE_MONO is automatically applied. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the music.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the music.</description></item>
            <item><term>BASS_MUSIC_RAMP</term><description>Use "normal" ramping (as used in FastTracker 2).</description></item>
            <item><term>BASS_MUSIC_RAMPS</term><description>Use "sensitive" ramping".</description></item>
            <item><term>BASS_MUSIC_NONINTER</term><description>Use non-interpolated mixing. This generally reduces the sound quality, but can be good for chip-tunes.</description></item>
            <item><term>BASS_MUSIC_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires quite a bit more processing. If neither this or the BASS_MUSIC_NONINTER flag is specified, linear interpolation is used.</description></item>
            <item><term>BASS_MUSIC_FT2MOD</term><description>Play .MOD file as FastTracker 2 would.</description></item>
            <item><term>BASS_MUSIC_PT1MOD</term><description>Play .MOD file as ProTracker 1 would.</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>Stop all notes when seeking (using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>).</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>Stop all notes and reset bpm/etc when seeking.</description></item>
            <item><term>BASS_MUSIC_SURROUND</term><description>Apply XMPlay's surround sound to the music (ignored in mono).</description></item>
            <item><term>BASS_MUSIC_SURROUND2</term><description>Apply XMPlay's surround sound mode 2 to the music (ignored in mono).</description></item>
            <item><term>BASS_MUSIC_STOPBACK</term><description>Stop the music when a backward jump effect is played. This stops musics that never reach the end from going into endless loops. Some MOD musics are designed to jump all over the place, so this flag would cause those to be stopped prematurely. If this flag is used together with the BASS_SAMPLE_LOOP flag, then the music would not be stopped but any BASS_SYNC_END sync would be triggered.</description></item>
            <item><term>BASS_MUSIC_PRESCAN</term><description>Calculate the playback length of the music, and enable seeking in bytes. This slightly increases the time taken to load the music, depending on how long it is. In the case of musics that loop, the length until the loop occurs is calculated. Use BASS_ChannelGetLength to retrieve the length.</description></item>
            <item><term>BASS_MUSIC_NOSAMPLE</term><description>Don't load the samples. This reduces the time taken to load the music, notably with MO3 files, which is useful if you just want to get the name and length of the music without playing it.</description></item>
            <item><term>BASS_MUSIC_AUTOFREE</term><description>Automatically free the music when it ends. This allows you to play a music and forget about it, as BASS will automatically free the music's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called. Note that some musics never actually end on their own (ie. without you stopping them).</description></item>
            <item><term>BASS_MUSIC_DECODE</term><description>Decode the music into sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. BASS_SAMPLE_SOFTWARE/3D/FX/AUTOFREE are ignored when using this flag, as are the SPEAKER flags.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>. The BASS_SAMPLE_MONO flag is automatically applied when using a mono speaker assignment flag.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>BASS uses the same code as XMPlay for it's MOD music support, giving the most accurate reproduction of MO3 / IT / XM / S3M / MTM / MOD / UMX files available from any sound system.</para>
            <para>MO3s are treated and used in exactly the same way as normal MOD musics. The advantage of MO3s is that they can be a lot smaller with virtually identical quality. Playing a MO3 does not use any more CPU power than playing the original MOD version does. The only difference is a slightly longer load time as the samples are being decoded. MO3 files are created using the MO3 encoder available at the BASS website.</para>
            <para>DMO effects (the same as available with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>) can be used in IT and XM files (and MO3 versions of them) created with Modplug Tracker. This allows effects to be added to a track without having to resort to an MP3 or OGG version, so it can remain small and still sound fancy. Of course, the effects require some CPU, so should not be used carelessly if performance is key. DirectX 8 (or above) is required for the effects to be heard - without that, the music can still be played, but the effects are disabled.</para>
            <para>Ramping doesn't take a lot of extra processing and improves the sound quality by removing "clicks". Sensitive ramping leaves sharp attacked samples, while normal ramping can cause them to lose a-bit of their impact. Generally, normal ramping is recommended for XMs, and sensitive ramping for the other formats. But, some XMs may also sound better using sensitive ramping.</para>
            <para>When loading a MOD music from memory, BASS does not use the memory after it's loaded the MOD music. So you can do whatever you want with the memory after calling this function.
            This means there is no need to pin the memory buffer for this method.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_MUSIC_AUTOFREE flag is unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            See <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>for examples on how to load data from memory.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicLoadMemory(System.Boolean,System.Byte[],System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Only used internally! See the file overload of <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> for details!
            </summary>
            <param name="mem">Needs to be set to TRUE</param>
            <param name="memory">An IntPtr to the memory block.</param>
            <param name="offset">File offset to load the MOD music from.</param>
            <param name="length">Needs to be set to the length of the buffer data which should be played.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>).</param>
            <param name="freq">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.Byte[],System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Loads a MOD music file - MO3 / IT / XM / S3M / MTM / MOD / UMX formats.
            <para>This overload implements loading from memory.</para>
            </summary>
            <param name="memory">A managed memory location as a byte[].</param>
            <param name="offset">File offset to load the MOD music from.</param>
            <param name="length">Data length... 0 = use all data up to the end of file. If length over-runs the end of the file, it'll automatically be lowered to the end of the file.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_MUSIC_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the MOD music in mono (uses less CPU than stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the MOD music to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Enable 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D channels are mono, so BASS_SAMPLE_MONO is automatically applied. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the music.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the music.</description></item>
            <item><term>BASS_MUSIC_RAMP</term><description>Use "normal" ramping (as used in FastTracker 2).</description></item>
            <item><term>BASS_MUSIC_RAMPS</term><description>Use "sensitive" ramping".</description></item>
            <item><term>BASS_MUSIC_NONINTER</term><description>Use non-interpolated mixing. This generally reduces the sound quality, but can be good for chip-tunes.</description></item>
            <item><term>BASS_MUSIC_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires quite a bit more processing. If neither this or the BASS_MUSIC_NONINTER flag is specified, linear interpolation is used.</description></item>
            <item><term>BASS_MUSIC_FT2MOD</term><description>Play .MOD file as FastTracker 2 would.</description></item>
            <item><term>BASS_MUSIC_PT1MOD</term><description>Play .MOD file as ProTracker 1 would.</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>Stop all notes when seeking (using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>).</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>Stop all notes and reset bpm/etc when seeking.</description></item>
            <item><term>BASS_MUSIC_SURROUND</term><description>Apply XMPlay's surround sound to the music (ignored in mono).</description></item>
            <item><term>BASS_MUSIC_SURROUND2</term><description>Apply XMPlay's surround sound mode 2 to the music (ignored in mono).</description></item>
            <item><term>BASS_MUSIC_STOPBACK</term><description>Stop the music when a backward jump effect is played. This stops musics that never reach the end from going into endless loops. Some MOD musics are designed to jump all over the place, so this flag would cause those to be stopped prematurely. If this flag is used together with the BASS_SAMPLE_LOOP flag, then the music would not be stopped but any BASS_SYNC_END sync would be triggered.</description></item>
            <item><term>BASS_MUSIC_PRESCAN</term><description>Calculate the playback length of the music, and enable seeking in bytes. This slightly increases the time taken to load the music, depending on how long it is. In the case of musics that loop, the length until the loop occurs is calculated. Use BASS_ChannelGetLength to retrieve the length.</description></item>
            <item><term>BASS_MUSIC_NOSAMPLE</term><description>Don't load the samples. This reduces the time taken to load the music, notably with MO3 files, which is useful if you just want to get the name and length of the music without playing it.</description></item>
            <item><term>BASS_MUSIC_AUTOFREE</term><description>Automatically free the music when it ends. This allows you to play a music and forget about it, as BASS will automatically free the music's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called. Note that some musics never actually end on their own (ie. without you stopping them).</description></item>
            <item><term>BASS_MUSIC_DECODE</term><description>Decode the music into sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. BASS_SAMPLE_SOFTWARE/3D/FX/AUTOFREE are ignored when using this flag, as are the SPEAKER flags.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>. The BASS_SAMPLE_MONO flag is automatically applied when using a mono speaker assignment flag.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>BASS uses the same code as XMPlay for it's MOD music support, giving the most accurate reproduction of MO3 / IT / XM / S3M / MTM / MOD / UMX files available from any sound system.</para>
            <para>MO3s are treated and used in exactly the same way as normal MOD musics. The advantage of MO3s is that they can be a lot smaller with virtually identical quality. Playing a MO3 does not use any more CPU power than playing the original MOD version does. The only difference is a slightly longer load time as the samples are being decoded. MO3 files are created using the MO3 encoder available at the BASS website.</para>
            <para>DMO effects (the same as available with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>) can be used in IT and XM files (and MO3 versions of them) created with Modplug Tracker. This allows effects to be added to a track without having to resort to an MP3 or OGG version, so it can remain small and still sound fancy. Of course, the effects require some CPU, so should not be used carelessly if performance is key. DirectX 8 (or above) is required for the effects to be heard - without that, the music can still be played, but the effects are disabled.</para>
            <para>Ramping doesn't take a lot of extra processing and improves the sound quality by removing "clicks". Sensitive ramping leaves sharp attacked samples, while normal ramping can cause them to lose a-bit of their impact. Generally, normal ramping is recommended for XMs, and sensitive ramping for the other formats. But, some XMs may also sound better using sensitive ramping.</para>
            <para>When loading a MOD music from memory, BASS does not use the memory after it's loaded the MOD music. So you can do whatever you want with the memory after calling this function.
            This means there is no need to pin the memory buffer for this method.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_MUSIC_AUTOFREE flag is unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example demontrates how to load music from memory:
            <code>
            // Init Bass
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, 0, null);
            // open file
            FileStream fs = File.OpenRead( "test.mod" );
            // get the length of the file
            int length = (int)fs.Length;
            // create the buffer which will keep the file in memory
            byte[] buffer = new byte[length];
            // read the file into the buffer
            fs.Read(buffer, 0, length);
            // buffer is filled, file can be closed
            fs.Close();
            // load music from memory buffer
            int music = Bass.BASS_MusicLoad(buffer, 0, length, BASSFlag.BASS_DEFAULT, 0);
            if (music != 0 &amp;&amp; Bass.BASS_ChannelPlay(stream, false) )
            {
            	// playing...
            }
            else
            {
            	Console.WriteLine("Error={0}", Bass.BASS_ErrorGetCode());
            }
            </code>
            <code lang="vbnet">
            ' Init Bass
            Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, 0, Nothing)
            ' open file
            Dim fs As FileStream = File.OpenRead("test.mod")
            ' get the length of the file
            Dim length As Integer = CInt(fs.Length)
            ' create the buffer which will keep the file in memory
            Dim buffer(length) As Byte
            ' read the file into the buffer
            fs.Read(buffer, 0, length)
            ' buffer is filled, file can be closed
            fs.Close()
            ' load music from memory buffer
            Dim music As Integer = Bass.BASS_MusicLoad(buffer, 0, length, BASSFlag.BASS_DEFAULT, 0)
            If music &lt;&gt; 0 AndAlso Bass.BASS_ChannelPlay(stream, False) Then
              ' playing...
            Else
              Console.WriteLine("Error={0}", Bass.BASS_ErrorGetCode())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicFree(System.Int32)">
            <summary>
            Frees a MOD music's resources, including any sync/DSP/FX it has.
            </summary>
            <param name="handle">The MOD music handle (which has been created with <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)">
            <summary>
            Initializes a recording device.
            </summary>
            <param name="device">The device to use... -1 = default device, 0 = first. <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceCount"/> can be used to get the total number of devices.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use BASS_ErrorGetCode to get the error code.</returns>
            <remarks>
            This function must be successfully called before using the recording features.
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. <see cref="M:Un4seen.Bass.Bass.BASS_RecordSetDevice(System.Int32)"/> is used to switch the current recording device. When successful, <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> automatically sets the current thread's device to the one that was just initialized</para>
            <para>When using the default device (device = -1), <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDevice"/> can be used to find out which device it was mapped to. On Windows, it'll always be the first device.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DX</term><description>A sufficient version of DirectX is not installed.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="device"/> is invalid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The device has already been initialized. <see cref="M:Un4seen.Bass.Bass.BASS_RecordFree"/> must be called before it can be initialized again.</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>There is no available device driver.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            private RECORDPROC _myRecProc; // make it global, so that the GC can not remove it
            private int _byteswritten = 0;
            private byte[] _recbuffer; // local recording buffer
            ...
            if ( Bass.BASS_RecordInit(-1) )
            {
              _myRecProc = new RECORDPROC(MyRecording);
              int recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero);
              ...
              // start recording
              Bass.BASS_ChannelPlay(recHandle, false);
            }
            ...
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              bool cont = true;
              if (length &gt; 0 &amp;&amp; buffer != IntPtr.Zero)
              {
                // increase the rec buffer as needed
                if (_recbuffer == null || _recbuffer.Length &lt; length)
                  _recbuffer = new byte[length];
                // copy from managed to unmanaged memory
                Marshal.Copy(buffer, _recbuffer, 0, length);
                _byteswritten += length;
                // write to file
                ...
                // stop recording after a certain amout (just to demo)
                if (_byteswritten &gt; 800000)
                  cont = false; // stop recording
              }
              return cont;
            }
            </code>
            <code lang="vbnet">
            Private _myRecProc As RECORDPROC ' make it global, so that the GC can not remove it
            Private _byteswritten As Integer = 0
            Private _recbuffer() As Byte ' local recording buffer
            ...
            If Bass.BASS_RecordInit(-1) Then
              _myRecProc = New RECORDPROC(AddressOf MyRecording)
              Dim recHandle As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero)
              ...
              ' start recording
              Bass.BASS_ChannelPlay(recHandle, False)
            End If
            ...
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              Dim cont As Boolean = True
              If length &gt; 0 AndAlso buffer &lt;&gt; IntPtr.Zero Then
                ' increase the rec buffer as needed
                If _recbuffer Is Nothing OrElse _recbuffer.Length &lt; length Then
                  _recbuffer = New Byte(length) {}
                End If
                ' copy from managed to unmanaged memory
                Marshal.Copy(buffer, _recbuffer, 0, length)
                _byteswritten += length
                ' write to file
                ...
                ' stop recording after a certain amout (just to demo)
                If _byteswritten &gt; 800000 Then
                  cont = False ' stop recording
                End If
              End If
              Return cont
            End Function
            </code>
            If you are into C# you might also use an unsafe codeblock with native pointer access 
            (which might be must faster than the above - depending on what you are doing with the data):
            <code>
            private unsafe bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              bool cont = true;
              if (length &gt; 0 &amp;&amp; buffer != IntPtr.Zero)
              {
                // assuming 16-bit sample data here
                short *data = (short*)buffer;
                ...
            
                // stop recording after a certain amout (just to demo)
                if (_byteswritten &gt; 800000)
                  cont = false; // stop recording
              }
              return cont;
            }
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)">
            <summary>
            Starts recording.
            </summary>
            <param name="freq">The sample rate to record at.</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>)
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the recorded data is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more information.</description></item>
            <item><term>BASS_RECORD_PAUSE</term><description>Start the recording paused. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> together with the handle returned by this method to start it.</description></item>
            </list>
            </param>
            <param name="proc">The user defined function to receive the recorded sample data... can be NULL if you do not wish to use a callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new recording's handle is returned, else FALSE is returned. Use BASS_ErrorGetCode to get the error code.</returns>
            <remarks>
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> to stop the recording. Recording can also be paused with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPause(System.Int32)"/>.
            <para>When specifying a very short period between RECORDPROC calls, some calls may be skipped due to there being no new data available from the recording device since the last call. This is more likely to happen with drivers that do not have hardware support.</para>
            <para>Starting the recording paused (BASS_RECORD_PAUSE) allows DSP/FX to be set on the recording channel before any data reaches the RECORDPROC function.</para>
            <para>Not using a callback (proc = NULL) allows lower latency for full-duplex recording (ie. playing the data as it's being recorded), as you get the recorded data on demand via the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> function. To keep latency at a minimum, the amount of data in the recording buffer should be monitored (also done via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, with the BASS_DATA_AVAILABLE flag) to check that there's not too much data. If there is too much data in the buffer, then that means the data currently being recorded will be delayed by the older data in the buffer being retrieved first.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>Recording is already in progress. You must stop the current recording (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/>) before calling this function again. On Windows XP, multiple simultaneous recordings can be made from the same device.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The recording device is not available. Another application may already be recording with it, or it could be a half-duplex device and is currently being used for playback.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The specified format is not supported. If using the BASS_SAMPLE_FLOAT flag, it could be that floating-point recording is not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Start recording at 44100hz 16-bit stereo:
            <code>
            private RECORDPROC _myRecProc; // make it global, so that the Garbage Collector can not remove it
            ...
            Bass.BASS_RecordInit(-1);
            _myRecProc = new RECORDPROC(MyRecording);
            // start recording paused
            int recChannel = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero);
            ...
            // really start recording
            Bass.BASS_ChannelPlay(recChannel, false);
            ...
            // the recording callback
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              return true;
            }
            </code>
            <code lang="vbnet">
            Private _myRecProc As RECORDPROC
            ...
            Bass.BASS_RecordInit(- 1)
            _myRecProc = New RECORDPROC(AddressOf MyRecording)
            ' start recording paused
            Dim recChannel As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero)
            ...
            ' really start recording
            Bass.BASS_ChannelPlay(recChannel, False)
            ...
            ' the recording callback
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              Return True
            End Function
            </code>
            See <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> for a recording callback sample.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int32,Un4seen.Bass.RECORDPROC,System.IntPtr)">
            <summary>
            Starts recording.
            </summary>
            <param name="freq">The sample rate to record at.</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>)
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the recorded data is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more information.</description></item>
            <item><term>BASS_RECORD_PAUSE</term><description>Start the recording paused. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> together with the handle returned by this method to start it.</description></item>
            </list>
            </param>
            <param name="period">Set the period (in milliseconds) between calls to the callback function (<see cref="T:Un4seen.Bass.RECORDPROC"/>). The minimum period is 10ms, the maximum is 500ms. If the period specified is outside this range, it is automatically capped.</param>
            <param name="proc">The user defined function to receive the recorded sample data... can be NULL if you do not wish to use a callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new recording's handle is returned, else FALSE is returned. Use BASS_ErrorGetCode to get the error code.</returns>
            <remarks>
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> to stop the recording. Recording can also be paused with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPause(System.Int32)"/>.
            <para>When specifying a very short period between RECORDPROC calls, some calls may be skipped due to there being no new data available from the recording device since the last call. This is more likely to happen with drivers that do not have hardware support.</para>
            <para>Starting the recording paused (BASS_RECORD_PAUSE) allows DSP/FX to be set on the recording channel before any data reaches the RECORDPROC function.</para>
            <para>Not using a callback (proc = NULL) allows lower latency for full-duplex recording (ie. playing the data as it's being recorded), as you get the recorded data on demand via the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> function. To keep latency at a minimum, the amount of data in the recording buffer should be monitored (also done via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, with the BASS_DATA_AVAILABLE flag) to check that there's not too much data. If there is too much data in the buffer, then that means the data currently being recorded will be delayed by the older data in the buffer being retrieved first.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>Recording is already in progress. You must stop the current recording (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/>) before calling this function again. On Windows XP, multiple simultaneous recordings can be made from the same device.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The recording device is not available. Another application may already be recording with it, or it could be a half-duplex device and is currently being used for playback.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The specified format is not supported. If using the BASS_SAMPLE_FLOAT flag, it could be that floating-point recording is not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Start recording at 44100hz 16-bit stereo with a 50ms recording period:
            <code>
            private RECORDPROC _myRecProc; // make it global, so that the Garbage Collector can not remove it
            ...
            Bass.BASS_RecordInit(-1);
            _myRecProc = new RECORDPROC(MyRecording);
            // start recording paused
            int recChannel = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, 50, _myRecProc, IntPtr.Zero);
            ...
            // really start recording
            Bass.BASS_ChannelPlay(recChannel, false);
            ...
            // the recording callback
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              return true;
            }
            </code>
            <code lang="vbnet">
            Private _myRecProc As RECORDPROC
            ...
            Bass.BASS_RecordInit(-1)
            _myRecProc = New RECORDPROC(AddressOf MyRecording)
            ' start recording paused
            Dim recChannel As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, 50, _myRecProc, IntPtr.Zero)
            ...
            ' really start recording
            Bass.BASS_ChannelPlay(recChannel, False)
            ...
            ' the recording callback
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              Return True
            End Function
            </code>
            See <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> for a recording callback sample.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfoInternal(System.Int32,Un4seen.Bass.BASS_DEVICEINFO_INTERNAL@)">
            <summary>
            
            </summary>
            <param name="device"></param>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)">
            <summary>
            Retrieves information on a recording device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> class to store the information at.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available recording devices for a setup dialog. 
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List all available recording devices:
            <code>
            BASS_DEVICEINFO info = new BASS_DEVICEINFO();
            for (int n=0; Bass.BASS_RecordGetDeviceInfo(n, info); n++)
            {
              Console.WriteLine(info.ToString());
            }
            </code>
            <code lang="vbnet">
            Dim n As Integer = 0
            Dim info As New BASS_DEVICEINFO()
            While (Bass.BASS_RecordGetDeviceInfo(n, info))
              Console.WriteLine(name.ToString())
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on a recording device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <returns>If successful, then an instance of the <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> class is returned, else NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available recording devices for a setup dialog. 
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Find the system default recording device:
            <code>
            int defDevice = -1;
            BASS_DEVICEINFO info;
            for (int n = 0; (info = Bass.BASS_RecordGetDeviceInfo(n)) != null; n++)
            {
              if (info.IsDefault)
              {
                defDevice = n;
                break;
              }
            }
            </code>
            <code lang="vbnet">
            Dim defDevice As Integer = -1
            Dim n As Integer = 0
            Dim info As New BASS_DEVICEINFO()
            While Not (info Is Nothing)
              info = Bass.BASS_RecordGetDeviceDescription(n)
              If Not (info Is Nothing) And info.IsDefault Then
                defDevice = n
                Exit While
              End If
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfos">
            <summary>
            Returns all available recording devices.
            </summary>
            <returns>An array of <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> elements representing the available recording devices.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceCount">
            <summary>
            Returns the total number of available recording devices.
            </summary>
            <returns>Number of real recording devices available.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordSetDevice(System.Int32)">
            <summary>
            Sets the recording device to use for subsequent calls in the current thread.
            </summary>
            <param name="device">The device to use... 0 = first recording device.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.</para>
            <para>The functions that use the recording device selection are the following: 
            <see cref="M:Un4seen.Bass.Bass.BASS_RecordFree"/>, <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInfo(Un4seen.Bass.BASS_RECORDINFO)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32,System.Single@)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInputName(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_RecordSetInput(System.Int32,Un4seen.Bass.BASSInput,System.Single)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>.</para>
            <para>When one of the above functions (or <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDevice"/>) is called, BASS will check the current thread's recording device setting, and if no device is selected (or the selected device is not initialized), BASS will automatically select the lowest device that is initialized. 
            This means that when using a single device, there is no need to use this function - BASS will automatically use the device that's initialized. 
            Even if you free the device, and initialize another, BASS will automatically switch to the one that is initialized.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="device"/> is invalid.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The device has not been initialized.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetDevice">
            <summary>
            Retrieves the recording device setting in the current thread.
            </summary>
            <returns>If successful, the device number is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/>to get the error code.</returns>
            <remarks>See also <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInfo(Un4seen.Bass.BASS_RECORDINFO)">
            <summary>
            Retrieves information on the recording device being used.
            </summary>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.BASS_RECORDINFO"/> class to store the information at.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>There is no need to initialize any size member of the <see cref="T:Un4seen.Bass.BASS_RECORDINFO"/> structure as described in the C/C++ interface, since all marchalling is already handled by the API here.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_RECORDINFO info = new BASS_RECORDINFO();
            bool ok = Bass.BASS_RecordGetInfo(info);
            </code>
            <code lang="vbnet">
            Dim info As New BASS_RECORDINFO()
            Dim ok As Boolean = Bass.BASS_RecordGetInfo(info)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInfo">
            <summary>
            Retrieves information on the recording device being used.
            </summary>
            <returns>An instance of the <see cref="T:Un4seen.Bass.BASS_RECORDINFO"/> class on success - else NULL.</returns>
            <remarks>There is no need to initialize any size member of the <see cref="T:Un4seen.Bass.BASS_RECORDINFO"/> structure as described in the C/C++ interface, since all marchalling is already handled by the API here.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_RECORDINFO info = Bass.BASS_RecordGetInfo(info);
            if (info != null)
              Console.WriteLine(info.ToString());
            </code>
            <code lang="vbnet">
            Dim info As BASS_RECORDINFO = Bass.BASS_RecordGetInfo(info)
            If Not (info Is Nothing) Then
              Console.WriteLine(info.ToString())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInputNamePtr(System.Int32)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInputName(System.Int32)">
            <summary>
            Retrieves the text description of a recording input source.
            </summary>
            <param name="input">The input to get the description of... 0 = first, -1 = master.</param>
            <returns>If succesful, then the description is returned, else NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="input"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the name of the first input:
            <code>
            string inputName = Bass.BASS_RecordGetInputName(0);
            </code>
            <code lang="vbnet">
            Dim inputName As String = Bass.BASS_RecordGetInputName(0)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInputNames">
            <summary>
            Returns all available recording input source names.
            </summary>
            <returns>An array of strings representing the available recording input source names.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInputName(System.Int32)"/> internally.
            <para>The index of the returned names equals the input-id, which might be used with <see cref="M:Un4seen.Bass.Bass.BASS_RecordSetInput(System.Int32,Un4seen.Bass.BASSInput,System.Single)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordSetInput(System.Int32,Un4seen.Bass.BASSInput,System.Single)">
            <summary>
            Adjusts the settings of a recording input source.
            </summary>
            <param name="input">The input to adjust the settings of... 0 = first, -1 = master.</param>
            <param name="setting">The new setting... a combination of these flags (<see cref="T:Un4seen.Bass.BASSInput"/>):
            <list type="table">
            <item><term>BASS_INPUT_OFF</term><description>Disable the input. This flag can't be used when the device supports only one input at a time.</description></item>
            <item><term>BASS_INPUT_ON</term><description>Enable the input. If the device only allows one input at a time, then any previously enabled input will be disabled by this.</description></item>
            <item><term>BASS_INPUT_NONE</term><description>Don't change any setting. Use this flag, if you only want to set the volume.</description></item>
            </list>
            </param>
            <param name="volume">The volume level... 0 (silent) to 1 (max), less than 0 = leave current.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Changes made by this function are system-wide, ie. other software using the device will be affected by it.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="input"/> or <paramref name="volume"/> is invalid.</description></item>
            <item><term>BASS_NOTAVAIL</term><description>The soundcard/driver doesn't allow you to change the input or it's volume.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // Disable the master input without changing the volume:
            Bass.BASS_RecordSetInput(-1, BASSInput.BASS_INPUT_OFF, -1f );
            
            // Enable the first input and set the volume to 50%:
            Bass.BASS_RecordSetInput(0, BASSInput.BASS_INPUT_ON, 0.5f );
            
            // Set the volume of the first input without changing the settings:
            Bass.BASS_RecordSetInput(0, BASSInput.BASS_INPUT_NONE, 1f );
            </code>
            <code lang="vbnet">
            ' Disable the master input without changing the volume:
            Bass.BASS_RecordSetInput(-1, BASSInput.BASS_INPUT_OFF, -1F)
            
            ' Enable the first input and set the volume to 50%:
            Bass.BASS_RecordSetInput(0, BASSInput.BASS_INPUT_ON, 0.5F)
            
            ' Set the volume of the first input without changing the settings:
            Bass.BASS_RecordSetInput(0, BASSInput.BASS_INPUT_NONE, 1F );
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32,System.Single@)">
            <summary>
            Retrieves the settings of a recording input source.
            </summary>
            <param name="input">The input to get the settings of... 0 = first, -1 = master.</param>
            <param name="volume">Reference to a variable to receive the current volume.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            If successful, then the settings are returned. The BASS_INPUT_OFF flag will be set if the input is disabled, 
            otherwise the input is enabled. The type of input (see <see cref="T:Un4seen.Bass.BASSInputType"/>) is also indicated in the high 8-bits (use BASS_INPUT_TYPE_MASK to test) of the return value, 
            and can be one of the following:
            <list type="table">
            <item><term>BASS_INPUT_TYPE_DIGITAL</term><description>Digital input source, for example, a DAT or audio CD.</description></item>
            <item><term>BASS_INPUT_TYPE_LINE</term><description>Line-in. On some devices, "Line-in" may be combined with other analog sources into a single BASS_INPUT_TYPE_ANALOG input.</description></item>
            <item><term>BASS_INPUT_TYPE_MIC</term><description>Microphone.</description></item>
            <item><term>BASS_INPUT_TYPE_SYNTH</term><description>Internal MIDI synthesizer.</description></item>
            <item><term>BASS_INPUT_TYPE_CD</term><description>Analog audio CD.</description></item>
            <item><term>BASS_INPUT_TYPE_PHONE</term><description>Telephone.</description></item>
            <item><term>BASS_INPUT_TYPE_SPEAKER</term><description>PC speaker.</description></item>
            <item><term>BASS_INPUT_TYPE_WAVE</term><description>The device's WAVE/PCM output.</description></item>
            <item><term>BASS_INPUT_TYPE_AUX</term><description>Auxiliary. Like "Line-in", "Aux" may be combined with other analog sources into a single BASS_INPUT_TYPE_ANALOG input on some devices.</description></item>
            <item><term>BASS_INPUT_TYPE_ANALOG</term><description>Analog, typically a mix of all analog sources.</description></item>
            <item><term>BASS_INPUT_TYPE_UNDEF</term><description>Anything that is not covered by the other types.</description></item>
            </list>
            </returns>
            <remarks>There is no "what you hear" type of input defined. If the device has one, it'll typically come under BASS_INPUT_TYPE_ANALOG or BASS_INPUT_TYPE_UNDEF.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="input"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List all available input sources, with their current status:
            <code>
            Bass.BASS_RecordInit(-1); // init the default device
            string name;
            for (int n = 0; (name = Bass.BASS_RecordGetInputName(n)) != null; n++)
            {
              float vol = 0f;
              int setting = Bass.BASS_RecordGetInput(n, ref vol);
              Console.WriteLine("{0} [{1} : {2}] - {3}", 
                                name, 
                                (BASSInputType)((int)BASSInputType.BASS_INPUT_TYPE_MASK &amp; setting), 
                                vol,
                                ((int)BASSInput.BASS_INPUT_OFF &amp; setting) != 0 ? "Off" : "On");
            }
            </code>
            <code lang="vbnet">
            Bass.BASS_RecordInit(-1) ' init the default device
            Dim n As Integer = 0
            Dim name As String = ""
            While Not (name Is Nothing)
              name = Bass.BASS_RecordGetInputName(n)
              n += 1
              If Not (name Is Nothing) Then
                Dim vol As Single = 0F
                Dim setting As Integer = Bass.BASS_RecordGetInput(n, vol)
                Console.WriteLine("{0} [{1} : {2}] - {3}", 
                                  name, 
                                  CType(CInt(BASSInputType.BASS_INPUT_TYPE_MASK) And setting, BASSInputType), 
                                  vol,
                                  CStr(IIf(CInt(BASSInput.BASS_INPUT_OFF) And setting &lt;&gt; 0, "Off", "On")))
              End If
            End While
            </code>
            Find a microphone input:
            <code>
            Bass.BASS_RecordInit(-1);
            int mic = -1;
            int n = 0;
            int settings = 0;
            float vol = 0f;
            while (settings != -1)
            {
              // get the settings of that input
              settings = Bass.BASS_RecordGetInput(n, ref vol);
              if ( (settings &amp; (int)BASSInputType.BASS_INPUT_TYPE_MASK) == (int)BASSInputType.BASS_INPUT_TYPE_MIC )
              { 
                // found the mic!
                mic = n;
                break;
              }
              n++;
            }
            if (mic != -1)
              Console.WriteLine( "Found a MIC at input {0}", mic );
            else
              Console.WriteLine( "No MIC found!" );
            </code>
            <code lang="vbnet">
            Bass.BASS_RecordInit(-1)
            Dim mic As Integer = -1
            Dim n As Integer = 0
            Dim settings As Integer = 0
            Dim vol As Single = 0F
            While settings &lt;&gt; -1
              ' get the settings of that input
              settings = Bass.BASS_RecordGetInput(n, vol)
              If (settings And CInt(BASSInputType.BASS_INPUT_TYPE_MASK)) = CInt(BASSInputType.BASS_INPUT_TYPE_MIC) Then
                ' found the mic!
                mic = n
                Exit While
              End If
              n += 1
            End While
            If mic &lt;&gt; -1 Then
              Console.WriteLine("Found a MIC at input {0}", mic)
            Else
              Console.WriteLine("No MIC found!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32)">
            <summary>
            Retrieves the setting of a recording input source.
            </summary>
            <param name="input">The input to get the settings of... 0 = first, -1 = master.</param>
            <returns>One of the <see cref="T:Un4seen.Bass.BASSInput"/> values (BASS_INPUT_NONE on error).</returns>
            <remarks><see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32,System.Single@)"/> returns both, the <see cref="T:Un4seen.Bass.BASSInputType"/> (in the high-word) 
            as well as the <see cref="T:Un4seen.Bass.BASSInput"/> (in the low-word).
            Use this overload to only retrieve the <see cref="T:Un4seen.Bass.BASSInput"/> without the <see cref="T:Un4seen.Bass.BASSInputType"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="input"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInputPtr(System.Int32,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <param name="vol"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInputType(System.Int32)">
            <summary>
            Retrieves the type of input of a recording input source.
            </summary>
            <param name="input">The input to get the settings of... 0 = first, -1 = master.</param>
            <returns>One of the <see cref="T:Un4seen.Bass.BASSInputType"/> values (BASS_INPUT_TYPE_ERROR on error).</returns>
            <remarks><see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32,System.Single@)"/> returns both, the <see cref="T:Un4seen.Bass.BASSInputType"/> (in the high-word) 
            as well as the <see cref="T:Un4seen.Bass.BASSInput"/> (in the low-word).
            Use this overload to only retrieve the <see cref="T:Un4seen.Bass.BASSInput"/> without the <see cref="T:Un4seen.Bass.BASSInputType"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="input"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Find a microphone input:
            <code>
            Bass.BASS_RecordInit(-1); // init the default device
            int mic = -1;
            BASSInputType flags;
            for (int n=0; (flags=Bass.BASS_RecordGetInputType(n)) != BASSInputType.BASS_INPUT_TYPE_ERROR; n++)
            {
              if ( (flags &amp; BASSInputType.BASS_INPUT_TYPE_MASK) == BASSInputType.BASS_INPUT_TYPE_MIC )
              { 
                // found the mic!
                mic = n;
                break;
              }
            }
            if (mic != -1)
              Console.WriteLine( "Found a MIC at input {0}", mic );
            else
              Console.WriteLine( "No MIC found!" );
            </code>
            <code lang="vbnet">
            Bass.BASS_RecordInit(- 1)
            Dim mic As Integer = -1
            Dim n As Integer = 0
            Dim flags As BASSInputType = BASSInputType.BASS_INPUT_TYPE_UNDEF
            While flags &lt;&gt; BASSInputType.BASS_INPUT_TYPE_ERROR
              ' get the settings of that input
              flags = Bass.BASS_RecordGetInputType(n)
              If (flags And BASSInputType.BASS_INPUT_TYPE_MASK) = BASSInputType.BASS_INPUT_TYPE_MIC) Then
                ' found the mic!
                mic = n
                Exit While
              End If
              n += 1
            End While
            If mic &lt;&gt; -1 Then
              Console.WriteLine("Found a MIC at input {0}", mic)
            Else
              Console.WriteLine("No MIC found!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordFree">
            <summary>
            Frees all resources used by the recording device.
            </summary>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function should be called for all initialized recording devices before your program exits.</para>
            <para>When using multiple recording devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_RecordSetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)">
            <summary>
            Retrieves information on a channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="info"><see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> instance where to store the channel information at.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the channel info:
            <code>
            BASS_CHANNELINFO info = new BASS_CHANNELINFO();
            Bass.BASS_ChannelGetInfo(_stream, info);
            Console.WriteLine( info.ToString() );
            </code>
            <code lang="vbnet">
            Dim info As New BASS_CHANNELINFO()
            Bass.BASS_ChannelGetInfo(_stream, info)
            Console.WriteLine(info.ToString())
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32)">
            <summary>
            Retrieves information on a channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <returns>An instance of the <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> class on success - else NULL.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the channel info:
            <code>
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(_stream);
            Console.WriteLine( info.ToString() );
            </code>
            <code lang="vbnet">
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(_stream)
            Console.WriteLine(info.ToString())
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)">
            <summary>
            Starts (or resumes) playback of a sample, stream, MOD music, or recording.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL / HMUSIC / HSTREAM / HRECORD handle.</param>
            <param name="restart">Restart playback from the beginning? If handle is a user stream, it's current buffer contents are flushed. If it's a MOD music, it's BPM/etc are automatically reset to their initial values.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When streaming in blocks (BASS_STREAM_BLOCK), the restart parameter is ignored as it's not possible to go back to the start. The restart parameter is also of no consequence with recording channels.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_START</term><description>The output is paused/stopped, use <see cref="M:Un4seen.Bass.Bass.BASS_Start"/> to start it.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description>The channel is not playable, it's a "decoding channel".</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>BASS_ERROR_NOHW</term><description>No hardware voices are available (HCHANNEL only). This only occurs if the sample was loaded/created with the BASS_SAMPLE_VAM flag, and BASS_VAM_HARDWARE is set in the sample's VAM mode, and there are no hardware voices available to play it.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, null);
            // create the stream
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            Bass.BASS_StreamFree(stream);
            </code>
            <code lang="vbnet">
            Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, Nothing)
            ' create the stream
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Bass.BASS_StreamFree(stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)">
            <summary>
            Sets up a user DSP function on a stream, MOD music, or recording channel.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="proc">The callback function (see <see cref="T:Un4seen.Bass.DSPPROC"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="priority">The priority of the new DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <returns>If succesful, then the new DSP's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            <para>Equally, you can also remove them at any time. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveDSP(System.Int32,System.Int32)"/> to remove a DSP function.</para>
            <para>Multiple DSP functions may be used per channel, in which case the order that the functions are called is determined by their priorities. Any DSPs that have the same priority are called in the order that they were added.</para>
            <para>DSP functions can be applied to MOD musics and streams, but not samples. If you want to apply a DSP function to a sample, then you should stream the sample.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example shows a little gain amplifier, assuming you are processing 32-bit BASS_SAMPLE_FLOAT!
            <code>
            private float _gainDB = 0f;
            private int _stream = 0;
            private DSPPROC _myDSPProc; // make it global, so that the GC can not remove it
            ...
            _gainDB = 6f; // amplify by +6dB
            _stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                           BASSFlag.BASS_STREAM_AUTOFREE | BASSFlag.BASS_SAMPLE_FLOAT);
            // set a DSP user callback method
            _myDSPProc = new DSPPROC(MyDSPGain);
            // set the user DSP callback
            Bass.BASS_ChannelSetDSP(_stream, _myDSPProc, IntPtr.Zero, 0);
            ...
            // this is the actual processing method
            private void MyDSPGain(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              // the global variable _gainDB contains the amplification value in dB!
              if (_gainDB == 0f || length == 0 || buffer == IntPtr.Zero)
                return;
            
              // convert the _gainDB value to a float
              float _gainAmplification = (float)Math.Pow(10d, _gainDB / 20d);
              // number of bytes in 32-bit floats, since length is in bytes
              int l4 = length/4;
              float[] data = new float[l4];
              // copy from managed to unmanaged memory
              Marshal.Copy(buffer, data, 0, l4);
              // apply gain, assumeing using 32-bit floats (no clipping here ;-)
              for (int a=0; a&lt;l4; a++)
                data[a] = data[a] * _gainAmplification;
              // copy back from unmanaged to managed memory
              Marshal.Copy(data, 0, buffer, l4);
            }
            </code>
            <code lang="vbnet">
            Private _gainDB As Single = 0F
            Private _stream As Integer = 0
            Private _myDSPProc As DSPPROC ' make it global, so that the GC can not remove it
            ...
            _gainDB = 6f; // amplify by +6dB
            _stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                           BASSFlag.BASS_STREAM_AUTOFREE Or BASSFlag.BASS_SAMPLE_FLOAT)
            ' set a DSP user callback method
            _myDSPProc = New DSPPROC(AddressOf MyDSPGain)
            ' set the user DSP callback
            Bass.BASS_ChannelSetDSP(_stream, _myDSPProc, IntPtr.Zero, 0)
            ...
            ' this is the actual processing method
            Private Sub MyDSPGain(handle As Integer, channel As Integer, 
                                  buffer As IntPtr, length As Integer, user As IntPtr)
              ' the global variable _gainDB contains the amplification value in dB!
              If _gainDB = 0F OrElse length = 0 OrElse buffer = IntPtr.Zero Then
                Return
              End If 
              ' convert the _gainDB value to a float
              Dim _gainAmplification As Single = CSng(Math.Pow(10.0, _gainDB / 20.0))
              ' number of bytes in 32-bit floats, since length is in bytes
              Dim l4 As Integer = length / 4
              Dim data(l4) As Single
              ' copy from managed to unmanaged memory
              Marshal.Copy(buffer, data, 0, l4)
              ' apply gain, assumeing using 32-bit floats (no clipping here ;-)
              Dim a As Integer
              For a = 0 To l4 - 1
                data(a) = data(a) * _gainAmplification
              Next a
              ' copy back from unmanaged to managed memory
              Marshal.Copy(data, 0, buffer, l4)
            End Sub
            </code>
            This example is type safe but 'slow', since two copy operations are involved. 
            One from unmanaged BASS to managed .NET and when processing has been done locally from .NET back to BASS.
            However, for VB.Net users this is almost the only way to do it.
            <para>C# user can be a little more lucky, since C# supports unsafe code blocks and native pointer access - 
            which will be shown in the following example:</para>
            <code>
            private unsafe void MyDSPGain(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              if (_gainDB == 1f || length == 0 || buffer == IntPtr.Zero)
                return;
            
              // convert the _gainDB value to a float
              float _gainAmplification = (float)Math.Pow(10d, _gainDB / 20d);
              // length is in bytes, so the number of floats to process is length/4 
              int l4 = length / 4;
              // cast the given buffer IntPtr to a native pointer to float values
              float *data = (float*)buffer;
              for (int a=0; a&lt;l4; a++)
              {
                data[a] = data[a] * _gainAmplification;
                // alternatively you can also use:
                // *data = *data * _gainAmplification;
                // data++;
              }
            }
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a stream or MOD music channel. Can also be used with a recording channel.
            This overload uses an IntPtr to reference the buffer data.
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="buffer">Location to write the data as an IntPtr (can be IntPtr.Zero when handle is a recording channel (HRECORD), to discard the requested amount of data from the recording buffer).
            <para>Use "Marshal.AllocCoTaskMem" to allocate a memory buffer, use "Marshal.Copy" to copy the buffer data from unmanaged BASS to your managed code and use "Marshal.FreeCoTaskMem" to free the memory buffer when not needed anymore.</para>
            <para>Or make use of a "GCHandle" to receive data to a pinned managed object.</para>
            </param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_FLOAT</term><description>Return floating-point sample data.</description></item>
            <item><term>BASS_DATA_FFT256</term><description>256 sample FFT (returns 128 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT512</term><description>512 sample FFT (returns 256 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT1024</term><description>1024 sample FFT (returns 512 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT2048</term><description>2048 sample FFT (returns 1024 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT4096</term><description>4096 sample FFT (returns 2048 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT8192</term><description>8192 sample FFT (returns 4096 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT_INDIVIDUAL</term><description>Use this flag to request separate FFT data for each channel. The size of the data returned (as listed above) is multiplied by the number channels.</description></item>
            <item><term>BASS_DATA_FFT_NOWINDOW</term><description>This flag can be used to prevent a hanning window being applied to the sample data when performing an FFT.</description></item>
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be NULL when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function can only return as much data as has been written to the channel's buffer, so it may not always be possible to get the amount of data requested, especially if you request large amounts. If you really do need large amounts, then increase the buffer lengths (BASS_CONFIG_BUFFER).
            The BASS_DATA_AVAILABLE flag can be used to check how much data a channel's buffer contains at any time, including when stopped or stalled.</para>
            <para>When requesting data from a "decoding channel" (BASS_STREAM_DECODE or BASS_MUSIC_DECODE was used at creation), there are no intermediate buffers involved, so as much data as is available can be decoded in one go.</para>
            <para>When retrieving sample data, the returned data is in the standard Windows PCM format: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1 (not clipped, so can actually be outside this range). That's unless the BASS_DATA_FLOAT flag is used, in which case, the sample data will be converted to 32-bit floating-point (if it isn't already).</para>
            <para>When requesting FFT data, floating-point values ranging from 0 to 1 are returned. Only the first half of the FFT is useful, so that's what BASS returns. For example with a 2048 sample FFT, it'll return 1024 values - the 1st value being the DC component, the 2nd the amplitude at 1/2048 of the channel's sample rate, then the amplitude at 2/2048, 3/2048, etc... A Hanning window is applied to the sample data to reduce leakage, unless the BASS_DATA_FFT_NOWINDOW flag is used.</para>
            <para>Channels that have 2 or more sample channels (ie. stereo or above) may have FFT performed on each individual channel, using the BASS_DATA_FFT_INDIVIDUAL flag. Without this flag, all the channels are combined, and a single mono FFT is performed. Performing the extra individual FFTs of course increases the amount of processing required. The return values are interleaved in the same order as the channel's sample data, eg. stereo = left,right,left,etc...</para>
            <para>This function is most useful if you wish to visualize (eg. spectrum analyze) the sound.</para>
            <para>FFT processing hint 1: DC stands for direct current (same as what a flashlight cell gives out) and is represents a 0 Hz sound, which cannot exist in real life. A sound sample should not have any DC component but probably will due to inaccuracies in the recording equipment. You won't hear it (except a click when playing and stopping the sample).
            The DC component is basically the average of all the samples that the FFT was applied to, and is pretty useless.
            You'll have to halve the DC component that BASS returns to get the actual DC component, as BASS doubles all the bin values.
            </para>
            <para>FFT processing hint 2: How to read out the amplitude of a single frequency/a frequency band?
            FFT[0] maps to amplitude at 0 Hz, FFT[length-1] maps to amplitude at Nyquist's frequency. So the index to FFT data at an arbitrary band is:
            <code lang="none">
            idx = length*freq/Nyquist
            where:
            length : length of the returned FFT buffer (in samples)
            freq : required frequency (Hz)
            Nyquist : Nyquist's frequency of the signal (half the sampling rate) (in Hz)
            </code>
            Example: If the stream is 44100Hz, then 16500Hz will be around bin 191 of a 512 sample FFT (512*16500/44100).
            Or, if you are using BASS_DATA_FFT4096 on a stream with a sample rate of 44100 a tone at 540Hz will be at: 540*4096/44100 = 50.15, so a bit of the energy will be in fft[51], but mostly in fft[50].
            Note: With a sample rate of 44100 the Nyquist frequency is 22050Hz, which is the max. frequency. This is also why BASS_DATA_FFT4096 only returns 2048 values - fft[2048] would represent 22050Hz.
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The channel has reached the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_DATA_AVAILABLE flag was used with a decoding channel.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example assumes that you have created the stream with the BASS_SAMPLE_FLOAT flag.
            So the buffer will contain 32-bit values between -1 and 1...as an array of float:
            <code>
            // a 30ms window in bytes to be filled with sample data
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03);
            
            // first we need a mananged object where the sample data should be held
            // only length/4 elements needed, since length is in byte and a float uses 4 bytes
            float[] data = new float[length/4];
            
            // create a pinned handle to a managed object
            GCHandle hGC = GCHandle.Alloc(data, GCHandleType.Pinned);
            
            // get the data
            length = Bass.BASS_ChannelGetData(channel, hGC.AddrOfPinnedObject(), length);
            
            // free the pinned handle
            hGC.Free();
            </code>
            <code lang="vbnet">
            ' a 30ms window in bytes to be filled with sample data
            Dim length As Integer = CInt(Bass.BASS_ChannelSeconds2Bytes(channel, 0.03))
            
            ' first we need a mananged object where the sample data should be held
            ' only length/4 elements needed, since length is in byte and a float uses 4 bytes
            Dim data(length/4) As Single
            
            ' create a pinned handle to a managed object
            Dim hGC As GCHandle = GCHandle.Alloc(data, GCHandleType.Pinned)
            
            ' get the data
            length = Bass.BASS_ChannelGetData(channel, hGC.AddrOfPinnedObject(), length)
            
            ' free the pinned handle
            hGC.Free()
            </code>
            A more simple way is to use the other overloads where you simply pass the array itself 
            (those overloads pass the buffer array as a reference type by value with automatic pinning,
            which is as fast as the following example).
            <para>If you are into C# you might even use native pointers in an unsafe code block:</para>
            <code>
            // a 30ms window in bytes to be filled with sample data
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03);
            
            // first we need a mananged object where the sample data should be held
            // only length/4 elements needed, since length is in byte and a float uses 4 bytes
            float[] data = new float[length/4];
            
            // start an unsafe code block allowing you to use native pointers
            unsafe
            {
              // pointers to managed objects need to be fixed
              fixed (float* buffer = data)    // equivalent to buffer = &amp;data[0]
              {
                length = Bass.BASS_ChannelGetData(channel, (IntPtr)buffer, length);
              }
            }
            </code>
            This is by far the fastest way to use BASS_ChannelGetData, but unfortunately not availabe with VB.Net.
            However, the other overloads do automatically pin the buffer as needed and are as fast as this.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a stream or MOD music channel. Can also be used with a recording channel.
            This overload uses a managed float[] to reference the buffer data as 32-bit!
            SHOULD ONLY BE USED, if the stream was created with BASS_SAMPLE_FLOAT!
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="buffer">The array (float[]) to receive the data, use BASS_SAMPLE_FLOAT when creating the channel stream!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_FLOAT</term><description>Return floating-point sample data.</description></item>
            <item><term>BASS_DATA_FFT256</term><description>256 sample FFT (returns 128 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT512</term><description>512 sample FFT (returns 256 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT1024</term><description>1024 sample FFT (returns 512 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT2048</term><description>2048 sample FFT (returns 1024 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT4096</term><description>4096 sample FFT (returns 2048 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT8192</term><description>8192 sample FFT (returns 4096 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT_INDIVIDUAL</term><description>Use this flag to request separate FFT data for each channel. The size of the data returned (as listed above) is multiplied by the number channels.</description></item>
            <item><term>BASS_DATA_FFT_NOWINDOW</term><description>This flag can be used to prevent a hanning window being applied to the sample data when performing an FFT.</description></item>
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be NULL when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function can only return as much data as has been written to the channel's buffer, so it may not always be possible to get the amount of data requested, especially if you request large amounts. If you really do need large amounts, then increase the buffer lengths (BASS_CONFIG_BUFFER).
            The BASS_DATA_AVAILABLE flag can be used to check how much data a channel's buffer contains at any time, including when stopped or stalled.</para>
            <para>When requesting data from a "decoding channel" (BASS_STREAM_DECODE or BASS_MUSIC_DECODE was used at creation), there are no intermediate buffers involved, so as much data as is available can be decoded in one go.</para>
            <para>When retrieving sample data, the returned data is in the standard Windows PCM format: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1 (not clipped, so can actually be outside this range). That's unless the BASS_DATA_FLOAT flag is used, in which case, the sample data will be converted to 32-bit floating-point (if it isn't already).</para>
            <para>When requesting FFT data, floating-point values ranging from 0 to 1 are returned. Only the first half of the FFT is useful, so that's what BASS returns. For example with a 2048 sample FFT, it'll return 1024 values - the 1st value being the DC component, the 2nd the amplitude at 1/2048 of the channel's sample rate, then the amplitude at 2/2048, 3/2048, etc... A Hanning window is applied to the sample data to reduce leakage, unless the BASS_DATA_FFT_NOWINDOW flag is used.</para>
            <para>Channels that have 2 or more sample channels (ie. stereo or above) may have FFT performed on each individual channel, using the BASS_DATA_FFT_INDIVIDUAL flag. Without this flag, all the channels are combined, and a single mono FFT is performed. Performing the extra individual FFTs of course increases the amount of processing required. The return values are interleaved in the same order as the channel's sample data, eg. stereo = left,right,left,etc...</para>
            <para>This function is most useful if you wish to visualize (eg. spectrum analyze) the sound.</para>
            <para>FFT processing hint 1: DC stands for direct current (same as what a flashlight cell gives out) and is represents a 0 Hz sound, which cannot exist in real life. A sound sample should not have any DC component but probably will due to inaccuracies in the recording equipment. You won't hear it (except a click when playing and stopping the sample).
            The DC component is basically the average of all the samples that the FFT was applied to, and is pretty useless.
            You'll have to halve the DC component that BASS returns to get the actual DC component, as BASS doubles all the bin values.
            </para>
            <para>FFT processing hint 2: How to read out the amplitude of a single frequency/a frequency band?
            FFT[0] maps to amplitude at 0 Hz, FFT[length-1] maps to amplitude at Nyquist's frequency. So the index to FFT data at an arbitrary band is:
            <code lang="none">
            idx = length*freq/Nyquist
            where:
            length : length of the returned FFT buffer (in samples)
            freq : required frequency (Hz)
            Nyquist : Nyquist's frequency of the signal (half the sampling rate) (in Hz)
            </code>
            Example: If the stream is 44100Hz, then 16500Hz will be around bin 191 of a 512 sample FFT (512*16500/44100).
            Or, if you are using BASS_DATA_FFT4096 on a stream with a sample rate of 44100 a tone at 540Hz will be at: 540*4096/44100 = 50.15, so a bit of the energy will be in fft[51], but mostly in fft[50].
            Note: With a sample rate of 44100 the Nyquist frequency is 22050Hz, which is the max. frequency. This is also why BASS_DATA_FFT4096 only returns 2048 values - fft[2048] would represent 22050Hz.
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The channel has reached the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_DATA_AVAILABLE flag was used with a decoding channel.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example assumes that you have created the stream with the BASS_SAMPLE_FLOAT flag.
            So the buffer will contain 32-bit values between -1 and 1...as an array of float:
            <code>
            // a 30ms window in bytes to be filled with sample data
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03);
            
            // first we need a mananged object where the sample data should be placed
            // length is in bytes, so the number of floats to process is length/4 
            float[] data = new float[length/4];
            
            // get the sample data
            length = Bass.BASS_ChannelGetData(channel, data, length);
            </code>
            <code lang="vbnet">
            ' a 30ms window in bytes to be filled with sample data
            Dim length As Integer = CInt(Bass.BASS_ChannelSeconds2Bytes(channel, 0.03))
            
            ' first we need a mananged object where the sample data should be placed
            ' length is in bytes, so the number of floats to process is length/4 
            Dim data(length/4) As Single
            
            ' get the sample data
            length = Bass.BASS_ChannelGetData(channel, data, length)
            </code>
            The next example will gather the immediate FFT data from a channel:
            <code>
            float[] fft = new float[2048];
            Bass.BASS_ChannelGetData(channel, fft, (int)BASSData.BASS_DATA_FFT4096)
            // assuming the channel's samplerate is 44.1kHz,
            // this will return the frequency represented by bucket 51
            int hz = Utils.FFTIndex2Frequency(51, 4096, 44100);
            </code>
            <code lang="vbnet">
            Dim fft(2048) As Single
            Bass.BASS_ChannelGetData(channel, fft, CInt(BASSData.BASS_DATA_FFT4096))
            ' assuming the channel's samplerate is 44.1kHz,
            ' this will return the frequency represented by bucket 51
            Dim hz As Integer = Utils.FFTIndex2Frequency(51, 4096, 44100)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Retrieves the immediate sample data of a stream or MOD music channel. Can also be used with a recording channel.
            This overload uses a managed short[] to reference the buffer data as 16-bit values - each element will represent one channel in this case!
            SHOULD ONLY BE USED, if the stream was created WITHOUT BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS!
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="buffer">The array (short[]) to receive the data, e.g. when creating the channel stream with default setting, meaning 16-bit samples!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be NULL when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function can only return as much data as has been written to the channel's buffer, so it may not always be possible to get the amount of data requested, especially if you request large amounts. If you really do need large amounts, then increase the buffer lengths (BASS_CONFIG_BUFFER).
            The BASS_DATA_AVAILABLE flag can be used to check how much data a channel's buffer contains at any time, including when stopped or stalled.</para>
            <para>When requesting data from a "decoding channel" (BASS_STREAM_DECODE or BASS_MUSIC_DECODE was used at creation), there are no intermediate buffers involved, so as much data as is available can be decoded in one go.</para>
            <para>When retrieving sample data, the returned data is in the standard Windows PCM format: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1 (not clipped, so can actually be outside this range). That's unless the BASS_DATA_FLOAT flag is used, in which case, the sample data will be converted to 32-bit floating-point (if it isn't already).</para>
            <para>This function is most useful if you wish to visualize (eg. spectrum analyze) the sound.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The channel has reached the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_DATA_AVAILABLE flag was used with a decoding channel.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example assumes that you have created the stream with the BASS_DEFAULT flag.
            So the buffer will contain 16-bit values...as an array of short values.
            <code>
            // a 30ms window in bytes to be filled with sample data
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03);
            
            // first we need a mananged object where the sample data should be placed
            // length is in bytes, so the number of shorts to process is length/2
            short[] data = new short[length/2];
            
            // get the sample data
            length = Bass.BASS_ChannelGetData(channel, data, length);
            </code>
            <code lang="vbnet">
            ' a 30ms window in bytes to be filled with sample data
            Dim length As Integer = CInt(Bass.BASS_ChannelSeconds2Bytes(channel, 0.03))
            
            ' first we need a mananged object where the sample data should be placed
            ' length is in bytes, so the number of floats to process is length/2
            Dim data(length/2) As Short
            
            ' get the sample data
            length = Bass.BASS_ChannelGetData(channel, data, length)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Retrieves the immediate sample data of a stream or MOD music channel. Can also be used with a recording channel.
            This overload uses a managed int[] to reference the buffer data (Note: an int is 32-bit meaning if we expect to receive 16-bit data stereo a single int value will contain 2 x 16-bit, so a full stereo pair of data)!
            SHOULD ONLY BE USED, if the stream was created WITHOUT BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS!
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="buffer">The array (int[]) to receive the data, e.g. when creating the channel stream with default setting, meaning 16-bit samples, an int value contains 2 channels (left and right)!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be NULL when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function can only return as much data as has been written to the channel's buffer, so it may not always be possible to get the amount of data requested, especially if you request large amounts. If you really do need large amounts, then increase the buffer lengths (BASS_CONFIG_BUFFER).
            The BASS_DATA_AVAILABLE flag can be used to check how much data a channel's buffer contains at any time, including when stopped or stalled.</para>
            <para>When requesting data from a "decoding channel" (BASS_STREAM_DECODE or BASS_MUSIC_DECODE was used at creation), there are no intermediate buffers involved, so as much data as is available can be decoded in one go.</para>
            <para>When retrieving sample data, the returned data is in the standard Windows PCM format: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1 (not clipped, so can actually be outside this range). That's unless the BASS_DATA_FLOAT flag is used, in which case, the sample data will be converted to 32-bit floating-point (if it isn't already).</para>
            <para>This function is most useful if you wish to visualize (eg. spectrum analyze) the sound.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The channel has reached the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_DATA_AVAILABLE flag was used with a decoding channel.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example assumes that you have created the stream with the BASS_DEFAULT flag.
            So the buffer will contain 16-bit values...as an array of int - meaning one int (32bit) value will represent a stereo pair (left and right channel).
            <code>
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03); // 30ms window
            int[] data = new int[length/4]; // 2 x 16-bit and length in is bytes
            length = Bass.BASS_ChannelGetData(channel, data, length);
            // further processing of length/4 array elements...where each int value represents a stereo pair
            // the HighWord contains the left channel
            // the LowWord contains the right channel
            </code>
            <code lang="vbnet">
            Dim length As Integer = CInt(Bass.BASS_ChannelSeconds2Bytes(channel, 0.03))
            Dim data(length/4) As Integer  ' 2 x 16-bit and length in is bytes
            length = Bass.BASS_ChannelGetData(channel, data, length)
            ' further processing of length/4 array elements...where each int value represents a stereo pair
            ' the HighWord contains the left channel
            ' the LowWord contains the right channel
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Retrieves the immediate sample data of a stream or MOD music channel. Can also be used with a recording channel.
            This overload uses a managed byte[] to reference the buffer data!
            SHOULD ONLY BE USED, if the stream was created with BASS_SAMPLE_8BITS!
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="buffer">The array (byte[]) to receive the data, e.g. when creating the channel with BASS_SAMPLE_8BITS!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be NULL when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function can only return as much data as has been written to the channel's buffer, so it may not always be possible to get the amount of data requested, especially if you request large amounts. If you really do need large amounts, then increase the buffer lengths (BASS_CONFIG_BUFFER).
            The BASS_DATA_AVAILABLE flag can be used to check how much data a channel's buffer contains at any time, including when stopped or stalled.</para>
            <para>When requesting data from a "decoding channel" (BASS_STREAM_DECODE or BASS_MUSIC_DECODE was used at creation), there are no intermediate buffers involved, so as much data as is available can be decoded in one go.</para>
            <para>When retrieving sample data, the returned data is in the standard Windows PCM format: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1 (not clipped, so can actually be outside this range). That's unless the BASS_DATA_FLOAT flag is used, in which case, the sample data will be converted to 32-bit floating-point (if it isn't already).</para>
            <para>This function is most useful if you wish to visualize (eg. spectrum analyze) the sound.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The channel has reached the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_DATA_AVAILABLE flag was used with a decoding channel.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example assumes that you have created the stream with the BASS_SAMPLE_8BITS flag.
            So the buffer will contain 8-bit values...as an array of byte.
            <code>
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03); // 30ms window
            byte[] data = new byte[length]; // 8-bit are bytes
            length = Bass.BASS_ChannelGetData(channel, data, length);
            </code>
            <code lang="vbnet">
            Dim length As Integer = CInt(Bass.BASS_ChannelSeconds2Bytes(channel, 0.03))
            Dim data(length) As Byte
            length = Bass.BASS_ChannelGetData(channel, data, length)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSeconds2Bytes(System.Int32,System.Double)">
            <summary>
            Translates a time (seconds) position into bytes, based on a channel's format.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD. HSAMPLE handles may also be used.</param>
            <param name="pos">The position to translate (in seconds, e.g. 0.03 = 30ms).</param>
            <returns>If successful, then the translated length in BYTES is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The translation is based on the channel's initial sample rate, when it was created.</para>
            <para>The return value is rounded down to the position of the nearest sample.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>Get the length of a 30ms window:
            <code>
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03);
            </code>
            <code lang="vbnet">
            Dim length As Integer = CInt(Bass.BASS_ChannelSeconds2Bytes(channel, 0.03))
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelBytes2Seconds(System.Int32,System.Int64)">
            <summary>
            Translates a byte position into time (seconds), based on a channel's format.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD. HSAMPLE handles may also be used.</param>
            <param name="pos">The position in BYTES to translate.</param>
            <returns>If successful, then the translated length in BYTES is returned, else a negative value is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            The translation is based on the channel's initial sample rate, when it was created.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the elapsed and remaining time:
            <code>
            // length in bytes
            long len = Bass.BASS_ChannelGetLength(channel);
            // position in bytes
            long pos = Bass.BASS_ChannelGetPosition(channel);
            // the total time length
            double totaltime = Bass.BASS_ChannelBytes2Seconds(channel, len);
            // the elapsed time length
            double elapsedtime = Bass.BASS_ChannelBytes2Seconds(channel, pos);
            double remainingtime = totaltime - elapsedtime;
            </code>
            <code lang="vbnet">
            ' length in bytes
            Dim len As Long = Bass.BASS_ChannelGetLength(channel)
            ' position in bytes
            Dim pos As Long = Bass.BASS_ChannelGetPosition(channel)
            ' the total time length
            Dim totaltime As Double = Bass.BASS_ChannelBytes2Seconds(channel, len)
            ' the elapsed time length
            Dim elapsedtime As Double = Bass.BASS_ChannelBytes2Seconds(channel, pos)
            Dim remainingtime As Double = totaltime - elapsedtime
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)">
            <summary>
            Checks if a sample, stream, or MOD music is active (playing) or stalled. Can also check if a recording is in progress.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL / HMUSIC / HSTREAM / HRECORD handle.</param>
            <returns>The return value is one of the folowing (see <see cref="T:Un4seen.Bass.BASSActive"/>):
            <list type="table">
            <item><term>BASS_ACTIVE_STOPPED</term><description>The channel is not active, or handle is not a valid channel.</description></item>
            <item><term>BASS_ACTIVE_PLAYING</term><description>The channel is playing (or recording).</description></item>
            <item><term>BASS_ACTIVE_PAUSED</term><description>The channel is paused.</description></item>
            <item><term>BASS_ACTIVE_STALLED</term><description>Playback of the stream has been stalled due to there not being enough sample data to continue playing. The playback will automatically resume once there's sufficient data to do so.</description></item>
            </list>
            </returns>
            <remarks>
            <para>When using this function with a decoding channel, BASS_ACTIVE_PLAYING will be returned while there is still data to decode.</para>
            <para>Once the end has been reached, BASS_ACTIVE_STOPPED will be returned.</para>
            <para>BASS_ACTIVE_STALLED is never returned for decoding channels - you can tell a decoding channel is stalled if <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> returns less data than requested, and this function still returns BASS_ACTIVE_PLAYING.</para>
            </remarks>
            <example>
            <code>
            BASSActive status = BASS_ChannelIsActive(stream);
            if (status == BASSActive.BASS_ACTIVE_PLAYING)
            {
              // the stream is still playing
              ...
            }
            </code>
            <code lang="vbnet">
            Dim status As BASSActive = BASS_ChannelIsActive(stream)
            If status = BASSActive.BASS_ACTIVE_PLAYING Then
              ' the stream is still playing
              ...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelLock(System.Int32,System.Boolean)">
            <summary>
            Locks a stream, MOD music or recording channel to the current thread.
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM or HRECORD handle.</param>
            <param name="state">If FALSE, unlock the channel, else lock it.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Locking a channel prevents other threads from performing most functions on it, including buffer updates. 
            Other threads wanting to access a locked channel will block until it is unlocked, so a channel should only be locked very briefly. 
            A channel must be unlocked in the same thread that it was locked.
            </remarks>
            <example>
            Lock a channel to ensure that 2 DSP functions start together:
            <code>
            Bass.BASS_ChannelLock(channel, true); // lock channel
            Bass.BASS_ChannelSetDSP(channel, DspProc1, null, 0); // set 1st DSP
            Bass.BASS_ChannelSetDSP(channel, DspProc2, null, 0); // set 2nd DSP
            Bass.BASS_ChannelLock(channel, false); // unlock channel
            </code>
            <code lang="vbnet">
            Bass.BASS_ChannelLock(channel, True); // lock channel
            Bass.BASS_ChannelSetDSP(channel, DspProc1, Nothing, 0); // set 1st DSP
            Bass.BASS_ChannelSetDSP(channel, DspProc2, Nothing, 0); // set 2nd DSP
            Bass.BASS_ChannelLock(channel, False); // unlock channel
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)">
            <summary>
            Retrieves the playback length of a channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM. HSAMPLE handles may also be used.</param>
            <param name="mode">How to retrieve the length (one of the <see cref="T:Un4seen.Bass.BASSMode"/> flags):
            <list type="table">
            <item><term>BASS_POS_BYTES</term><description>Get the length in bytes.</description></item>
            <item><term>BASS_POS_MUSIC_ORDERS</term><description>Get the length in orders. (HMUSIC only).</description></item>
            </list>
            <i>Other modes may be supported by add-ons, see the documentation.</i>
            </param>
            <returns>If succesful, then the channel's length is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The exact length of a stream will be returned once the whole file has been streamed, until then it's not always possible to 100% accurately estimate the length of a stream.</para>
            <para>The length is always exact for MP3/MP2/MP1 files when the BASS_STREAM_PRESCAN flag is used in the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> call.
            Note: BASS_STREAM_PRESCAN is ONLY needed for files with a VBR, files with a CBR are always accurate.
            </para>
            <para>When the BASS_STREAM_PRESCAN flag is not used, the length is an (usually accurate) estimation based on the file size, until the whole file has been streamed (Note: This is ONLY needed for files with a VBR, files with a CBR are always accurate).</para>
            <para>The length returned for OGG files will usually be exact (assuming the file is not corrupt), but for OGG files streamed from the internet (or "buffered" user file stream) it can be a very rough estimation until the whole file has been downloaded.</para>
            <para>Retrieving the length of a MOD music requires that the BASS_MUSIC_PRESCAN flag was used in the <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> call.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The length is not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the duration (in seconds) of a channel:
            <code>
            // length in bytes
            long len = Bass.BASS_ChannelGetLength(channel, BASSMode.BASS_POS_BYTES);
            // the time length
            double time = Bass.BASS_ChannelBytes2Seconds(channel, len);
            </code>
            <code lang="vbnet">
            ' length in bytes
            Dim len As Long = Bass.BASS_ChannelGetLength(channel, BASSMode.BASS_POS_BYTES)
            ' the time length
            Dim time As Double = Bass.BASS_ChannelBytes2Seconds(channel, len)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32)">
            <summary>
            Retrieves the playback length in bytes of a channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM. HSAMPLE handles may also be used.</param>
            <returns>If succesful, then the channel's length is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The exact length of a stream will be returned once the whole file has been streamed, until then it's not always possible to 100% accurately estimate the length of a stream.</para>
            <para>The length is always exact for MP3/MP2/MP1 files when the BASS_STREAM_PRESCAN flag is used in the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> call.
            Note: BASS_STREAM_PRESCAN is ONLY needed for files with a VBR, files with a CBR are always accurate.
            </para>
            <para>When the BASS_STREAM_PRESCAN flag is not used, the length is an (usually accurate) estimation based on the file size, until the whole file has been streamed (Note: This is ONLY needed for files with a VBR, files with a CBR are always accurate).</para>
            <para>The length returned for OGG files will usually be exact (assuming the file is not corrupt), but for OGG files streamed from the internet (or "buffered" user file stream) it can be a very rough estimation until the whole file has been downloaded.</para>
            <para>Retrieving the length of a MOD music requires that the BASS_MUSIC_PRESCAN flag was used in the <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> call.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The length is not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the duration (in seconds) of a channel:
            <code>
            // length in bytes
            long len = Bass.BASS_ChannelGetLength(channel);
            // the time length
            double time = Bass.BASS_ChannelBytes2Seconds(channel, len);
            </code>
            <code lang="vbnet">
            ' length in bytes
            Dim len As Long = Bass.BASS_ChannelGetLength(channel)
            ' the time length
            Dim time As Double = Bass.BASS_ChannelBytes2Seconds(channel, len)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">
            <summary>
            Sets up a synchronizer on a MOD music, stream or recording channel.
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="type">The type of sync (see the table below or <see cref="T:Un4seen.Bass.BASSSync"/>), you may also use these flags:
            <list type="table">
            <item><term>BASS_SYNC_ONETIME</term><description>Call the sync only once.</description></item>
            <item><term>BASS_SYNC_MIXTIME</term><description>Call the sync function when the sync occurs during decoding/mixing, instead of delaying the call until the sync is actually heard. This is automatically applied with decoding channels, as they can not be played/heard.</description></item>
            </list>
            </param>
            <param name="param">The sync parameters, depends on the sync type... see the table below.</param>
            <param name="proc">The callback function which should be invoked with the sync.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If succesful, then the new synchronizer's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Sync types, with param and <see cref="T:Un4seen.Bass.SYNCPROC"/> data definitions:
            <list type="table">
            <item><term>BASS_SYNC_DOWNLOAD</term><description>Sync when downloading of an internet (or "buffered" user file) stream is done.
            <para>param : not used.</para>
            <para>data : not used.</para>
            </description></item>
            <item><term>BASS_SYNC_END</term><description>Sync when a channel reaches the end. Note that some MOD musics never reach the end, they may jump to another position first. If the BASS_MUSIC_STOPBACK flag is used with a MOD music (through <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>), then this sync will also be called when a backward jump effect is played.
            <para>param : not used.</para>
            <para>data : 1 = the sync is triggered by a backward jump in a MOD music, otherwise not used</para>
            </description></item>
            <item><term>BASS_SYNC_FREE</term><description>Sync when a channel is freed. This can be useful when you need to release some resources associated with the channel. Note that you will not be able to use any BASS functions with the channel in the callback (the channel will no longer exist).
            <para>param : not used.</para>
            <para>data : not used.</para>
            </description></item>
            <item><term>BASS_SYNC_META</term><description>Sync when metadata is received in a Shoutcast stream. This sync is also triggered when a new logical-bitstream begins in a chained OGG stream (multiple streams are strung one-after-another), in which case the metadata is the updated OGG tags. (see example below)
            <para>param : not used.</para>
            <para>data : not used - the updated metadata is available from <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_META)</para>
            </description></item>
            <item><term>BASS_SYNC_MUSICFX</term><description>Sync when the sync effect is used in a MOD music. The sync effect is E8x or Wxx for the XM/MTM/MOD formats, and S2x for the IT/S3M formats (where x = any value).
            <para>param : 0 = the position is passed to the callback (data : LOWORD = order, HIWORD = row),</para>
            <para>param : 1 = the value of x is passed to the callback (data : x value).</para>
            </description></item>
            <item><term>BASS_SYNC_MUSICINST</term><description>Sync when an instrument (sample for the MOD/S3M/MTM formats) is played in a MOD music (not including retrigs).
            <para>param : LOWORD = instrument (1=first), HIWORD = note (0=c0...119=b9, -1=all).</para>
            <para>data : LOWORD = note, HIWORD = volume (0-64).</para>
            </description></item>
            <item><term>BASS_SYNC_MUSICPOS</term><description>Sync when a MOD music reaches an order:row position.
            <para>param : LOWORD = order (0=first, -1=all), HIWORD = row (0=first, -1=all).</para>
            <para>data : LOWORD = order, HIWORD = row.</para>
            </description></item>
            <item><term>BASS_SYNC_OGG_CHANGE</term><description>Sync when a new logical bitstream begins in a chained OGG stream. Updated tags are available from <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            <para>param : not used.</para>
            <para>data : not used.</para>
            </description></item>
            <item><term>BASS_SYNC_POS</term><description>Sync when a channel reaches a position.
            <para>param : position in bytes (automatically rounded down to nearest sample).</para>
            <para>data : not used.</para>
            </description></item>
            <item><term>BASS_SYNC_SETPOS</term><description>Sync when a channel's position is set, including when looping/restarting.
            <para>param : not used.</para>
            <para>data : 0 = playback buffer is not flushed, 1 = playback buffer is flushed.</para>
            </description></item>
            <item><term>BASS_SYNC_SLIDE</term><description>Sync when an attribute slide has completed.
            <para>param : not used.</para>
            <para>data : the type of slide completed (one of the BASS_SLIDE_xxx values).</para>
            </description></item>
            <item><term>BASS_SYNC_STALL</term><description>Sync when playback of the channel is stalled/resumed.
            <para>param : not used.</para>
            <para>data : 0 = stalled, 1 = resumed.</para>
            </description></item>
            </list>
            <i>Other sync types may be supported by add-ons, see the documentation.</i>
            <para> </para>
            <para>Multiple synchronizers may be used per channel. The channel does not have to be playing to set a synchronizer, they can be set before and while playing. Equally, synchronizers can be removed at any time too. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveSync(System.Int32,System.Int32)"/> to remove a sync. If the BASS_SYNC_ONETIME flag is used, then the sync is automatically removed after it's occured (ie. there's no need to remove it manually).</para>
            <para>The BASS_SYNC_MIXTIME flag can be used with BASS_SYNC_END or BASS_SYNC_POS/MUSICPOS syncs to implement custom looping, by using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> in the callback.
            A MIXTIME sync can also be used to add or remove DSP/FX at specific points, or change a HMUSIC channel's flags or attributes (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>).
            The BASS_SYNC_MIXTIME flag can also be useful with a BASS_SYNC_SETPOS sync, to reset DSP states after seeking.</para>
            <para>With recording channels, BASS_SYNC_POS syncs are triggered just before the <see cref="T:Un4seen.Bass.RECORDPROC"/> receives the block of data containing the sync position.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description>An illegal <paramref name="type"/> was specified.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal <paramref name="param"/> was specified.</description></item>
            </list>
            </para>
            </remarks>
            <example>Set a sync to get notified when the channel reaches the end:
            <code>
            private SYNCPROC _mySync;
            ...
            _mySync = new SYNCPROC(EndSync);
            Bass.BASS_ChannelSetSync(_stream, BASSSync.BASS_SYNC_END | BASSSync.BASS_SYNC_MIXTIME, 
                                     0, _mySync, IntPtr.Zero);
            ...
            private void EndSync(int handle, int channel, int data, IntPtr user)
            {
              // the 'channel' has ended - jump to the beginning
              BASS_ChannelSetPosition(channel, 0L);
            }
            </code>
            <code lang="vbnet">
            Private _mySync As SYNCPROC
            ...
            _mySync = New SYNCPROC(AddressOf EndSync)
            Bass.BASS_ChannelSetSync(_stream, BASSSync.BASS_SYNC_END Or BASSSync.BASS_SYNC_MIXTIME, 
                                     0, _mySync, IntPtr.Zero)
            ...
            Private Sub EndSync(ByVal handle As Integer, ByVal channel As Integer, 
                                ByVal data As Integer, ByVal user As IntPtr)
              ' the 'channel' has ended - jump to the beginning
              BASS_ChannelSetPosition(channel, 0L)
            End Sub
            </code>
            Process metadata received from an internet stream:
            <code>
            private SYNCPROC _mySync;
            ...
            int stream = Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_DEFAULT, null, 0);
            // set a sync to get notified on stream title updates
            _mySync = new SYNCPROC(MetaSync);
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            private void MetaSync(int handle, int channel, int data, IntPtr user)
            {
              // BASS_SYNC_META is triggered
              string[] tags = Bass.BASS_ChannelGetTagsMETA(channel);
              foreach (string tag in tags)
                Console.WriteLine(tag);
            }
            </code>
            <code lang="vbnet">
            Private _mySync As SYNCPROC
            ...
            Dim stream As Integer =  Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_DEFAULT, Nothing, 0) 
            ' set a sync to get notified on stream title updates
            _mySync = New SYNCPROC(AddressOf MetaSync)
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Private Sub MetaSync(ByVal handle As Integer, ByVal channel As Integer, 
                                 ByVal data As Integer, ByVal user As IntPtr)
              ' BASS_SYNC_META is triggered
              Dim tags() As String = Bass.BASS_ChannelGetTagsMETA(channel) 
              Dim tag As String
              For Each tag In tags
                Console.WriteLine(tag)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)">
            <summary>
            Sets an effect on a stream, MOD music, or recording channel.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="type">One of the following types of effect (see <see cref="T:Un4seen.Bass.BASSFXType"/>):
            <list type="table">
            <item><term>BASS_FX_DX8_CHORUS</term><description>DX8 Chorus. Use <see cref="T:Un4seen.Bass.BASS_DX8_CHORUS"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_COMPRESSOR</term><description>DX8 Compression. Use <see cref="T:Un4seen.Bass.BASS_DX8_COMPRESSOR"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_DISTORTION</term><description>DX8 Distortion. Use <see cref="T:Un4seen.Bass.BASS_DX8_DISTORTION"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_ECHO</term><description>DX8 Echo. Use <see cref="T:Un4seen.Bass.BASS_DX8_ECHO"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_FLANGER</term><description>DX8 Flanger. Use <see cref="T:Un4seen.Bass.BASS_DX8_FLANGER"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_GARGLE</term><description>DX8 Gargle. Use <see cref="T:Un4seen.Bass.BASS_DX8_GARGLE"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_I3DL2REVERB</term><description>DX8 I3DL2 (Interactive 3D Audio Level 2) reverb. Use <see cref="T:Un4seen.Bass.BASS_DX8_I3DL2REVERB"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_PARAMEQ</term><description>DX8 Parametric equalizer. Use <see cref="T:Un4seen.Bass.BASS_DX8_PARAMEQ"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_REVERB</term><description>DX8 Reverb. Use <see cref="T:Un4seen.Bass.BASS_DX8_REVERB"/> structure to set/get parameters.</description></item>
            </list>
            <i>Other effects may be supported by add-ons, e.g. <see cref="N:Un4seen.Bass.AddOn.Fx">BASS_FX</see>:</i>
            <list type="table">
            <item><term>BASS_FX_BFX_MIX</term><description>BASS_FX Channel Swap/Remap/Downmix. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_ROTATE</term><description>BASS_FX Channel Rotate. No parameters.</description></item>
            <item><term>BASS_FX_BFX_ECHO</term><description>BASS_FX Echo. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_FLANGER</term><description>BASS_FX Flanger. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_VOLUME</term><description>BASS_FX Volume. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_PEAKEQ</term><description>BASS_FX Peaking Equalizer. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_REVERB</term><description>BASS_FX Reverb. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_LPF</term><description>BASS_FX Low Pass Filter. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_DAMP</term><description>BASS_FX Dynamic Amplification. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_AUTOWAH</term><description>BASS_FX Auto Wah. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_ECHO2</term><description>BASS_FX Echo 2. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_PHASER</term><description>BASS_FX Phaser. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_ECHO3</term><description>BASS_FX Echo 3. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_CHORUS</term><description>BASS_FX Chorus. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_APF</term><description>BASS_FX All Pass Filter. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_COMPRESSOR</term><description>BASS_FX Compressor. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_DISTORTION</term><description>BASS_FX Distortion. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION"/> structure to set/get parameters.</description></item>
            </list>
            </param>
            <param name="priority">The priority of the new FX, which determines it's position in the DSP chain - DSP/FX with higher priority are applied before those with lower. This parameter is ignored when the "with FX flag" effect implementation is used.</param>
            <returns>If succesful, then the new effect's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Multiple effects may be used per channel. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveFX(System.Int32,System.Int32)"/> to remove an effect. Use <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to set an effect's parameters.</para>
            <para>Effects can be applied to MOD musics and streams, but not samples. If you want to apply an effect to a sample, then you should stream the sample.</para>
            <para>Depending on the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a> being used by the channel, the channel may have to be stopped before adding or removing DX8 effects on it. 
            If necessary, that is done automatically and the channel is resumed afterwards. DX8 effects are only supported on floating-point channels with DirectX 9 or above installed.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description>An illegal <paramref name="type"/> was specified.</description></item>
            <item><term>BASS_ERROR_NOFX</term><description>DX8 effects are unavailable.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The channel's format is not supported by the effect. It may be floating-point (without DX9) or more than stereo.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_DX8_ECHO echo = new BASS_DX8_ECHO(90f, 50f, 500f, 500f, true);
            int channel = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            int fxEchoHandle = Bass.BASS_ChannelSetFX(channel, BASSFXType.BASS_FX_ECHO, 1);
            ...
            // changing the echo effect, dry/wet mix...
            echo.fWetDryMix = 50f;
            Bass.BASS_FXSetParameters(fxEchoHandle, echo);
            </code>
            <code lang="vbnet">
            Dim echo As New BASS_DX8_ECHO(90F, 50F, 500F, 500F, True)
            Dim channel As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim fxEchoHandle As Integer = Bass.BASS_ChannelSetFX(channel, BASSFXType.BASS_FX_ECHO, 1)
            ...
            ' changing the echo effect, dry/wet mix...
            echo.fWetDryMix = 50F
            Bass.BASS_FXSetParameters(fxEchoHandle, echo)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetDevice(System.Int32)">
            <summary>
            Retrieves the device that the channel is using.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD. HSAMPLE handles may also be used.</param>
            <returns>If successful, the device number is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Recording devices are indicated by the HIWORD of the return value being 1, when this function is called with a HRECORD channel.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>Check, if a device number is a recording device:
            <code>
            bool isRecordingDevice = false;
            int device = Bass.BASS_ChannelGetDevice(stream);
            if (device != -1 &amp;&amp; Utils.HighWord(device) == 1)
              isRecordingDevice = true;
            </code>
            <code lang="vbnet">
            Dim isRecordingDevice As Boolean = False
            Dim device As Integer = Bass.BASS_ChannelGetDevice(stream)
            If device &lt;&gt; - 1 AndAlso Utils.HighWord(device) = 1 Then
              isRecordingDevice = True
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetDevice(System.Int32,System.Int32)">
            <summary>
            Assigns a (new) output device to a channel.
            </summary>
            <param name="handle">The channel handle... only HMUSIC and HSTREAM are supported.</param>
            <param name="device">The new device number the channel should be using (the device needs to be iniialized by the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> method before it can be used).</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>All of the channel's current settings are carried over to the new device, but if the channel is using the "with FX flag" <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a>, 
            the internal state (eg. buffers) of the DX8 effects will be reset. Using the "without FX flag" <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a>, the state of the DX8 effects is preserved.
            <para>When changing a sample's device, all the sample's existing channels (HCHANNELs) are freed. It's not possible to change the device of an individual sample channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="device"/> is invalid.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The requested device has not been initialized.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The channel is already using the requested device.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels are allowed to use the "no sound" device.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the channel is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // init device 1 and 2
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle, null);
            // now device 1 is the current one
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle, null);
            // now device 2 is the current one
            ...
            // create the stream on device 1
            Bass.BASS_SetDevice(1);
            // now device 1 is the current one
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            // move the channel to device 2
            Bass.BASS_ChannelSetDevice(stream, 2);
            </code>
            <code lang="vbnet">
            ' init device 1 and 2
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle, Nothing)
            ' now device 1 is the current one
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle, Nothing)
            ' now device 2 is the current one
            ' create the stream on device 1
            Bass.BASS_SetDevice(1)
            ' now device 1 is the current one
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            ' move the channel to device 2
            Bass.BASS_ChannelSetDevice(stream, 2)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)">
            <summary>
            Stops a sample, stream, MOD music, or recording.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL / HMUSIC / HSTREAM / HRECORD handle.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Stopping a user stream (created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/>) will flush it's buffer contents. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPause(System.Int32)"/> if you wish to stop a user stream and then resume it from the same point.</para>
            <para>When used with a "decoding channel" (BASS_STREAM_DECODE or BASS_MUSIC_DECODE was used at creation), this function will end the channel at its current position, 
            so that it's not possible to decode any more data from it. Any BASS_SYNC_END syncs that have been set on the channel will not be triggered by this, they are only triggered when reaching the natural end. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> can be used to reset the channel and start decoding again.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelPause(System.Int32)">
            <summary>
            Pauses a sample, stream, MOD music, or recording.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL / HMUSIC / HSTREAM / HRECORD handle.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> to resume a paused channel. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> can be used to stop a paused channel.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_NOPLAY</term><description>The channel is not playing (or <paramref name="handle"/> is not a valid channel).</description></item>
            <item><term>BASS_ERROR_DECODE</term><description>The channel is not playable, it's a "decoding channel".</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The channel is already paused.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)">
            <summary>
            Sets the value of an attribute of a sample, stream or MOD music.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM  or HRECORD.</param>
            <param name="attrib">The attribute to set the value of (one of the following, see <see cref="T:Un4seen.Bass.BASSAttribute"/>):
            <list type="table">
            <item><term>BASS_ATTRIB_FREQ</term><description>The sample rate, 100 (min) to 100000 (max), 0 = original rate (when the channel was created).</description></item>
            <item><term>BASS_ATTRIB_PAN</term><description>The panning/balance position, -1 (full left) to +1 (full right), 0 = centre.</description></item>
            <item><term>BASS_ATTRIB_VOL</term><description>The volume level, 0 (silent) to 1 (full).</description></item>
            <item><term>BASS_ATTRIB_EAXMIX</term><description>EAX wet/dry mix, 0 (full dry) to 1 (full wet), -1 = automatically calculate the mix based on the distance (the default).</description></item>
            <item><term>BASS_ATTRIB_MUSIC_AMPLIFY</term><description>The amplification level, 0 (min) to 100 (max) rounded down to a whole number. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_BPM</term><description>The BPM, 1 (min) to 255 (max) rounded down to a whole number. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PANSEP</term><description>The Pan separation level, 0 (min) to 100 (max), 50 = linear rounded down to a whole number. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PSCALER</term><description>The Position scaler, 1 (min) to 256 (max) rounded down to a whole number. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_SPEED</term><description>The Speed, 0 (min) to 255 (max) rounded down to a whole number. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_CHAN</term><description>A channel volume level, 0 (silent) to 1 (full). (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_GLOBAL</term><description>Global volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_INST</term><description>An instrument/sample volume level, 0 (min) to 64 (max, 128 for IT format) rounded down to a whole number. (HMUSIC)</description></item>
            </list>
            <i>Other attributes may be supported by add-ons, e.g. <see cref="N:Un4seen.Bass.AddOn.Fx">BASS_FX</see>:</i>
            <list type="table">
            <item><term>BASS_ATTRIB_TEMPO</term><description>The tempo of a channel, [-95%...0...+5000%] percents.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_PITCH</term><description>The pitch of a channel, [-60...0...+60] semitones.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_FREQ</term><description>The sample rate of a channel in Hz, but calculates by the same % as BASS_ATTRIB_TEMPO.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_USE_AA_FILTER</term><description>Use the AA Filter for a tempo channel (TRUE=1, FALSE=0).</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_AA_FILTER_LENGTH</term><description>Sets the AA Filter length in taps (between 8 and 128).</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_USE_QUICKALGO</term><description>Use the tempo quick algorithm for a tempo channel (TRUE=1, FALSE=0).</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_SEQUENCE_MS</term><description>Sets the tempo sequence in ms. of a tempo channel (default = 82).</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_SEEKWINDOW_MS</term><description>Sets the tempo seek window in ms. of a tempo channel (default = 82).</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_OVERLAP_MS</term><description>Sets the tempo overlap in ms. of a tempo channel (default = 12).</description></item>
            <item><term>BASS_ATTRIB_REVERSE_DIR</term><description>Sets the playback direction of a reverse channel (-1=reverse, 1=forward, or use one of the <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXReverse"/> flags).</description></item>
            </list>
            </param>
            <param name="value">The new attribute value. See the attribute's documentation for details on the possible values.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            The actual attribute value may not be exactly the same as requested, due to precision differences. For example, an attribute might only allow whole number values. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/> can be used to confirm what the value is.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="attrib"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="value"/> is not valid. See the attribute's documentation for the valid range of values.</description></item>
            </list>
            <i>Some attributes may have additional error codes, see the documentation</i>
            </para>
            </remarks>
            <example>Change the volume of a channel to 50%:
            <code>
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            Bass.BASS_ChannelSetAttribute(stream, BASSAttribute.BASS_ATTRIB_VOL, 0.5f);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Bass.BASS_ChannelSetAttribute(stream, BASSAttribute.BASS_ATTRIB_VOL, 0.5F)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)">
            <summary>
            Retrieves the value of an attribute of a sample, stream or MOD music. Can also get the sample rate of a recording channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD.</param>
            <param name="attrib">The attribute to set the value of (one of the following, see <see cref="T:Un4seen.Bass.BASSAttribute"/>):
            <list type="table">
            <item><term>BASS_ATTRIB_EAXMIX</term><description>EAX wet/dry mix.</description></item>
            <item><term>BASS_ATTRIB_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_ATTRIB_MUSIC_AMPLIFY</term><description>Amplification level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_BPM</term><description>BPM. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PANSEP</term><description>Pan separation level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PSCALER</term><description>Position scaler. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_SPEED</term><description>Speed. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_CHAN</term><description>A channel volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_GLOBAL</term><description>Global volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_INST</term><description>An instrument/sample volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_PAN</term><description>Panning/balance position.</description></item>
            <item><term>BASS_ATTRIB_VOL</term><description>Volume level.</description></item>
            </list>
            <i>Other attributes may be supported by add-ons, e.g. <see cref="N:Un4seen.Bass.AddOn.Fx">BASS_FX</see>:</i>
            <list type="table">
            <item><term>BASS_ATTRIB_TEMPO</term><description>The tempo of a channel in percent.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_PITCH</term><description>The pitch of a channel in semitones.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_FREQ</term><description>The sample rate of a channel in Hz.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_USE_AA_FILTER</term><description>AA Filter used on a tempo channel.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_AA_FILTER_LENGTH</term><description>The AA Filter length in taps.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_USE_QUICKALGO</term><description>Tempo quick algorithm used on a tempo channel.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_SEQUENCE_MS</term><description>The tempo sequence in ms. used on a tempo channel.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_SEEKWINDOW_MS</term><description>The tempo seek window in ms. used on a tempo channel.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_OVERLAP_MS</term><description>The tempo overlap in ms. used on a tempo channel.</description></item>
            <item><term>BASS_ATTRIB_REVERSE_DIR</term><description>The current playback direction of a reverse stream.</description></item>
            </list>
            </param>
            <param name="value">Pointer to a variable to receive the attribute value.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="attrib"/> is not valid.</description></item>
            </list>
            <i>Some attributes may have additional error codes, see the documentation</i>
            </para>
            </remarks>
            <example>Get the current volume of a channel:
            <code>
            float vol = 0f;
            if (Bass.BASS_ChannelGetAttribute(stream, BASSAttribute.BASS_ATTRIB_VOL, ref vol))
              Console.WriteLine("Volume={0}", vol);
            </code>
            <code lang="vbnet">
            Dim vol As Single = 0F
            If Bass.BASS_ChannelGetAttribute(stream, BASSAttribute.BASS_ATTRIB_VOL, vol) Then
              Console.WriteLine("Volume={0}", vol)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)">
            <summary>
            Modifies and retrieves a channel's flags.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the channel.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the channel when playback ends. Note that the BASS_MUSIC_AUTOFREE flag is identical to this flag. (HSTREAM/HMUSIC)</description></item>
            <item><term>BASS_STREAM_RESTRATE</term><description>Restrict the download rate. (HSTREAM)</description></item>
            <item><term>BASS_MUSIC_RAMP</term><description>Use "normal" ramping. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_RAMPS</term><description>Use "sensitive" ramping. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_SURROUND</term><description>Use surround sound. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_SURROUND2</term><description>Use surround sound mode 2. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_NONINTER</term><description>Use non-interpolated mixing. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_FT2MOD</term><description>Use FastTracker 2 .MOD playback. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_PT1MOD</term><description>Use ProTracker 1 .MOD playback. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>Stop all notes when seeking. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>Stop all notes and reset BPM/etc when seeking. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_STOPBACK</term><description>Stop when a backward jump effect is played. (HMUSIC)</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment</a> flags. (HSTREAM/HMUSIC)</description></item>
            </list>
            <i>Other attributes may be supported by add-ons, see the documentation</i>
            </param>
            <param name="mask">The flags (as above) to modify. Flags that are not included in this are left as they are, so it can be set to 0 in order to just retrieve the current flags. To modify the speaker flags, any of the BASS_SPEAKER_xxx flags can be used in the mask (no need to include all of them).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Some flags may not be adjustable in some circumstances, so the return value should be checked to confirm any changes. 
            The flags listed above are just the flags that can be modified, and there may be additional flags present in the return value. 
            See the <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> documentation for a full list of flags.</para>
            <para>Streams that are created by add-ons may have additional flags available. There is a limited number of possible flag values though, so some add-ons may use the same flag value for different things. 
            This means that when using add-on specific flags with a stream created via the plugin system, it is a good idea to first confirm that the add-on is handling the stream, by checking its ctype via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.</para>
            <para>During playback, the effects of flag changes are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Toggle looping on a channel:
            <code>
            if (Bass.BASS_ChannelFlags(channel, BASSFlag.BASS_SAMPLE_LOOP, 0) != BASSFlag.BASS_DEFAULT)
            {
              // loop flag was set, so remove it
              Bass.BASS_ChannelFlags(channel, BASSFlag.BASS_DEFAULT, BASSFlag.BASS_SAMPLE_LOOP);
            }
            else
            {
              // loop flag was not set, so set it
              Bass.BASS_ChannelFlags(channel, BASSFlag.BASS_SAMPLE_LOOP, BASSFlag.BASS_SAMPLE_LOOP);
            }
            </code>
            <code lang="vbnet">
            If Bass.BASS_ChannelFlags(channel, BASSFlag.BASS_SAMPLE_LOOP, 0) &lt;&gt; BASSFlag.BASS_DEFAULT Then
              ' loop flag was set, so remove it
              Bass.BASS_ChannelFlags(channel, BASSFlag.BASS_DEFAULT, BASSFlag.BASS_SAMPLE_LOOP)
            Else
              ' loop flag was not set, so set it
              Bass.BASS_ChannelFlags(channel, BASSFlag.BASS_SAMPLE_LOOP, BASSFlag.BASS_SAMPLE_LOOP)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)">
            <summary>
            Updates the playback buffer of a stream or MOD music.
            </summary>
            <param name="handle">The channel handle... a HMUSIC or HSTREAM.</param>
            <param name="length">The amount to render, in milliseconds... 0 = default (2 x <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD"/>). This is capped at the space available in the buffer.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>When starting playback of a stream or MOD music, after creating it or changing its position, there will be a slight delay while the initial data is decoded for playback. 
            Usually the delay is not noticeable or important, but if you need playback to start instantly when you call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>, then use this function first. 
            The length parameter should be at least equal to the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD"/>.</para>
            <para>It may not always be possible to render the requested amount of data, in which case this function will still succeed. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check how much data a channel has buffered for playback.</para>
            <para>When automatic updating is disabled (<see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD"/> = 0), this function could be used instead of <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> to implement different update periods for different channels, 
            instead of a single update period for all. Unlike <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/>, this function can also be used while automatic updating is enabled.</para>
            <para>The CPU usage of this function is not included in the <see cref="M:Un4seen.Bass.Bass.BASS_GetCPU"/> reading.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Decoding channels do not have playback buffers.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The channel has ended.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>Pre-buffer to enable instant playback:
            <code>
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_STREAM_PRESCAN);
            // pre-buffer
            Bass.BASS_ChannelUpdate(stream, 0);
            // start playback
            Bass.BASS_ChannelPlay(stream, false);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_STREAM_PRESCAN)
            ' pre-buffer
            Bass.BASS_ChannelUpdate(stream, 0)
            ' start playback
            Bass.BASS_ChannelPlay(stream, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelIsSliding(System.Int32,Un4seen.Bass.BASSAttribute)">
            <summary>
            Checks if an attribute (or any attribute) of a sample, stream, or MOD music is sliding.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD.</param>
            <param name="attrib">The attribute to check for sliding (one of the following, see <see cref="T:Un4seen.Bass.BASSAttribute"/> or 0 for any attribute):
            <list type="table">
            <item><term>BASS_ATTRIB_EAXMIX</term><description>EAX wet/dry mix.</description></item>
            <item><term>BASS_ATTRIB_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_ATTRIB_PAN</term><description>Panning/balance position.</description></item>
            <item><term>BASS_ATTRIB_VOL</term><description>Volume level.</description></item>
            <item><term>BASS_ATTRIB_MUSIC_AMPLIFY</term><description>Amplification level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_BPM</term><description>BPM. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PANSEP</term><description>Pan separation level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PSCALER</term><description>Position scaler. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_SPEED</term><description>Speed. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_CHAN</term><description>A channel volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_GLOBAL</term><description>Global volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_INST</term><description>An instrument/sample volume level. (HMUSIC)</description></item>
            </list>
            <i>Other attributes may be supported by add-ons, see the documentation</i>
            </param>
            <returns>If the attribute (or any) is sliding, then TRUE is returned, else FALSE is returned.</returns>
            <example>
            Wait until a volume slideing has finished:
            <code>
            while (Bass.BASS_ChannelIsSliding(channel, BASSAttribute.BASS_ATTRIB_VOL))
            {
              Thread.Sleep(20); // wait 20ms
            }
            </code>
            <code lang="vbnet">
            While Bass.BASS_ChannelIsSliding(channel, BASSAttribute.BASS_ATTRIB_VOL)
              Thread.Sleep(20) ' wait 20ms
            End While
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSlideAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single,System.Int32)">
            <summary>
            Slides a channel's attribute from its current value to a new value.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HSTREAM or HMUSIC, or HRECORD.</param>
            <param name="attrib">The attribute to slide the value of (one of the following, see <see cref="T:Un4seen.Bass.BASSAttribute"/>):
            <list type="table">
            <item><term>BASS_ATTRIB_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_ATTRIB_PAN</term><description>Panning/balance position.</description></item>
            <item><term>BASS_ATTRIB_VOL</term><description>Volume level.</description></item>
            <item><term>BASS_ATTRIB_EAXMIX</term><description>EAX wet/dry mix.</description></item>
            <item><term>BASS_ATTRIB_MUSIC_AMPLIFY</term><description>Amplification level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_BPM</term><description>BPM. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PANSEP</term><description>Pan separation level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PSCALER</term><description>Position scaler. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_SPEED</term><description>Speed. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_CHAN</term><description>A channel volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_GLOBAL</term><description>Global volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_INST</term><description>An instrument/sample volume level. (HMUSIC)</description></item>
            </list>
            <i>Other attributes may be supported by add-ons, see the documentation</i>
            </param>
            <param name="value">The new attribute value. See the attribute's documentation for details on the possible values.</param>
            <param name="time">The length of time (in milliseconds) that it should take for the attribute to reach the <paramref name="value"/>.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function is similar to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>, except that the attribute is ramped to the value over the specified period of time. 
            Another difference is that the value is not pre-checked. If it is invalid, the slide will simply end early.</para>
            <para>If an attribute is already sliding, then the old slide is stopped and replaced by the new one.</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsSliding(System.Int32,Un4seen.Bass.BASSAttribute)"/> can be used to check if an attribute is currently sliding. A BASS_SYNC_SLIDE sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered at the end of a slide. 
            The sync will not be triggered in the case of an existing slide being replaced by a new one.</para>
            <para>Note: Attribute slides are executed in real-time, so they should not be used while decoding a channel in non-real-time (e.g. by calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> in a loop).
            Attribute slides are unaffected by whether the channel is playing, paused or stopped. They carry on regardless.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="attrib"/> is not valid.</description></item>
            </list>
            <i>Some attributes may have additional error codes, see the documentation.</i>
            </para>
            </remarks>
            <example>
            Fadeout a channel's volume over a period of 1 second:
            <code>
            Bass.BASS_ChannelSlideAttribute(channel, BASSAttribute.BASS_ATTRIB_VOL, 0f, 1000);
            </code>
            <code lang="vbnet">
            Bass.BASS_ChannelSlideAttribute(channel, BASSAttribute.BASS_ATTRIB_VOL, 0F, 1000)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the 3D attributes of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="mode">The 3D processing mode... one of these flags, -1 = leave current (see <see cref="T:Un4seen.Bass.BASS3DMode"/>):
            <list type="table">
            <item><term>BASS_3DMODE_NORMAL</term><description>Normal 3D processing.</description></item>
            <item><term>BASS_3DMODE_RELATIVE</term><description>The channel's 3D position (position/velocity/orientation) is relative to the listener. When the listener's position/velocity/orientation is changed with <see cref="M:Un4seen.Bass.Bass.BASS_Set3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>, the channel's position relative to the listener does not change.</description></item>
            <item><term>BASS_3DMODE_OFF</term><description>Turn off 3D processing on the channel, the sound will be played in the centre.</description></item>
            </list>
            </param>
            <param name="min">The minimum distance. The channel's volume is at maximum when the listener is within this distance... less than 0.0 = leave current.</param>
            <param name="max">The maximum distance. The channel's volume stops decreasing when the listener is beyond this distance... less than 0.0 = leave current.</param>
            <param name="iangle">The angle of the inside projection cone in degrees... 0 (no cone) - 360 (sphere), -1 = leave current.</param>
            <param name="oangle">The angle of the outside projection cone in degrees... 0 (no cone) - 360 (sphere), -1 = leave current.</param>
            <param name="outvol">The delta-volume outside the outer projection cone... 0 (silent) - 100 (same as inside the cone), -1 = leave current.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The iangle and oangle parameters must both be set in a single call to this function (ie. you can't set one without the other). 
            The iangle and oangle angles decide how wide the sound is projected around the orientation angle. Within the inside angle the volume level is the channel volume, as set with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            Outside the outer angle, the volume changes according to the outvol value. Between the inner and outer angles, the volume gradually changes between the inner and outer volume levels. 
            If the inner and outer angles are 360 degrees, then the sound is transmitted equally in all directions.</para>
            <para>As with all 3D functions, use <see cref="M:Un4seen.Bass.Bass.BASS_Apply3D"/> to apply the changes made.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The channel does not have 3D functionality.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One or more of the attribute values is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode@,System.Single@,System.Single@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the 3D attributes of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="mode">The 3D processing mode (see <see cref="T:Un4seen.Bass.BASS3DMode"/>).</param>
            <param name="min">The minimum distance.</param>
            <param name="max">The maximum distance.</param>
            <param name="iangle">The angle of the inside projection cone.</param>
            <param name="oangle">The angle of the outside projection cone.</param>
            <param name="outvol">The delta-volume outside the outer projection cone.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The iangle and oangle parameters must both be retrieved in a single call to this function (ie. you can't retrieve one without the other). See <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)"/> for an explanation of the parameters.
            <para>This overload uses reference types, so you need to specify all parameters here and therefore can only get the parameters all together. See the other overloads which allows you to retrieve only certain values.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The channel does not have 3D functionality.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS3DMode mode = BASS3DMode.BASS_3DMODE_NORMAL;
            float min = 0f;
            float max = 0f;
            int iangle = 0;
            int oangle = 0;
            int outvol = 0;
            bool ok = Bass.BASS_ChannelGet3DAttributes(handle, ref mode, ref min, ref max, ref iangle, ref oangle, ref outvol);
            </code>
            <code lang="vbnet">
            Dim mode As BASS3DMode = BASS3DMode.BASS_3DMODE_NORMAL
            Dim min As Single = 0F
            Dim max As Single = 0F
            Dim iangle As Integer = 0
            Dim oangle As Integer = 0
            Dim outvol As Integer = 0
            Dim ok As Boolean = Bass.BASS_ChannelGet3DAttributes(handle, mode, min, max, iangle, oangle, outvol)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGet3DAttributes(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Retrieves the 3D attributes of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="mode">The 3D processing mode (see <see cref="T:Un4seen.Bass.BASS3DMode"/>)... NULL = don't retrieve it. (int)</param>
            <param name="min">The minimum distance... NULL = don't retrieve it. (float)</param>
            <param name="max">The maximum distance... NULL = don't retrieve it. (float)</param>
            <param name="iangle">The angle of the inside projection cone... NULL = don't retrieve it. (int)</param>
            <param name="oangle">The angle of the outside projection cone... NULL = don't retrieve it. (int)</param>
            <param name="outvol">The delta-volume outside the outer projection cone... NULL = don't retrieve it. (int)</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The iangle and oangle parameters must both be retrieved in a single call to this function (ie. you can't retrieve one without the other). See <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)"/> for an explanation of the parameters.
            <para>This overload uses native object, so you can specify NULL for some or all parameters in order to not retrieve them. However, the return values of these parameters must be casted back to it's original type.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The channel does not have 3D functionality.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Only get the delta-volume outside the outer projection cone:
            <code>
            object outvol = 0;
            bool ok = Bass.BASS_ChannelGet3DAttributes(handle, null, null, null, null, null, outvol);
            // cast the outvol back it it's normal value type (int)
            int deltaVol = (int)outvol;
            </code>
            <code lang="vbnet">
            Dim outvol As BASobject = 0
            Dim ok As Boolean = Bass.BASS_ChannelGet3DAttributes(handle, Nothing, Nothing, Nothing, Nothing, Nothing, outvol)
            ' cast the outvol back it it's normal value type (int)
            Dim deltaVol As Integer = CInt(outvol)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSet3DPosition(System.Int32,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)">
            <summary>
            Sets the 3D position of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="pos">Position of the sound... NULL = leave current.</param>
            <param name="orient">Orientation of the sound... NULL = leave current.</param>
            <param name="vel">Velocity of the sound... NULL = leave current. This is only used to calculate the doppler effect, and has no effect on the sound's position.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>As with all 3D functions, <see cref="M:Un4seen.Bass.Bass.BASS_Apply3D"/> must be called to apply the changes made.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The channel does not have 3D functionality.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGet3DPosition(System.Int32,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)">
            <summary>
            Retrieves the 3D position of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="pos">Position of the sound... NULL = don't retrieve it.</param>
            <param name="orient">Orientation of the sound... NULL = don't retrieve it.</param>
            <param name="vel">Velocity of the sound... NULL = don't retrieve it.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The channel does not have 3D functionality.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_3DVECTOR pos = new BASS_3DVECTOR();
            BASS_3DVECTOR orient = new BASS_3DVECTOR();
            BASS_3DVECTOR vel = new BASS_3DVECTOR();
            if (Bass.BASS_ChannelGet3DPosition(stream, pos, orient, vel))
            {
              Console.WriteLine("{0} : {1} : {2}", pos, orient, vel);
            }
            </code>
            <code lang="vbnet">
            Dim pos As New BASS_3DVECTOR()
            Dim orient As New BASS_3DVECTOR()
            Dim vel As New BASS_3DVECTOR()
            If Bass.BASS_ChannelGet3DPosition(stream, pos, orient, vel) Then
              Console.WriteLine("{0} : {1} : {2}", pos, orient, vel)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)">
            <summary>
            Sets the playback position of a sample, MOD music, or stream.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HSTREAM or HMUSIC.</param>
            <param name="pos">The position, in units determined by the <paramref name="mode"/>.</param>
            <param name="mode">How to set the position. One of the following (see <see cref="T:Un4seen.Bass.BASSMode"/>), with optional flags:
            <list type="table">
            <item><term>BASS_POS_BYTE</term><description>The position is in bytes, which will be rounded down to the nearest sample boundary.</description></item>
            <item><term>BASS_POS_MUSIC_ORDER</term><description>The position is in orders and rows... use <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>. (HMUSIC only).</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>Flag: Stop all notes. This flag is applied automatically if it has been set on the channel, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. (HMUSIC).</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>Flag: Stop all notes and reset bpm/etc. This flag is applied automatically if it has been set on the channel, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. (HMUSIC).</description></item>
            </list>
            <i>Other modes and flags may be supported by add-ons, see the documentation.</i>
            </param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Setting the position of a MOD music in bytes requires that the BASS_MUSIC_PRESCAN flag was used in the <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> call. When setting the position in orders/rows, the channel's byte position (as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>) is reset to 0. 
            This is because it's not possible to get the byte position of an order/row position - it's possible that a position may never be played in the normal cause of events, or it may be played multiple times.</para>
            <para>When changing the position of a MOD music, and the BASS_MUSIC_POSRESET flag is active on the channel, all notes that were playing before the position changed will be stopped. Otherwise, the notes will continue playing until they are stopped in the MOD music. 
            When setting the position in bytes, the BPM, "speed" and "global volume" are updated to what they would normally be at the new position. Otherwise they are left as they were prior to the postion change, unless the seek position is 0 (the start), in which case they are also reset to the starting values (when using the BASS_MUSIC_POSRESET flag). 
            When the BASS_MUSIC_POSRESETEX flag is active, the BPM, speed and global volume are reset with every seek.</para>
            <para>When setting the position of a file stream, the position is automatically rounded down to the nearest sample. For MP3/MP2/MP1 streams, if the BASS_STREAM_PRESCAN flag was used when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> was called to create the stream, then the seeking will be accurate to the exact requested byte. 
            Otherwise it will be an approximation, which is generally still very accurate.
            Note: BASS_STREAM_PRESCAN is ONLY needed for files with a VBR, files with a CBR are always accurate.
            </para>
            <para>Seeking in internet file (and "buffered" user file) streams is possible once the download has reached the requested position, so long as the file is not being streamed in blocks (BASS_STREAM_BLOCK flag).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>The requested position is invalid, eg. beyond the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The download has not yet reached the requested position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set the position of a stream channel to 10sec. and 200ms:
            <code>
            Bass.BASS_ChannelSetPosition(stream, Bass.BASS_ChannelSeconds2Bytes(stream, 10.20), BASSMode.BASS_POS_BYTES);
            </code>
            <code lang="vbnet">
            Bass.BASS_ChannelSetPosition(stream, Bass.BASS_ChannelSeconds2Bytes(stream, 10.20), BASSMode.BASS_POS_BYTES)
            </code>
            Set the position of a MOD music to row 20 of order 10:
            <code>
            Bass.BASS_ChannelSetPosition(music, Utils.MakeMusicPos(10,20), BASSMode.BASS_POS_MUSIC_ORDER );
            </code>
            <code lang="vbnet">
            Bass.BASS_ChannelSetPosition(music, Utils.MakeMusicPos(10,20), BASSMode.BASS_POS_MUSIC_ORDER )
            </code>
            Start playback of a MOD music from the beginning of the last order:
            <code>
            // get number of orders
            int len = (int)Bass.BASS_ChannelGetLength(music, BASSMode.BASS_POS_MUSIC_ORDER);
            // seek to last order
            Bass.BASS_ChannelSetPosition(music, Utils.MakeMusicPos(len-1, 0), BASSMode.BASS_POS_MUSIC_ORDER);
            Bass.BASS_ChannelPlay(music, false); // play
            </code>
            <code lang="vbnet">
            ' get number of orders
            Dim len As Integer = CInt(Bass.BASS_ChannelGetLength(music, BASSMode.BASS_POS_MUSIC_ORDER))
            ' seek to last order
            Bass.BASS_ChannelSetPosition(music, Utils.MakeMusicPos(len-1, 0), BASSMode.BASS_POS_MUSIC_ORDER)
            Bass.BASS_ChannelPlay(music, False) ' play
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64)">
            <summary>
            Sets the playback position in bytes of a sample, MOD music, or stream.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HSTREAM or HMUSIC.</param>
            <param name="pos">The position, in bytes.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Setting the position of a MOD music in bytes requires that the BASS_MUSIC_PRESCAN flag was used in the <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> call. When setting the position in orders/rows, the channel's byte position (as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>) is reset to 0. 
            This is because it's not possible to get the byte position of an order/row position - it's possible that a position may never be played in the normal cause of events, or it may be played multiple times.</para>
            <para>When changing the position of a MOD music, and the BASS_MUSIC_POSRESET flag is active on the channel, all notes that were playing before the position changed will be stopped. Otherwise, the notes will continue playing until they are stopped in the MOD music. 
            When setting the position in bytes, the BPM, "speed" and "global volume" are updated to what they would normally be at the new position. Otherwise they are left as they were prior to the postion change, unless the seek position is 0 (the start), in which case they are also reset to the starting values (when using the BASS_MUSIC_POSRESET flag). 
            When the BASS_MUSIC_POSRESETEX flag is active, the BPM, speed and global volume are reset with every seek.</para>
            <para>When setting the position of a file stream, the position is automatically rounded down to the nearest sample. For MP3/MP2/MP1 streams, if the BASS_STREAM_PRESCAN flag was used when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> was called to create the stream, then the seeking will be accurate to the exact requested byte. 
            Otherwise it will be an approximation, which is generally still very accurate.
            Note: BASS_STREAM_PRESCAN is ONLY needed for files with a VBR, files with a CBR are always accurate.
            </para>
            <para>Seeking in internet file (and "buffered" user file) streams is possible once the download has reached the requested position, so long as the file is not being streamed in blocks (BASS_STREAM_BLOCK flag).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>The requested position is invalid, eg. beyond the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The download has not yet reached the requested position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set the position of a stream channel to 10sec. and 200ms:
            <code>
            Bass.BASS_ChannelSetPosition(stream, Bass.BASS_ChannelSeconds2Bytes(stream, 10.20));
            </code>
            <code lang="vbnet">
            Bass.BASS_ChannelSetPosition(stream, Bass.BASS_ChannelSeconds2Bytes(stream, 10.20))
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Double)">
            <summary>
            Sets the playback position of a sample or stream to the given seconds value.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL or HSTREAM.</param>
            <param name="seconds">The seconds value to set the position to (milliseconds are represented in the fraction part).</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This is just an overload which uses <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSeconds2Bytes(System.Int32,System.Double)"/> internally.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>The requested position is invalid, eg. beyond the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The download has not yet reached the requested position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the playback position in order.row of a MOD music.
            </summary>
            <param name="handle">The channel handle... HMUSIC.</param>
            <param name="order">The order position.</param>
            <param name="row">The row position.</param>
            <returns>If succesful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This is just an overload which uses <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> and <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/> internally.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>The requested position is invalid, eg. beyond the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The download has not yet reached the requested position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)">
            <summary>
            Retrieves the playback position of a sample, stream, or MOD music. Can also be used with a recording channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="mode">How to retrieve the position. One of the following (see <see cref="T:Un4seen.Bass.BASSMode"/>):
            <list type="table">
            <item><term>BASS_POS_BYTE</term><description>Get the position in bytes.</description></item>
            <item><term>BASS_POS_MUSIC_ORDER</term><description>Get the position in orders and rows... LoWord = order, HiWord = row * scaler (<see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_PSCALER"/>). (HMUSIC only).</description></item>
            </list>
            <i>Other modes may be supported by add-ons, see the documentation.</i>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. If successful, the position is returned.</returns>
            <remarks>With MOD music you might use the <see cref="M:Un4seen.Bass.Utils.LowWord32(System.Int32)"/> and <see cref="M:Un4seen.Bass.Utils.HighWord32(System.Int32)"/> methods to retrieve the order resp. the row values.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            long pos = Bass.BASS_ChannelGetPosition(stream, BASSMode.BASS_POS_BYTES);
            </code>
            <code lang="vbnet">
            Dim pos As Long = Bass.BASS_ChannelGetPosition(stream, BASSMode.BASS_POS_BYTES)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32)">
            <summary>
            Retrieves the playback position in bytes of a sample, stream, or MOD music. Can also be used with a recording channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. If successful, the position in bytes is returned.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            long pos = Bass.BASS_ChannelGetPosition(stream);
            </code>
            <code lang="vbnet">
            Dim pos As Long = Bass.BASS_ChannelGetPosition(stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)">
            <summary>
            Retrieves the level (peak amplitude) of a stream or MOD music channel. Can also be used with a recording channel.
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM, or HRECORD.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            <para>If successful, the level of the left channel is returned in the low word (low 16-bits, use <see cref="M:Un4seen.Bass.Utils.LowWord32(System.Int32)"/>), and the level of the right channel is returned in the high word (high 16-bits, use <see cref="M:Un4seen.Bass.Utils.HighWord32(System.Int32)"/>). If the channel is mono, then the low word is duplicated in the high word. 
            The level ranges linearly from 0 (silent) to 32768 (max). 0 will be returned when a channel is stalled.</para>
            </returns>
            <remarks>
            <para>This function measures the level of the channel's sample data, not the level of the channel in the final output mix, 
            so the channel's volume (as set with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>, BASS_ATTRIB_VOL) does not affect it.</para>
            <para>For channels that are more than stereo, the left level will include all left channels (eg. front-left, rear-left, center), and the right will include all right (front-right, rear-right, LFE). 
            If there are an odd number of channels then the left and right levels will include all channels. 
            If the level of each individual channel is required, that can be calculated from the sample data that <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> provides.</para>
            <para>When used with a decoding channel, this function has to decode data (20ms worth) from the channel in order to calculate the level. 
            Which means that data is gone, eg. it's not available to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> or other targets anymore!</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOPLAY</term><description>The channel is not playing.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The decoding channel has reached the end.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the left and right levels of a stereo channel:
            <code>
            int level = Bass.BASS_ChannelGetLevel(channel);
            int left = Utils.LowWord32(level); // the left level
            int right = Utils.HighWord32(level); // the right level
            </code>
            <code lang="vbnet">
            Dim level As Integer = Bass.BASS_ChannelGetLevel(channel)
            Dim left As Integer = Utils.LowWord32(level) ' the left level
            Dim right As Integer = Utils.HighWord32(level) ' the right level
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32,System.Single[])">
            <summary>
            Retrieves the level (peak amplitude) of a stream or MOD music channel. Can also be used with a recording channel.
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="level">The array which will receive the peak levels values. The size of the array must be set to the number of channels of the stream (e.g. 2 for stereo).</param>
            <returns>On success TRUE is returned - else FALSE, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            <para>If successful, the peak levels of the interleaved channel order is returned in the <paramref name="level"/> array.
            The level value ranges linearly from 0.0 (silent) to 1.0 (=0dB) or above.</para>
            </returns>
            <remarks>
            <para>This function measures the level of the channel's sample data, not the level of the channel in the final output mix, 
            so the channel's volume (as set with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>, BASS_ATTRIB_VOL) does not affect it.</para>
            <para>When used with a decoding channel, this function has to decode data (20ms worth) from the channel in order to calculate the level. 
            Which means that data is gone, eg. it's not available to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> or other targets anymore!</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be NULL when using this flag.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the left and right levels of a stereo channel:
            <code>
            float[] level = new float[2]; // dealing with stereo
            if (Bass.BASS_ChannelGetLevel(channel, level))
            {
              float left  = level[0]; // the left level
              float right = level[1]; // the right level
            }
            </code>
            <code lang="vbnet">
            Dim level(2) As Single ' dealing with stereo
            If Bass.BASS_ChannelGetLevel(channel, level) Then
              Dim left As Single  = level(0) ' the left level
              Dim right As Single = level(1) ' the right level
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelRemoveSync(System.Int32,System.Int32)">
            <summary>
            Removes a synchronizer from a MOD music or stream channel.
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="sync">Handle of the synchronizer to remove (return value of a previous <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> call).</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="sync"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelRemoveDSP(System.Int32,System.Int32)">
            <summary>
            Removes a DSP function from a stream, MOD music, or recording channel.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="dsp">Handle of the DSP function to remove from the channel (return value of a previous <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/> call).</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="dsp"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelRemoveFX(System.Int32,System.Int32)">
            <summary>
            Removes an effect on a stream, MOD music, or recording channel.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="fx">Handle of the effect to remove from the channel (return value of a previous <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> call).</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Depending on the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a> being used by the channel, the channel may have to be stopped before removing a DX8 effect on it.
            If necessary, that is done automatically and the channel is resumed afterwards.
            <para><see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveDSP(System.Int32,System.Int32)"/> can also be used to remove effects.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="fx"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetLink(System.Int32,System.Int32)">
            <summary>
            Links two MOD music or stream channels together.
            </summary>
            <param name="handle">The channel handle... a HMUSIC or HSTREAM.</param>
            <param name="chan">The handle of the channel to have linked with it... a HMUSIC or HSTREAM.</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Linked channels are started/stopped/paused/resumed together. Links are one-way, for example, channel <paramref name="chan"/> will be started by channel <paramref name="handle"/>, but not vice versa unless another link has been set in that direction.</para>
            <para>If a linked channel has reached the end, it will not be restarted when a channel it is linked to is started. If you want a linked channel to be restarted, you need to have resetted it's position using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> beforehand.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="chan"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description>At least one of <paramref name="handle"/> and <paramref name="chan"/> is a "decoding channel", so can't be linked.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description><paramref name="chan"/> is already linked to <paramref name="handle"/>.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Link 2 streams and play them together:
            <code>
            // link stream2 to stream1
            Bass.BASS_ChannelSetLink(stream1, stream2);
            // start both streams together
            Bass.BASS_ChannelPlay(stream1, false);
            </code>
            <code lang="vbnet">
            ' link stream2 to stream1
            Bass.BASS_ChannelSetLink(stream1, stream2)
            ' start both streams together
            Bass.BASS_ChannelPlay(stream1, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelRemoveLink(System.Int32,System.Int32)">
            <summary>
            Removes a links between two MOD music or stream channels.
            </summary>
            <param name="handle">The channel handle... a HMUSIC or HSTREAM.</param>
            <param name="chan">The handle of the channel to have unlinked with it... a HMUSIC or HSTREAM.</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>Either <paramref name="chan"/> is not a valid channel, or it is already not linked to <paramref name="handle"/>.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)">
            <summary>
            Retrieves the requested tags/headers from a channel, if they are available.
            </summary>
            <param name="handle">The channel handle...a HMUSIC or HSTREAM.</param>
            <param name="tags">The tags/headers wanted... one of the following (see <see cref="T:Un4seen.Bass.BASSTag"/>):
            <list type="table">
            <item><term>BASS_TAG_ID3</term><description>ID3v1 tags. A pointer to a 128 byte block is returned. See <a href="http://www.id3.org/id3v1.html">www.id3.org</a> for details of the block's structure.</description></item>
            <item><term>BASS_TAG_ID3V2</term><description>ID3v2 tags. A pointer to a variable length block is returned. See <a href="http://www.id3.org">www.id3.org</a> for details of the block's structure. ID3v2 tags are supported at both the start and end of the file.</description></item>
            <item><term>BASS_TAG_LYRICS3</term><description>Lyrics3v2 tag. A single string is returned, containing the Lyrics3v2 information. See <a href="http://www.id3.org/Lyrics3v2">www.id3.org/Lyrics3v2</a> for details of its format.</description></item>
            <item><term>BASS_TAG_OGG</term><description>OGG comments, only available when streaming an OGG file. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_VENDOR</term><description>OGG encoder. A single UTF-8 string is returned.</description></item>
            <item><term>BASS_TAG_HTTP</term><description>HTTP headers, only available when streaming from a HTTP server. A pointer to a series of null-terminated strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_ICY</term><description>ICY (Shoutcast) tags. A pointer to a series of null-terminated strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_META</term><description>Shoutcast metadata. A single null-terminated string containing the current stream title and url (usually omitted). The format of the string is: StreamTitle='xxx';StreamUrl='xxx';</description></item>
            <item><term>BASS_TAG_RIFF_INFO</term><description>RIFF/WAVE 'INFO' tags. A pointer to a series of null-terminated ANSI strings is returned, the final string ending with a double null. The tags are in the form of 'XXXX=text', where 'XXXX' is the chunk ID.</description></item>
            <item><term>BASS_TAG_MUSIC_NAME</term><description>MOD music title (a single null-terminated ANSI String).</description></item>
            <item><term>BASS_TAG_MUSIC_MESSAGE</term><description>MOD message text (a single null-terminated ANSI String).</description></item>
            <item><term>BASS_TAG_MUSIC_INST</term><description>+ instrument number (0=first). MOD instrument name (a single null-terminated ANSI String).</description></item>
            <item><term>BASS_TAG_MUSIC_SAMPLE</term><description>+ sample number (0=first). MOD sample name (a single null-terminated ANSI String).</description></item>
            </list>
            Other tags may be supported by Add-Ons, see the documentation.
            </param>
            <returns>If succesful, a pointer to the data of the tags/headers is returned, else IntPtr.Zero is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            ID3v1 tags are located at the end of the file, so when streaming an MPEG file with ID3v1 tags from the internet, 
            the tags will not be available until the download is complete. A sync (BASS_SYNC_DOWNLOAD) can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be informed of when the download is complete. 
            A BASS_SYNC_META sync can be used to be informed of new Shoutcast metadata, and a BASS_SYNC_OGG_CHANGE sync for when a new logical bitstream begins in a chained OGG stream, which generally brings new OGG tags.
            <para>You might also use one of these overloads to directly get specific tags:
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsID3V1(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsID3V2(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsAPE(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsWMA(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsMP4(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsOGG(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsHTTP(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsICY(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsRIFF(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsMETA(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagLyrics3v2(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicName(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicSample(System.Int32,System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicInstrument(System.Int32,System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicMessage(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMidiTrackText(System.Int32,System.Int32)"/>.
            </para>
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Getting OGG Tags:
            <code>
            int channel = Bass.BASS_StreamCreateFile("test.ogg", 0, 0, BASSFlag.BASS_SAMPLE_FLOAT);
            IntPtr tag = Bass.BASS_ChannelGetTags(channel, BASSTag.BASS_TAG_OGG);
            string[] tags = Utils.IntPtrToArrayNullTermUtf8(tag);
            if (tags != null)
            {
              foreach (string tag in tags)
                Console.Writeln("Tag: {0}\n", tag);
            }
            </code>
            <code lang="vbnet">
            Dim channel As Integer = Bass.BASS_StreamCreateFile("test.ogg", 0, 0, BASSFlag.BASS_SAMPLE_FLOAT)
            Dim tag As IntPtr = Bass.BASS_ChannelGetTags(channel, BASSTag.BASS_TAG_OGG)
            Dim tags As String() = Utils.IntPtrToArrayNullTermUtf8(tag)
            If Not (tags Is Nothing) Then
              Dim tag As String
              For Each tag In  tags
                Console.Writeln("Tag: {0}" + ControlChars.Lf, tag)
              Next tag
            End If
            </code>
            Getting MOD Music Instruments:
            <code>
            IntPtr p = BASS_ChannelGetTags(handle, (BASSTag)(BASSTag.BASS_TAG_MUSIC_INST + instrument));
            if (p != IntPtr.Zero)
              string instr = Marshal.PtrToStringAnsi(p);
            </code>
            <code lang="vbnet">
            Dim p As IntPtr = BASS_ChannelGetTags(handle, CType(BASSTag.BASS_TAG_MUSIC_INST + instrument, BASSTag))
            If p &lt;&gt; IntPtr.Zero Then
              Dim instr As String = Marshal.PtrToStringAnsi(p)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsArrayNullTermAnsi(System.Int32,Un4seen.Bass.BASSTag)">
            <summary>
            Retrieves the header tags from a channel, if they are available.
            <para>NOTE: This method evaluates the header as a series/array of null-terminated Ansi strings.</para>
            <para>Might be used e.g. with: RIFF_INFO, ICY and HTTP.</para>
            </summary>
            <param name="handle">The stream's handle.</param>
            <param name="format">The type of tags/headers wanted... one of the following (see <see cref="T:Un4seen.Bass.BASSTag"/>):
            <list type="table">
            <item><term>BASS_TAG_HTTP</term><description>HTTP headers, only available when streaming from a HTTP server. A pointer to a series of null-terminated strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_ICY</term><description>ICY (Shoutcast) tags. A pointer to a series of null-terminated strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_RIFF_INFO</term><description>RIFF/WAVE 'INFO' tags. A pointer to a series of null-terminated ANSI strings is returned, the final string ending with a double null. The tags are in the form of 'XXXX=text', where 'XXXX' is the chunk ID.</description></item>
            </list>
            Other tags may be supported by Add-Ons, see the documentation (ASNI only).
            </param>
            <returns>NULL or an array of strings. Each array element will represent one tag, e.g. "TITLE=this is a title"
            </returns>
            <remarks>
            Only available when streaming a file containing tags/headers which are defined as a series of null-terminated ASNI strings! So make sure to use this method only with appropriate formats!
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsArrayNullTermUtf8(System.Int32,Un4seen.Bass.BASSTag)">
            <summary>
            Retrieves the header tags from a channel, if they are available.
            <para>NOTE: This method evaluates the header as a series/array of null-terminated UTF-8 strings.</para>
            <para>Might be used e.g. with: APE, MP4, OGG and WMA - if UTF-8!</para>
            </summary>
            <param name="handle">The channel handle...a HMUSIC or HSTREAM.</param>
            <param name="format">The type of tags/headers wanted... one of the following (see <see cref="T:Un4seen.Bass.BASSTag"/>):
            <list type="table">
            <item><term>BASS_TAG_OGG</term><description>OGG tags, only available when streaming an OGG file. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_VENDOR</term><description>Vendor encoder tag. A single UTF-8 string is returned.</description></item>
            <item><term>BASS_TAG_WMA</term><description>WMA tags : array of null-terminated UTF-8 strings.</description></item>
            <item><term>BASS_TAG_WMA_META</term><description>WMA mid-stream tag : A single UTF-8 string is returned.</description></item>
            <item><term>BASS_TAG_APE</term><description>APE tags. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_MP4</term><description>MP4 tags. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</description></item>
            </list>
            Other tags may be supported by Add-Ons, see the documentation - only UTF-8!
            </param>
            <returns>NULL or an array of strings. Each array element will represent one tag, e.g. "TITLE=this is a title"</returns>
            <remarks>
            Only available when streaming a file containing tags/headers which are defined as a series of null-terminated UNICODE strings! So make sure to use this method only with appropriate formats!
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsID3V1(System.Int32)">
            <summary>
            Retrieves the ID3v1 tags from a channel, if they are available.
            <para>This special helper method already evaluates the 128-byte ID3v3 data block.</para>
            </summary>
            <param name="handle">The channel handle...a HSTREAM.</param>
            <returns>NULL or an array of strings with exactly 6 elements:
            <para>string[0] = 'song title' (max. 30 chars)</para>
            <para>string[1] = 'artist' (max. 30 chars)</para>
            <para>string[2] = 'album' (max. 30 chars)</para>
            <para>string[3] = 'year' (yyyy)</para>
            <para>string[4] = 'comment' (max. 30 chars)</para>
            <para>string[5] = 'genre-id'</para>
            </returns>
            <remarks>
            ID3v1 tags are located at the end of the file, so when streaming an MPEG file with ID3v1 tags from the internet, the tags will not be available until the download is complete. 
            A BASS_SYNC_DOWNLOAD sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be informed of when the download is complete.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsID3V1(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsID3V1(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsID3V2(System.Int32)">
            <summary>
            Retrieves the ID3v2 header tags from a channel, if they are available.
            </summary>
            <param name="handle">The channel handle...a HSTREAM.</param>
            <returns>NULL or an array of strings. Each array element will represent one tag in the format 'FrameId=Value' (e.g. "TIT2=This is a Title").</returns>
            <remarks>Only tag values containing strings are returned (e.g. Txxx, Wxxx or COMM tags).
            <para>ID3v2 tags are supported at both the start and end of the file.</para>
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">Invalid/Unsupported ID3v2 version detected.</exception>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsID3V2(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsID3V2(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsAPE(System.Int32)">
            <summary>
            Retrieves the APEv2 header tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using UTF-8 strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns>NULL or an array of strings. Each array element will represent one tag in the format 'TagName=Value' (e.g. "TITLE=This is a Title").</returns>
            <remarks>
            Only available when streaming a file containing APE tags.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_PlugInLoad("bass_ape.dll");
            ...
            int stream = Bass.BASS_StreamCreateFile("test.ape", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsAPE(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Bass.BASS_PlugInLoad("bass_ape.dll")
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.ape", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsAPE(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsWMA(System.Int32)">
            <summary>
            Retrieves the WMA header tags or mid-stream tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using UTF-8 strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns>NULL or an array of strings. Each array element will represent one tag in the format 'AttribName=Value' (e.g. "TITLE=This is a Title").</returns>
            <remarks>
            Only available when streaming a file containing WMA tags.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_PlugInLoad("basswma.dll");
            ...
            int stream = Bass.BASS_StreamCreateFile("test.wma", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsWMA(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Bass.BASS_PlugInLoad("basswma.dll")
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.wma", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsWMA(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsMP4(System.Int32)">
            <summary>
            Retrieves the MP4 header tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using ANSI strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns>NULL or an array of strings. Each array element will represent one tag in the format 'TagName=Value' (e.g. "TITLE=This is a Title").</returns>
            <remarks>
            Only available when streaming a file containing MP4 tags.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_PlugInLoad("bass_aac.dll");
            ...
            int stream = Bass.BASS_StreamCreateFile("test.m4a", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsMP4(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Bass.BASS_PlugInLoad("bass_aac.dll")
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.m4a", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsMP4(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsHTTP(System.Int32)">
            <summary>
            Retrieves the HTTP header tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using ANSI strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns>NULL or an array of strings. Each array element will represent one header entry, e.g. "Server: Icecast 2.2.0"
            </returns>
            <remarks>
            Only available when streaming from a HTTP source.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateURL("http://www.radio42.com/playHiFi.pls", 0, 
                              BASSFlag.BASS_STREAM_STATUS, null, IntPtr.Zero);
            string[] tags = Bass.BASS_ChannelGetTagsICY(stream);
            if (tags == null)
            {
              // try http...
              tags = Bass.BASS_ChannelGetTagsHTTP(stream);
            }
            if (tags != null)
            {
              foreach (string tag in tags)
                Console.WriteLine(tag);
            }
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateURL("http://www.radio42.com/playHiFi.pls", 0, 
                                         BASSFlag.BASS_STREAM_STATUS, Nothing, IntPtr.Zero)
            Dim tags As String() = Bass.BASS_ChannelGetTagsICY(stream)
            If tags Is Nothing Then
              ' try http...
              tags = Bass.BASS_ChannelGetTagsHTTP(stream)
            End If
            If Not (tags Is Nothing) Then
              Dim tag As String
              For Each tag In tags
                Console.WriteLine(tag)
              Next tag
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsICY(System.Int32)">
            <summary>
            Retrieves the ICY (Shoutcast) tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using ANSI strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns>NULL or an array of strings. Each array element will represent one ICY entry, e.g. "icy-name: name of the stream"
            </returns>
            <remarks>
            Only available when streaming from Shoutcast.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateURL("http://www.radio42.com/playHiFi.pls", 0, 
                              BASSFlag.BASS_STREAM_STATUS, null, IntPtr.Zero);
            string[] tags = Bass.BASS_ChannelGetTagsICY(stream);
            if (tags == null)
            {
              // try http...
              tags = Bass.BASS_ChannelGetTagsHTTP(stream);
            }
            if (tags != null)
            {
              foreach (string tag in tags)
                Console.WriteLine(tag);
            }
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateURL("http://www.radio42.com/playHiFi.pls", 0, 
                                         BASSFlag.BASS_STREAM_STATUS, Nothing, IntPtr.Zero)
            Dim tags As String() = Bass.BASS_ChannelGetTagsICY(stream)
            If tags Is Nothing Then
              ' try http...
              tags = Bass.BASS_ChannelGetTagsHTTP(stream)
            End If
            If Not (tags Is Nothing) Then
              Dim tag As String
              For Each tag In tags
                Console.WriteLine(tag)
              Next tag
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsOGG(System.Int32)">
            <summary>
            Retrieves the OGG tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using UTF-8 strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns>NULL or an array of strings. Each array element will represent one tag in the format 'TagName=Value' (e.g. "TITLE=This is a Title").</returns>
            <remarks>
            Only available when streaming an OGG file.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.ogg", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsOGG(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.ogg", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsOGG(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsRIFF(System.Int32)">
            <summary>
            Retrieves the RIFF/WAVE Info tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using ANSI strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns>NULL or an array of strings. Each array element will represent one tag in the format 'ID=Value' (e.g. "IART =This is the Artist").</returns>
            <remarks>
            Only available for RIFF/WAVE files.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.wav", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsRIFF(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.wav", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsRIFF(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsMETA(System.Int32)">
            <summary>
            Retrieves metadata tags from a channel (Shoutcast or Icecast), if they are available.
            </summary>
            <param name="handle">The channel handle.</param>
            <returns>NULL or an array of strings. Each array element will represent one tag in the format 'Name=Value' (e.g. "StreamTitle='xyz'").</returns>
            <remarks>
            Only available when streaming from Shoutcast.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateURL("http://www.radio42.com/playHiFi.pls", 0, 
                              BASSFlag.BASS_STREAM_STATUS, null, IntPtr.Zero);
            string[] tags = Bass.BASS_ChannelGetTagsMETA(stream);
            if (tags != null)
            {
              foreach (string tag in tags)
                Console.WriteLine(tag);
            }
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateURL("http://www.radio42.com/playHiFi.pls", 0, 
                                         BASSFlag.BASS_STREAM_STATUS, Nothing, IntPtr.Zero)
            Dim tags As String() = Bass.BASS_ChannelGetTagsMETA(stream)
            If Not (tags Is Nothing) Then
              Dim tag As String
              For Each tag In tags
                Console.WriteLine(tag)
              Next tag
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagLyrics3v2(System.Int32)">
            <summary>
            Retrieves a Lyrics3v2 tag.
            </summary>
            <param name="handle">The channel handle.</param>
            <returns> A single string is returned, containing the Lyrics3v2 information - or NULL, if not available. 
            <para>See <a href="http://www.id3.org/Lyrics3v2">www.id3.org/Lyrics3v2</a> for details of its format.</para>
            </returns>
            <remarks>
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicName(System.Int32)">
            <summary>
            Retrieves the MOD music title from a channel, if it is available.
            </summary>
            <param name="handle">The channel handle...a HMUSIC.</param>
            <returns>NULL or a single string representing the MOD music title.</returns>
            <remarks>
            Only available for MOD music channels.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicMessage(System.Int32)">
            <summary>
            Retrieves the MOD message text from a channel, if it is available.
            </summary>
            <param name="handle">The channel handle...a HMUSIC.</param>
            <returns>NULL or a single string representing the MOD message text.</returns>
            <remarks>
            Only available for MOD music channels.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicInstrument(System.Int32,System.Int32)">
            <summary>
            Retrieves a specific MOD instrument name from a channel, if it is available.
            </summary>
            <param name="handle">The channel handle...a HMUSIC.</param>
            <param name="instrument">The instrument number (0=first).</param>
            <returns>NULL or a single string representing the MOD instrument name.</returns>
            <remarks>
            Only available for MOD music channels.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicSample(System.Int32,System.Int32)">
            <summary>
            Retrieves a specific MOD sample name from a channel, if it is available.
            </summary>
            <param name="handle">The channel handle...a HMUSIC.</param>
            <param name="sample">The sample number (0=first).</param>
            <returns>NULL or a single string representing the MOD sample name.</returns>
            <remarks>
            Only available for MOD music channels.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List all MOD music's samples:
            <code>
            string name = String.Empty;
            int i = 0;
            while ( true )
            {
              name = Bass.BASS_ChannelGetMusicSample( mod, i );
              if ( name != null )
                Console.Writeln( String.Format( "Sample {0}={1}", i, name ) );
              else
                break;
              i++;
            }
            </code>
            <code lang="vbnet">
            Dim name As String = [String].Empty
            Dim i As Integer = 0
            While True
              name = Bass.BASS_ChannelGetMusicSample([mod], i)
              If Not (name Is Nothing) Then
                Console.Writeln([String].Format("Sample {0}={1}", i, name))
              Else
                Exit While
              End If
              i += 1
            End While
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetMidiTrackText(System.Int32,System.Int32)">
            <summary>
            Retrieves a specific MIDI track text from a channel, if it is available.
            </summary>
            <param name="handle">The channel handle...a MIDI HSTREAM.</param>
            <param name="track">The MIDI track number (0=first), use -1 to get the text for all tracks.</param>
            <returns>NULL or an array of strings. Each array element will represent one text of the MIDI track.</returns>
            <remarks>
            The texts of each track in the MIDI file are available via the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_MIDI_TRACK"/>+track tag, where track=0 is the first track. 
            The first text in the first track is generally the title of the MIDI file. 
            <para>RIFF MIDI tags are also available via the standard <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_INFO"/> tag.</para>
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParametersExt(System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="par"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.
            <para><i>Additional effect parameter structures might be implemented by add-ons.</i></para>
            </param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
             The structure used depends on the effect type.
            <para>For DX8 effects you might use: <see cref="T:Un4seen.Bass.BASS_DX8_CHORUS"/>, <see cref="T:Un4seen.Bass.BASS_DX8_COMPRESSOR"/>, <see cref="T:Un4seen.Bass.BASS_DX8_DISTORTION"/>, <see cref="T:Un4seen.Bass.BASS_DX8_ECHO"/>, <see cref="T:Un4seen.Bass.BASS_DX8_FLANGER"/>, <see cref="T:Un4seen.Bass.BASS_DX8_GARGLE"/>, <see cref="T:Un4seen.Bass.BASS_DX8_I3DL2REVERB"/>, <see cref="T:Un4seen.Bass.BASS_DX8_PARAMEQ"/>, <see cref="T:Un4seen.Bass.BASS_DX8_REVERB"/>.</para>
            <para>For BASS_FX DSP effetcs you might use: <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF"/>.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add an effect DSP to a channel at anay time and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveFX(System.Int32,System.Int32)"/> to remove an effect from the channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One or more of the parameters are invalid, make sure all the values are within the valid ranges.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            BASS_DX8_ECHO echo = new BASS_DX8_ECHO();
            // add the effect to the DSP chain
            int fxHandle = Bass.BASS_ChannelSetFX(stream, BASSFXType.BASS_FX_ECHO, 0);
            echo.Preset_Long();
            // apply the effect parameters
            Bass.BASS_FXSetParameters(fxHandle, echo);
            // play the channel
            Bass.BASS_ChannelPlay(stream, false);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim echo As New BASS_DX8_ECHO()
            ' add the effect to the DSP chain
            Dim fxHandle As Integer = Bass.BASS_ChannelSetFX(stream, BASSFXType.BASS_FX_ECHO, 0)
            echo.Preset_Long()
            ' apply the effect parameters
            Bass.BASS_FXSetParameters(fxHandle, echo)
            ' play the channel
            Bass.BASS_ChannelPlay(stream, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParametersExt(System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="par"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.
            <para><i>Additional effect parameter structures might be implemented by add-ons.</i></para>
            </param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
             The structure used depends on the effect type.
            <para>For DX8 effects you might use: <see cref="T:Un4seen.Bass.BASS_DX8_CHORUS"/>, <see cref="T:Un4seen.Bass.BASS_DX8_COMPRESSOR"/>, <see cref="T:Un4seen.Bass.BASS_DX8_DISTORTION"/>, <see cref="T:Un4seen.Bass.BASS_DX8_ECHO"/>, <see cref="T:Un4seen.Bass.BASS_DX8_FLANGER"/>, <see cref="T:Un4seen.Bass.BASS_DX8_GARGLE"/>, <see cref="T:Un4seen.Bass.BASS_DX8_I3DL2REVERB"/>, <see cref="T:Un4seen.Bass.BASS_DX8_PARAMEQ"/>, <see cref="T:Un4seen.Bass.BASS_DX8_REVERB"/>.</para>
            <para>For BASS_FX DSP effetcs you might use: <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF"/>.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add an effect DSP to a channel at anay time and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveFX(System.Int32,System.Int32)"/> to remove an effect from the channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_DX8_ECHO echo = new BASS_DX8_ECHO();
            Bass.BASS_FXGetParameters(_fxEchoHandle, echo);
            Console.WriteLine( "Panning={0}", echo.lPanDelay );
            </code>
            <code lang="vbnet">
            Dim echo As New BASS_DX8_ECHO()
            Bass.BASS_FXGetParameters(_fxEchoHandle, echo)
            Console.WriteLine("Panning={0}", echo.lPanDelay)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXReset(System.Int32)">
            <summary>
            Resets the state of an effect or all effects on a channel.
            </summary>
            <param name="handle">The effect or channel handle... a HFX, HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Call this function e.g. after changing the position or when you pause a channel or when a stream stalls to avoid clicks when resuming.
            <para>This function flushes the internal buffers of the effect(s). Effects are automatically reset by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, except when called from a "mixtime" <see cref="T:Un4seen.Bass.SYNCPROC"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Bass.SupportedStreamExtensions">
            <summary>
            Supported stream file extensions of the bass.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Bass.SupportedStreamName">
            <summary>
            Supported file format name of the bass.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Bass.SupportedMusicExtensions">
            <summary>
            Supported music file extensions of the bass.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Bass.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSWMA from the application's startup path:
            <code>
            Bass.LoadMe();
            BassWma.LoadMe();
            ...
            // when not used anymore...
            BassWma.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSWMA from a different directory:
            <code>
            Bass.LoadMe( @"C:\Development\BASS\_libs" );
            BassWma.LoadMe( @"C:\Development\BASS\_libs" );
            ...
            // when not used anymore...
            BassWma.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.Bass.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.Bass.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.BASSError">
            <summary>
            BASS error codes as returned e.g. by <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> (int)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_OK">
            <summary>
            All is OK
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_MEM">
            <summary>
            Memory error
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_FILEOPEN">
            <summary>
            Can't open the file
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_DRIVER">
            <summary>
            Can't find a free/valid driver
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_BUFLOST">
            <summary>
            The sample buffer was lost
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_HANDLE">
            <summary>
            Invalid handle
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_FORMAT">
            <summary>
            Unsupported sample format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_POSITION">
            <summary>
            Invalid playback position
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_INIT">
            <summary>
            BASS_Init has not been successfully called
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_START">
            <summary>
            BASS_Start has not been successfully called
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOCD">
            <summary>
            No CD in drive
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_CDTRACK">
            <summary>
            Invalid track number
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_ALREADY">
            <summary>
            Already initialized/paused/whatever
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOPAUSE">
            <summary>
            Not paused
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOTAUDIO">
            <summary>
            Not an audio track
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOCHAN">
            <summary>
            Can't get a free channel
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_ILLTYPE">
            <summary>
            An illegal type was specified
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_ILLPARAM">
            <summary>
            An illegal parameter was specified
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NO3D">
            <summary>
            No 3D support
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOEAX">
            <summary>
            No EAX support
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_DEVICE">
            <summary>
            Illegal device number
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOPLAY">
            <summary>
            Not playing
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_FREQ">
            <summary>
            Illegal sample rate
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOTFILE">
            <summary>
            The stream is not a file stream
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOHW">
            <summary>
            No hardware voices available
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_EMPTY">
            <summary>
            The MOD music has no sequence data
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NONET">
            <summary>
            No internet connection could be opened
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_CREATE">
            <summary>
            Couldn't create the file
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOFX">
            <summary>
            Effects are not available
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_PLAYING">
            <summary>
            The channel is playing
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOTAVAIL">
            <summary>
            Requested data is not available
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_DECODE">
            <summary>
            The channel is a 'decoding channel'
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_DX">
            <summary>
            A sufficient DirectX version is not installed
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_TIMEOUT">
            <summary>
            Connection timedout
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_FILEFORM">
            <summary>
            Unsupported file format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_SPEAKER">
            <summary>
            Unavailable speaker
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_VERSION">
            <summary>
            Invalid BASS version (used by add-ons)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_CODEC">
            <summary>
            Codec is not available/supported
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_UNKNOWN">
            <summary>
            Some other mystery error
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WMA_LICENSE">
            <summary>
            BassWma: the file is protected
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WMA_WM9">
            <summary>
            BassWma: WM9 is required
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WMA_DENIED">
            <summary>
            BassWma: access denied (user/pass is invalid)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WMA_CODEC">
            <summary>
            BassWma: no appropriate codec is installed
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WMA_INDIVIDUAL">
            <summary>
            BassWma: individualization is needed
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_ACM_CANCEL">
            <summary>
            BassEnc: ACM codec selection cancelled
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_CAST_DENIED">
            <summary>
            BassEnc: Access denied (invalid password)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_VST_ERROR_NOINPUTS">
            <summary>
            BassVst: the given effect has no inputs and is probably a VST instrument and no effect
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_VST_ERROR_NOOUTPUTS">
            <summary>
            BassVst:  the given effect has no outputs
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_VST_ERROR_NOREALTIME">
            <summary>
            BassVst: the given effect does not support realtime processing
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_FX_ERROR_NODECODE">
            <summary>
            BassFx: Not a decoding channel
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_FX_ERROR_BPMINUSE">
            <summary>
            BassFx: BPM detection is in use
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSInit">
            <summary>
            Initialization flags to be used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_DEFAULT">
            <summary>
            0 = 16 bit, stereo, no 3D, no Latency calc, no Speaker Assignments
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_8BITS">
            <summary>
            Use 8 bit resolution, else 16 bit.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_MONO">
            <summary>
            Use mono, else stereo.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_3D">
            <summary>
            Enable 3D functionality.
            Note: If the BASS_DEVICE_3D flag is not specified when initilizing BASS,
            then the 3D flags (BASS_SAMPLE_3D and BASS_MUSIC_3D) are ignored when
            loading/creating a sample/stream/music.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_LATENCY">
            <summary>
            Calculate device latency (BASS_INFO struct).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_CPSPEAKERS">
            <summary>
            Use the Windows control panel setting to detect the number of speakers.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_SPEAKERS">
            <summary>
            Force enabling of speaker assignment.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_NOSPEAKER">
            <summary>
            ignore speaker arrangement
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSDirectSound">
            <summary>
            Direct Sound interface flags for use with <see cref="M:Un4seen.Bass.Bass.BASS_GetDSoundObject(System.Int32)"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDirectSound.BASS_OBJECT_DS">
            <summary>
            Retrieve the IDirectSound interface.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDirectSound.BASS_OBJECT_DS3DL">
            <summary>
            Retrieve the IDirectSound3DListener interface.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSConfig">
            <summary>
            Configuration options to be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER">
            <summary>
            Playback buffer length.
            <para>length (int): The buffer length in milliseconds. The minimum length is 1ms above the update period (see <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD"/>), the maximum is 5000 milliseconds. If the length specified is outside this range, it is automatically capped.</para>
            </summary>
            <remarks>
            <para>The default buffer length is 500 milliseconds. Increasing the length, decreases the chance of the sound possibly breaking-up on slower computers, but also increases the latency for DSP/FX.</para>
            <para>Small buffer lengths are only required if the sound is going to be changing in real-time, for example, in a soft-synth. If you need to use a small buffer, then the minbuf member of BASS_INFO should be used to get the recommended minimum buffer length supported by the device and it's drivers. Even at this default length, it's still possible that the sound could break up on some systems, it's also possible that smaller buffers may be fine. So when using small buffers, you should have an option in your software for the user to finetune the length used, for optimal performance.</para>
            <para>Using this config option only affects the HMUSIC/HSTREAM channels that you create afterwards, not the ones that have already been created. So you can have channels with differing buffer lengths by using this config option each time before creating them.</para>
            <para>If automatic updating is disabled, make sure you call <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> frequently enough to keep the buffers updated.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD">
            <summary>
            Update period of playback buffers.
            <para>period (int): The update period in milliseconds... 0 = disable automatic updating. The minimum period is 5ms, the maximum is 100ms. If the period specified is outside this range, it is automatically capped.</para>
            </summary>
            <remarks>
            <para>The update period is the amount of time between updates of the playback buffers of HSTREAM/HMUSIC channels. Shorter update periods allow smaller buffers to be set with the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> option, but as the rate of updates increases, so the overhead of setting up the updates becomes a greater part of the CPU usage. 
            The update period only affects HSTREAM and HMUSIC channels, it does not affect samples. Nor does it have any effect on decoding channels, as they are not played.</para>
            <para>BASS creates a thread specifically to perform the updating, except when automatic updating is disabled (period=0) - then you must regularly call <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> instead. This allows you to synchronize BASS's CPU usage with your program's. For example, in a game loop you could call <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> once per frame, which keeps all the processing in sync so that the frame rate is as smooth as possible. BASS_Update should be called at least around 8 times per second, even more often if the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> option is used to set smaller buffers.</para>
            <para>The update period can be altered at any time, including during playback. The default period is 100ms.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_GVOL_SAMPLE">
            <summary>
            Global sample volume.
            <para>volume (int): Sample global volume level... 0 (silent) - 10000 (full).</para>
            </summary>
            <remarks>
            <para>This config option allows you to have control over the volume levels of all the samples, which is useful for setup options (eg. separate music and fx volume controls).</para>
            <para>A channel's final volume = channel volume * global volume / max volume. So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000, then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_GVOL_STREAM">
            <summary>
            Global stream volume.
            <para>volume (int): Stream global volume level... 0 (silent) - 10000 (full).</para>
            </summary>
            <remarks>
            <para>This config option allows you to have control over the volume levels of all streams, which is useful for setup options (eg. separate music and fx volume controls).</para>
            <para>A channel's final volume = channel volume * global volume / max volume. So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000, then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_GVOL_MUSIC">
            <summary>
            Global music volume.
            <para>volume (int): MOD music global volume level... 0 (silent) - 10000 (full).</para>
            </summary>
            <remarks>
            <para>This config option allows you to have control over the volume levels of all the MOD musics, which is useful for setup options (eg. separate music and fx volume controls).</para>
            <para>A channel's final volume = channel volume * global volume / max volume. So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000, then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CURVE_VOL">
            <summary>
            Volume translation curve.
            <para>logvol (bool): Volume curve... FALSE = linear, TRUE = logarithmic.</para>
            </summary>
            <remarks>
            <para>DirectSound uses logarithmic volume and panning curves, which can be awkward to work with. 
            For example, with a logarithmic curve, the audible difference between 10000 and 9000, is not the same as between 9000 and 8000. 
            With a linear "curve" the audible difference is spread equally across the whole range of values, so in the previous example the audible difference between 10000 and 9000, and between 9000 and 8000 would be identical.</para>
            <para>When using the linear curve, the volume range is from 0% (silent) to 100% (full). 
            When using the logarithmic curve, the volume range is from -100 dB (effectively silent) to 0 dB (full). For example, a volume level of 0.5 is 50% linear or -50 dB logarithmic.</para>
            <para>The linear curve is used by default.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CURVE_PAN">
            <summary>
            Panning translation curve.
            <para>logpan (bool): Panning curve... FALSE = linear, TRUE = logarithmic.</para>
            </summary>
            <remarks>
            <para>The panning curve affects panning in exactly the same way as the volume curve (BASS_CONFIG_CURVE_VOL) affects the volume.</para>
            <para>The linear curve is used by default.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_FLOATDSP">
            <summary>
            Pass 32-bit floating-point sample data to all DSP functions?
            <para>floatdsp (bool): If TRUE, 32-bit floating-point sample data is passed to all <see cref="T:Un4seen.Bass.DSPPROC"/> callback functions.</para>
            </summary>
            <remarks>
            <para>Normally DSP functions receive sample data in whatever format the channel is using, ie. it can be 8, 16 or 32-bit. But using this config option, BASS will convert 8/16-bit sample data to 32-bit floating-point before passing it to DSP functions, and then convert it back after all the DSP functions are done. As well as simplifying the DSP code (no need for 8/16-bit processing), this also means that there is no degradation of quality as sample data passes through a chain of DSP.</para>
            <para>This option also affects DX8 effects when using the "without FX flag" DX8 effect implementation. Note that floating-point FX processing requires DX9 or above.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_3DALGORITHM">
            <summary>
            The 3D algorithm for software mixed 3D channels.
            <para>algo (int): Use one of the <see cref="T:Un4seen.Bass.BASS3DAlgorithm"/> flags.</para>
            </summary>
            <remarks>
            <para>These algorithms only affect 3D channels that are being mixed in software. This config option allows you to use higher quality 3D processing on more powerful CPUs, and more efficient 3D processing on less powerful CPUs. Changing the algorithm only affects subsequently created or loaded samples, musics or streams, it does not affect those that already exist.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_TIMEOUT">
            <summary>
            Time to wait for a server to respond to a connection request.
            <para>timeout (int): The time to wait, in milliseconds.</para>
            </summary>
            <remarks>
            <para>The default timeout is 5 seconds (5000 milliseconds).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_BUFFER">
            <summary>
            Internet download buffer length.
            <para>length (int): The buffer length, in milliseconds.</para>
            </summary>
            <remarks>
            <para>Increasing the buffer length decreases the chance of the stream stalling, but also increases the time taken by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> to create the stream, as it has to pre-buffer more data (adjustable via the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_PREBUF"/> option). Aside from the pre-buffering, this setting has no effect on streams without either the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_BLOCK"/> or <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_RESTRATE"/> flags.</para>
            <para>When streaming in blocks, this option determines the download buffer length. The effective buffer length can actually be a bit more than that specified, including data that's been read from the buffer by the decoder but not been used yet.</para>
            <para>This config option also determines the buffering used by "buffered" user file streams created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            <para>The default buffer length is 5 seconds (5000 milliseconds). The net buffer length should be larger than the length of the playback buffer (<see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/>), otherwise the stream is likely to briefly stall soon after starting playback.</para>
            <para>Using this config option only affects streams created afterwards, not any that have already been created.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_PAUSE_NOPLAY">
            <summary>
            Prevent channels being played when the output is paused?
            <para>noplay (bool): If TRUE, channels can't be played while the output is paused.</para>
            <para>When the output is paused using <see cref="M:Un4seen.Bass.Bass.BASS_Pause"/>, and this config option is enabled, channels can't be played until the output is resumed using <see cref="M:Un4seen.Bass.Bass.BASS_Start"/>. Attempts to play a channel will give a <see cref="F:Un4seen.Bass.BASSError.BASS_ERROR_START"/> error.</para>
            <para>By default, this config option is enabled.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_PREBUF">
            <summary>
            Amount to pre-buffer when opening internet streams.
            <para>prebuf (int): Amount (percentage) to pre-buffer.</para>
            </summary>
            <remarks>
            <para>This setting determines what percentage of the buffer length (<see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_BUFFER"/>) should be filled by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>. The default is 75%. Setting this lower (eg. 0) is useful if you want to display a "buffering progress" (using <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/>) when opening internet streams, but note that this setting is just a minimum - BASS will always pre-download a certain amount to verify the stream.</para>
            <para>As well as internet streams, this config setting also applies to "buffered" user file streams created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_AGENT">
            <summary>
            "User-Agent" header.
            <para>agent (string pointer): The "User-Agent" header.</para>
            </summary>
            <remarks>
            <para>BASS does not make a copy of the config string, so it must reside in the heap (not the stack), eg. a global variable. This also means that the agent setting can subsequently be changed at that location without having to call this function again.</para>
            <para>Changes take effect from the next internet stream creation call.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_PROXY">
            <summary>
            Proxy server settings (in the form of "user:pass@server:port"... NULL = don't use a proxy).
            <para>proxy (string pointer): The proxy server settings, in the form of "user:pass@server:port"... NULL = don't use a proxy. "" (empty string) = use the default proxy settings. If only the "user:pass@" part is specified, then those authorization credentials are used with the default proxy server. If only the "server:port" part is specified, then that proxy server is used without any authorization credentials.</para>
            </summary>
            <remarks>
            <para>BASS does not make a copy of the config string, so it must reside in the heap (not the stack), eg. a global variable. This also means that the proxy settings can subsequently be changed at that location without having to call this function again.</para>
            <para>Changes take effect from the next internet stream creation call. By default, BASS will use the Windows proxy settings, as set in the Internet Properties control panel.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_PASSIVE">
            <summary>
            Use passive mode in FTP connections?
            <para>passive (bool): If TRUE, passive mode is used, otherwise normal/active mode is used.</para>
            </summary>
            <remarks>
            <para>Changes take effect from the next internet stream creation call. By default, passive mode is enabled.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_REC_BUFFER">
            <summary>
            The buffer length for recording channels.
            <para>length (int): The buffer length in milliseconds... 1000 (min) - 5000 (max). If the length specified is outside this range, it is automatically capped.</para>
            </summary>
            <remarks>
            <para>Unlike a playback buffer, where the aim is to keep the buffer full, a recording buffer is kept as empty as possible and so this setting has no effect on latency. The default recording buffer length is 2000 milliseconds. Unless processing of the recorded data could cause significant delays, or you want to use a large recording period with <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>, there should be no need to increase this.</para>
            <para>Using this config option only affects the recording channels that are created afterwards, not any that have already been created. So you can have channels with differing buffer lengths by using this config option each time before creating them.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_PLAYLIST">
            <summary>
            Process URLs in PLS, M3U or ASX playlists?
            <para>netlists (int): When to process URLs in PLS, M3U or ASX playlists... 0 = never, 1 = in <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> only, 2 = in <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> too.</para>
            </summary>
            <remarks>
            <para>When enabled, BASS will process PLS, M3U and ASX playlists, going through each entry until it finds a URL that it can play. 
            By default, playlist procesing is disabled.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MUSIC_VIRTUAL">
            <summary>
            The maximum number of virtual music channels (1-512) to use.
            <para>number (int): The maximum number of virtual music channels (1-512), ), which should be set before loading the IT file (doesn't affect already loaded files).</para>
            </summary>
            <remarks>
            <para>When there are no virtual channels free, the quietest one is killed to make way. That means any extra channels (due to raised limit) will be quieter ones.</para>
            <para>Note that the virtual channel count/limit is in addition to the normal channels.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_VERIFY">
            <summary>
            The amount of data to check in order to verify/detect the file format.
            <para>length (int): The amount of data to check, in bytes... 1000 (min) to 100000 (max). If the value specified is outside this range, it is automatically capped.</para>
            </summary>
            <remarks>
            <para>Of the file formats supported as standard, this setting only affects the detection of MP3/MP2/MP1 formats, 
            but it may also be used by add-ons (see the documentation). For internet (and "buffered" user file) streams, a quarter of the length is used, up to a minimum of 1000 bytes.</para>
            <para>The verification length excludes any tags that may be at the start of the file. The default length is 16000 bytes.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATETHREADS">
            <summary>
            The number of threads to use for updating playback buffers.
            <para>threads (int): The number of threads to use... 0 = disable automatic updating.</para>
            </summary>
            <remarks>
            The number of update threads determines how many HSTREAM/HMUSIC channel playback buffers can be updated in parallel; 
            each thread can process one channel at a time. The default is to use a single thread, but additional threads can be used to take advantage of multiple CPU cores. 
            There is generally nothing much to be gained by creating more threads than there are CPU cores, but one benefit of using multiple threads even with a single CPU core is that a slow updating channel need not delay the updating of other channels.
            <para>When automatic updating is disabled (threads = 0), <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> should be used instead.</para>
            <para>The number of update threads can be changed at any time, including during playback.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_AC3_DYNRNG">
            <summary>
            AC3 add-on: dynamic range compression option
            <para>dynrng (bool): If TRUE dynamic range compression is enbaled (default is FALSE).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_WMA_PREBUF">
            <summary>
            WMA add-on: Prebuffer internet streams on creation, before returning from BASS_WMA_StreamCreateFile?
            <para>prebuf (bool): The Windows Media modules must prebuffer a stream before starting decoding/playback of it. This option determines when/where to wait for that to be completed.</para>
            </summary>
            <remarks>
            The Windows Media modules must prebuffer a stream before starting decoding/playback of it. 
            This option determines whether the stream creation function (eg. <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>) will wait for the prebuffering to complete before returning. 
            If playback of a stream is attempted before it has prebuffered, it will stall and then resume once it has finished prebuffering. 
            The prebuffering progress can be monitored via <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> (BASS_FILEPOS_WMA_BUFFER).
            <para>This option is enabled by default.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_WMA_BASSFILE">
            <summary>
            WMA add-on: use BASS file handling.
            <para>bassfile (bool): Default is disabled (FALSE).</para>
            </summary>
            <remarks>
            <para>When enabled (TRUE) BASSWMA uses BASS's file routines when playing local files. It uses the IStream interface to do that.
            This would also allow to support the "offset" parameter for WMA files with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>.
            The downside of enabling this feature is, that it stops playback while encoding from working.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_WMA_NETSEEK">
            <summary>
            WMA add-on: enable network seeking?
            <para>seek (bool): If TRUE seeking in network files/streams is enabled (default is FALSE).</para>
            </summary>
            <remarks>
            <para>If TRUE, it allows seeking before the entire file has been downloaded/cached. Seeking is slow that way, so it's disabled by default.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CD_FREEOLD">
            <summary>
            CD add-on: Automatically free an existing stream when creating a new one on the same drive?
            <para>freeold (bool): Only one stream can exist at a time per CD drive. So if a stream using the same drive already exists, stream creation function calls will fail, unless this config option is enabled to automatically free the existing stream. This is enabled by default.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CD_RETRY">
            <summary>
            CD add-on: Number of times to retry after a read error.
            <para>retries (int): Number of times to retry reading...0 = don't retry. The default is 2 retries.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CD_AUTOSPEED">
            <summary>
            CD add-on: Automatically reduce the read speed when a read error occurs?
            <para>autospd (bool): By default, this option is disabled.</para>
            </summary>
            <remarks>
            <para>If TRUE, the read speed will be halved when a read error occurs, before retrying (if the BASS_CONFIG_CD_RETRY config setting allows).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CD_SKIPERROR">
            <summary>
            CD add-on: Skip past read errors?
            <para>skip (bool): If TRUE, reading will skip onto the next frame when a read error occurs, otherwise reading will stop.</para>
            </summary>
            <remarks>
            <para>When skipping an error, it will be replaced with silence, so that the track length is unaffected. Before skipping past an error, BASSCD will first retry according to the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CD_RETRY"/> setting.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_ENCODE_PRIORITY">
            <summary>
            ENC add-on: Encoder DSP priority (default -1000)
            <para>priority (int): The priorty determines where in the DSP chain the encoding is performed - all DSP with a higher priority will be present in the encoding. Changes only affect subsequent encodings, not those that have already been started. The default priority is -1000.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_ENCODE_CAST_TIMEOUT">
            <summary>
            ENC add-on: The time to wait to send data to a cast server (default 5000ms)
            <para>timeout (int): The time to wait, in milliseconds.</para>
            </summary>
            <remarks>
            When an attempt to send data is timed-out, the data is discarded. <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/> can be used to receive a notification of when this happens.
            <para>The default timeout is 5 seconds (5000 milliseconds). Changes take immediate effect.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIDI_COMPACT">
            <summary>
            MIDI add-on: Automatically compact all soundfonts following a configuration change?
            <para>compact (bool): If TRUE, all soundfonts are compacted following a MIDI stream being freed, or a BASS_MIDI_StreamSetFonts call.</para>
            </summary>
            <remarks>
            <para>The compacting isn't performed immediately upon a MIDI stream being freed or <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/> being called. It's actually done 2 seconds later (in another thread), so that if another MIDI stream starts using the soundfonts in the meantime, they aren't needlessly closed and reopened. By default, this option is enabled.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIDI_VOICES">
            <summary>
            MIDI add-on: The maximum number of samples to play at a time (polyphony).
            <para>voices (int): Maximum number of samples to play at a time... 1 (min) - 256 (max).</para>
            </summary>
            <remarks>
            <para>This setting determines the maximum number of samples that can play together in a single MIDI stream. This isn't necessarily the same thing as the maximum number of notes, due to presets often layering multiple samples. When there are no voices available to play a new sample, the voice with the lowest volume will be killed to make way for it.</para>
            <para>Changing this setting only affects subsequently created MIDI streams, not any that have already been created. The default setting is 128 voices.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIDI_AUTOFONT">
            <summary>
            MIDI add-on: Automatically load matching soundfonts?
            <para>autofont (bool): If TRUE, BASSMIDI will try to load a soundfont matching the MIDI file.</para>
            </summary>
            <remarks>
            <para>This option only applies to local MIDI files, loaded using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> via the plugin system). BASSMIDI won't look for matching soundfonts for MIDI files loaded from the internet.</para>
            <para>By default, this option is enabled.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIXER_FILTER">
            <summary>
            Mix add-on: The order of filter used to reduce aliasing.
            <para>order (int): The filter order... 2 (min) to 50 (max), and even. If the value specified is outside this range, it is automatically capped.</para>
            </summary>
            <remarks>
            The filter order determines how abruptly the level drops at the cutoff frequency, or the roll-off. The levels rolls off at 6 dB per octave for each order. For example, a 4th order filter will roll-off at 24 dB per octave. A low order filter may result in some aliasing persisting, and sounds close to the cutoff frequency being attenuated. 
            Higher orders reduce those things, but require more processing.
            <para>By default, a 4th order filter is used. Changes only affect channels that are subsequently plugged into a mixer, not those that are already plugged in.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIXER_BUFFER">
            <summary>
            Mix add-on: The source channel buffer size multiplier.
            <para>multiple (int): The buffer size multiplier... 1 (min) to 5 (max). If the value specified is outside this range, it is automatically capped.</para>
            </summary>
            <remarks>
            When a source channel has buffering enabled, the mixer will buffer the decoded data, so that it is available to the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/> functions. 
            To reach the source channel's buffer size, the multiplier (multiple) is applied to the BASS_CONFIG_BUFFER setting at the time of the mixer's creation. If the source is played at it's default rate, then the buffer only need to be as big as the mixer's buffer. 
            But if it's played at a faster rate, then the buffer needs to be bigger for it to contain the data that is currently being heard from the mixer. For example, playing a channel at 2x its normal speed would require the buffer to be 2x the normal size (multiple = 2).
            <para>Larger buffers obviously require more memory, so the multiplier should not be set higher than necessary.</para>
            <para>The default multiplier is 2x. Changes only affect subsequently setup channel buffers. An existing channel can have its buffer reinitilized by disabling and then re-enabling the BASS_MIXER_BUFFER flag using <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.BASSDeviceInfo">
            <summary>
            BASS_DEVICEINFO flags to be used with <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_NONE">
            <summary>
            The device is not enabled and not initialized.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_ENABLED">
            <summary>
            The device is enabled. It will not be possible to initialize the device if this flag is not present.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_DEFAULT">
            <summary>
            The device is the system default.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_INIT">
            <summary>
            The device is initialized, ie. <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has been called.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSInfo">
            <summary>
            BASS_INFO flags to be used with <see cref="T:Un4seen.Bass.BASS_INFO"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_NONE">
            <summary>
            Non of the falgs are set
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_CONTINUOUSRATE">
            <summary>
            The device supports all sample rates between minrate and maxrate.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_EMULDRIVER">
            <summary>
            The device's drivers do NOT have DirectSound support, so it is being emulated. Updated drivers should be installed.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_CERTIFIED">
            <summary>
            The device driver has been certified by Microsoft. This flag is always set on WDM drivers.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_SECONDARYMONO">
            <summary>
            Mono samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_SECONDARYSTEREO">
            <summary>
            Stereo samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_SECONDARY8BIT">
            <summary>
            8-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_SECONDARY16BIT">
            <summary>
            16-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSRecordInfo">
            <summary>
            BASS_RECORDINFO flags to be used with <see cref="T:Un4seen.Bass.BASS_RECORDINFO"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordInfo.DSCAPS_NONE">
            <summary>
            Non of the flags is set
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordInfo.DSCAPS_EMULDRIVER">
            <summary>
            The device's drivers do NOT have DirectSound support, so it is being emulated. Updated drivers should be installed.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordInfo.DSCAPS_CERTIFIED">
            <summary>
            The device driver has been certified by Microsoft. This flag is always set on WDM drivers.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSRecordFormat">
            <summary>
            Formats field of BASS_RECORDINFO to be used with <see cref="T:Un4seen.Bass.BASS_RECORDINFO"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_UNKNOWN">
            <summary>
            unknown format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_1M08">
            <summary>
            11.025 kHz, Mono,   8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_1S08">
            <summary>
            11.025 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_1M16">
            <summary>
            11.025 kHz, Mono,   16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_1S16">
            <summary>
            11.025 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_2M08">
            <summary>
            22.05  kHz, Mono,   8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_2S08">
            <summary>
            22.05  kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_2M16">
            <summary>
            22.05  kHz, Mono,   16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_2S16">
            <summary>
            22.05  kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_4M08">
            <summary>
            44.1   kHz, Mono,   8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_4S08">
            <summary>
            44.1   kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_4M16">
            <summary>
            44.1   kHz, Mono,   16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_4S16">
            <summary>
            44.1   kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_48M08">
            <summary>
            48 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_48S08">
            <summary>
            48 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_48M16">
            <summary>
            48 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_48S16">
            <summary>
            48 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_96M08">
            <summary>
            96 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_96S08">
            <summary>
            96 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_96M16">
            <summary>
            96 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_96S16">
            <summary>
            96 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS3DMode">
            <summary>
            3D Channel Mode flags to be used with e.g. <see cref="T:Un4seen.Bass.BASS_SAMPLE"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DMode.BASS_3DMODE_LEAVECURRENT">
            <summary>
            To be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)"/> in order to leave the current 3D processing mode unchanged.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DMode.BASS_3DMODE_NORMAL">
            <summary>
            normal 3D processing
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DMode.BASS_3DMODE_RELATIVE">
            <summary>
            The channel's 3D position (position/velocity/orientation) are relative to the listener. 
            When the listener's position/velocity/orientation is changed with <see cref="M:Un4seen.Bass.Bass.BASS_Set3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>, the channel's position relative to the listener does not change.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DMode.BASS_3DMODE_OFF">
            <summary>
            Turn off 3D processing on the channel, the sound will be played in the center.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSMode">
            <summary>
            Channel Position Mode flags to be used with e.g. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_BYTES">
            <summary>
            Byte position.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_MUSIC_ORDERS">
            <summary>
            Order.Row position (HMUSIC only).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_MIDI_TICK">
            <summary>
            Tick position (MIDI streams only).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_MUSIC_POSRESET">
            <summary>
            MOD Music Flag: Stop all notes when moving position.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_MUSIC_POSRESETEX">
            <summary>
            MOD Music Flag: Stop all notes and reset bmp/etc when moving position.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_MIXER_NORAMPIN">
            <summary>
            Mixer Flag: Don't ramp-in the start after seeking.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS3DAlgorithm">
            <summary>
            Software 3D mixing algorithm modes to be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> using the BASS_CONFIG_3DALGORITHM.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DAlgorithm.BASS_3DALG_DEFAULT">
            <summary>
            default algorithm (currently translates to BASS_3DALG_OFF)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DAlgorithm.BASS_3DALG_OFF">
            <summary>
            Uses normal left and right panning. The vertical axis is ignored except for scaling of volume due to distance. 
            Doppler shift and volume scaling are still applied, but the 3D filtering is not performed. 
            This is the most CPU efficient software implementation, but provides no virtual 3D audio effect. 
            Head Related Transfer Function processing will not be done. 
            Since only normal stereo panning is used, a channel using this algorithm may be accelerated by a 2D hardware voice if no free 3D hardware voices are available.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DAlgorithm.BASS_3DALG_FULL">
            <summary>
            This algorithm gives the highest quality 3D audio effect, but uses more CPU.
            Requires Windows 98 2nd Edition or Windows 2000 that uses WDM drivers, if this mode is not available then BASS_3DALG_OFF will be used instead.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DAlgorithm.BASS_3DALG_LIGHT">
            <summary>
            This algorithm gives a good 3D audio effect, and uses less CPU than the FULL mode. 
            Requires Windows 98 2nd Edition or Windows 2000 that uses WDM drivers, if this mode is not available then BASS_3DALG_OFF will be used instead.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSStreamProc">
            <summary>
            User sample stream constant to be used with <see cref="T:Un4seen.Bass.STREAMPROC"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamProc.BASS_STREAMPROC_END">
            <summary>
            flag to signify that the end of the stream is reached
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSStreamSystem">
            <summary>
            User file system flag to be used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamSystem.STREAMFILE_NOBUFFER">
            <summary>
            Unbuffered file system (like also used by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>).
            </summary>
            <remarks>
            The unbuffered file system is what is used by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>. In this system, BASS does not do any intermediate buffering - 
            it simply requests data from the file as and when it needs it. This means that reading (<see cref="T:Un4seen.Bass.FILEREADPROC"/>) must be quick, 
            otherwise the decoding will be delayed and playback buffer underruns (old data repeated) are a possibility. 
            It's not so important for seeking (<see cref="T:Un4seen.Bass.FILESEEKPROC"/>) to be fast, as that is generally not required during decoding, except when looping a file.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamSystem.STREAMFILE_BUFFER">
            <summary>
            Buffered file system (like also used by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>).
            </summary>
            <remarks>
            The buffered file system is what is used by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>. 
            As the name suggests, data from the file is buffered so that it's readily available for decoding - 
            BASS creates a thread dedicated to "downloading" the data. This is ideal for when the data is coming from a source that has high latency, like the internet. 
            It's not possible to seek in buffered file streams, until the download has reached the requested position - it's not possible to seek at all if it's being streamed in blocks.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamSystem.STREAMFILE_BUFFERPUSH">
            <summary>
            Buffered, with the data pushed to BASS via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)"/>.
            </summary>
            <remarks>
            The push buffered file system is the same as STREAMFILE_BUFFER, except that instead of the file data being pulled from the <see cref="T:Un4seen.Bass.FILEREADPROC"/> function in a "download" thread, 
            the data is pushed to BASS via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)"/>. A <see cref="T:Un4seen.Bass.FILEREADPROC"/> function is still required, to get the initial data used in the creation of the stream.
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.BASSStreamFilePosition">
            <summary>
            Stream File Position modes to be used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_CURRENT">
            <summary>
            Position that is to be decoded for playback next. This will be a bit ahead of the position actually being heard due to buffering.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_DOWNLOAD">
            <summary>
            Download progress of an internet file stream or "buffered" user file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_END">
            <summary>
            End of the file, in other words the file length. When streaming in blocks, the file length is unknown, so the download buffer length is returned instead.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_START">
            <summary>
            Start of stream data in the file.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_CONNECTED">
            <summary>
            Internet file stream or "buffered" user file stream is still connected? 0 = no, 1 = yes.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_BUFFER">
            <summary>
            The amount of data in the buffer of an internet file stream or "buffered" user file stream. 
            Unless streaming in blocks, this is the same as BASS_FILEPOS_DOWNLOAD.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_WMA_BUFFER">
            <summary>
            WMA add-on: internet buffering progress (0-100%)
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSVam">
            <summary>
            Voice allocation management flags.
            These flags enable hardware resource stealing... if the hardware has no	available voices, a currently playing buffer will be stopped to make room for the new buffer. 
            </summary>
            <remarks>
            NOTE: only samples loaded/created with the BASS_SAMPLE_VAM flag are considered for termination by the DX7 voice management.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSVam.BASS_VAM_HARDWARE">
            <summary>
            Play the sample in hardware. If no hardware voices are available then the "play" call will fail
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSVam.BASS_VAM_SOFTWARE">
            <summary>
            Play the sample in software (ie. non-accelerated). No other VAM flags may be used together with this flag.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSVam.BASS_VAM_TERM_TIME">
            <summary>
            If there are no free hardware voices, the buffer to be terminated will be the one with the least time left to play.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSVam.BASS_VAM_TERM_DIST">
            <summary>
            If there are no free hardware voices, the buffer to be terminated will be one that was loaded/created with the BASS_SAMPLE_MUTEMAX flag and is beyond it's max distance. 
            If there are no buffers that match this criteria, then the "play" call will fail.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSVam.BASS_VAM_TERM_PRIO">
            <summary>
            If there are no free hardware voices, the buffer to be terminated will be the one with the lowest priority.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSFlag">
            <summary>
            Stream/Sample/Music/Recording/BASS_FX create flags to be used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.String,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>, <see cref="T:Un4seen.Bass.BASS_SAMPLE"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/> and 
            <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_ReverseCreate(System.Int32,System.Single,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROCESSPROC)"/>, <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMPROC,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,System.IntPtr)"/> etc.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_DEFAULT">
            <summary>
            0 = default create stream: 16 Bit, stereo, no Float, hardware mixing, no Loop, no 3D, no speaker assignments...
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_8BITS">
            <summary>
            Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit. 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_MONO">
            <summary>
            Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo).
            This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_LOOP">
            <summary>
            Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_3D">
            <summary>
            Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 
            3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_SOFTWARE">
            <summary>
            Force the stream to not use hardware mixing.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_MUTEMAX">
            <summary>
            Sample: muted at max distance (3D only)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_VAM">
            <summary>
            Sample: uses the DX7 voice allocation &amp; management
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FX">
            <summary>
            Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details.
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream. Requires DirectX 8 or above.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT">
            <summary>
            Use 32-bit floating-point sample data (see <a href="../Overview.html#FloatingPoint">Floating-Point Channels</a> for details). WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_RECORD_PAUSE">
            <summary>
            Recording: Start the recording paused. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> to start it.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_STREAM_PRESCAN">
            <summary>
            Enable pin-point accurate seeking (to the exact byte) on the MP3/MP2/MP1 stream.
            This also increases the time taken to create the stream, due to the entire file being pre-scanned for the seek points.
            Note: BASS_STREAM_PRESCAN is ONLY needed for files with a VBR, files with a CBR are always accurate.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_STREAM_AUTOFREE">
            <summary>
            Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_STREAM_RESTRATE">
            <summary>
            Restrict the download rate of the file to the rate required to sustain playback.
            If this flag is not used, then the file will be downloaded as quickly as possible.
            This flag has no effect on "unbuffered" streams (buffer=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_STREAM_BLOCK">
            <summary>
            Download and play the file in smaller chunks.
            Uses a lot less memory than otherwise, but it's not possible to seek or loop the stream - once it's ended, the file must be opened again to play it again. 
            This flag will automatically be applied when the file length is unknown. 
            This flag also has the effect of resticting the download rate. 
            This flag has no effect on "unbuffered" streams (buffer=FALSE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_STREAM_DECODE">
            <summary>
            Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. 
            BASS_SAMPLE_SOFTWARE/3D/FX/AUTOFREE are all ignored when using this flag, as are the SPEAKER flags.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_STREAM_STATUS">
            <summary>
            Pass status info (HTTP/ICY tags) from the server to the DOWNLOADPROC callback during connection. 
            This can be useful to determine the reason for a failure.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_FRONT">
            <summary>
            Front speakers (channel 1/2)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_REAR">
            <summary>
            Rear/Side speakers (channel 3/4)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_CENLFE">
            <summary>
            Center &amp; LFE speakers (5.1, channel 5/6)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_REAR2">
            <summary>
            Rear Center speakers (7.1, channel 7/8)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_LEFT">
            <summary>
            Speaker Modifier: left channel only
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_RIGHT">
            <summary>
            Speaker Modifier: right channel only
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_FRONTLEFT">
            <summary>
            Front Left speaker only (channel 1)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_FRONTRIGHT">
            <summary>
            Front Right speaker only (channel 2)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_REARLEFT">
            <summary>
            Rear/Side Left speaker only (channel 3)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_REARRIGHT">
            <summary>
            Rear/Side Right speaker only (channel 4)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_CENTER">
            <summary>
            Center speaker only (5.1, channel 5)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_LFE">
            <summary>
            LFE speaker only (5.1, channel 6)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_REAR2LEFT">
            <summary>
            Rear Center Left speaker only (7.1, channel 7)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_REAR2RIGHT">
            <summary>
            Rear Center Right speaker only (7.1, channel 8)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR1">
            <summary>
            speakers Pair 1
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR2">
            <summary>
            speakers Pair 2
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR3">
            <summary>
            speakers Pair 3
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR4">
            <summary>
            speakers Pair 4
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR5">
            <summary>
            speakers Pair 5
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR6">
            <summary>
            Speakers Pair 6
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR7">
            <summary>
            Speakers Pair 7
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR8">
            <summary>
            Speakers Pair 8
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR9">
            <summary>
            Speakers Pair 9
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR10">
            <summary>
            Speakers Pair 10
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR11">
            <summary>
            Speakers Pair 11
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR12">
            <summary>
            Speakers Pair 12
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR13">
            <summary>
            Speakers Pair 13
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR14">
            <summary>
            Speakers Pair 14
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR15">
            <summary>
            Speakers Pair 15
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_UNICODE">
            <summary>
            File is a Unicode (16-bit characters) filename
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_OVER_VOL">
            <summary>
            Sample: override lowest volume
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_OVER_POS">
            <summary>
            Sample: override longest playing
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_OVER_DIST">
            <summary>
            Sample: override furthest from listener (3D only)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_WV_STEREO">
            <summary>
            WavPack add-on: limit to stereo
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_AC3_DOWNMIX_2">
            <summary>
            AC3 add-on: downmix to stereo
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_AC3_DOWNMIX_4">
            <summary>
            AC3 add-on: downmix to quad
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_AC3_DOWNMIX_DOLBY">
            <summary>
            AC3 add-on: downmix to dolby
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_AC3_DYNAMIC_RANGE">
            <summary>
            AC3 add-on: enable dynamic range compression
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_AAC_STEREO">
            <summary>
            AAC, MP4 add-on: downmatrix to stereo
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_WINAMP_SYNC_BITRATE">
            <summary>
            Winamp add-on: synchronize bitrate between Bass and Winamp
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_END">
            <summary>
            Mix Add-On: end the stream when there are no sources
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_PAUSE">
            <summary>
            Mix Add-On: don't process the source
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_NONSTOP">
            <summary>
            Mix Add-On: don't stall when there are no sources
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_RESUME">
            <summary>
            Mix Add-On: resume a stalled mixer immediately upon new/unpaused source
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_MATRIX">
            <summary>
            Mix Add-On: Matrix mixing
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_DOWNMIX">
            <summary>
            Mix Add-On: downmix to stereo (or mono if mixer is mono)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_NORAMPIN">
            <summary>
            Mix Add-On: don't ramp-in the start
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_FILTER">
            <summary>
            Mix add-on: filter the sample data when resampling.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_BUFFER">
            <summary>
            Mix add-on: buffer source data for <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_CD_SUBCHANNEL">
            <summary>
            Cd Add-On: Read sub-channel data. 96 bytes of de-interleaved sub-channel data will be returned after each 2352 bytes of audio. This flag can not be used with the BASS_SAMPLE_FLOAT flag, and is ignored if the BASS_STREAM_DECODE flag is not used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_CD_SUBCHANNEL_NOHW">
            <summary>
            Cd Add-On: Read sub-channel data, without using any hardware de-interleaving. This is identical to the BASS_CD_SUBCHANNEL flag, except that the de-interleaving is always performed by BASSCD even if the drive is apparently capable of de-interleaving itself.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_DECAYEND">
            <summary>
            Midi Add-On: Let the ending decay naturally, instead of stopping abruptly at the end of the file. This doesn't apply when looping. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_NOFX">
            <summary>
            Midi Add-On: Disable the MIDI reverb/chorus processing. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_FX_FREESOURCE">
            <summary>
            BASS_FX Add-On: Free the source handle as well?
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_FX_BPM_BKGRND">
            <summary>
            BASS_FX Add-On: If in use, then you can do other stuff while detection's in process.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_FX_BPM_MULT2">
            <summary>
            BASS_FX Add-On: If in use, then will auto multiply bpm by 2 (if BPM &lt; MinBPM*2)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_FLOAT">
            <summary>
            Music: Use 32-bit floating-point sample data (see <a href="../Overview.html#FloatingPoint">Floating-Point Channels</a> for details). WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_MONO">
            <summary>
            Music: Decode/play the mod music in mono, reducing the CPU usage (if it was originally stereo).
            This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_LOOP">
            <summary>
            Music: Loop the music. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_3D">
            <summary>
            Music: Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 
            3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_FX">
            <summary>
            Music: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details.
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream. Requires DirectX 8 or above.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_AUTOFREE">
            <summary>
            Music: Automatically free the music when it ends. This allows you to play a music and forget about it, as BASS will automatically free the music's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called. 
            Note that some musics never actually end on their own (ie. without you stopping them). 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_DECODE">
            <summary>
            Music: Decode the music into sample data, without outputting it. 
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. 
            BASS_SAMPLE_SOFTWARE/3D/FX/AUTOFREE are ignored when using this flag, as are the SPEAKER flags.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_PRESCAN">
            <summary>
            Music: Calculate the playback length of the music, and enable seeking in bytes. This slightly increases the time taken to load the music, depending on how long it is. 
            In the case of musics that loop, the length until the loop occurs is calculated. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> to retrieve the length.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_RAMP">
            <summary>
            Music: Use "normal" ramping (as used in FastTracker 2).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_RAMPS">
            <summary>
            Music: Use "sensitive" ramping.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_SURROUND">
            <summary>
            Music: Apply XMPlay's surround sound to the music (ignored in mono).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_SURROUND2">
            <summary>
            Music: Apply XMPlay's surround sound mode 2 to the music (ignored in mono).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_FT2MOD">
            <summary>
            Music: Play .MOD file as FastTracker 2 would.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_PT1MOD">
            <summary>
            Music: Play .MOD file as ProTracker 1 would.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_NONINTER">
            <summary>
            Music: Use non-interpolated mixing. This generally reduces the sound quality, but can be good for chip-tunes.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_SINCINTER">
            <summary>
             Music: Sinc interpolated sample mixing.
            This increases the sound quality, but also requires quite a bit more processing. If neither this or the BASS_MUSIC_NONINTER flag is specified, linear interpolation is used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_POSRESET">
            <summary>
            Music: Stop all notes when seeking (using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>). 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_POSRESETEX">
            <summary>
            Music: Stop all notes and reset bpm/etc when seeking.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_STOPBACK">
            <summary>
            Music: Stop the music when a backward jump effect is played. This stops musics that never reach the end from going into endless loops. 
            Some MOD musics are designed to jump all over the place, so this flag would cause those to be stopped prematurely. 
            If this flag is used together with the BASS_SAMPLE_LOOP flag, then the music would not be stopped but any BASS_SYNC_END sync would be triggered.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_NOSAMPLE">
            <summary>
            Music: Don't load the samples. This reduces the time taken to load the music, notably with MO3 files, which is useful if you just want to get the name and length of the music without playing it.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSChannelType">
            <summary>
            Channel Type flags to be used with <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> (see also <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_UNKNOWN">
            <summary>
            Unknown channel format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_SAMPLE">
            <summary>
            Sample channel. (HCHANNEL)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_RECORD">
            <summary>
            Recording channel. (HRECORD)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_MUSIC_MO3">
            <summary>
            MO3 format music.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM">
            <summary>
            User sample stream. This can also be used as a flag to test if the channel is any kind of HSTREAM.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_OGG">
            <summary>
            OGG format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MP1">
            <summary>
            MP1 format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MP2">
            <summary>
            MP2 format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MP3">
            <summary>
            MP2 format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_AIFF">
            <summary>
            WAV format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MIXER">
            <summary>
            A BASSmix mixer stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WAV">
            <summary>
            WAV format file stream, LOWORD=codec.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WAV_PCM">
            <summary>
            WAV format file stream, PCM 16-bit.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WAV_FLOAT">
            <summary>
            WAV format file stream, FLOAT 32-bit.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_MUSIC_MOD">
            <summary>
            MOD format music. This can also be used as a flag to test if the channel is any kind of HMUSIC.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_MUSIC_MTM">
            <summary>
            MTM format music.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_MUSIC_S3M">
            <summary>
            S3M format music.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_MUSIC_XM">
            <summary>
            XM format music.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_MUSIC_IT">
            <summary>
            IT format music.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WV">
            <summary>
            WavPack Lossless format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WV_H">
            <summary>
             WavPack Hybrid Lossless format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WV_L">
            <summary>
            WavPack Lossy format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WV_LH">
            <summary>
             WavPack Hybrid Lossy format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_CD">
            <summary>
            Audio-CD, CDA
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WMA">
            <summary>
            WMA format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WMA_MP3">
            <summary>
            MP3 over WMA format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_FLAC">
            <summary>
            FLAC format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_OFR">
            <summary>
            Optimfrog format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_APE">
            <summary>
            APE format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MPC">
            <summary>
            MPC format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_AAC">
            <summary>
            AAC format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MP4">
            <summary>
            MP4 format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_SPX">
            <summary>
            Speex format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_ALAC">
            <summary>
            Apple Lossless (ALAC) format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_TTA">
            <summary>
            TTA format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_AC3">
            <summary>
            AC3 format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WINAMP">
            <summary>
            Winamp input format file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MIDI">
            <summary>
            MIDI sound format file stream.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.EAXEnvironment">
            <summary>
            EAX environment constants to be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetEAXParameters(Un4seen.Bass.EAXEnvironment,System.Single,System.Single,System.Single)"/> (int)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_LEAVECURRENT">
            <summary>
            -1 = leave current EAX environment as is
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_GENERIC">
            <summary>
            Generic
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_PADDEDCELL">
            <summary>
            Padded Cell
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_ROOM">
            <summary>
            Room
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_BATHROOM">
            <summary>
            Bathroom
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_LIVINGROOM">
            <summary>
            Livingroom
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_STONEROOM">
            <summary>
            Stoneroom
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_AUDITORIUM">
            <summary>
            Auditorium
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_CONCERTHALL">
            <summary>
            Concert Hall
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_CAVE">
            <summary>
            Cave
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_ARENA">
            <summary>
            Arena
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_HANGAR">
            <summary>
            Hangar
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_CARPETEDHALLWAY">
            <summary>
            Carpeted Hallway
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_HALLWAY">
            <summary>
            Hallway
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_STONECORRIDOR">
            <summary>
            Stone Corridor
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_ALLEY">
            <summary>
            Alley
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_FOREST">
            <summary>
            Forest
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_CITY">
            <summary>
            City
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_MOUNTAINS">
            <summary>
            Mountains
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_QUARRY">
            <summary>
            Quarry
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_PLAIN">
            <summary>
            Plain
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_PARKINGLOT">
            <summary>
            Parkinglot
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_SEWERPIPE">
            <summary>
            Sewer Pipe
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_UNDERWATER">
            <summary>
            Underwater
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_DRUGGED">
            <summary>
            Drugged
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_DIZZY">
            <summary>
            Dizzy
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_PSYCHOTIC">
            <summary>
            Psychotic
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXEnvironment.EAX_ENVIRONMENT_COUNT">
            <summary>
            total number of environments
            </summary>
        </member>
        <member name="T:Un4seen.Bass.EAXPreset">
            <summary>
            EAX environment preset constants to be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetEAXParameters(Un4seen.Bass.EAXEnvironment,System.Single,System.Single,System.Single)"/> (int)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_GENERIC">
            <summary>
            Generic
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_PADDEDCELL">
            <summary>
            Preset Padded Cell
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_ROOM">
            <summary>
            Preset Room
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_BATHROOM">
            <summary>
            Preset Bathroom
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_LIVINGROOM">
            <summary>
            Preset Livingroom
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_STONEROOM">
            <summary>
            Preset Stoneroom
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_AUDITORIUM">
            <summary>
            Preset Auditorium
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_CONCERTHALL">
            <summary>
            Preset Concert Hall
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_CAVE">
            <summary>
            Preset Cave
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_ARENA">
            <summary>
            Preset Arena
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_HANGAR">
            <summary>
            Preset Hangar
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_CARPETEDHALLWAY">
            <summary>
            Preset Carpeted Hallway
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_HALLWAY">
            <summary>
            Preset Hallway
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_STONECORRIDOR">
            <summary>
            Preset Stone Corridor
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_ALLEY">
            <summary>
            Preset Alley
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_FOREST">
            <summary>
            Preset Forest
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_CITY">
            <summary>
            Preset City
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_MOUNTAINS">
            <summary>
            Preset Mountains
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_QUARRY">
            <summary>
            Preset Quarry
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_PLAIN">
            <summary>
            Preset Plain
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_PARKINGLOT">
            <summary>
            Preset Parkinglot
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_SEWERPIPE">
            <summary>
            Preset Sewer Pipe
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_UNDERWATER">
            <summary>
            Preset Underwater
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_DRUGGED">
            <summary>
            Preset Drugged
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_DIZZY">
            <summary>
            Preset Dizzy
            </summary>
        </member>
        <member name="F:Un4seen.Bass.EAXPreset.EAX_PRESET_PSYCHOTIC">
            <summary>
            Preset Psychotic
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSData">
            <summary>
            Flags to be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_AVAILABLE">
            <summary>
            Query how much data is buffered
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT_INDIVIDUAL">
            <summary>
            FFT flag: FFT for each channel, else all combined
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT_NOWINDOW">
            <summary>
            FFT flag: no Hanning window
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FLOAT">
            <summary>
            flag: return floating-point sample data
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT256">
            <summary>
            256 sample FFT (returns 128 floating-point values)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT512">
            <summary>
            512 sample FFT (returns 256 floating-point values)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT1024">
            <summary>
            1024 sample FFT (returns 512 floating-point values)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT2048">
            <summary>
            2048 sample FFT (returns 1024 floating-point values)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT4096">
            <summary>
            4096 sample FFT (returns 2048 floating-point values)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT8192">
            <summary>
            8192 sample FFT (returns 4096 floating-point values)
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSActive">
            <summary>
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> return values.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSActive.BASS_ACTIVE_STOPPED">
            <summary>
            The channel is not active, or handle is not a valid channel.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSActive.BASS_ACTIVE_PLAYING">
            <summary>
            The channel is playing (or recording).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSActive.BASS_ACTIVE_STALLED">
            <summary>
            Playback of the stream has been stalled due to there not being enough sample data to continue playing. The playback will automatically resume once there's sufficient data to do so.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSActive.BASS_ACTIVE_PAUSED">
            <summary>
            The channel is paused.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSInput">
            <summary>
            <see cref="M:Un4seen.Bass.Bass.BASS_RecordSetInput(System.Int32,Un4seen.Bass.BASSInput,System.Single)"/> flags.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInput.BASS_INPUT_NONE">
            <summary>
            No input flag change.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInput.BASS_INPUT_OFF">
            <summary>
            Disable the input. This flag can't be used when the device supports only one input at a time.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInput.BASS_INPUT_ON">
            <summary>
            Enable the input. If the device only allows one input at a time, then any previously enabled input will be disabled by this.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSInputType">
            <summary>
            <see cref="M:Un4seen.Bass.Bass.BASS_RecordSetInput(System.Int32,Un4seen.Bass.BASSInput,System.Single)"/> flags.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_ERROR">
            <summary>
            The type of input is errorness.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_MASK">
            <summary>
            The type of input is also indicated in the high 8-bits of <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32,System.Single@)"/> (use BASS_INPUT_TYPE_MASK to test the return value).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_UNDEF">
            <summary>
            Anything that is not covered by the other types
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_DIGITAL">
            <summary>
            Digital input source, for example, a DAT or audio CD.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_LINE">
            <summary>
            Line-in. On some devices, "Line-in" may be combined with other analog sources into a single BASS_INPUT_TYPE_ANALOG input.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_MIC">
            <summary>
            Microphone.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_SYNTH">
            <summary>
            Internal MIDI synthesizer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_CD">
            <summary>
            Analog audio CD.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_PHONE">
            <summary>
            Telephone.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_SPEAKER">
            <summary>
            PC speaker.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_WAVE">
            <summary>
            The device's WAVE/PCM output.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_AUX">
            <summary>
            Auxiliary. Like "Line-in", "Aux" may be combined with other analog sources into a single BASS_INPUT_TYPE_ANALOG input on some devices.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_ANALOG">
            <summary>
            Analog, typically a mix of all analog sources (what you hear).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSTag">
            <summary>
            Types of what's returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_ID3">
            <summary>
            ID3v1 tags : A pointer to a 128 byte block is returned. See <a href="http://www.id3.org/id3v1.html">www.id3.org</a> for details of the block's structure.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_ID3V2">
            <summary>
            ID3v2 tags : A pointer to a variable length block is returned. See <a href="http://www.id3.org">www.id3.org</a> for details of the block's structure.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_OGG">
            <summary>
            OGG comments : Only available when streaming an OGG file. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_HTTP">
            <summary>
            HTTP headers : Only available when streaming from a HTTP server. A pointer to a series of null-terminated ANSI strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_ICY">
            <summary>
            ICY headers : A pointer to a series of null-terminated ANSI strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_META">
            <summary>
            ICY (Shoutcast) metadata :  A single null-terminated ANSI string containing the current stream title and url (usually omitted). The format of the string is: StreamTitle='xxx';StreamUrl='xxx';
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_APE">
            <summary>
            APE tags : Only available when streaming an APE file. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MP4">
            <summary>
            iTunes/MP4 metadata : Only available when streaming a MP4 file. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_WMA">
            <summary>
            WMA header tags: WMA tags : Only available when streaming a WMA file. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_VENDOR">
            <summary>
            OGG encoder : A single null-terminated UTF-8 string.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_LYRICS3">
            <summary>
            Lyric3v2 tag : A single ANSI string is returned, containing the Lyrics3v2 information. See <a href="http://www.id3.org/Lyrics3v2">www.id3.org/Lyrics3v2</a> for details of its format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_WMA_META">
            <summary>
            WMA mid-stream tag: a single UTF-8 string.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_INFO">
            <summary>
            RIFF/WAVE tags : array of null-terminated ANSI strings.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MUSIC_NAME">
            <summary>
            MOD music name : a single ANSI string.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MUSIC_MESSAGE">
            <summary>
            MOD message : a single ANSI string.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MUSIC_INST">
            <summary>
            + instrument#, MOD instrument name : ANSI string
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MUSIC_SAMPLE">
            <summary>
            + sample#, MOD sample name : ANSI string
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MIDI_TRACK">
            <summary>
            + track#, track text : array of null-terminated ANSI strings
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_UNKNOWN">
            <summary>
            Unknown tags : not supported tags
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSAttribute">
            <summary>
            Channel attribute options used by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_FREQ">
            <summary>
            The sample rate of a channel.
            <para>freq: The sample rate... 100 (min) to 100000 (max), 0 = original rate (when the channel was created). The value will be rounded down to a whole number.</para>
            </summary>
            <remarks>
            <para>This attribute applies to playback of the channel, and does not affect the channel's sample data, so has no real effect on decoding channels. It is still adjustable though, so that it can be used by the <see cref="N:Un4seen.Bass.AddOn.Mix">BassMix</see> add-on, and anything else that wants to use it.</para>
            <para>Although the standard valid sample rate range is 100 to 100000, some devices/drivers may have a different valid range. See the minrate and maxrate members of the <see cref="T:Un4seen.Bass.BASS_INFO"/> structure.</para>
            <para>It is not possible to change the sample rate of a channel if the "with FX flag" <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a> enabled on it, unless DirectX 9 or above is installed.</para>
            <para>It requires an increased amount of CPU processing to play MOD musics and streams at increased sample rates. If you plan to play MOD musics or streams at greatly increased sample rates, then you should increase the buffer lengths (<see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/>) to avoid possible break-ups in the sound.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_VOL">
            <summary>
            The volume level of a channel.
            <para>volume: The volume level... 0 (silent) to 1 (full).</para>
            </summary>
            <remarks>
            <para>This attribute applies to playback of the channel, and does not affect the channel's sample data, so has no real effect on decoding channels. It is still adjustable though, so that it can be used by the <see cref="N:Un4seen.Bass.AddOn.Mix">BassMix</see> add-on, and anything else that wants to use it.</para>
            <para>When using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSlideAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single,System.Int32)"/> to slide this attribute, a negative volume value can be used to fade-out and then stop the channel.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_PAN">
            <summary>
            The panning/balance position of a channel.
            <para>pan: The pan position... -1 (full left) to +1 (full right), 0 = centre.</para>
            </summary>
            <remarks>
            <para>This attribute applies to playback of the channel, and does not affect the channel's sample data, so has no real effect on decoding channels. It is still adjustable though, so that it can be used by the <see cref="N:Un4seen.Bass.AddOn.Mix">BassMix</see> add-on, and anything else that wants to use it.</para>
            <para>It is not possible to set the pan position of a 3D channel. It is also not possible to set the pan position when using <a href="../Overview.html#SpeakerAssignement">speaker assignment</a>, but if needed, it can be done via a <see cref="T:Un4seen.Bass.DSPPROC">DSP function</see> instead (not on mono channels).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_EAXMIX">
            <summary>
            The wet (reverb) / dry (no reverb) mix ratio on a sample, stream, or MOD music channel with 3D functionality.
            <para>mix: The wet / dry ratio... 0 (full dry) to 1 (full wet), -1 = automatically calculate the mix based on the distance (the default).</para>
            </summary>
            <remarks>
            <para>Obviously, EAX functions have no effect if the output device does not support EAX. <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> can be used to check that. EAX only affects 3D channels, but EAX functions do not require <see cref="M:Un4seen.Bass.Bass.BASS_Apply3D"/> to apply the changes.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">Additional ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_NOEAX</term><description>The channel does not have EAX support. EAX only applies to 3D channels that are mixed by the hardware/drivers. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> can be used to check if a channel is being mixed by the hardware.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_AMPLIFY">
            <summary>
            The amplification level of a MOD music.
            <para>amp: Amplification level... 0 (min) to 100 (max). This will be rounded down to a whole number.</para>
            </summary>
            <remarks>
            <para>As the amplification level get's higher, the sample data's range increases, and therefore, the resolution increases. But if the level is set too high, then clipping can occur, which can result in distortion of the sound.</para>
            <para>You can check the current level of a MOD music at any time by using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>. By doing so, you can decide if a MOD music's amplification level needs adjusting.</para>
            <para>The default amplification level is 50.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_PANSEP">
            <summary>
            The pan separation level of a MOD music.
            <para>pansep: Pan separation... 0 (min) to 100 (max), 50 = linear. This will be rounded down to a whole number.</para>
            </summary>
            <remarks>
            <para>By default BASS uses a linear panning "curve". If you want to use the panning of FT2, use a pan separation setting of around 35. To use the Amiga panning (ie. full left and right) set it to 100.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_PSCALER">
            <summary>
            The position scaler of a MOD music.
            <para>scale: The scaler... 1 (min) to 256 (max). This will be rounded down to a whole number.</para>
            </summary>
            <remarks>
            <para>When calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>, the row (HIWORD) will be scaled by this value. By using a higher scaler, you can get a more precise position indication.</para>
            <para>The default scaler is 1.</para>
            </remarks>
            <example>
            Get the position of a MOD music accurate to within a 10th of a row:
            <code>
            // set the scaler
            Bass.BASS_ChannelSetAttribute(music, BASSAttribute.BASS_ATTRIB_MUSIC_PSCALER, 10f);
            int pos = Bass.BASS_MusicGetOrderPosition(music);
            // the order
            int order = Utils.LowWord32(pos);
            // the row
            int row = HighWord32(pos) / 10;
            // the 10th of a row
            int row10th = HighWord32(pos) % 10;
            </code>
            <code lang="vbnet">
            ' set the scaler
            Bass.BASS_ChannelSetAttribute(music, BASSAttribute.BASS_ATTRIB_MUSIC_PSCALER, 10F)
            Dim pos As Integer = Bass.BASS_MusicGetOrderPosition(music)
            ' the order
            Dim order As Integer = Utils.LowWord32(pos)
            ' the row
            Dim row As Integer = HighWord32(pos) / 10
            ' the 10th of a row
            Dim row10th As Integer = HighWord32(pos) Mod 10
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_BPM">
            <summary>
            The BPM of a MOD music.
            <para>bpm: The BPM... 1 (min) to 255 (max). This will be rounded down to a whole number.</para>
            </summary>
            <remarks>
            <para>This attribute is a direct mapping of the MOD's BPM, so the value can be changed via effects in the MOD itself.</para>
            <para>Note that by changing this attribute, you are changing the playback length.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_SPEED">
            <summary>
            The speed of a MOD music.
            <para>speed: The speed... 0 (min) to 255 (max). This will be rounded down to a whole number.</para>
            </summary>
            <remarks>
            <para>This attribute is a direct mapping of the MOD's speed, so the value can be changed via effects in the MOD itself.</para>
            <para>The "speed" is the number of ticks per row. Setting it to 0, stops and ends the music. Note that by changing this attribute, you are changing the playback length.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_VOL_GLOBAL">
            <summary>
            The global volume level of a MOD music.
            <para>volume: The global volume level... 0 (min) to 64 (max, 128 for IT format). This will be rounded down to a whole number.</para>
            </summary>
            <remarks>
            <para>This attribute is a direct mapping of the MOD's global volume, so the value can be changed via effects in the MOD itself.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_VOL_CHAN">
            <summary>
            The volume level of a channel in a MOD music + <i>channel#</i>.
            <para>channel: The channel to set the volume of... 0 = 1st channel.</para>
            <para>volume: The volume level... 0 (silent) to 1 (full).</para>
            </summary>
            <remarks>
            <para>The volume curve used by this attribute is always linear, eg. 0.5 = 50%. The <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CURVE_VOL"/> config option setting has no effect on this. The volume level of all channels is initially 1 (full).</para>
            <para>This attribute can also be used to count the number of channels in a MOD Music.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            </remarks>
            <example>
            Count the number of channels in a MOD music:
            <code>
            int channels = 0;
            float dummy;
            while (Bass.BASS_ChannelGetAttribute(music, (BASSAttribute)((int)BASS_ATTRIB_MUSIC_VOL_CHAN + channels), ref dummy))
            {
              channels++; 
            }
            </code>
            <code lang="vbnet">
            Dim channels As Integer = 0
            Dim dummy As Single
            While Bass.BASS_ChannelGetAttribute(music, CType(CInt(BASS_ATTRIB_MUSIC_VOL_CHAN) + channels, BASSAttribute), dummy)
              channels += 1
            End While
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_VOL_INST">
            <summary>
            The volume level of an instrument in a MOD music + <i>inst#</i>.
            <para>inst: The instrument to set the volume of... 0 = 1st instrument.</para>
            <para>volume: The volume level... 0 (silent) to 1 (full).</para>
            </summary>
            <remarks>
            <para>The volume curve used by this attribute is always linear, eg. 0.5 = 50%. The <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CURVE_VOL"/> config option setting has no effect on this. The volume level of all instruments is initially 1 (full). For MOD formats that do not use instruments, read "sample" for "instrument".</para>
            <para>This attribute can also be used to count the number of instruments in a MOD music.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            </remarks>
            <example>
            Count the number of instruments in a MOD music:
            <code>
            int instruments = 0;
            float dummy;
            while (Bass.BASS_ChannelGetAttribute(music, (BASSAttribute)((int)BASS_ATTRIB_MUSIC_VOL_INST + instruments), ref dummy))
            {
              instruments++; 
            }
            </code>
            <code lang="vbnet">
            Dim instruments As Integer = 0
            Dim dummy As Single
            While Bass.BASS_ChannelGetAttribute(music, CType(CInt(BASS_ATTRIB_MUSIC_VOL_INST) + instruments, BASSAttribute), dummy)
              instruments += 1
            End While
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO">
            <summary>
            BASS_FX Tempo: The Tempo in percents (-95%..0..+5000%).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_PITCH">
            <summary>
            BASS_FX Tempo: The Pitch in semitones (-60..0..+60).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_FREQ">
            <summary>
            BASS_FX Tempo: The Samplerate in Hz, but calculates by the same % as BASS_ATTRIB_TEMPO.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_USE_AA_FILTER">
            <summary>
            BASS_FX Tempo Option: Use FIR low-pass (anti-alias) filter (gain speed, lose quality)? TRUE=1 (default), FALSE=0.
            </summary>
            <remarks>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_AA_FILTER_LENGTH">
            <summary>
            BASS_FX Tempo Option: FIR low-pass (anti-alias) filter length in taps (8 .. 128 taps, default = 32, should be %4).
            </summary>
            <remarks>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_USE_QUICKALGO">
            <summary>
            BASS_FX Tempo Option: Use quicker tempo change algorithm (gain speed, lose quality)? TRUE=1, FALSE=0 (default).
            </summary>
            <remarks>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_SEQUENCE_MS">
            <summary>
            BASS_FX Tempo Option: Tempo Sequence in milliseconds (default = 82).
            </summary>
            <remarks>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_SEEKWINDOW_MS">
            <summary>
            BASS_FX Tempo Option: SeekWindow in milliseconds (default = 14).
            </summary>
            <remarks>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_OVERLAP_MS">
            <summary>
            BASS_FX Tempo Option: Tempo Overlap in milliseconds (default = 12).
            </summary>
            <remarks>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_REVERSE_DIR">
            <summary>
            BASS_FX Reverse: The Playback direction (-1=BASS_FX_RVS_REVERSE or 1=BASS_FX_RVS_FORWARD).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_PPQN">
            <summary>
            BASSMIDI: Gets the PPQN (or ticks per beat) of the MIDI file.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSSync">
            <summary>
            Sync types to be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> (param flag) and <see cref="T:Un4seen.Bass.SYNCPROC"/> (data flag).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_POS">
            <summary>
            Sync when a channel reaches a position.
            <para>param : position in bytes</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MUSICINST">
            <summary>
            Sync when an instrument (sample for the non-instrument based formats) is played in a MOD music (not including retrigs).
            <para>param : LOWORD=instrument (1=first) HIWORD=note (0=c0...119=b9, -1=all)</para>
            <para>data : LOWORD=note HIWORD=volume (0-64)</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_END">
            <summary>
            Sync when a channel reaches the end.
            <para>param : not used</para>
            <para>data : 1 = the sync is triggered by a backward jump in a MOD music, otherwise not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MUSICFX">
            <summary>
            Sync when the "sync" effect (XM/MTM/MOD: E8x/Wxx, IT/S3M: S2x) is used.
            <para>param : 0:data=pos, 1:data="x" value</para>
            <para>data : param=0: LOWORD=order HIWORD=row, param=1: "x" value</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_META">
            <summary>
            Sync when metadata is received in a stream.
            <para>param : not used</para>
            <para>data : not used - the updated metadata is available from <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_META)</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_SLIDE">
            <summary>
            Sync when an attribute slide is completed.
            <para>param : not used</para>
            <para>data : the type of slide completed (one of the BASS_SLIDE_xxx values)</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_STALL">
            <summary>
            Sync when playback has stalled.
            <para>param : not used</para>
            <para>data : 0=stalled, 1=resumed</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_DOWNLOAD">
            <summary>
            Sync when downloading of an internet (or "buffered" user file) stream has ended.
            <para>param : not used</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_FREE">
            <summary>
            Sync when a channel is freed.
            <para>param : not used</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MUSICPOS">
            <summary>
            Sync when a MOD music reaches an order:row position.
            <para>param : LOWORD=order (0=first, -1=all) HIWORD=row (0=first, -1=all)</para>
            <para>data : LOWORD=order HIWORD=row</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_SETPOS">
            <summary>
            Sync when seeking (inc. looping and restarting). So it could be used to reset DSP/etc.
            <para>param : position in bytes</para>
            <para>data : 0=playback is unbroken, 1=if is it broken (eg. buffer flushed). The latter would be the time to reset DSP/etc.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_OGG_CHANGE">
            <summary>
            Sync when a new logical bitstream begins in a chained OGG stream. Updated tags are available from <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            <para>param : not used</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIXTIME">
            <summary>
            FLAG: sync at mixtime, else at playtime
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_ONETIME">
            <summary>
            FLAG: sync only once, else continuously
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIXER_ENVELOPE">
            <summary>
            MIX add-on: Sync when an envelope reaches the end.
            <para>param : not used</para>
            <para>data : envelope type</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_WMA_CHANGE">
            <summary>
            WMA add-on: Sync on a track change in a server-side playlist. Updated tags are available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            <para>param : not used</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_WMA_META">
            <summary>
            WMA add-on: Sync on a mid-stream tag change in a server-side playlist. Updated tags are available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            <para>param : not used</para>
            <para>data : not used - the updated metadata is available from <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_WMA_META)</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_CD_ERROR">
            <summary>
            CD add-on: Sync when playback is stopped due to an error. For example, the drive door being opened.
            <para>param : not used</para>
            <para>data : the position that was being read from the CD track at the time.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_CD_SPEED">
            <summary>
            CD add-on: Sync when the read speed is automatically changed due to the BASS_CONFIG_CD_AUTOSPEED setting.
            <para>param : not used</para>
            <para>data : the new read speed.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_WINAMP_SYNC_BITRATE">
            <summary>
            WINAMP add-on: Sync when bitrate is changed or retrieved from a winamp input plug-in.
            <para>param : not used</para>
            <para>data : the bitrate retrieved from the winamp input plug-in - called when it is retrieved or changed (VBR MP3s, OGGs, etc).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_MARKER">
            <summary>
            MIDI add-on: Sync when a marker is encountered.
            <para>param : not used</para>
            <para>data : the marker index, which can be used in a <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> call.</para>
            </summary>
            <example>
            <code>
            private void MidiSync(int handle, int channel, int data, IntPtr user)
            {
              BASS_MIDI_MARK mark = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_MARKER, data);
              ...
            }
            </code>
            <code lang="vbnet">
            Private Sub MidiSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              Dim mark As BASS_MIDI_MARK = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_MARKER, data)
              ...
            End Sub
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_CUE">
            <summary>
            MIDI add-on: Sync when a cue is encountered.
            <para>param : not used</para>
            <para>data : the marker index, which can be used in a <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> call.</para>
            </summary>
            <example>
            <code>
            private void MidiSync(int handle, int channel, int data, IntPtr user)
            {
              BASS_MIDI_MARK mark = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_CUE, data);
              ...
            }
            </code>
            <code lang="vbnet">
            Private Sub MidiSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              Dim mark As BASS_MIDI_MARK = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_CUE, data)
              ...
            End Sub
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_LYRIC">
            <summary>
            MIDI add-on: Sync when a lyric event is encountered.
            <para>param : not used</para>
            <para>data : the marker index, which can be used in a <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> call.
            If the text begins with a '/' (slash) character, a new line should be started. If it begins with a '\' (backslash) character, the display should be cleared.</para>
            </summary>
            <example>
            <code>
            private void MidiSync(int handle, int channel, int data, IntPtr user)
            {
              BASS_MIDI_MARK mark = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_LYRIC, data);
              ...
            }
            </code>
            <code lang="vbnet">
            Private Sub MidiSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              Dim mark As BASS_MIDI_MARK = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_LYRIC, data)
              ...
            End Sub
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_TEXT">
            <summary>
            MIDI add-on: Sync when a text event is encountered.
            <para>param : not used</para>
            <para>data : the marker index, which can be used in a <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> call.
            Lyrics can sometimes be found in BASS_MIDI_MARK_TEXT instead of BASS_MIDI_MARK_LYRIC markers.</para>
            </summary>
            <example>
            <code>
            private void MidiSync(int handle, int channel, int data, IntPtr user)
            {
              BASS_MIDI_MARK mark = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_SYNC_MIDI_TEXT, data);
              ...
            }
            </code>
            <code lang="vbnet">
            Private Sub MidiSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              Dim mark As BASS_MIDI_MARK = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_SYNC_MIDI_TEXT, data)
              ...
            End Sub
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_EVENT">
            <summary>
            MIDI add-on: Sync when a type of event is processed, in either a MIDI file or <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/>.
            <para>param : event type.</para>
            <para>data : LOWORD = event parameter, HIWORD = channel. See <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> for a list of event types and their parameters.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_TICK">
            <summary>
            MIDI add-on: Sync when reaching a tick position.
            <para>param : tick position.</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSFXType">
            <summary>
            FX effect types, use with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_CHORUS">
            <summary>
            DX8 Chorus. Use <see cref="T:Un4seen.Bass.BASS_DX8_CHORUS"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_COMPRESSOR">
            <summary>
            DX8 Compressor. Use <see cref="T:Un4seen.Bass.BASS_DX8_COMPRESSOR"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_DISTORTION">
            <summary>
            DX8 Distortion. Use <see cref="T:Un4seen.Bass.BASS_DX8_DISTORTION"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_ECHO">
            <summary>
            DX8 Echo. Use <see cref="T:Un4seen.Bass.BASS_DX8_ECHO"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_FLANGER">
            <summary>
            DX8 Flanger. Use <see cref="T:Un4seen.Bass.BASS_DX8_FLANGER"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_GARGLE">
            <summary>
            DX8 Gargle. Use <see cref="T:Un4seen.Bass.BASS_DX8_GARGLE"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_I3DL2REVERB">
            <summary>
            DX8 I3DL2 (Interactive 3D Audio Level 2) reverb. Use <see cref="T:Un4seen.Bass.BASS_DX8_I3DL2REVERB"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_PARAMEQ">
            <summary>
            DX8 Parametric equalizer. Use <see cref="T:Un4seen.Bass.BASS_DX8_PARAMEQ"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_REVERB">
            <summary>
            DX8 Reverb. Use <see cref="T:Un4seen.Bass.BASS_DX8_REVERB"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_ROTATE">
            <summary>
            BASS_FX Channel Volume Ping-Pong (stereo channel only). No parameters to get or set.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_ECHO">
            <summary>
            BASS_FX Echo (2 channels max). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_FLANGER">
            <summary>
            BASS_FX Flanger (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_VOLUME">
            <summary>
            BASS_FX Volume control (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_PEAKEQ">
            <summary>
            BASS_FX Peaking Equalizer (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_REVERB">
            <summary>
            BASS_FX Reverb (2 channels max). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_LPF">
            <summary>
            BASS_FX Low Pass Filter (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_MIX">
            <summary>
            BASS_FX Channel Swap/Remap/Downmix (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_DAMP">
            <summary>
            BASS_FX Dynamic Amplification (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_AUTOWAH">
            <summary>
            BASS_FX Auto WAH (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_ECHO2">
            <summary>
            BASS_FX Echo 2 (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_PHASER">
            <summary>
            BASS_FX Phaser (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_ECHO3">
            <summary>
            BASS_FX Echo 3 (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_CHORUS">
            <summary>
            BASS_FX Chorus (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_APF">
            <summary>
            BASS_FX All Pass Filter (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_COMPRESSOR">
            <summary>
            BASS_FX Compressor (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_DISTORTION">
            <summary>
            BASS_FX Distortion (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSFXPhase">
            <summary>
            DX8 effect types, use with e.g. the <see cref="T:Un4seen.Bass.BASS_DX8_CHORUS"/> and <see cref="T:Un4seen.Bass.BASS_DX8_FLANGER"/> effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXPhase.BASS_FX_PHASE_NEG_180">
            <summary>
            Phase differential between left and right LFOs (-180)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXPhase.BASS_FX_PHASE_NEG_90">
            <summary>
            Phase differential between left and right LFOs (-90)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXPhase.BASS_FX_PHASE_ZERO">
            <summary>
            Phase differential between left and right LFOs (+/-0)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXPhase.BASS_FX_PHASE_90">
            <summary>
            Phase differential between left and right LFOs (+90)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXPhase.BASS_FX_PHASE_180">
            <summary>
            Phase differential between left and right LFOs (+180)
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_PLUGINFORM">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> to retrieve information on the supported plugin formats.
            </summary>
            <remarks>The plugin information does not change, so the returned pointer remains valid for as long as the plugin is loaded.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_PLUGINFORM.ctype">
            <summary>
            The channel type, as would appear in the <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> structure.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_PLUGINFORM.name">
            <summary>
            The Format description or name.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_PLUGINFORM.exts">
            <summary>
            File extension filter, in the form of "*.ext1;*.ext2;etc...".
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGINFORM.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGINFORM.#ctor(System.String,System.String,Un4seen.Bass.BASSChannelType)">
            <summary>
            Constructor.
            </summary>
            <param name="ChannelType">The channel type, as would appear in the <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> structure.</param>
            <param name="Name">The Format description or name.</param>
            <param name="Extensions">File extension filter, in the form of "*.ext1;*.ext2;etc...".</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGINFORM.ToString">
            <summary>
            A description of the plugin format (name|exts) which can be used for file filter settings.
            </summary>
            <returns>The file filter of the plugin format (name|exts).</returns>
        </member>
        <member name="T:Un4seen.Bass.bass_plugininfo">
            <summary>
            Only used internally! See <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.bass_plugininfo.version">
            <summary>
            plugin version (same form as BASS_GetVersion).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.bass_plugininfo.formatc">
            <summary>
            Number of supported formats.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.bass_plugininfo.formats">
            <summary>
            The pointer to the array of supported formats. The array contains formatc elements.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_PLUGININFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> to retrieve information on a plugin.
            </summary>
            <remarks>This class can not be used directly! It will be returned and created by <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> only.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_PLUGININFO.version">
            <summary>
            plugin version (same form as BASS_GetVersion).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_PLUGININFO.formatc">
            <summary>
            Number of supported formats.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_PLUGININFO.formats">
            <summary>
            The array of supported formats. The array contains formatc elements.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGININFO.#ctor">
            <summary>
            An instance of this class can not be created directly. Use <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> instead.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGININFO.#ctor(System.Int32,Un4seen.Bass.BASS_PLUGINFORM[])">
            <summary>
            Internal Constructor.
            </summary>
            <param name="Formats">The formats to use.</param>
            <param name="Version">The version of the plugin.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGININFO.#ctor(System.IntPtr)">
            <summary>
            Constructor. Can be used with the return value of <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfoPtr(System.Int32)"/>.
            </summary>
            <param name="pluginInfoPtr">A pointer to the <see cref="T:Un4seen.Bass.BASS_PLUGININFO"/> structure.</param>
            <remarks>Should only be used with the return value of <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfoPtr(System.Int32)"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGININFO.#ctor(System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="ver">The version of the plugin.</param>
            <param name="count">The number of supported formats.</param>
            <param name="fPtr">The pointer to the array of supported formats</param>
            <remarks>Only used internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGININFO.ReadArrayStructure(System.Int32,System.IntPtr)">
            <summary>
            Reads in the <see cref="T:Un4seen.Bass.BASS_PLUGINFORM"/> array.
            </summary>
            <param name="count">Number of array elements to read.</param>
            <param name="p">The pointer to the first array element.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGININFO.ToString">
            <summary>
            A description of the plugin.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Un4seen.Bass.BASS_DEVICEINFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> to retrieve information on a device.
            </summary>
            <remarks>
            When a device is disabled/disconnected, it is still retained in the device list, but the BASS_DEVICE_ENABLED flag is removed from it. 
            If the device is subsequently re-enabled, it may become available again with the same device number, or the system may add a new entry for it.
            <para>When a new device is connected, it can affect the other devices and result in the system moving them to new device entries. 
            If an affected device is initialized, it will stop working and will need to be reinitialized using its new device number.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_DEVICEINFO.name">
            <summary>
            The description of the device.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DEVICEINFO.driver">
            <summary>
            The filename of the driver being used... NULL = no driver (ie. "no sound" device).
            <para>On systems that can use both VxD and WDM drivers (Windows Me/98SE), this will reveal which type of driver is being used.</para>
            <para>Further information can be obtained from the file using the GetFileVersionInfo Win32 API function.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DEVICEINFO.flags">
            <summary>
            The device's current status. A combination of these flags (<see cref="T:Un4seen.Bass.BASSDeviceInfo"/>):
            <list type="table">
            <item><term>BASS_DEVICE_ENABLED</term><description>The device is enabled. It will not be possible to initialize the device if this flag is not present.</description></item>
            <item><term>BASS_DEVICE_DEFAULT</term><description>The device is the system default.</description></item>
            <item><term>BASS_DEVICE_INIT</term><description>The device is initialized, ie. <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has been called.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DEVICEINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DEVICEINFO.ToString">
            <summary>
            A description of the decive info object (name).
            </summary>
            <returns></returns>
        </member>
        <member name="P:Un4seen.Bass.BASS_DEVICEINFO.IsEnabled">
            <summary>
            The device is enabled and can be used.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_DEVICEINFO.IsDefault">
            <summary>
            The device is the system default device.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_DEVICEINFO.IsInitialized">
            <summary>
            The device is already initialized.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_INFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> to retrieve information on the current device.
            </summary>
            <remarks>
            The DSCAPS_SECONDARY flags only indicate which sample formats are supported by hardware mixing.
            When using the BASS_DEVICE_SPEAKERS flag (<see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>), speakers will be 8, even though the device may not really support that many speakers. 
            The result of assigning channels to the nonexistent speakers is undefined - they may be heard on other speakers, or not heard at all.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.flags">
            <summary>
            The device's capabilities. A combination of these flags (<see cref="T:Un4seen.Bass.BASSInfo"/>):
            <list type="table">
            <item><term>DSCAPS_CONTINUOUSRATE</term><description>The device supports all sample rates between minrate and maxrate.</description></item>
            <item><term>DSCAPS_EMULDRIVER</term><description>The device's drivers do NOT have DirectSound support, so it is being emulated. Updated drivers should be installed.</description></item>
            <item><term>DSCAPS_CERTIFIED</term><description>The device driver has been certified by Microsoft. This flag is always set on WDM drivers.</description></item>
            <item><term>DSCAPS_SECONDARYMONO</term><description>Mono samples are supported by hardware mixing.</description></item>
            <item><term>DSCAPS_SECONDARYSTEREO</term><description>Stereo samples are supported by hardware mixing.</description></item>
            <item><term>DSCAPS_SECONDARY8BIT</term><description>8-bit samples are supported by hardware mixing.</description></item>
            <item><term>DSCAPS_SECONDARY16BIT</term><description>16-bit samples are supported by hardware mixing.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.hwsize">
            <summary>
            The device's total amount of hardware memory.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.hwfree">
            <summary>
            The device's amount of free hardware memory.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.freesam">
            <summary>
            The number of free sample slots in the hardware.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.free3d">
            <summary>
            The number of free 3D sample slots in the hardware.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.minrate">
            <summary>
            The minimum sample rate supported by the hardware.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.maxrate">
            <summary>
            The maximum sample rate supported by the hardware.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.eax">
            <summary>The device supports EAX and has it enabled?
            <para>The device's "Hardware acceleration" needs to be set to "Full" in it's "Advanced Properties" setup, else EAX is disabled.</para>
            <para>This is always FALSE if BASS_DEVICE_3D was not used when <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> was called.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.minbuf">
            <summary>The minimum buffer length (rounded up to the nearest millisecond) recommended for use with the BASS_CONFIG_BUFFER config option (see <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>).
            <para>Requires that BASS_DEVICE_LATENCY was used when <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> was called.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.dsver">
            <summary>
            DirectX version.
            <para>9 = DX9/8/7/5 features are available, 8 = DX8/7/5 features are available, 7 = DX7/5 features are available, 5 = DX5 features are available. 0 = none of the DX9/8/7/5 features are available.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.latency">
            <summary>The delay (rounded up to the nearest millisecond) for playback of HSTREAM/HMUSIC channels to start and be heard.
            <para>Requires that BASS_DEVICE_LATENCY was used when <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> was called.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.initflags">
            <summary>
            The flags parameter of the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call (<see cref="T:Un4seen.Bass.BASSInit"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.speakers">
            <summary>The number of speakers the device/drivers supports... 2 means that there is no support for speaker assignment - this will always be the case with non-WDM drivers in Windows.
            <para>It's also possible that it could mistakenly be 2 with some devices/drivers, when the device in fact supports more speakers.</para>
            <para>In that case the BASS_DEVICE_SPEAKERS flag can be used in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> call to force the enabling of speaker assignment.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.freq">
            <summary>
            The device's current output sample rate. This is only available on Windows Vista and OSX.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_INFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_INFO.ToString">
            <summary>
            A description of the decive info object (speakers, rates, dx, eax).
            </summary>
            <returns></returns>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.SupportsContinuousRate">
            <summary>
            The device supports all sample rates between minrate and maxrate.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.SupportsDirectSound">
            <summary>
            The device's drivers has DirectSound support
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.IsCertified">
            <summary>
            The device driver has been certified by Microsoft. Always true for WDM drivers.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.SupportsMonoSamples">
            <summary>
            Mono samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.SupportsStereoSamples">
            <summary>
            Stereo samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.Supports8BitSamples">
            <summary>
            8-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.Supports16BitSamples">
            <summary>
            16-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_RECORDINFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInfo(Un4seen.Bass.BASS_RECORDINFO)"/> to retrieve information on the current recording device.
            </summary>
            <remarks>
            <para>The formats member does not represent all the formats supported by the device, just the "standard" ones.</para>
            <para>If there is no DirectSound driver for the device (ie. it's being emulated), then the driver member will contain something like "WaveIn" instead of a filename.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_RECORDINFO.flags">
            <summary>
            The device's capabilities <see cref="T:Un4seen.Bass.BASSRecordInfo"/>.
            A combination of these flags (see <see cref="T:Un4seen.Bass.BASSRecordInfo"/>):
            <list type="table">
            <item><term>DSCCAPS_EMULDRIVER</term><description>The device's drivers do NOT have DirectSound recording support, so it is being emulated.</description></item>
            <item><term>DSCCAPS_CERTIFIED</term><description>The device driver has been certified by Microsoft.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_RECORDINFO.formats">
            <summary>
            The standard formats supported by the device (default is WAVE_FORMAT_4S16).
            A combination of these flags (see <see cref="T:Un4seen.Bass.BASSRecordFormat"/>):
            <list type="table">
            <item><term>WAVE_FORMAT_1M08</term><description>11025hz, Mono, 8-bit</description></item>
            <item><term>WAVE_FORMAT_1S08</term><description>11025hz, Stereo, 8-bit</description></item>
            <item><term>WAVE_FORMAT_1M16</term><description>11025hz, Mono, 16-bit</description></item>
            <item><term>WAVE_FORMAT_1S16</term><description>11025hz, Stereo, 16-bit</description></item>
            <item><term>WAVE_FORMAT_2M08</term><description>22050hz, Mono, 8-bit</description></item>
            <item><term>WAVE_FORMAT_2S08</term><description>22050hz, Stereo, 8-bit</description></item>
            <item><term>WAVE_FORMAT_2M16</term><description>22050hz, Mono, 16-bit</description></item>
            <item><term>WAVE_FORMAT_2S16</term><description>22050hz, Stereo, 16-bit</description></item>
            <item><term>WAVE_FORMAT_4M08</term><description>44100hz, Mono, 8-bit</description></item>
            <item><term>WAVE_FORMAT_4S08</term><description>44100hz, Stereo, 8-bit</description></item>
            <item><term>WAVE_FORMAT_4M16</term><description>44100hz, Mono, 16-bit</description></item>
            <item><term>WAVE_FORMAT_4S16</term><description>44100hz, Stereo, 16-bit</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_RECORDINFO.inputs">
            <summary>
            The number of input sources available to the device
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_RECORDINFO.singlein">
            <summary>
            TRUE = only one input may be active at a time
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_RECORDINFO.freq">
            <summary>
            The device's current input sample rate. This is only available on Windows Vista and OSX.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_RECORDINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_RECORDINFO.ToString">
            <summary>
            A description of the record decive info object (inputs, singlein).
            </summary>
            <returns></returns>
        </member>
        <member name="P:Un4seen.Bass.BASS_RECORDINFO.SupportsDirectSound">
            <summary>
            The device's drivers has DirectSound support
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_RECORDINFO.IsCertified">
            <summary>
            The device driver has been certified by Microsoft. Always true for WDM drivers.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_FILEPROCS">
            <summary>
            Table of callback functions used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.
            </summary>
            <remarks>A copy is made of the procs callback function table, so it does not have to persist beyond this function call. 
            This means it is not required to pin the <paramref name="procs"/> instance, but it is still required to keep a reference as long as BASS uses the callback delegates in order to prevent the callbacks from being garbage collected.
            </remarks>
            <example>
            <code>
            using Un4seen.Bass;
            ...
            private BASS_FILEPROCS _myStreamCreateUser;
            private FileStream _fs;
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle, null);
            // creating the user file callback delegates
            _myStreamCreateUser = new BASS_FILEPROCS(
                new FILECLOSEPROC(MyFileProcUserClose), 
                new FILELENPROC(MyFileProcUserLength), 
                new FILEREADPROC(MyFileProcUserRead), 
                new FILESEEKPROC(MyFileProcUserSeek));
            // open the file...
            _fs = File.OpenRead("test.mp3");
            // create the stream (the PRESCAN flag shows you what BASS is doing at the beginning to scan the entire file)
            // if that generates to much output for you, you can simply remove it
            int stream = Bass.BASS_StreamCreateFileUser(BASSStreamSystem.STREAMFILE_NOBUFFER, BASSFlag.BASS_STREAM_PRESCAN | BASSFlag.BASS_STREAM_AUTOFREE, _myStreamCreateUser, IntPtr.Zero);
            // play the channel
            Bass.BASS_ChannelPlay(stream, false);
            ...
            private void MyFileProcUserClose(IntPtr user)
            {
              if (_fs == null)
                return;
              _fs.Close();
              Console.WriteLine("File Closed");
            }
            
            private long MyFileProcUserLength(IntPtr user)
            {
              if (_fs == null)
                return 0L;
              return _fs.Length;
            }
            
            private int MyFileProcUserRead(IntPtr buffer, int length, IntPtr user)
            {
              if (_fs == null)
                return 0;
              try
              {
                // at first we need to create a byte[] with the size of the requested length
                byte[] data = new byte[length];
                // read the file into data
                int bytesread = _fs.Read(data, 0, length);
                // and now we need to copy the data to the buffer
                // we write as many bytes as we read via the file operation
                Marshal.Copy(data, 0, buffer, bytesread);
                return bytesread;
              }
              catch { return 0; }
            }
            
            private bool MyFileProcUserSeek(long offset, IntPtr user)
            {
              if (_fs == null)
                return false;
              try
              {
                long pos = _fs.Seek(offset, SeekOrigin.Begin);
                return true;
              }
              catch
              {
                return false;
              }
            }
            </code>
            <code lang="vbnet">
            Imports Un4seen.Bass
            ...
            Private _myStreamCreateUser As BASS_FILEPROCS
            Private _fs As FileStream
            ...
            Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle, Nothing)
            ' creating the user file callback delegates
            _myStreamCreateUser = New BASS_FILEPROCS(
                New FILECLOSEPROC(AddressOf MyFileProcUserClose), 
                New FILELENPROC(AddressOf MyFileProcUserLength), 
                New FILEREADPROC(AddressOf MyFileProcUserRead), 
                New FILESEEKPROC(AddressOf MyFileProcUserSeek))
            ' open the file...
            _fs = File.OpenRead("test.mp3")
            ' create the stream (the PRESCAN flag shows you what BASS is doing at the beginning to scan the entire file)
            ' if that generates to much output for you, you can simply remove it
            Dim stream As Integer = Bass.BASS_StreamCreateFileUser(BASSStreamSystem.STREAMFILE_NOBUFFER, BASSFlag.BASS_STREAM_PRESCAN Or BASSFlag.BASS_STREAM_AUTOFREE, _myStreamCreateUser, IntPtr.Zero)
            ' play the channel
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Private Sub MyFileProcUserClose(user As IntPtr)
              If _fs Is Nothing Then
                Return
              End If 
              _fs.Close()
            End Sub
            
            Private Function MyFileProcUserLength(user As IntPtr) As Long
              If _fs Is Nothing Then
                Return 0L
              End If 
              Return _fs.Length   
            End Function
            
            Private Function MyFileProcUserRead(buffer As IntPtr, length As Integer, user As IntPtr) As Integer
              If _fs Is Nothing Then
                Return 0
              End If 
              Try
                ' at first we need to create a byte[] with the size of the requested length
                Dim data(length) As Byte
                ' read the file into data
                Dim bytesread As Integer = _fs.Read(data, 0, length)
                ' and now we need to copy the data to the buffer
                ' we write as many bytes as we read via the file operation
                Marshal.Copy(data, 0, buffer, bytesread)
                Return bytesread
              Catch
                Return 0
              End Try
            End Function
            
            Private Function MyFileProcUserSeek(offset As Long, user As IntPtr) As Boolean
              If _fs Is Nothing Then
                Return False
              End If 
              Try
                Dim pos As Long = _fs.Seek(offset, SeekOrigin.Begin)
                Return True
              Catch
                Return False
              End Try
            End Function
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASS_FILEPROCS.close">
            <summary>
            Callback function to close the file.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_FILEPROCS.length">
            <summary>
            Callback function to get the file length.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_FILEPROCS.read">
            <summary>
            Callback function to read from the file.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_FILEPROCS.seek">
            <summary>
            Callback function to seek in the file. Not used by buffered file streams.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_FILEPROCS.#ctor(Un4seen.Bass.FILECLOSEPROC,Un4seen.Bass.FILELENPROC,Un4seen.Bass.FILEREADPROC,Un4seen.Bass.FILESEEKPROC)">
            <summary>
            Default constructor taking the callback delegates.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_SAMPLE">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/> to retrieve and set the default playback attributes of a sample.
            </summary>
            <remarks>
            <para>When a sample has 3D functionality, the iangle and oangle angles decide how wide the sound is projected around the orientation angle (as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DPosition(System.Int32,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>).</para>
            <para>Within the inside angle the volume level is the level set in the volume member (or as set with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/> when the sample is playing).</para>
            <para>Outside the outer angle, the volume changes according to the outvol value. Between the inner and outer angles, the volume gradually changes between the inner and outer volume levels.</para>
            <para>If the inner and outer angles are 360 degrees, then the sound is transmitted equally in all directions.</para>
            <para>BASS supports 8 &amp; 16-bit samples, so if a WAV file, for example, uses another sample resolution, it'll have to be converted by BASS.</para>
            <para>The origres member can be used to check what the resolution originally was.</para>
            <para>When VAM is enabled, and neither the BASS_VAM_HARDWARE or BASS_VAM_SOFTWARE flags are specified, then the sample will be played in hardware if resources are available, and in software if no hardware resources are available.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.freq">
            <summary>
            Default playback rate (set to 44100 by default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.volume">
            <summary>
            Default volume... 0 (silent) to 1 (full, default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.pan">
            <summary>
            Default panning position -1 (full left) to +1 (full right) - defaulted to 0 = centre.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.flags">
            <summary>
            A combination of these flags (<see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>The samples's resolution is 8-bit. If neither this or the BASS_SAMPLE_FLOAT flags are present, then the sample's resolution is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>The samples's resolution is 32-bit floating-point.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped?</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>The sample has 3D functionality enabled.</description></item>
            <item><term>BASS_SAMPLE_MUTEMAX	</term><description>Mute the sample when it is at (or beyond) it's max distance (3D samples only).</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>The sample is not using hardware mixing... it is being mixed in software by DirectSound.</description></item>
            <item><term>BASS_SAMPLE_VAM</term><description>DX7 voice allocation and management features are enabled (see below).</description></item>
            <item><term>BASS_SAMPLE_OVER_VOL</term><description>Override: the channel with the lowest volume is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_POS</term><description>Override: the longest playing channel is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_DIST</term><description>Override: the channel furthest away (from the listener) is overriden (3D samples only).</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.length">
            <summary>
            The length in bytes.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.max">
            <summary>
            Maximum number of simultaneous playbacks (defaulted to 1).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.origres">
            <summary>
            The original resolution (bits per sample)... 0 = undefined (default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.chans">
            <summary>
            Number of channels... 1=mono, 2=stereo (default), etc.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.mingap">
            <summary>
            Minimum time gap in milliseconds between creating channels using <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/>. 
            This can be used to prevent flanging effects caused by playing a sample multiple times very close to eachother. 
            The default setting, when loading/creating a sample, is 0 (disabled).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.mode3d">
            <summary>
            The 3D processing mode... one of these flags (see <see cref="T:Un4seen.Bass.BASS3DMode"/>):
            <list type="table">
            <item><term>BASS_3DMODE_NORMAL</term><description>Normal 3D processing (default).</description></item>
            <item><term>BASS_3DMODE_RELATIVE</term><description>The sample's 3D position (position/velocity/orientation) is relative to the listener. When the listener's position/velocity/orientation is changed with <see cref="M:Un4seen.Bass.Bass.BASS_Set3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>, the sample's position relative to the listener does not change.</description></item>
            <item><term>BASS_3DMODE_OFF</term><description>Turn off 3D processing on the sample, the sound will be played in the center.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.mindist">
            <summary>
            The minimum distance (default 0). The sample's volume is at maximum when the listener is within this distance.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.maxdist">
            <summary>
            The maximum distance (default 0). The sample's volume stops decreasing when the listener is beyond this distance.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.iangle">
            <summary>
            The angle of the inside projection cone in degrees... 0 (no cone, default) - 360 (sphere).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.oangle">
            <summary>
            The angle of the outside projection cone in degrees... 0 (no cone, default) - 360 (sphere).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.outvol">
            <summary>
            The delta-volume outside the outer projection cone... 0 (silent) to 1 (full, default) - same as inside the cone.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.vam">
            <summary>
            The following are the sample's DX7 voice allocation/management settings (if VAM is enabled)...a combination of these (<see cref="T:Un4seen.Bass.BASSVam"/>):
            <list type="table">
            <item><term>BASS_VAM_HARDWARE</term><description>Play the sample in hardware (default). If no hardware voices are available then the play call will fail.</description></item>
            <item><term>BASS_VAM_SOFTWARE</term><description>Play the sample in software (ie. non-accelerated). No other VAM flags may be used together with this flag.</description></item>
            </list>
            The following flags enable hardware resource stealing... if the hardware has no available voices, a currently playing buffer will be stopped to make room for the new buffer. Only samples with VAM enabled are considered for termination:
            <list type="table">
            <item><term>BASS_VAM_TERM_TIME</term><description>If there are no free hardware voices, the buffer to be terminated will be the one with the least time left to play.</description></item>
            <item><term>BASS_VAM_TERM_DIST</term><description>If there are no free hardware voices, the buffer to be terminated will be one that was loaded/created with the BASS_SAMPLE_MUTEMAX flag and is beyond it's max distance (maxdist). If there are no buffers that match this criteria, then the play call will fail.</description></item>
            <item><term>BASS_VAM_TERM_PRIO</term><description>If there are no free hardware voices, the buffer to be terminated will be the one with the lowest priority. This flag may be used with the TERM_TIME or TERM_DIST flag, if multiple voices have the same priority then the time or distance is used to decide which to terminate.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.priority">
            <summary>
            Priority, used with the BASS_VAM_TERM_PRIO flag... 0 (min, default) - 0xFFFFFFFF (max)
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_SAMPLE.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_SAMPLE.#ctor(System.Int32,System.Single,System.Single,Un4seen.Bass.BASSFlag,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Single,Un4seen.Bass.BASSVam,System.Int32)">
            <summary>
            Constructor to initialize the members.
            </summary>
            <param name="Freq">Default playback rate.</param>
            <param name="Volume">Default volume (0-1).</param>
            <param name="Pan">Default pan (-1=left, 0=middle, +1=right).</param>
            <param name="Flags">BASS_SAMPLE_xxx flags (<see cref="T:Un4seen.Bass.BASSFlag"/>).</param>
            <param name="Length">Length (in bytes).</param>
            <param name="Max">Maximum simultaneous playbacks.</param>
            <param name="OrigRes">Original resolution bits.</param>
            <param name="Chans">Number of channels.</param>
            <param name="MinGap">Minimum time gap in milliseconds between creating channels.</param>
            <param name="Flag3D">BASS_3DMODE_xxx mode (<see cref="T:Un4seen.Bass.BASS3DMode"/>).</param>
            <param name="MinDist">Minimum distance.</param>
            <param name="MaxDist">Maximum distance.</param>
            <param name="IAngle">Angle of inside projection cone.</param>
            <param name="OAngle">Angle of outside projection cone.</param>
            <param name="OutVol">Delta-volume outside the projection cone.</param>
            <param name="FlagsVam">Voice allocation/management flags (BASS_VAM_xxx flags <see cref="T:Un4seen.Bass.BASSVam"/>).</param>
            <param name="Priority">Priority (0=lowest, 0xffffffff=highest).</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_SAMPLE.ToString">
            <summary>
            A description of the record decive info object (driver file name, inputs etc.)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Un4seen.Bass.BASS_CHANNELINFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on a channel.
            </summary>
            <remarks>
            A "channel" can be a playing sample (HCHANNEL), a sample stream (HSTREAM), a MOD music (HMUSIC), or a recording (HRECORD).
            <para>Each "Channel" function can be used with one or more of these channel types.</para>
            <para>The BASS_SAMPLE_SOFTWARE flag indicates whether or not the channel's sample data is being mixed into the final output by the hardware. It does not indicate (in the case of a stream or MOD music) whether the processing required to generate the sample data is being done by the hardware, this processing is always done in software.</para>
            <para>BASS supports 8/16/32-bit sample data, so if a WAV file, for example, uses another sample resolution, it'll have to be converted by BASS. The origres member can be used to check what the resolution originally was.</para>
            </remarks>
            <example>
            BASS_CHANNELINFO info = new BASS_CHANNELINFO();
            Bass.BASS_ChannelGetInfo(channel, info); // get info
            if (info.ctype == BassChannel.BASS_CTYPE_STREAM_MP3) 
            {
            	// it's an MP3!
            }
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.freq">
            <summary>
            Default playback rate.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.chans">
            <summary>
            Number of channels... 1=mono, 2=stereo, etc.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.flags">
            <summary>
            BASS_SAMPLE/STREAM/MUSIC/SPEAKER flags. A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>The channel's resolution is 8-bit. If neither this or the BASS_SAMPLE_FLOAT flags are present, then the channel's resolution is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>The channel's resolution is 32-bit floating-point.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>The channel is looped.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>The channel has 3D functionality enabled.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>The channel is NOT using hardware mixing... it doesn't benefit from any special hardware interpolation, etc.</description></item>
            <item><term>BASS_SAMPLE_VAM</term><description>The channel is using the DX7 voice allocation and management features. (HCHANNEL only)</description></item>
            <item><term>BASS_SAMPLE_MUTEMAX</term><description>The channel is muted when at (or beyond) it's max distance. (HCHANNEL)</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>The channel has the "with FX flag" <a href="../Overview.html#DX8DMOEffects">DX8 effects implementation</a> enabled. (HSTREAM/HMUSIC)</description></item>
            <item><term>BASS_STREAM_RESTRATE</term><description>The internet file download rate is restricted. (HSTREAM)</description></item>
            <item><term>BASS_STREAM_BLOCK</term><description>The internet file (or "buffered" user file) is streamed in small blocks. (HSTREAM)</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>The channel will automatically be freed when it ends. (HSTREAM/HMUSIC)</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>The channel is a "decoding channel". (HSTREAM/HMUSIC)</description></item>
            <item><term>BASS_MUSIC_RAMP</term><description>The MOD music is using "normal" ramping. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_RAMPS</term><description>The MOD music is using "sensitive" ramping. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_SURROUND</term><description>The MOD music is using surround sound. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_SURROUND2</term><description>The MOD music is using surround sound mode 2. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_NONINTER</term><description>The MOD music is using non-interpolated mixing. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_FT2MOD</term><description>The MOD music is using FastTracker 2 .MOD playback. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_PT1MOD</term><description>The MOD music is using ProTracker 1 .MOD playback. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>All notes will be stopped when seeking in the MOD music. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>All notes will be stopped and BPM/etc reset when seeking in the MOD music. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_STOPBACK</term><description>The MOD music will be stopped when a backward jump effect is played. (HMUSIC)</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a scr="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>. (HSTREAM/HMUSIC)</description></item>
            <item><term>BASS_UNICODE</term><description><paramref name="filename"/> is a Unicode (UTF-16) filename.</description></item>
            </list>
            <i>Other flags may be supported by add-ons, see the documentation.</i>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.ctype">
            <summary>
            The type of channel it is, which can be one of the following (see <see cref="T:Un4seen.Bass.BASSChannelType"/>), or another value if it's an add-on format (see the add-on's API).
            <list type="table">
            <item><term>BASS_CTYPE_SAMPLE</term><description>Sample channel. (HCHANNEL)</description></item>
            <item><term>BASS_CTYPE_STREAM</term><description>User sample stream. This can also be used as a flag to test if the channel is any kind of HSTREAM.</description></item>
            <item><term>BASS_CTYPE_STREAM_OGG</term><description>OGG format file stream.</description></item>
            <item><term>BASS_CTYPE_STREAM_MP1</term><description>MP1 format file stream.</description></item>
            <item><term>BASS_CTYPE_STREAM_MP2</term><description>MP2 format file stream.</description></item>
            <item><term>BASS_CTYPE_STREAM_MP3</term><description>MP3 format file stream.</description></item>
            <item><term>BASS_CTYPE_STREAM_AIFF</term><description>Audio IFF format stream.</description></item>
            <item><term>BASS_CTYPE_STREAM_WAV</term><description>WAVE format flag. This can be used to test if the channel is any kind of WAVE format (LOWORD contains the codec number).</description></item>
            <item><term>BASS_CTYPE_STREAM_WAV_PCM</term><description>WAV format file stream, PCM 16-bit.</description></item>
            <item><term>BASS_CTYPE_STREAM_WAV_FLOAT</term><description>WAV format file stream, FLOAT 32-bit.</description></item>
            <item><term>BASS_CTYPE_MUSIC_MOD</term><description>MOD format music. This can also be used as a flag to test if the channel is any kind of HMUSIC.</description></item>
            <item><term>BASS_CTYPE_MUSIC_MTM</term><description>MTM format music.</description></item>
            <item><term>BASS_CTYPE_MUSIC_S3M</term><description>S3M format music.</description></item>
            <item><term>BASS_CTYPE_MUSIC_XM</term><description>XM format music.</description></item>
            <item><term>BASS_CTYPE_MUSIC_IT</term><description>IT format music.</description></item>
            <item><term>BASS_CTYPE_MUSIC_MO3</term><description>MO3 format flag, used in combination with one of the BASS_CTYPE_MUSIC types.</description></item>
            <item><term>BASS_CTYPE_RECORD</term><description>Recording channel. (HRECORD)</description></item>
            </list>
            <i>Other channel types may be supported by add-ons, see the documentation.</i>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.origres">
            <summary>
            The original resolution (bits per sample)... 0 = undefined.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.plugin">
            <summary>
            The plugin that is handling the channel... 0 = not using a plugin. 
            <para>Note this is only available with streams created using the plugin system via the standard BASS stream creation functions, not those created by add-on functions. 
            Information on the plugin can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.sample">
            <summary>
            The sample that is playing on the channel. (HCHANNEL only)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.filename">
            <summary>
            The filename associated with the channel. (HSTREAM only)
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_CHANNELINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_CHANNELINFO.ToString">
            <summary>
            A description of the record decive info object (driver file name, inputs etc.)
            </summary>
            <returns></returns>
        </member>
        <member name="P:Un4seen.Bass.BASS_CHANNELINFO.IsDecodingChannel">
            <summary>
            Is the channel a decoding channel?
            </summary>
            <remarks>Checks, that the <see cref="F:Un4seen.Bass.BASS_CHANNELINFO.flags"/> property contains the BASS_STREAM_DECODE resp. BASS_MUSIC_DECODE flag.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_CHANNELINFO.Is32bit">
            <summary>
            Gets, if the <see cref="F:Un4seen.Bass.BASS_CHANNELINFO.flags"/> property contains the BASS_SAMPLE_FLOAT resp. BASS_MUSIC_FLOAT flag.
            </summary>
            <remarks>TRUE is returned for floating-point channels - else FALSE.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_CHANNELINFO.Is8bit">
            <summary>
            Gets, if the <see cref="F:Un4seen.Bass.BASS_CHANNELINFO.flags"/> property contains the BASS_SAMPLE_8BITS resp. BASS_MUSIC_8BITS flag.
            </summary>
            <remarks>TRUE is returned for 8-bit channels - else FALSE.</remarks>
        </member>
        <member name="T:Un4seen.Bass.BASS_3DVECTOR">
            <summary>
            Structure used by the 3D functions to describe positions, velocities, and orientations (e.g. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DPosition(System.Int32,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_Get3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>).
            </summary>
            <remarks>
            The left-handed coordinate system is used.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_3DVECTOR.x">
            <summary>
            +values=right, -values=left (default=0)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_3DVECTOR.y">
            <summary>
            +values=up, -values=down (default=0)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_3DVECTOR.z">
            <summary>
            +values=front, -values=behind (default=0)
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_3DVECTOR.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_3DVECTOR.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            constructor to initialize the members
            </summary>
            <param name="X">X value (+=right, -=left)</param>
            <param name="Y">Y value (+=up, -=down)</param>
            <param name="Z">Z value (+=front, -=behind)</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_3DVECTOR.ToString">
            <summary>
            The 3D vector as a descriptive string (X=, Y=, Z=)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_CHORUS">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a chorus effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.fWetDryMix">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 (default) through 100 (all wet).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.fDepth">
            <summary>
            Percentage by which the delay time is modulated by the low-frequency oscillator, in hundredths of a percentage point. Must be in the range from 0 through 100. The default value is 25.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.fFeedback">
            <summary>
            Percentage of output signal to feed back into the effect's input, in the range from -99 to 99. The default value is 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.fFrequency">
            <summary>
            Frequency of the LFO, in the range from 0 to 10. The default value is 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.lWaveform">
            <summary>
            Waveform of the LFO... 0 = triangle, 1 = sine. By default, the waveform is a sine.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.fDelay">
            <summary>
            Number of milliseconds the input is delayed before it is played back, in the range from 0 to 20. The default value is 0 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.lPhase">
            <summary>
            Phase differential between left and right LFOs, one of <see cref="T:Un4seen.Bass.BASSFXPhase"/> values. Default is (int)BASSFXPhase.BASS_FX_PHASE_ZERO.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_CHORUS.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_CHORUS.#ctor(System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,Un4seen.Bass.BASSFXPhase)">
            <summary>
            constructor to initialize the members
            </summary>
            <param name="WetDryMix">Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 through 100 (all wet).</param>
            <param name="Depth">Percentage by which the delay time is modulated by the low-frequency oscillator, in hundredths of a percentage point. Must be in the range from 0 through 100.</param>
            <param name="Feedback">Percentage of output signal to feed back into the effect's input, in the range from -99 to 99.</param>
            <param name="Frequency">Frequency of the LFO, in the range from 0 to 10.</param>
            <param name="Waveform">Waveform of the LFO... 0 = triangle, 1 = sine.</param>
            <param name="Delay">Number of milliseconds the input is delayed before it is played back, in the range from 0 to 20.</param>
            <param name="Phase">Phase differential between left and right LFOs (see <see cref="T:Un4seen.Bass.BASSFXPhase"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_CHORUS.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_CHORUS.Preset_A">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_CHORUS.Preset_B">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_COMPRESSOR">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a compression effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_COMPRESSOR.fGain">
            <summary>
            Output gain of signal after compression, in the range from -60 to 60. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_COMPRESSOR.fAttack">
            <summary>
            Time before compression reaches its full value, in the range from 0.01 to 500. The default value is 0.01 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_COMPRESSOR.fRelease">
            <summary>
            Speed at which compression is stopped after input drops below fThreshold, in the range from 50 to 3000. The default value is 50 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_COMPRESSOR.fThreshold">
            <summary>
            Point at which compression begins, in decibels, in the range from -60 to 0. The default value is -10 dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_COMPRESSOR.fRatio">
            <summary>
            Compression ratio, in the range from 1 to 100. The default value is 10, which means 10:1 compression.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_COMPRESSOR.fPredelay">
            <summary>
            Time after lThreshold is reached before attack phase is started, in milliseconds, in the range from 0 to 4. The default value is 0 ms.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            constructor to already set the members
            </summary>
            <param name="Gain">Output gain of signal after compression, in the range from -60 to 60.</param>
            <param name="Attack">Time before compression reaches its full value, in the range from 0.01 to 500.</param>
            <param name="Release">Speed at which compression is stopped after input drops below fThreshold, in the range from 50 to 3000.</param>
            <param name="Threshold">Point at which compression begins, in decibels, in the range from -60 to 0.</param>
            <param name="Ratio">Compression ratio, in the range from 1 to 100.</param>
            <param name="Predelay">Time after lThreshold is reached before attack phase is started, in milliseconds, in the range from 0 to 4.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_Soft">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_Soft2">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_Medium">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_Hard">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_Hard2">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_HardCommercial">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_DISTORTION">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a distortion effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_DISTORTION.fGain">
            <summary>
            Amount of signal change after distortion, in the range from -60 through 0. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_DISTORTION.fEdge">
            <summary>
            Percentage of distortion intensity, in the range in the range from 0 through 100. The default value is 50 percent.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_DISTORTION.fPostEQCenterFrequency">
            <summary>
            Center frequency of harmonic content addition, in the range from 100 through 8000. The default value is 4000 Hz.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_DISTORTION.fPostEQBandwidth">
            <summary>
            Width of frequency band that determines range of harmonic content addition, in the range from 100 through 8000. The default value is 4000 Hz.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_DISTORTION.fPreLowpassCutoff">
            <summary>
            Filter cutoff for high-frequency harmonics attenuation, in the range from 100 through 8000. The default value is 4000 Hz.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_DISTORTION.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_DISTORTION.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="Gain">Amount of signal change after distortion, in the range from -60 through 0.</param>
            <param name="Edge">Percentage of distortion intensity, in the range in the range from 0 through 100.</param>
            <param name="PostEQCenterFrequency">Center frequency of harmonic content addition, in the range from 100 through 8000.</param>
            <param name="PostEQBandwidth">Width of frequency band that determines range of harmonic content addition, in the range from 100 through 8000.</param>
            <param name="PreLowpassCutoff">Filter cutoff for high-frequency harmonics attenuation, in the range from 100 through 8000.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_DISTORTION.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_ECHO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a echo effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_ECHO.fWetDryMix">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 (default) through 100 (all wet).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_ECHO.fFeedback">
            <summary>
            Percentage of output fed back into input, in the range from 0 through 100. The default value is 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_ECHO.fLeftDelay">
            <summary>
            Delay for left channel, in milliseconds, in the range from 1 through 2000. The default value is 333 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_ECHO.fRightDelay">
            <summary>
            Delay for right channel, in milliseconds, in the range from 1 through 2000. The default value is 333 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_ECHO.lPanDelay">
            <summary>
            Value that specifies whether to swap left and right delays with each successive echo. The default value is FALSE, meaning no swap.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_ECHO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_ECHO.#ctor(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="WetDryMix">Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 through 100 (all wet).</param>
            <param name="Feedback">Percentage of output fed back into input, in the range from 0 through 100.</param>
            <param name="LeftDelay">Delay for left channel, in milliseconds, in the range from 1 through 2000.</param>
            <param name="RightDelay">Delay for right channel, in milliseconds, in the range from 1 through 2000.</param>
            <param name="PanDelay">Value that specifies whether to swap left and right delays with each successive echo.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_ECHO.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_ECHO.Preset_Small">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_ECHO.Preset_Long">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_FLANGER">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a flanger effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.fWetDryMix">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 (default) through 100 (all wet).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.fDepth">
            <summary>
            Percentage by which the delay time is modulated by the low-frequency oscillator (LFO), in hundredths of a percentage point. Must be in the range from 0 through 100. The default value is 25.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.fFeedback">
            <summary>
            Percentage of output signal to feed back into the effect's input, in the range from -99 to 99. The default value is 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.fFrequency">
            <summary>
            Frequency of the LFO, in the range from 0 to 10. The default value is 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.lWaveform">
            <summary>
            Waveform of the LFO... 0 = triangle, 1 = sine. By default, the waveform is a sine.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.fDelay">
            <summary>
            Number of milliseconds the input is delayed before it is played back, in the range from 0 to 4. The default value is 0 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.lPhase">
            <summary>
            Phase differential between left and right LFOs, one of the <see cref="T:Un4seen.Bass.BASSFXPhase"/> values. Default (int)BASSFXPhase.BASS_FX_PHASE_ZERO.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_FLANGER.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_FLANGER.#ctor(System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,Un4seen.Bass.BASSFXPhase)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="WetDryMix">Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 through 100 (all wet).</param>
            <param name="Depth">Percentage by which the delay time is modulated by the low-frequency oscillator (LFO), in hundredths of a percentage point. Must be in the range from 0 through 100.</param>
            <param name="Feedback">Percentage of output signal to feed back into the effect's input, in the range from -99 to 99.</param>
            <param name="Frequency">Frequency of the LFO, in the range from 0 to 10.</param>
            <param name="Waveform">Waveform of the LFO... 0 = triangle, 1 = sine.</param>
            <param name="Delay">Number of milliseconds the input is delayed before it is played back, in the range from 0 to 4.</param>
            <param name="Phase">Phase differential between left and right LFOs, one of <see cref="T:Un4seen.Bass.BASSFXPhase"/>.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_FLANGER.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_FLANGER.Preset_A">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_FLANGER.Preset_B">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_GARGLE">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a gargle effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_GARGLE.dwRateHz">
            <summary>
            Rate of modulation, in Hertz. Must be in the range from 1 through 1000. Default 500 Hz.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_GARGLE.dwWaveShape">
            <summary>
            Shape of the modulation wave... 0 = triangle, 1 = square (default).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_GARGLE.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_GARGLE.#ctor(System.Int32,System.Int32)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="RateHz">Rate of modulation, in Hertz. Must be in the range from 1 through 1000.</param>
            <param name="WaveShape">Shape of the modulation wave... 0 = triangle, 1 = square.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_GARGLE.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_I3DL2REVERB">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of an I3DL2 (Interactive 3D Audio Level 2) reverberation effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.lRoom">
            <summary>
            Attenuation of the room effect, in millibels (mB), in the range from -10000 to 0. The default value is -1000 mB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.lRoomHF">
            <summary>
            Attenuation of the room high-frequency effect, in mB, in the range from -10000 to 0. The default value is 0 mB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flRoomRolloffFactor">
            <summary>
            Rolloff factor for the reflected signals, in the range from 0 to 10. The default value is 0.0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flDecayTime">
            <summary>
            Decay time, in seconds, in the range from 0.1 to 20. The default value is 1.49 second.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flDecayHFRatio">
            <summary>
            Ratio of the decay time at high frequencies to the decay time at low frequencies, in the range from 0.1 to 2. The default value is 0.83.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.lReflections">
            <summary>
            Attenuation of early reflections relative to lRoom, in mB, in the range from -10000 to 1000. The default value is -2602 mB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flReflectionsDelay">
            <summary>
            Delay time of the first reflection relative to the direct path, in seconds, in the range from 0 to 0.3. The default value is 0.007 seconds.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.lReverb">
            <summary>
            Attenuation of late reverberation relative to lRoom, in mB, in the range from -10000 to 2000. The default value is 200 mB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flReverbDelay">
            <summary>
            Time limit between the early reflections and the late reverberation relative to the time of the first reflection, in seconds, in the range from 0 to 0.1. The default value is 0.011 seconds.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flDiffusion">
            <summary>
            Echo density in the late reverberation decay, in percent, in the range from 0 to 100. The default value is 100.0 percent.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flDensity">
            <summary>
            Modal density in the late reverberation decay, in percent, in the range from 0 to 100. The default value is 100.0 percent.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flHFReference">
            <summary>
            Reference high frequency, in hertz, in the range from 20 to 20000. The default value is 5000.0 Hz.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_I3DL2REVERB.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_I3DL2REVERB.#ctor(System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Int32,System.Single,System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="Room">Attenuation of the room effect, in millibels (mB), in the range from -10000 to 0.</param>
            <param name="RoomHF">Attenuation of the room high-frequency effect, in mB, in the range from -10000 to 0.</param>
            <param name="RoomRolloffFactor">Rolloff factor for the reflected signals, in the range from 0 to 10.</param>
            <param name="DecayTime">Decay time, in seconds, in the range from 0.1 to 20.</param>
            <param name="DecayHFRatio">Ratio of the decay time at high frequencies to the decay time at low frequencies, in the range from 0.1 to 2.</param>
            <param name="Reflections">Attenuation of early reflections relative to lRoom, in mB, in the range from -10000 to 1000.</param>
            <param name="ReflectionsDelay">Delay time of the first reflection relative to the direct path, in seconds, in the range from 0 to 0.3.</param>
            <param name="Reverb">Attenuation of late reverberation relative to lRoom, in mB, in the range from -10000 to 2000.</param>
            <param name="ReverbDelay">Time limit between the early reflections and the late reverberation relative to the time of the first reflection, in seconds, in the range from 0 to 0.1.</param>
            <param name="Diffusion">Echo density in the late reverberation decay, in percent, in the range from 0 to 100.</param>
            <param name="Density">Modal density in the late reverberation decay, in percent, in the range from 0 to 100.</param>
            <param name="HFReference">Reference high frequency, in hertz, in the range from 20 to 20000.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_I3DL2REVERB.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_PARAMEQ">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a parametric equalizer effect.
            </summary>
            <example>
            Setting up a 3-band EQ:
            <code>
            private int[] _fxEQ = {0, 0, 0};
            ...
            // 3-band EQ
            BASS_DX8_PARAMEQ eq = new BASS_DX8_PARAMEQ();
            _fxEQ[0] = Bass.BASS_ChannelSetFX(_stream, BASSFXType.BASS_FX_DX8_PARAMEQ, 0);
            _fxEQ[1] = Bass.BASS_ChannelSetFX(_stream, BASSFXType.BASS_FX_DX8_PARAMEQ, 0);
            _fxEQ[2] = Bass.BASS_ChannelSetFX(_stream, BASSFXType.BASS_FX_DX8_PARAMEQ, 0);
            eq.fBandwidth = 18f;
            eq.fCenter = 100f;
            eq.fGain = 0f;
            Bass.BASS_FXSetParameters(_fxEQ[0], eq);
            eq.fCenter = 1000f;
            Bass.BASS_FXSetParameters(_fxEQ[1], eq);
            eq.fCenter = 8000f;
            Bass.BASS_FXSetParameters(_fxEQ[2], eq);
            ...
            private void UpdateEQ(int band, float gain)
            {
              BASS_DX8_PARAMEQ eq = new BASS_DX8_PARAMEQ();
              if (Bass.BASS_FXGetParameters(_fxEQ[band], eq))
              {
                eq.fGain = gain;
                Bass.BASS_FXSetParameters(_fxEQ[band], eq);
              }
            }
            </code>
            <code lang="vbnet">
            Private _fxEQ As Integer() =  {0, 0, 0}
            ...
            ' 3-band EQ
            Dim eq As New BASS_DX8_PARAMEQ()
            _fxEQ(0) = Bass.BASS_ChannelSetFX(_stream, BASSFXType.BASS_FX_DX8_PARAMEQ, 0)
            _fxEQ(1) = Bass.BASS_ChannelSetFX(_stream, BASSFXType.BASS_FX_DX8_PARAMEQ, 0)
            _fxEQ(2) = Bass.BASS_ChannelSetFX(_stream, BASSFXType.BASS_FX_DX8_PARAMEQ, 0)
            eq.fBandwidth = 18F
            eq.fCenter = 100F
            Bass.BASS_FXSetParameters(_fxEQ(0), eq)
            eq.fCenter = 1000F
            Bass.BASS_FXSetParameters(_fxEQ(1), eq)
            eq.fCenter = 8000F
            Bass.BASS_FXSetParameters(_fxEQ(2), eq)
            ...
            Private Sub UpdateEQ(band As Integer, gain As Single)
              Dim eq As New BASS_DX8_PARAMEQ()
              If Bass.BASS_FXGetParameters(_fxEQ(band), eq) Then
                eq.fGain = gain
                Bass.BASS_FXSetParameters(_fxEQ(band), eq)
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_PARAMEQ.fCenter">
            <summary>
            Center frequency, in hertz, in the range from 80 to 16000. This value cannot exceed one-third of the frequency of the channel. Default 100 Hz.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_PARAMEQ.fBandwidth">
            <summary>
            Bandwidth, in semitones, in the range from 1 to 36. Default 18 semitones.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_PARAMEQ.fGain">
            <summary>
            Gain, in the range from -15 to 15. Default 0 dB.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_PARAMEQ.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_PARAMEQ.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="Center">Center frequency, in hertz, in the range from 80 to 16000. This value cannot exceed one-third of the frequency of the channel.</param>
            <param name="Bandwidth">Bandwidth, in semitones, in the range from 1 to 36.</param>
            <param name="Gain">Gain in dB, in the range from -15 to 15.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_PARAMEQ.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_PARAMEQ.Preset_Low">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_PARAMEQ.Preset_Mid">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_PARAMEQ.Preset_High">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_REVERB">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a reverb effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_REVERB.fInGain">
            <summary>
            Input gain of signal, in decibels (dB), in the range from -96 through 0. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_REVERB.fReverbMix">
            <summary>
            Reverb mix, in dB, in the range from -96 through 0. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_REVERB.fReverbTime">
            <summary>
            Reverb time, in milliseconds, in the range from 0.001 through 3000. The default value is 1000.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_REVERB.fHighFreqRTRatio">
            <summary>
            In the range from 0.001 through 0.999. The default value is 0.001.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_REVERB.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_REVERB.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="InGain">Input gain of signal, in decibels (dB), in the range from -96 through 0.</param>
            <param name="ReverbMix">Reverb mix, in dB, in the range from -96 through 0.</param>
            <param name="ReverbTime">Reverb time, in milliseconds, in the range from 0.001 through 3000.</param>
            <param name="HighFreqRTRatio">In the range from 0.001 through 0.999.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_REVERB.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.STREAMPROC">
            <summary>
            User stream writing callback delegate (to be used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/>).
            </summary>
            <param name="handle">The stream that needs writing.</param>
            <param name="buffer">The pointer to the buffer to write the sample data in. The sample data must be written in standard Windows PCM format - 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1.</param>
            <param name="length">The number of bytes to write.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/> was called.</param>
            <returns>The number of bytes written by the function, optionally using the BASS_STREAMPROC_END (<see cref="T:Un4seen.Bass.BASSStreamProc"/>) flag to signify that the end of the stream is reached.</returns>
            <remarks>
            <para>A stream writing function should obviously be as quick as possible, because other streams (and MOD musics) can't be updated until it's finished.</para>
            <para>It is better to return less data quickly, rather than spending a long time delivering the amount BASS requested.</para>
            <para>Although a STREAMPROC may return less data than BASS requests, be careful not to do so by too much, too often. If the buffer level gets too low, BASS will automatically stall playback of the stream, until the whole buffer has refilled.</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled.</para>
            <para>A sync (BASS_SYNC_STALL) can also be set, to be triggered upon playback stalling or resuming.</para>
            <para>If you do return less than the requested amount of data, the number of bytes should still equate to a whole number of samples.</para>
            <para>Some functions can cause problems if called from within a stream (or DSP) function. Do not call these functions from within a stream callback:</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Free"/>, <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/> (or any other stream creation functions).</para>
            <para>Also, do not call <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> with the same handle as received by the callback.</para>
            <para>When streaming multi-channel sample data, the channel order of each sample is as follows:</para>
            <para>3 channels: left-front, right-front, center.</para>
            <para>4 channels: left-front, right-front, left-rear/side, right-rear/side.</para>
            <para>6 channels(5.1): left-front, right-front, center, LFE, left-rear/side, right-rear/side.</para>
            <para>8 channels(7.1): left-front, right-front, center, LFE, left-rear/side, right-rear/side, left-rear center, right-rear center.</para>
            <para>
            It is clever to NOT alloc buffer data (e.g. a float[]) everytime within the callback method, since ALL callbacks should be really fast!
            And if you would do a 'float[] data = new float[]' every time here...the GarbageCollector would never really clean up that memory.
            Sideeffects might occure, due to the fact, that BASS will call this callback too fast and too often...
            However, this is not always the case, so in most examples it'll work just fine - but if you got problems - try moving any memory allocation things outside any callbacks.
            </para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            A callback function to stream a file, in 44100hz 16-bit stereo:
            <code>
            private STREAMPROC _myStreamCreate; // make it global, so that the GC can not remove it
            private byte[] _data; // local data buffer
            ...
            _myStreamCreate = new STREAMPROC(MyFileProc);
            FileStream _fs = File.OpenRead("test.raw");
            int channel = Bass.BASS_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT, _myStreamCreate, IntPtr.Zero);
            Bass.BASS_ChannelPlay(channel, false);
            ...
            private int MyFileProc(int handle, IntPtr buffer, int length, IntPtr user)
            {
            	// implementing the callback for BASS_StreamCreate...
            	// here we need to deliver PCM sample data
            	// increase the data buffer as needed
            	if (_data == null || _data.Length &lt; length)
            		_data = new byte[length];
            	int bytesread = _fs.Read( _data, 0, length ); 
            	Marshal.Copy( _data, 0, buffer, bytesread );
            	if ( bytesread &lt; length )
            	{
            		bytesread |= (int)BASSStreamProc.BASS_STREAMPROC_END; // set indicator flag
            		_fs.Close();
            	}
            	return bytesread;
            }
            </code>
            <code lang="vbnet">
            Private _myStreamCreate As STREAMPROC  ' make it global, so that the GC can not remove it
            Private _data As Byte() = Nothing  ' our local buffer
            ...
            _myStreamCreate = New STREAMPROC(AddressOf MyFileProc)
            Dim fs As FileStream =  File.OpenRead("test.raw")
            Dim channel As Integer =  Bass.BASS_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT, _myStreamCreate, IntPtr.Zero) 
            Bass.BASS_ChannelPlay(channel, False)
            ...
            Private Function MyFileProc(ByVal handle As Integer, ByVal buffer As IntPtr, 
                                        ByVal length As Integer, ByVal user As IntPtr) As Integer
              ' implementing the callback for BASS_StreamCreate...
              ' here we need to deliver PCM sample data
              ' increase the data buffer as needed
              If _data = Nothing OrElse _data.Length &lt; length Then
                _data = New Byte(length) {}
              End If
              Dim bytesread As Integer = _fs.Read(_data, 0, length) 
              Marshal.Copy(_data, 0, buffer, bytesread)
              If bytesread &lt; length Then
                bytesread = bytesread Or CInt(BASSStreamProc.BASS_STREAMPROC_END) ' set indicator flag
                _fs.Close()
              EndIf
              Return bytesread
            End Function
            </code>
            If you're into C# you might also make use of native pointers in an unsafe code block:
            <code>
            unsafe private int MyFileProcUnsafe(int handle, IntPtr buffer, int length, IntPtr user)
            {
            	// simply cast the given IntPtr to a native pointer to byte values
            	byte *data = (byte*)buffer;
            	// read the file into the data pointer directly
            	int bytesread = length;
            	for (int a=0; a &lt; length; a++)
            	{
            		int val = _fs.ReadByte();
            		if (val != -1)
            		{
            			data[a] = (byte)val;   // set the value
            		}
            		else
            		{
            			bytesread = a;
            			break;
            		}
            	}
            	// end of the file/stream?
            	if ( bytesread &lt; length )
            	{
            		bytesread |= (int)BASSStreamProc.BASS_STREAMPROC_END; // set indicator flag
            		_fs.Close();
            	}
            	return bytesread;
            }
            </code>
            However, even if we directly access memory here, this is not really faster in that case, since we read the file byte per byte and also in a way perform a copy (we just use a single int buffer called val).
            So in essence when you need to read from a file you should take care, that the file access and read operation is fast an additional Marshal.Copy wouldn't count much in terms of performance.
            The only advantage we get here is actually, that we use less memory.
            </example>
        </member>
        <member name="T:Un4seen.Bass.FILECLOSEPROC">
            <summary>
            User file stream close callback function (to be used with <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).
            </summary>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> was called.</param>
            <remarks>With a buffered file stream, this function is called as soon as reading reaches the end of the file. 
            If the stream is freed before then, this function could be called while its <see cref="T:Un4seen.Bass.FILEREADPROC"/> function is in progress. 
            If that happens, the <see cref="T:Un4seen.Bass.FILEREADPROC"/> function call should be immediately cancelled.
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="T:Un4seen.Bass.FILELENPROC">
            <summary>
            User file stream length callback function (to be used with <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).
            </summary>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> was called.</param>
            <returns>The length of the file in bytes. 
            Returning 0 for a buffered file stream, makes BASS stream the file in blocks, and is equivalent to using the BASS_STREAM_BLOCK flag 
            in the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> call.</returns>
            <remarks>This function is called first thing, and is only used the once with buffered streams. 
            With unbuffered streams, it may be used again when testing for EOF (end of file), 
            allowing the file to grow in size.
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="T:Un4seen.Bass.FILEREADPROC">
            <summary>
            User file stream read callback function (to be used with <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).
            </summary>
            <param name="buffer">Pointer to the buffer to put the data in.</param>
            <param name="length">Maximum number of bytes to read.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> was called.</param>
            <returns>The number of bytes read... -1 = end of file, 0 = end of file (buffered file stream only).</returns>
            <remarks>During creation of the stream, this function should try to return the amount of data requested. 
            After that, it can just return whatever is available up to the requested amount.
            <para>For an unbuffered file stream during playback, this function should be as quick as possible - 
            any delays will not only affect the decoding of the current stream, but also all other streams and MOD musics that are playing. 
            It is better to return less data (even none) rather than wait for more data. 
            A buffered file stream isn't affected by delays like this, as this function runs in its own thread then.</para>
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="T:Un4seen.Bass.FILESEEKPROC">
            <summary>
            User file stream seek callback function (to be used with <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).
            </summary>
            <param name="offset">Position in bytes to seek to.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> was called.</param>
            <returns>TRUE if successful, else FALSE.</returns>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="T:Un4seen.Bass.DSPPROC">
            <summary>
            User defined DSP callback function (to be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/>).
            </summary>
            <param name="handle">The DSP handle (as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/>).</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The pointer to the buffer to apply the DSP to. The sample data is in standard Windows PCM format - 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of bytes to process.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/> was called.</param>
            <remarks>
            <para>A DSP function should obviously be as quick as possible... playing streams, MOD musics and other DSP functions can not be processed until it has finished.</para>
            <para>Some functions can cause problems if called from within a DSP (or stream) function. Do not call these functions from within a DSP callback:</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Free"/>, <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/> (or any other stream creation functions).</para>
            <para>Also, do not call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveDSP(System.Int32,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_MusicFree(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/> with the same channel handle as received by the callback.</para>
            <para>If the BASS_CONFIG_FLOATDSP config option is set, then DSP callback functions will always be passed 32-bit floating-point sample data, regardless of what the channels' actual sample format is.</para>
            <para>
            It is clever to NOT alloc buffer data (e.g. a float[]) everytime within the callback method, since ALL callbacks should be really fast!
            And if you would do a 'float[] data = new float[]' every time here...the GarbageCollector would never really clean up that memory.
            Sideeffects might occure, due to the fact, that BASS will call this callback too fast and too often...
            However, this is not always the case, so in most examples it'll work just fine - but if you got problems - try moving any memory allocation things outside any callbacks.
            </para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            You might use this code as a starting reference (it assumes 32-bit floating-point sample data):
            <code>
            private DSPPROC _myDSPAddr; // make it global, so that the GC can not remove it
            private float[] _data; // local data buffer
            ...
            _myDSPAddr = new DSPPROC(MyDSPCallback);
            Bass.BASS_ChannelSetDSP(_stream, _myDSPAddr, IntPtr.Zero, 2);
            ...
            private void MyDSPCallback(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              if (length == 0 || buffer == IntPtr.Zero)
                return;
              // number of bytes in 32-bit floats, since length is in bytes
              int l4 = length/4;
              // increase the data buffer as needed
              if (_data == null || _data.Length &lt; l4)
                _data = new float[l4];
              // copy from managed to unmanaged memory
              Marshal.Copy(buffer, _data, 0, l4);
            	
              // ... do your processing here
                
              // copy back from unmanaged to managed memory
              Marshal.Copy(_data, 0, buffer, l4);
            }
            </code>
            <code lang="vbnet">
            Private _myDSPAddr As DSPPROC  ' make it global, so that the GC can not remove it
            Private _data As Single() = Nothing  ' our local buffer
            ...
            _myDSPAddr = New DSPPROC(AddressOf MyDSPCallback)
            Bass.BASS_ChannelSetDSP(_stream, _myDSPAddr, IntPtr.Zero, 2)
            ...
            Private Sub MyGain(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              If length = 0 OrElse buffer = IntPtr.Zero Then
                Return
              End If
              ' number of bytes in 32-bit floats, since length is in bytes
              Dim l4 As Integer = length / 4
              ' increase the data buffer as needed
              If _data Is Nothing OrElse _data.Length &lt; l4 Then
                _data = New Single(l4) {}
              End If
              ' copy from unmanaged to managed memory
              Marshal.Copy(buffer, _data, 0, l4)
              	
              // ... do your processing here
            
              ' copy back from unmanaged to managed memory
              Marshal.Copy(_data, 0, buffer, l4)
            End Sub
            </code>
            If you're using C# you might even use unsafe code blocks to directly access memory via pointers, like in C/C++:
            <para>Note: such application must be compiled using the /unsafe compiler option!</para>
            <code>
            myDSPAddr = new DSPPROC(MyDSPGainUnsafe);
            Bass.BASS_ChannelSetDSP(_stream, myDSPAddr, IntPtr.Zero, 2);
            ...
            // the unsafe callback
            private DSPPROC myDSPAddr; // make it global, so that the Garbage Collector can not remove it
            private void MyDSPGainUnsafe(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              if (_gainAmplification == 1f || length == 0 || buffer == IntPtr.Zero)
                return;
              // length is in bytes, so the number of floats to process is:
              // length/4 : byte = 8-bit, float = 32-bit
              int l4 = length/4;
              unsafe
              {
                float *data = (float*)buffer;
                for (int a=0; a&lt;l4; a++)
                {
                  data[a] *= _gainAmplification;
                }
              }
            }
            </code>
            Using unsafe code is fast and efficient (especially in DSP routines), but is not type safe (e.g. no overflow handling, no type checking etc.) - so you just need to know what you are doing.
            </example>
        </member>
        <member name="T:Un4seen.Bass.DOWNLOADPROC">
            <summary>
            Internet stream download callback function (to be used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>).
            </summary>
            <param name="buffer">The pointer to the buffer containing the downloaded data... IntPtr.Zero = finished downloading.</param>
            <param name="length">The number of bytes in the buffer... 0 = HTTP or ICY tags.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>The callback will be called before the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> call returns (if it's successful), with the initial downloaded data. So any initialization (eg. creating the file if writing to disk) needs to be done either before the call, or in the callback function.</para>
            <para>When the BASS_STREAM_STATUS flag is specified in the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> call, HTTP and ICY tags may be passed to the callback during connection, before any stream data is received. The tags are given exactly as would be returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>. You can destinguish between HTTP and ICY tags by checking what the first string starts with ("HTTP" or "ICY").</para>
            <para>A download callback function could be used in conjunction with a BASS_SYNC_META sync set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to save individual tracks to disk from a Shoutcast stream.</para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            Stream an MP3 file, and save a local copy:
            <code>
            private FileStream _fs = null;
            private DOWNLOADPROC _myDownloadProc;
            private byte[] _data; // local data buffer
            ...
            _myDownloadProc = new DOWNLOADPROC(MyDownload);
            int stream = Bass.BASS_StreamCreateURL("http://www.asite.com/afile.mp3", 0, 
                              BASSFlag.BASS_DEFAULT, _myDownloadProc, IntPtr.Zero);
            ...
            private void MyDownload(IntPtr buffer, int length, IntPtr user)
            {
              if (_fs == null) 
              {
                // create the file
                _fs = File.OpenWrite( "output.mp3" );
              }
              if (buffer == IntPtr.Zero)
              {
                // finished downloading
                _fs.Flush();
                _fs.Close();
              }
              else
              {
                // increase the data buffer as needed
                if (_data == null || _data.Length &lt; length)
                  _data = new byte[length];
                // copy from managed to unmanaged memory
                Marshal.Copy(buffer, _data, 0, length);
                // write to file
                _fs.Write( _data, 0, length );
              }
            }
            </code>
            <code lang="vbnet">
            Private _fs As FileStream = Nothing
            Private _myDownloadProc As DOWNLOADPROC
            Private _data() As Byte ' local data buffer
            ...
            _myDownloadProc = New DOWNLOADPROC(AddressOf MyDownload)
            Dim stream As Integer = Bass.BASS_StreamCreateURL("http://www.asite.com/afile.mp3", 0, 
                                         BASSFlag.BASS_DEFAULT, _myDownloadProc, IntPtr.Zero)
            ...
            Private Sub MyDownload(buffer As IntPtr, length As Integer, user As IntPtr)
              If _fs Is Nothing Then
                ' create the file
                _fs = File.OpenWrite("output.mp3")
              End If
              If buffer = IntPtr.Zero Then
                ' finished downloading
                _fs.Flush()
                _fs.Close()
              Else
                ' increase the data buffer as needed
                If _data Is Nothing OrElse _data.Length &lt; length Then
                  _data = New Byte(length) {}
                End If
                ' copy from managed to unmanaged memory
                Marshal.Copy(buffer, _data, 0, length)
                ' write to file
                _fs.Write(_data, 0, length)
              End If
            End Sub
            </code>
            Note: If you are into C# the above example can also make use of usafe code blocks using native pointers to read the data from BASS and to write it to a file:
            <code>
            // within your download callback method...
            // assuming you have created a: BinaryWriter bw = new BinaryWriter(_fs);
            unsafe
            {
              // simply cast the given IntPtr to a native pointer to short values
              // assuming you receive 16-bit sample data here
              short *data = (short*)buffer;
              for (int a = 0; a &lt; length/2; a++)
              {
                // write the received sample data to a local file
                bw.Write( data[a] );
              }
            }
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.SYNCPROC">
            <summary>
            User defined synchronizer callback function (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> for details).
            </summary>
            <param name="handle">The sync handle that has occured (as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>).</param>
            <param name="channel">The channel that the sync occured on.</param>
            <param name="data">Additional data associated with the sync's occurance.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>A sync callback function should be very quick as other syncs can't be processed until it has finished. Attribute slides (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelSlideAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single,System.Int32)"/>) are also performed by the sync thread, so are also affected if a sync callback takes a long time.</para>
            <para>If the sync is a "mixtime" sync (BASS_SYNC_MIXTIME), then depending on the sync type, the callback will be executed in the update thread, and so the usual restrictions on which BASS functions can be called that apply to stream callbacks (<see cref="T:Un4seen.Bass.STREAMPROC"/>) also apply here. 
            It is also unsafe to call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> on the same channel from a mixtime sync callback. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> can be used in a mixtime sync to implement custom looping, eg. set a BASS_SYNC_POS sync at the loop end position and seek to the loop start position in the callback.</para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            Do some processing until a MOD music reaches the 10th order
            <code>
            private volatile bool _order10 = false; // the order 10 flag
            private SYNCPROC _mySyncProc;
            ...
            // set the one-time order 10 sync
            _mySyncProc = new SYNCPROC(MySync);
            Bass.BASS_ChannelSetSync(music, BASSSync.BASS_SYNC_MUSICPOS | BASSSync.BASS_SYNC_ONETIME, 
                 Utils.MakeLong64(10,0), _mySyncProc, IntPtr.Zero);
            while (!_order10) 
            {
              // order 10 has not arrived, so do some processing
              Thread.Sleep(0);
            }
            // order 10 has arrived!
            ...
            // the sync callback
            private void MySync(int syncHandle, int channel, int data, IntPtr user) 
            {
            	_order10 = true; // set the order 10 flag
            }
            </code>
            <code lang="vbnet">
            Private _order10 As Boolean = False ' the order 10 flag
            Private _mySyncProc As SYNCPROC
            ...
            ' set the one-time order 10 sync
            _mySyncProc = New SYNCPROC(AddressOf MySync)
            Bass.BASS_ChannelSetSync(music, BASSSync.BASS_SYNC_MUSICPOS Or BASSSync.BASS_SYNC_ONETIME, 
                 Utils.MakeLong64(10, 0), _mySyncProc, IntPtr.Zero)
            While Not _order10
              ' order 10 has not arrived, so do some processing
              Thread.Sleep(0)
            End While
            ' order 10 has arrived!
            ...
            ' the sync callback
            Private Sub MySync(syncHandle As Integer, channel As Integer, data As Integer, user As IntPtr)
              _order10 = True ' set the order 10 flag
            End Sub
            </code>
            Process metadata received from an internet stream:
            <code>
            private SYNCPROC _mySync;
            ...
            int stream = Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_DEFAULT, null, 0);
            // set a sync to get notified on stream title updates
            _mySync = new SYNCPROC(MetaSync);
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            private void MetaSync(int handle, int channel, int data, IntPtr user)
            {
              // BASS_SYNC_META is triggered
              string[] tags = Bass.BASS_ChannelGetTagsMETA(channel);
              foreach (string tag in tags)
                Console.WriteLine(tag);
            }
            </code>
            <code lang="vbnet">
            Private _mySync As SYNCPROC
            ...
            Dim stream As Integer =  Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_DEFAULT, Nothing, 0) 
            ' set a sync to get notified on stream title updates
            _mySync = New SYNCPROC(AddressOf MetaSync)
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Private Sub MetaSync(ByVal handle As Integer, ByVal channel As Integer, 
                                 ByVal data As Integer, ByVal user As IntPtr)
              ' BASS_SYNC_META is triggered
              Dim tags() As String = Bass.BASS_ChannelGetTagsMETA(channel) 
              Dim tag As String
              For Each tag In tags
                Console.WriteLine(tag)
            End Sub
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.RECORDPROC">
            <summary>
            User defined callback function to process recorded sample data.
            </summary>
            <param name="handle">The recording handle that the data is from.</param>
            <param name="buffer">The pointer to the buffer containing the recorded sample data. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of bytes in the buffer.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/> was called.</param>
            <returns>Return 0 to stop recording, and anything else to continue recording.</returns>
            <remarks>
            <para>
            It is clever to NOT alloc any buffer data (e.g. a byte[]) everytime within the callback method, since ALL callbacks should be really fast!
            And if you would do a 'byte[] data = new byte[]' every time here...the GarbageCollector would never really clean up that memory.
            Sideeffects might occure, due to the fact, that BASS will call this callback too fast and too often...
            </para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            <code>
            private RECORDPROC _myRecProc; // make it global, so that the GC can not remove it
            private int _byteswritten = 0;
            private byte[] _recbuffer; // local recording buffer
            ...
            if ( Bass.BASS_RecordInit(-1) )
            {
              _myRecProc = new RECORDPROC(MyRecording);
              int recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero);
              ...
              // start recording
              Bass.BASS_ChannelPlay(recHandle, false);
            }
            ...
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              bool cont = true;
              if (length &gt; 0 &amp;&amp; buffer != IntPtr.Zero)
              {
                // increase the rec buffer as needed
                if (_recbuffer == null || _recbuffer.Length &lt; length)
                  _recbuffer = new byte[length];
                // copy from managed to unmanaged memory
                Marshal.Copy(buffer, _recbuffer, 0, length);
                _byteswritten += length;
                // write to file
                ...
                // stop recording after a certain amout (just to demo)
                if (_byteswritten &gt; 800000)
                  cont = false; // stop recording
              }
              return cont;
            }
            </code>
            <code lang="vbnet">
            Private _myRecProc As RECORDPROC ' make it global, so that the GC can not remove it
            Private _byteswritten As Integer = 0
            Private _recbuffer() As Byte ' local recording buffer
            ...
            If Bass.BASS_RecordInit(-1) Then
              _myRecProc = New RECORDPROC(AddressOf MyRecording)
              Dim recHandle As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero)
              ...
              ' start recording
              Bass.BASS_ChannelPlay(recHandle, False)
            End If
            ...
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              Dim cont As Boolean = True
              If length &gt; 0 AndAlso buffer &lt;&gt; IntPtr.Zero Then
                ' increase the rec buffer as needed
                If _recbuffer Is Nothing OrElse _recbuffer.Length &lt; length Then
                  _recbuffer = New Byte(length) {}
                End If
                ' copy from managed to unmanaged memory
                Marshal.Copy(buffer, _recbuffer, 0, length)
                _byteswritten += length
                ' write to file
                ...
                ' stop recording after a certain amout (just to demo)
                If _byteswritten &gt; 800000 Then
                  cont = False ' stop recording
                End If
              End If
              Return cont
            End Function
            </code>
            If you are into C# you might also use an unsafe codeblock with native pointer access 
            (which might be must faster than the above - depending on what you are doing with the data):
            <code>
            private unsafe bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              bool cont = true;
              if (length &gt; 0 &amp;&amp; buffer != IntPtr.Zero)
              {
                // assuming 16-bit sample data here
                short *data = (short*)buffer;
                ...
            
                // stop recording after a certain amout (just to demo)
                if (_byteswritten &gt; 800000)
                  cont = false; // stop recording
              }
              return cont;
            }
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Alac.BassAlac">
            <summary>
            BASS.NET API wrapper for BASS_ALAC.DLL
            <para>Requires: bass_alac.dll - Apple Lossless Audio Codec (ALAC) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_ALAC is an extension to the BASS audio library, enabling the playback of ALAC files.</para>
            <para>ALAC is an audio codec developed by Apple Computer. It is not a variant of AAC, but a totally new lossless format which is usually wrapped into an MP4 or MOV container. The Apple Lossless Encoder was introduced as a component of QuickTime 6.5.1 on April 28th, 2004 and thus as a feature of iTunes 4.5.</para>
            <para>The ALAC format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Alac.BassAlac.BASS_ALAC_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> /User functions.</para>
            <para>More information can be found on <a href="http://www.dolby.com">www.dolby.com</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Alac.BassAlac.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Alac.BassAlac.BASS_ALAC_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Alac.BassAlac.BASS_ALAC_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Apple Lossless Audio file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Alac.BassAlac.BASS_ALAC_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Alac.BassAlac.BASS_ALAC_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Apple Lossless Audio memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Alac.BassAlac.BASS_ALAC_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a Apple Lossless Audio file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Alac.BassAlac.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_alac.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Alac.BassAlac.SupportedStreamName">
            <summary>
            Supported file format name of the bass_alac.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Alac.BassAlac.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Alac.BassAlac.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Alac.BassAlac.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Alac.BassAlac.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Alac.BassAlac.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.BaseDSP">
            <summary>
            Base class for all user defined DSP classes (e.g. <see cref="T:Un4seen.Bass.Misc.DSP_PeakLevelMeter"/>, <see cref="T:Un4seen.Bass.Misc.DSP_Gain"/> or your own DSP implementations).
            </summary>
            <remarks>This base class is not intended for direct use, but defines all abstract properties and methods which needs to be implemented by an actual DSP class.
            A derived class must implement: <see cref="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>.
            <para>The properties <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelBitwidth"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelSampleRate"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelNumChans"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPHandle"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPProc"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.IsBypassed"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.IsAssigned"/>
            as well as the methods <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>, <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> and <see cref="M:Un4seen.Bass.Misc.BaseDSP.SetBypass(System.Boolean)"/> have been already implemented.</para>
            <para>You might use this base class to derive your own DSP implementations.
            In this case a derived class must implement the <see cref="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> method and might override the <see cref="M:Un4seen.Bass.Misc.BaseDSP.OnChannelChanged"/> method (e.g. in order to reset an internal buffer etc.).</para>
            <para>The whole DSP framework is based on the standard BASS DSP functionality.
            So as with all DSP's - the DSP is automatically freed whenever the source stream is freed, e.g. when calling <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/> or when using the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_AUTOFREE"/> flag.</para>
            </remarks>
            <example>
            This example shows a basic implementation of an own DSP class:
            <code>
            public class DSP_MyDsp : BaseDSP
            {
            	// First Constructor overload
            	public DSP_MyDsp() : base()
            	{
            	}
            	// Second Constructor overload
            	public DSP_MyDsp(int channel, int priority) : base(channel, priority, 0)
            	{
            	}
            	
            	// example implementation of the DSPCallback method
            	unsafe public override void DSPCallback(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            	{
            		if (IsBypassed)
            			return;
            			
            		if (ChannelBitwidth == 16)
            		{
            			// process the data
            			short *data = (short*)buffer;
            			for (int a = 0; a &lt; length/2; a++)
            			{
            				// your work goes here (16-bit sample data)
            			}
            		}
            		else if (ChannelBitwidth == 32)
            		{
            			// process the data
            			float *data = (float*)buffer;
            			for (int a = 0; a &lt; length/4; a++)
            			{
            				// your work goes here (32-bit sample data)
            			}
            		}
            		else
            		{
            			// process the data
            			byte *data = (byte*)buffer;
            			for (int a = 0; a &lt; length; a++)
            			{
            				// your work goes here (8-bit sample data)
            			}
            		}
            		// if you have calculated UI relevant data you might raise the event
            		// else comment out the following line
            		RaiseNotification();
            	}
            	
            	public override void OnChannelChanged()
            	{
            		// override this method if you need to react on channel changes
            		// e.g. usefull, if an internal buffer needs to be reset etc.
            	}
            	
            	public override string ToString()
            	{
            		return "My DSP";
            	}
            }
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.#ctor">
            <summary>
            Default constructor. Not assigning a DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            <para>If an instance of a derived class s being disposed, an already assigned DSP will automatically be removed from the channel.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.#ctor(System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Default constructor, which already evaluates the channel handle and assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>If an instance of a derived class s being disposed, an already assigned DSP will automatically be removed from the channel.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid channel used.</exception>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.Dispose">
            <summary>
            Implement IDisposable.
            </summary>
            <remarks>Do not make this method virtual. A derived class should not be able to override this method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.Start">
            <summary>
            Assigns the DSP to the channel (actually starts using the DSP).
            </summary>
            <returns>TRUE, if started successfully - else FALSE will be returned.</returns>
            <remarks>
            <para>Depending on which constructor you used to create an instance of the DSP, this method might have already being called.</para>
            <para>Calling this method again, if the DSP has already being assigned will have no effect. You must call <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> before you can call <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> again.</para>
            <para>Internally this method simply calls <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/> and thereby uses the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPProc"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> members.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.Stop">
            <summary>
            Stops (removes) the DSP from the channel.
            </summary>
            <returns>TRUE, if the DSP was removed successfully - else FALSE will be returned (e.g. in case that the DSP has already been removed).</returns>
            <remarks>
            <para>A DSP will automatically be removed, if the channel is being freed. So there is not an explicit need of calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> at the end of stream.
            However, the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPHandle"/> might return invalid handle in such case. You might use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> to check, if a channel is still active.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.SetBypass(System.Boolean)">
            <summary>
            Sets the Bypass mode.
            </summary>
            <param name="bypass">Bypass?</param>
            <remarks>If Bypass is set, a DSP function should actually return immediately and not process the sample data. 
            You might check the actual Bypass mode with the <see cref="P:Un4seen.Bass.Misc.BaseDSP.IsBypassed"/> property.
            <para>If the DSP function should be bypassed, this needs to be implemented in the <see cref="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> function of a derived class.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.OnChannelChanged">
            <summary>
            This method will be called every time the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> changed.
            </summary>
            <remarks>In the default implementation this method does nothing. 
            It might be overridden in a derived class to reflect a channel change, e.g. to reset an internal buffer etc.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.OnStarted">
            <summary>
            This method will be called every time the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> method had been called.
            </summary>
            <remarks>In the default implementation this method does nothing. 
            It might be overridden in a derived class to perform some addition setup calculations whenever the DSP was started, e.g. to reset an internal buffer etc.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.OnStopped">
            <summary>
            This method will be called every time the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> method had been called.
            </summary>
            <remarks>In the default implementation this method does nothing. 
            It might be overridden in a derived class to perform some addition cleanup calculations whenever the DSP was stopped, e.g. to reset an internal buffer etc.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.OnBypassChanged">
            <summary>
            This method will be called every time the <see cref="M:Un4seen.Bass.Misc.BaseDSP.SetBypass(System.Boolean)"/> method had been called.
            </summary>
            <remarks>In the default implementation this method does nothing. 
            It might be overridden in a derived class to reflect a change of the bypass status, e.g. to reset an internal buffer etc.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which needs to be implemented in the derived class.
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>A DSP function should obviously be as quick as possible... playing streams, MOD musics and other DSP functions can not be processed until it has finished.
            <para>You might use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelBitwidth"/> to determine if the sample data received is 8-, 16- or 32-bit. <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelNumChans"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelSampleRate"/> might be used to retrieve additional information about the channel being used.</para>
            <para>Make sure to handle the <see cref="P:Un4seen.Bass.Misc.BaseDSP.IsBypassed"/> property in order to support a bypass feature.</para>
            <para>Some functions can cause problems if called from within a DSP (or stream) function. Do not call these functions from within a DSP callback:</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Free"/>, <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/> (or any other stream creation functions).</para>
            <para>Also, do not call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveDSP(System.Int32,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_MusicFree(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/> with the same channel handle as received by the callback.</para>
            <para>
            It is clever to NOT alloc buffer data (e.g. a float[]) everytime within the callback method, since ALL callbacks should be really fast!
            And if you would do a 'float[] data = new float[]' every time here...the GarbageCollector would never really clean up that memory.
            Sideeffects might occure, due to the fact, that BASS will call this callback too fast and too often...you might also declare the callback function as 'unsafe' and use native pointer assignements for fast processing.
            However, this is not always the case, so in most examples it'll work just fine - but if you got problems - try moving any memory allocation things outside any callbacks.
            </para>
            <para>In a derived class you might call <see cref="M:Un4seen.Bass.Misc.BaseDSP.RaiseNotification"/> at the end of your processing, in order to fire the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/>.
            By doing so all subscribers will get notified, that the DSP processing has been done - e.g. in order to update a UI thread.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.RaiseNotification">
            <summary>
            Fires the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event.
            </summary>
            <remarks>Call this method to fire the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event.
            <para>This event might be used to notified the subscriber, that the DSP has processed some data and that for an example a UI needs to be updated in order to reflect this.
            However, if a DSP implementation does not have any UI relevant data to show, there will be no need to call this method in your DSP implementation and can simply be omitted.</para>
            <para>Note: This implementation ensures, that the event will be executed in the main thread the subscriber executes in!
            So when subscribing to this event from UI thread, the specified event delegate will also be called in that UI thread.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.ToString">
            <summary>
            Returns the name of the DSP implementation.
            </summary>
        </member>
        <member name="E:Un4seen.Bass.Misc.BaseDSP.Notification">
            <summary>
            Event handler used to notify that the DSP has processed some data.
            </summary>
            <remarks>This event might be used to get notified, that the DSP has processed some data and that for example a UI needs to be updated in order to reflect this.
            <para>Note: This implementation ensures, that the event will be executed in the main thread the subscriber executes in!
            So when subscribing to this event from UI thread, the specified event delegate will also be called in that UI thread.</para>
            <para>In a DSP implementation you need to call <see cref="M:Un4seen.Bass.Misc.BaseDSP.RaiseNotification"/> in order to fire this event.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle">
            <summary>
            Gets or Sets the channel that the DSP is being applied to.
            </summary>
            <remarks>If the DSP has already been assigned, changing the channel will automatically reassign the DSP to the new channel.
            <para>A DSP will automatically be removed, if the channel is being freed.
            Therefore this member might return a channel handle which is not active anymore. You might use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> to check, if a channel is still active.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid channel used.</exception>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.ChannelInfo">
            <summary>
            Gets the <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> of the assigned <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.ChannelBitwidth">
            <summary>
            This property returns the actual bitwidth of the sample data of the channel (e.g. 8, 16, 32).
            </summary>
            <remarks>BASS supports 8/16/32-bit sample data, so if a WAV file, for example, uses another sample resolution, it'll have to be converted by BASS.
            This bitwidth represents the bitwidth which is used by BASS (e.g. in a DSP callback delegate) and does not represent the original bitwidth of the channel.
            The bitwidth used by BASS is determined how the underlying channel handle was created (e.g. using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> with the <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_8BITS"/> or <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT"/> flag)
            and if the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_FLOATDSP"/> option has been set.
            If non of the above was used, by default 16 bits per sample are used.
            <para>However this bitwidth is the bitwidth in use when sending sample data to the <see cref="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>.
            If for example the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_FLOATDSP"/> or the <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT"/> option have been used, the DSP would receive 32-bit float samples.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.ChannelSampleRate">
            <summary>
            This property returns the actual sample rate in Hz of the sample data BASS is using with the channel (e.g. 44100).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.ChannelNumChans">
            <summary>
            This property returns the actual number of channles of the sample data BASS is using with the channel (e.g. 1=mono, 2=stereo, etc.).
            </summary>
            <remarks>BASS supports multi-channel sample data, so make sure the actual DSP implementation supports multi-channel too.
            If the DSP does not support multi-channel make sure that you are using non-multi-channel handles only.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority">
            <summary>
            Sets or reassigns the priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.
            </summary>
            <remarks>If the DSP has already been assigned, changing the priority will immediately reassig the DSP to the new priority.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.User">
            <summary>
            Gets or Sets the value of the user instance data to pass to the callback function (see <see cref="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.DSPHandle">
            <summary>
            Returns the actual DSP handle (or 0, if the DSP has not been assigned to the channel).
            </summary>
            <remarks>Caution: This member is not intended for direct use - but has more of an informal character.
            <para>A DSP will automatically be removed, if the channel is being freed.
            Therefore this member might return a dsp handle which is not active anymore. You might use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> to check, if a channel is still active.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.DSPProc">
            <summary>
            Returns the actual <see cref="T:Un4seen.Bass.DSPPROC"/> (callback delegate) which is used by the DSP.
            </summary>
            <remarks>This callback delegate is being created when a DSP instance is being created.
            <para>Caution: This member is not intended for direct use - but has more of an informal character.
            However, you might use the delegate, if you want to manually make use of the implementation of the DSP, but want to handle the entire DSP assignement yourself.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.IsBypassed">
            <summary>
            Returns if the DSP is currently bypassed (TRUE=bypass).
            </summary>
            <remarks>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.SetBypass(System.Boolean)"/> to change the current bypass mode.
            <para>Bypassing a DSP is not done automatically! 
            The actual implementation of the <see cref="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> method in a derived class must support this feature (e.g. the <see cref="P:Un4seen.Bass.Misc.BaseDSP.IsBypassed"/> member has to be evaluated there).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.IsAssigned">
            <summary>
            Is the DSP assigned to an active channel? (TRUE=assigned, FALSE=not assigned).
            </summary>
            <remarks>This property will also return FALSE, if the underlying <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> has been freed in the meantime.
            In this case the DSP will be removed automatically.</remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_PeakLevelMeter">
            <summary>
            Peak Level Meter DSP.
            </summary>
            <remarks>Calculates the volume (amplitude) of the channel signal in volts or dB.
            <para>The DSP automatically converts 8-, 16- or 32-bit sample data accordingly.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>The peak levels (Left channel=<see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelL"/> and Right channel=<see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelR"/>) are integer values between 0 (-inf.dB) and 32768 (0dB) - or higher, if the channel is floating-point.
            Use the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelL_dBV"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelR_dBV"/> properties, if you want these integer peak values already converted into dBV values (to a reference voltage of 1.0).</para>
            </remarks>
            <example>
            Set up a PeakLevelMeter DSP on a recording channel:
            <code>
            private DSP_PeakLevelMeter _plm;
            public delegate void UpdatePeakMeterCallback();
            ...
            Bass.BASS_RecordInit(-1);
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, _recProc, 0);
            ...
            // set up a ready-made DSP (here the PeakLevelMeter)
            _plm = new DSP_PeakLevelMeter(_recHandle, 1);
            _plm.CalcRMS = true;
            _plm.Notification += new EventHandler(UpdatePeakMeterDisplay);
            ...
            private void UpdatePeakMeterDisplay(object sender, EventArgs e)
            {
            	this.progressBarRecL.Value = _plm.LevelL;
            	this.progressBarRecR.Value = _plm.LevelR;
            	this.labelRMS.Text = String.Format( "RMS: {0:#00.0} dB - AVG: {1:#00.0} dB - Peak: {2:#00.0} dB", 
            				_plm.RMS_dBV, 
            				_plm.AVG_dBV, 
            				Math.Max(_plm.PeakHoldLevelL_dBV, _plm.PeakHoldLevelR_dBV) );
            }
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.#ctor">
            <summary>
            Creates a new instance of the PeakMeterLevel DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the PeakMeterLevel DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.OnChannelChanged">
            <summary>
            Resets the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelL"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelR"/> values when a channel change occurred.
            </summary>
            <remarks>If you want to reset the peak hold values more ofen, call the <see cref="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold"/> method manually.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold">
            <summary>
            Resets the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelL"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelR"/> values when a channel change occurred.
            </summary>
            <remarks>If you want to reset the peak hold values more ofen, call the <see cref="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold"/> method manually.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the peak level calculation. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelL">
            <summary>
            Returns the current level signal (in linear voltage steps) of the left-channel as an integer value (between 0 and 32768, or above, if a floating-point channel was selected).
            </summary>
            <remarks>The voltage steps are between 0 and 32768 or above.
            Meaning a level signal of 1.0 volt is equivalent to a value of 32768 which means 0 dBV. A level signal of 0.0 volt is equivalent to 0 which means -Infinity dBV (-0.5 volt is approx. 16384 as an integer value or -6 dbV).
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelL">
            <summary>
            Returns the peak level signal (in linear voltage steps) of the left-channel since the last channel change or <see cref="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelL_dBV">
            <summary>
            Returns the current level signal of the left-channel as a dBV value (between -Infinity and 0.0 - or above, if a floating-point channel was selected).
            </summary>
            <remarks>The reference voltage for dBV is exactly 1.0 volt.
            <para>Meaning a level signal of 0.0 dbV is equivalent to 1.0 volt or a level signal of -Infinity dBV is equivalent to 0.0 volt (and -6 dBV is approx. -0.5 volt).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelL_dBV">
            <summary>
            Returns the peak level signal of the left-channel as a dBV value (between -Infinity and 0.0 - or above, if a floating-point channel was selected) since the last channel change or <see cref="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelR">
            <summary>
            Returns the current level signal (in linear voltage steps) of the right-channel as an integer value (between 0 and 32768, or above, if a floating-point channel was selected).
            </summary>
            <remarks>The voltage steps are between 0 and 32768 or above.
            Meaning a level signal of 1.0 volt is equivalent to a value of 32768 which means 0 dBV. A level signal of 0.0 volt is equivalent to 0 which means -Infinity dBV (-0.5 volt is approx. 16384 as an integer value or -6 dbV).
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelR">
            <summary>
            Returns the peak level signal (in linear voltage steps) of the right-channel since the last channel change or <see cref="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelR_dBV">
            <summary>
            Returns the current level signal of the right-channel as a dBV value (between -Infinity and 0.0 - or above, if a floating-point channel was selected).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelR_dBV">
            <summary>
            Returns the peak level signal of the right-channel as a dBV value (between -Infinity and 0.0 - or above, if a floating-point channel was selected) since the last channel change or <see cref="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.CalcRMS">
            <summary>
            Gets or Sets if the AVG and RMS values should be calculated.
            </summary>
            <remarks>The AVG (average value) and RMS (root mean square error) might be retrieved using the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.AVG"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.RMS"/> property.
            If CalcRMS is turned off (FALSE, default) the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.AVG"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.RMS"/> property would always return 0.0.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.AVG">
            <summary>
            Returns the current AVG value (average, in linear voltage steps, between 0...32768...N) of the signal.
            </summary>
            <remarks>If CalcRMS is turned off (FALSE, default) this property would always return 0.0.
            Use <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.CalcRMS"/> to turn AVG calculation on or off.
            <para>The AVG is calculated based on the samples received in each DSP call.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.AVG_dBV">
            <summary>
            Returns the current AVG value (average, in dBV) of the signal.
            </summary>
            <remarks>If CalcRMS is turned off (FALSE, default) this property would always return -Infinity.
            Use <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.CalcRMS"/> to turn AVG calculation on or off.
            <para>The reference voltage for dBV is exactly 1.0 volt.</para>
            <para>The AVG is calculated based on the samples received in each DSP call.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.RMS">
            <summary>
            Returns the current RMS value (root mean square, in voltage steps, between 0...32768...N) of the signal.
            </summary>
            <remarks>If CalcRMS is turned off (FALSE, default) this property would always return 0.0.
            Use <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.CalcRMS"/> to turn RMS calculation on or off.
            <para>The RMS is calculated based on the samples received in each DSP call.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.RMS_dBV">
            <summary>
            Returns the current RMS value (root mean square, in dBV) of the signal.
            </summary>
            <remarks>If CalcRMS is turned off (FALSE, default) this property would always return -Infinity.
            Use <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.CalcRMS"/> to turn RMS calculation on or off.
            <para>The reference voltage for dBV is exactly 1.0 volt.</para>
            <para>The RMS is calculated based on the samples received in each DSP call.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.UpdateTime">
            <summary>
            Gets or Sets the update time in seconds (default is 0.1 = 100ms, max. is 60 seconds) which is the timespan being used to measure RMS and PeakLevels and is also used for Notification trigges.
            </summary>
            <remarks>This timespan controls the following:
            <para>1. How often the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event should be raised.</para>
            <para>2. How many samples should be used to calculate the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.RMS"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.AVG"/> values.</para>
            <para>3. How many samples should be used to calculate the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelL"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelR"/> values.</para>
            <para>If you set the value to 0.0 (zero) immediate update is triggered, meaning with each DSP processing step the above is being triggered/calculated.</para>
            <para>Depending on what you want to do, good values are between 0.02 (20ms, realtime), 0.08 (80ms, user-interface) and 0.5 (500ms, RMS).</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_Gain">
            <summary>
            Gain DSP (amplification).
            </summary>
            <remarks>Amplifies the channel signal by a given factor (either specified as a double <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain"/> factor or in dB via the <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain_dBV"/> property).
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>The gain to be applied is defined via <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain"/> (factor, Min.: 0.0, Max.: 1024.0, no amplification at a value of 1.0) or <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain_dBV"/> (dB, Min.: -Infinity, Max.: +60, no amplification at a value of 0.0).</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Gain.#ctor">
            <summary>
            Creates a new instance of the Gain DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Gain.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Gain DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Gain.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the gain amplification. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Gain.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Gain.Gain">
            <summary>
            Gets or Sets the amplification level (factor, Min.: 0.0, Max.: 1024.0, no amplification at 1.0).
            </summary>
            <remarks>The sample data is actually multiplied by this factory. 
            <para>Values between 0.0 and less than 1.0 will actually be an attenuation of the signal level.</para>
            <para>Values above 1.0 will actually be an amplification of the signal level, whereas a value of exactly 1.0 will leave the signal level unmodified.</para>
            <para>The gain can also be applied via <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain_dBV"/> (dB, Min.: -Infinity, Max.: +60, no amplification at a value of 0.0).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Gain.Gain_dBV">
            <summary>
            Gets or Sets the amplification level (in dBV, Min.: -Infinity, Max.: +60, no amplification at a value of 0.0 dB).
            </summary>
            <remarks>Using this property will actually convert the specified dB value into a factor (see <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain"/>) internally. 
            The sample data is then multiplied by this factory. The reference voltage for dBV is exactly 1.0 volt.
            <para>Values between -Infinity and less than 0.0 dB will actually be an attenuation of the signal level.</para>
            <para>Values above 0.0 dB will actually be an amplification of the signal level, whereas a value of exactly 0.0 will leave the signal level unmodified.</para>
            <para>The gain can also be applied directly via <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain"/> (factor, Min.: 0.0, Max.: 1024.0, no amplification at 1.0).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Gain.UseDithering">
            <summary>
            Gets or Sets, if Dithering should be used (default is FALSE).
            </summary>
            <remarks>
            Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dither only applies when processing 8- or 16-bit sample data (since here the <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain"/> factor might result in computation 'errors') - for 32-bit (float) sample data dither will never be applied here.</para>
            <para>Dithering is implemented here as a triangular probability density function (TPDF), actually a "<see cref="P:Un4seen.Bass.Misc.DSP_Gain.DitherFactor"/> bit triangular dither" (default is 0.7).</para>
            <para>If Dithering is disabled, the sample value will be rounded to the nearest value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Gain.DitherFactor">
            <summary>
            Gets or Sets the dithering bitdepth of the triangular probability density function (TPDF) - default is 0.7.
            </summary>
            <remarks>The TPDF is implemented as a "<see cref="P:Un4seen.Bass.Misc.DSP_Gain.DitherFactor"/> bit triangular dither", ie. by default a "0.7 bit triangular dither" is used.
            <para>Dithering only applies here when processing 8- or 16-bit sample data and when the <see cref="P:Un4seen.Bass.Misc.DSP_Gain.UseDithering"/> property has been set to TRUE.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_Pan">
            <summary>
            Stereo Panning DSP (balance).
            </summary>
            <remarks>A stereo Panning DSP. Panning is controlled via the <see cref="P:Un4seen.Bass.Misc.DSP_Pan.Pan"/> property.
            <para>Note: This DSP only works on streams with a multiple of 2 channels (e.g. stereo, quadro, etc.).</para>
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Pan.#ctor">
            <summary>
            Creates a new instance of the Panning DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Pan.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Panning DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Pan.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the panning. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Pan.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Pan.Pan">
            <summary>
            Defines the panning factor between -1.0 (pan left) and 1.0 (pan right), center is at 0.0 (default).
            </summary>
            <remarks>Assigning values outside the valid range [-1..1] will be capped automatically.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Pan.UseDithering">
            <summary>
            Gets or Sets, if Dithering should be used (default is FALSE).
            </summary>
            <remarks>
            Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dither only applies when processing 8- or 16-bit sample data (since here the <see cref="P:Un4seen.Bass.Misc.DSP_Pan.Pan"/> factor might result in computation 'errors') - for 32-bit (float) sample data dither will never be applied here.</para>
            <para>Dithering is implemented here as a triangular probability density function (TPDF), actually a "<see cref="P:Un4seen.Bass.Misc.DSP_Pan.DitherFactor"/> bit triangular dither" (default is 0.7).</para>
            <para>If Dithering is disabled, the sample value will be rounded to the nearest value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Pan.DitherFactor">
            <summary>
            Gets or Sets the dithering bitdepth of the triangular probability density function (TPDF) - default is 0.7.
            </summary>
            <remarks>The TPDF is implemented as a "<see cref="P:Un4seen.Bass.Misc.DSP_Pan.DitherFactor"/> bit triangular dither", ie. by default a "0.7 bit triangular dither" is used.
            <para>Dithering only applies here when processing 8- or 16-bit sample data and when the <see cref="P:Un4seen.Bass.Misc.DSP_Pan.UseDithering"/> property has been set to TRUE.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_Mono">
            <summary>
            Mono DSP (converts a stereo signal to a mono signal).
            </summary>
            <remarks>A stereo to mono DSP.
            <para>Note: This DSP only works on streams with a multiple of 2 channels (e.g. stereo, quadro, etc.).</para>
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Mono.#ctor">
            <summary>
            Creates a new instance of the Mono DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Mono.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Mono DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Mono.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the mono conversion. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Mono.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Mono.Invert">
            <summary>
            Gets or Sets, if the stereo signal should be inverted (forces inverted stereo information to be removed - default is FALSE).
            </summary>
            <remarks>Forcing to remove any stereo information which often results in a kind of karaoce effect. Also might be used, if there is an inverted phase in the stereo signal, if a mono signal had been recorded in stereo.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Mono.UseDithering">
            <summary>
            Gets or Sets, if Dithering should be used (default is FALSE).
            </summary>
            <remarks>
            Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dither only applies when processing 8- or 16-bit sample data (since here the mono calculation might result in computation 'errors') - for 32-bit (float) sample data dither will never be applied here.</para>
            <para>Dithering is implemented here as a triangular probability density function (TPDF), actually a "<see cref="P:Un4seen.Bass.Misc.DSP_Mono.DitherFactor"/> bit triangular dither" (default is 0.7).</para>
            <para>If Dithering is disabled, the sample value will be rounded to the nearest value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Mono.DitherFactor">
            <summary>
            Gets or Sets the dithering bitdepth of the triangular probability density function (TPDF) - default is 0.7.
            </summary>
            <remarks>The TPDF is implemented as a "<see cref="P:Un4seen.Bass.Misc.DSP_Mono.DitherFactor"/> bit triangular dither", ie. by default a "0.7 bit triangular dither" is used.
            <para>Dithering only applies here when processing 8- or 16-bit sample data and when the <see cref="P:Un4seen.Bass.Misc.DSP_Mono.UseDithering"/> property has been set to TRUE.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_StereoEnhancer">
            <summary>
            Stereo Enhancer DSP (actually also removes mono signals).
            </summary>
            <remarks>A simple stereo enhancer. Use the <see cref="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.WideCoeff"/> property to contol the wideness of the stereo effect and the <see cref="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.WetDry"/> property to control how much the effect should impact the original signal.
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StereoEnhancer.#ctor">
            <summary>
            Creates a new instance of the Stereo Enhancer DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StereoEnhancer.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Stereo Enhancer DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StereoEnhancer.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the stereo enhancement. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StereoEnhancer.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.WideCoeff">
            <summary>
            Gets or Sets the stereo wide (coefficient) controling the stereo enhancement between 0.0 (narrow, mono signal) and 10.0 (wide, enhanced stereo signal) - default is 2.0.
            </summary>
            <remarks>A values of 0.0 will result in a narrow mono signal and a value of 1.0 in a original stereo, whereas values above 1.0 will provide an enhanced wide stereo signal.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.WetDry">
            <summary>
            Gets or Sets the Wet/Dry ratio between 0.0 (dry, unprocessed signal only) and 1.0 (wet, processed signal only) - default is 0.5.
            </summary>
            <remarks>This property defines how much of the effect signal will be mixed into the original signal.
            <para>A values of 0.0 means, that only the dry (unprocessed, original) signal is used. A value of 1.0 means, that only the wet (processed) signal is used.</para>
            <para>If you assign values outside this range they will actually be capped to [0.0...1.0].</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.UseDithering">
            <summary>
            Gets or Sets, if Dithering should be used (default is FALSE).
            </summary>
            <remarks>
            Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dither only applies when processing 8- or 16-bit sample data (since here the effect calculation might result in computation 'errors') - for 32-bit (float) sample data dither will never be applied here.</para>
            <para>Dithering is implemented here as a triangular probability density function (TPDF), actually a "<see cref="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.DitherFactor"/> bit triangular dither" (default is 0.7).</para>
            <para>If Dithering is disabled, the sample value will be rounded to the nearest value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.DitherFactor">
            <summary>
            Gets or Sets the dithering bitdepth of the triangular probability density function (TPDF) - default is 0.7.
            </summary>
            <remarks>The TPDF is implemented as a "<see cref="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.DitherFactor"/> bit triangular dither", ie. by default a "0.7 bit triangular dither" is used.
            <para>Dithering only applies here when processing 8- or 16-bit sample data and when the <see cref="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.UseDithering"/> property has been set to TRUE.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_IIRDelay">
            <summary>
            IIR Delay Filter DSP.
            </summary>
            <remarks>An IIR Delay filer (flexible-time, non-sample quantized delay). Use the <see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.Delay"/> resp. the <see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.DelaySeconds"/> property to control the delay time. The <see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.WetDry"/> and <see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.Feedback"/> properties conrol the ratio between the original signal and the processed effect signal as well as the ratio of the processed delay which will be mixed into the delay buffer.
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.#ctor(System.Single)">
            <summary>
            Creates a new instance of the IIR Delay Filter DSP, not assigning the DSP yet.
            </summary>
            <param name="maxDelay">The maximum delay buffer size in seconds.</param>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Creates a new instance of the IIR Delay Filter DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <param name="maxDelay">The maximum delay buffer size in seconds (between 0.001 and 60.0).</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.Preset_Metallic">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.Preset_Echo">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.Reset">
            <summary>
            Clears the internal buffer.
            </summary>
            <remarks>It is a good idea to call this method whenever you change the position of the stream.
            <para>This will also automatically be called <see cref="M:Un4seen.Bass.Misc.DSP_IIRDelay.OnChannelChanged"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.OnChannelChanged">
            <summary>
            This method will be called every time the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> changed.
            </summary>
            <remarks>It resets the internal buffer.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which adds the delay effect. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_IIRDelay.WetDry">
            <summary>
            Gets or Sets the Wet/Dry ratio between 0.0 (dry, unprocessed signal only) and 1.0 (wet, processed signal only) - default is 0.5.
            </summary>
            <remarks>This property defines how much of the effect signal will be mixed into the original signal.
            <para>A values of 0.0 means, that only the dry (unprocessed, original) signal is used. A value of 1.0 means, that only the wet (processed) signal is used.</para>
            <para>If you assign values outside this range they will actually be capped to [0.0...1.0].</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_IIRDelay.Feedback">
            <summary>
            Gets or Sets the feedback factor of the processed signal between 0.0 (none) and 1.0 (full) which should be stored in the delay buffer - default is 0.5.
            </summary>
            <remarks>This property defines how much of the processed signal will be feed back to the delay buffer.
            <para>A values of 0.0 means, that only the original signal is used and stored in the delay buffer. 
            A value of 1.0 means, that only the processed signal is used and stored in the delay buffer.</para>
            <para>If you assign values outside this range they will actually be capped to [0.0...1.0].</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_IIRDelay.Delay">
            <summary>
            Gets or Sets the Delay in number of samples (default is 4096).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_IIRDelay.DelaySeconds">
            <summary>
            Gets or Sets the Delay in seconds (e.g. 0.01 for 10ms - between 0.0 and 60.0).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_IIRDelay.UseDithering">
            <summary>
            Gets or Sets, if Dithering should be used (default is FALSE).
            </summary>
            <remarks>
            Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dither only applies when processing 8- or 16-bit sample data (since here the effect calculation might result in computation 'errors') - for 32-bit (float) sample data dither will never be applied here.</para>
            <para>Dithering is implemented here as a triangular probability density function (TPDF), actually a "<see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.DitherFactor"/> bit triangular dither" (default is 0.7).</para>
            <para>If Dithering is disabled, the sample value will be rounded to the nearest value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_IIRDelay.DitherFactor">
            <summary>
            Gets or Sets the dithering bitdepth of the triangular probability density function (TPDF) - default is 0.7.
            </summary>
            <remarks>The TPDF is implemented as a "<see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.DitherFactor"/> bit triangular dither", ie. by default a "0.7 bit triangular dither" is used.
            <para>Dithering only applies here when processing 8- or 16-bit sample data and when the <see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.UseDithering"/> property has been set to TRUE.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_SoftSaturation">
            <summary>
            Soft Saturation DSP (a waveshaper).
            </summary>
            <remarks>A Soft Saturation DSP doing some wave sharping. Use the <see cref="P:Un4seen.Bass.Misc.DSP_SoftSaturation.Factor"/> property to play around with sharping effect.
            Basically it reduces/modifies the level signal, if above the <see cref="P:Un4seen.Bass.Misc.DSP_SoftSaturation.Factor"/> value. If the signal is below the <see cref="P:Un4seen.Bass.Misc.DSP_SoftSaturation.Factor"/> the signal will be left unchanged.
            The effect is a good combination with a gain effect to minimize distortion or clipping which might happen with loud signal peaks.
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_SoftSaturation.#ctor">
            <summary>
            Creates a new instance of the Soft Saturation DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_SoftSaturation.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Soft Saturation DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_SoftSaturation.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the soft saturation wave sharping. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_SoftSaturation.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_SoftSaturation.Depth">
            <summary>
            Gets or Sets the Depth between 0.0 and 1.0 (default is 0.5, 0.0=off).
            </summary>
            <remarks>The signal will be warmed when set above 0.0.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_SoftSaturation.Factor">
            <summary>
            Gets or Sets the Soft Saturation factor between 0.0 and 0.99998848714 (default is 0.5).
            </summary>
            <remarks>The signal will be dynamically sharped, if the signal amplitude is above this given factor.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_SoftSaturation.Factor_dBV">
            <summary>
            Gets or Sets the Soft Saturation factor in dBV between NegativeInfinity and -0.0001 (default is -6 dB).
            </summary>
            <remarks>The signal will be dynamically sharped, if the signal amplitude is above this given factor.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_SoftSaturation.UseDithering">
            <summary>
            Gets or Sets, if Dithering should be used (default is FALSE).
            </summary>
            <remarks>
            Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dither only applies when processing 8- or 16-bit sample data (since here the mono calculation might result in computation 'errors') - for 32-bit (float) sample data dither will never be applied here.</para>
            <para>Dithering is implemented here as a triangular probability density function (TPDF), actually a "<see cref="P:Un4seen.Bass.Misc.DSP_SoftSaturation.DitherFactor"/> bit triangular dither" (default is 0.7).</para>
            <para>If Dithering is disabled, the sample value will be rounded to the nearest value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_SoftSaturation.DitherFactor">
            <summary>
            Gets or Sets the dithering bitdepth of the triangular probability density function (TPDF) - default is 0.7.
            </summary>
            <remarks>The TPDF is implemented as a "<see cref="P:Un4seen.Bass.Misc.DSP_SoftSaturation.DitherFactor"/> bit triangular dither", ie. by default a "0.7 bit triangular dither" is used.
            <para>Dithering only applies here when processing 8- or 16-bit sample data and when the <see cref="P:Un4seen.Bass.Misc.DSP_SoftSaturation.UseDithering"/> property has been set to TRUE.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_StreamCopy">
            <summary>
            Stream Copy DSP (to clone any BASS stream).
            </summary>
            <remarks>A Stream Copy DSP actually provides a synchronized clone of the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> which can for example be used to playout the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> to another device or spreakers.
            Use the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyDevice"/> property to specify the BASS device which should be used for the stream copy.
            Use the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyFlags"/> property to specify additional flags which should be used create the stream copy.
            <para>The <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> handles will be linked.
            So the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> channel will be started/stopped/paused/resumed together with the original <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>.</para>
            <para>When using with a mixer stream (see <see cref="N:Un4seen.Bass.AddOn.Mix"/>) you need to set the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.SourceMixerStream"/> and <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> properties accordingly.
            It is possible to copy either a mixer source stream or the mixer stream itself (in both cases the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.SourceMixerStream"/> handle must be set - so the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> might be equal to the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>).
            If you specify a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> handle will automatically be add as a new source channel to that mixer (in such case make sure to use BASS_STREAM_DECODE as a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyFlags"/>).
            The <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.IsOutputBuffered"/> property will define, if the final output is a buffered stream or not (so if using with a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> you might still need to set this to TRUE).
            </para>
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the original channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            <para>Internally the <see cref="T:Un4seen.Bass.Misc.DSP_StreamCopy"/> implementation uses <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.IntPtr,System.Int32)"/> to keep the sample data of the original stream in sync with the custom created push stream (the 'StreamCopy' is created via <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/> 
            and linked to the source stream via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetLink(System.Int32,System.Int32)"/>). 
            It is not recommended to use this DSP with ASIO sources (use the <see cref="T:Un4seen.Bass.Misc.DSP_BufferStream"/> DSP instead).</para>
            <para>So when you now call the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> method on the DSP_StreamCopy instance the copied-stream will be freed (but not the source stream).
            The same is true, if the GarbageCollector disposes your DSP_StreamCopy instance, since within the dispose implementation the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> method will be called.</para>
            <para>However, stopping the source stream will not reset the copied-stream! Also the copied-stream will not be freed automatically, if you simply free the original stream (only the DSP will be removed from it).</para>
            <para>So when you free your source stream (or the playback ends) it is advised to call the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> method on your DSP_StreamCopy method as well. So that the DSP is removed and the copied-stream will be removed/freed!
            When you need to start the original stream again, simply call <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> again.</para>
            <para>Here is a full overview of all possible scenarios:</para>
            <para>A) Stopping/Releasing the source stream:
            -&gt; call <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to also free the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> (and internal DSP).</para>
            <para>A.1) Restarting the same source stream:
            -&gt; call <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> if you need to start the source stream again.</para>
            <para>A.2) Assigning a new source stream:
            -&gt; set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> to the new source stream (see B).</para>
            <para>B) Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> of the DSP_StreamCopy instance:
            -&gt; the current <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> (if existing) will be freed automatically (and internal DSP).
            A new <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> is created automatically for the new source stream.</para>
            <para>C) Changing the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyDevice"/> of the DSP_StreamCopy instance:
            -&gt; the current <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> (if existing) will be freed automatically.
            A new <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> is created automatically on the new device.</para>
            <para>D) Disposing of the DSP_StreamCopy instance (e.g. via GC):
            -&gt; the current <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> (if existing) will be freed automatically (and internal DSP).</para>
            </remarks>
            <example>
            Create a copy of a regular BASS stream and play it on another BASS device:
            <code>
            private DSP_StreamCopy _streamCopy;
            ...
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, null);
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, null);
            ...
            // create the original stream (on device 1)
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_FLOAT);
            // start playing it...
            Bass.BASS_ChannelPlay(stream, false);
            ...
            _streamCopy = new DSP_StreamCopy();
            BASS_INFO info = Bass.BASS_GetInfo();
            _streamCopy.OutputLatency = info.latency;
            // the stream to copy
            _streamCopy.ChannelHandle = stream;
            _streamCopy.DSPPriority = -1000;
            // use device 2 to create the copy on
            _streamCopy.StreamCopyDevice = 2;
            // use the exact same stream flags for the stream copy
            _streamCopy.StreamCopyFlags = _streamCopy.ChannelInfo.flags;
            _streamCopy.Start();
            </code>
            <code lang="vbnet">
            Private _streamCopy As DSP_StreamCopy
            ...
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, Nothing)
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero, Nothing)
            ...
            ' create the original stream (on device 1)
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_FLOAT)
            ' start playing it...
            Bass.BASS_ChannelPlay(stream, False)
            ...
            _streamCopy = New DSP_StreamCopy()
            BASS_INFO info = Bass.BASS_GetInfo()
            _streamCopy.OutputLatency = info.latency
            ' the stream to copy
            _streamCopy.ChannelHandle = stream
            _streamCopy.DSPPriority = -1000
            ' use device 2 to create the copy on
            _streamCopy.StreamCopyDevice = 2
            ' use the exact same stream flags for the stream copy
            _streamCopy.StreamCopyFlags = _streamCopy.ChannelInfo.flags
            _streamCopy.Start()
            </code>
            Create a copy of a regular BASS stream and play it on other speakers:
            <code>
            private DSP_StreamCopy _streamCopy;
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_SPEAKERS, IntPtr.Zero, null);
            ...
            // create the original stream (using front speakers)
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                              BASSFlag.BASS_SAMPLE_FLOAT | BASSFlag.BASS_SPEAKER_FRONT);
            // start playing it...
            Bass.BASS_ChannelPlay(stream, false);
            ...
            _streamCopy = new DSP_StreamCopy();
            BASS_INFO info = Bass.BASS_GetInfo();
            _streamCopy.OutputLatency = info.latency;
            // the stream to copy
            _streamCopy.ChannelHandle = stream;
            _streamCopy.DSPPriority = -1000;
            // use different speaker flags for the stream copy
            _streamCopy.StreamCopyFlags = BASSFlag.BASS_SAMPLE_FLOAT | BASSFlag.BASS_SPEAKER_REAR;
            _streamCopy.Start();
            </code>
            <code lang="vbnet">
            Private _streamCopy As DSP_StreamCopy
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_SPEAKERS, IntPtr.Zero, Nothing)
            ...
            ' create the original stream (using front speakers)
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                                         BASSFlag.BASS_SAMPLE_FLOAT Or BASSFlag.BASS_SPEAKER_FRONT)
            ' start playing it...
            Bass.BASS_ChannelPlay(stream, False)
            ...
            _streamCopy = New DSP_StreamCopy()
            BASS_INFO info = Bass.BASS_GetInfo();
            _streamCopy.OutputLatency = info.latency;
            ' the stream to copy
            _streamCopy.ChannelHandle = stream
            _streamCopy.DSPPriority = -1000
            ' use different speaker flags for the stream copy
            _streamCopy.StreamCopyFlags = BASSFlag.BASS_SAMPLE_FLOAT Or BASSFlag.BASS_SPEAKER_REAR
            _streamCopy.Start()
            </code>
            Create a copy of a BASSmix source mixer stream and copy it to another BASSmix mixer as a source:
            <code>
            private DSP_StreamCopy _streamCopy;
            ...
            _streamCopy = new DSP_StreamCopy();
            BASS_INFO info = Bass.BASS_GetInfo();
            _streamCopy.OutputLatency = info.latency;
            _streamCopy.DSPPriority = -9000;
            ...
            // assign the copy
            _streamCopy.ChannelHandle = _mixerSourceStream; // the stream to copy
            _streamCopy.StreamCopyDevice = 0;
            _streamCopy.StreamCopyFlags = BASSFlag.BASS_STREAM_DECODE;
            _streamCopy.SourceMixerStream = MixerStreamA;
            _streamCopy.TargetMixerStream = MixerStreamB;
            _streamCopy.IsOutputBuffered = true;
            _streamCopy.Start();
            ...
            // start playing the original source
            BassMix.BASS_Mixer_ChannelPlay(_mixerSourceStream);
            if (_streamCopy.IsAssigned)
              _streamCopy.ReSync();
            ...
            // pausing the original source
            BassMix.BASS_Mixer_ChannelPause(_mixerSourceStream);
            ...
            </code>
            <code lang="vbnet">
            Private _streamCopy As DSP_StreamCopy
            ...
            _streamCopy = New DSP_StreamCopy()
            BASS_INFO info = Bass.BASS_GetInfo();
            _streamCopy.OutputLatency = info.latency;
            _streamCopy.DSPPriority = -9000
            ...
            ' assign the copy
            _streamCopy.ChannelHandle = _mixerSourceStream ' the stream to copy
            _streamCopy.StreamCopyDevice = 0
            _streamCopy.StreamCopyFlags = BASSFlag.BASS_STREAM_DECODE
            _streamCopy.SourceMixerStream = MixerStreamA
            _streamCopy.TargetMixerStream = MixerStreamB
            _streamCopy.IsOutputBuffered = true
            _streamCopy.Start()
            ...
            ' start playing the original source
            BassMix.BASS_Mixer_ChannelPlay(_mixerSourceStream)
            If _streamCopy.IsAssigned Then
              _streamCopy.ReSync();
            End If
            ...
            ' pausing the original source
            BassMix.BASS_Mixer_ChannelPause(_mixerSourceStream)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.#ctor">
            <summary>
            Creates a new instance of the Stream Copy DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Stream Copy DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.ReSync">
            <summary>
            Re-Synchronizes the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> with the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> when using BASSmix mixer channels.
            </summary>
            <remarks>
            Call this method right after you unpaused or start playing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>, and if you are using this instance with a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> in order to resync the stream copy after it was paused.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.OnChannelChanged">
            <summary>
            Occures when the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> has been changed. 
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.OnBypassChanged">
            <summary>
            Occures when the <see cref="M:Un4seen.Bass.Misc.BaseDSP.SetBypass(System.Boolean)"/> method was called.
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.OnStarted">
            <summary>
            Occures when the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> method was called.
            Actually creates the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> custom push stream here.
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.OnStopped">
            <summary>
            Occures when the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> method was called.
            Actually frees the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> custom stream here.
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the stream copy operation. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy">
            <summary>
            Gets the copied BASS stream (the created custom push stream).
            </summary>
            <remarks>Note: The <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> handles will be linked.
            So the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> channel will be started/stopped/paused/resumed together with the original <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>.
            <para>Use the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyDevice"/> property to specify the BASS device which should be used for the stream copy. Use the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyFlags"/> property to specify additional flags which should be used create the stream copy.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyFlags">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.BASSFlag"/> flags which should be used to create the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/>.
            </summary>
            <remarks>Note: Setting the stream copy flags while the DSP_StreamCopy is already assigned will automatically (re)start it.
            <para>By default no flags are used with the stream copy, so make sure to set these flags accordingly to your scenario.
            E.g. add a BASS_STREAM_DECODE flag, if you want to create a decoding copy which you might add to a mixer stream.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyDevice">
            <summary>
            Gets or Sets the BASS device, which should be used for the stream copy.
            </summary>
            <remarks>Note: Setting the BASS device while the DSP_StreamCopy is already assigned will automatically (re)start it.
            By default the current device is being used.
            <para>Make also sure, that the BASS device has been initializes (see <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>) before.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.OutputLatency">
            <summary>
            Gets or Sets the output latency in milliseconds (default = 0).
            </summary>
            <remarks>The output latency compensates for an additional delay of the DirectSound buffer.
            You should initialize this property with the <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)">BASS_INFO.latency</see> member when using with a buffered output.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.IsOutputBuffered">
            <summary>
            Gets or Sets, if the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> should be buffered or not (default is TRUE).
            </summary>
            <remarks>If set to TRUE, the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> will be (pre)buffered with the data available from the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>. 
            This option is useful, if you want to use this instance with a buffered output stream.
            If set to FALSE the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> will not be (pre)buffered, which is usefull when used with unbuffered outputs (e.g. ASIO).
            <para>Note: Setting this member while the DSP_StreamCopy is already assigned will automatically (re)start it.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.SourceMixerStream">
            <summary>
            Gets or Sets the mixer handle of the mixer from which you are cloning (see <see cref="N:Un4seen.Bass.AddOn.Mix">BASSmix</see> addon).
            </summary>
            <remarks>
            It is possible to copy either a mixer's source stream or the mixer stream itself.
            In both cases you must specify the mixers channel handle - so if you clone the mixer itself the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> will be equal to this property.
            If you specify a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> handle will automatically be add as a new source channel to that mixer (in such case make sure to use BASS_STREAM_DECODE as a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyFlags"/>).
            The <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.IsOutputBuffered"/> property will define, if the final output is a buffered stream or not (so if using with a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> you might still need to set it to TRUE).
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream">
            <summary>
            Gets or Sets the mixer handle of the mixer to which the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> handle should be added (see <see cref="N:Un4seen.Bass.AddOn.Mix">BASSmix</see> addon).
            </summary>
            <remarks>
            If you specify a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> handle will automatically be add as a new source channel to that mixer 
            (the BASS_STREAM_DECODE flag will automatically be added to the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyFlags"/>).
            The <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.IsOutputBuffered"/> property will define, if the final output is a buffered stream or not (so if using with a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> you might still need to set it to TRUE).
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_BufferStream">
            <summary>
            Stream Buffer DSP (to clone a BASS stream's current sample data to a decoding stream).
            </summary>
            <remarks>A Stream Buffer DSP actually provides a synchronized clone of the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>'s sample data in a new decoding channel which can for example be used to get FFT or level data. 
            Use the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> decoding channel with the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/> methods to do retrieve the cloned sample data.
            This DSP will always provide a decoding channel (<see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/>).
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.
            Note: The channel flags of the <seealso cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> being used are actually the same as from the original <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>, but if you have FLOATDSP enabled the FLOAT flag will be added automatically.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> property (which represents a custom decoding stream) to get the level or FFT data from it. 
            If the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> is attached to a buffered output stream (e.g. via BASSmix to a mixer stream) there will be a delay due to the additional output buffer. 
            Use the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.OutputHandle"/> property in order to compensate for that (or leave to it's default 0 value in order to simply use a non-synchronized direct buffer - in such case the internal buffer will return the data as being heard).</para>
            <para>In addition you might use the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.IsOutputBuffered"/> property to specify, if the created <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> will be used with a buffered output stream. 
            In such case the decoding <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> position will be aligned to the output buffer (default is TRUE).</para>
            <para>By default the internal buffer size is determined from the current BASS_CONFIG_BUFFER setting. 
            However, that might not always be correct, since the buffer size must also be equal to the one used with the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>.
            So you might change that using the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.ConfigBuffer"/> property.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
            <example>
            Create an exact shadow copy of a decoding stream:
            <code>
            private DSP_BufferStream _bufferStream;
            ...
            // create a mixer outout stream
            _mixer1 = BassMix.BASS_MIXER_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT);
            Bass.BASS_ChannelPlay(_mixer1, false);
            _mixer2 = BassMix.BASS_MIXER_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT);
            Bass.BASS_ChannelPlay(_mixer2, false);
            // create a source stream and add it to the mixer1
            _stream = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_SAMPLE_FLOAT | 
                                                                  BASSFlag.BASS_STREAM_DECODE);
            BassMix.BASS_Mixer_StreamAddChannel(_mixer1, _stream, BASSFlag.BASS_DEFAULT);
            ...
            // create a clone of the source stream to add it to mixer2
            _bufferStream = new DSP_BufferStream();
            _bufferStream.ChannelHandle = _stream; // the stream to copy
            _bufferStream.DSPPriority = -4000;
            _bufferStream.Start();
            BassMix.BASS_Mixer_StreamAddChannel(_mixer1, _bufferStream.BufferStream, BASSFlag.BASS_DEFAULT);
            </code>
            <code lang="vbnet">
            Private _bufferStream As DSP_BufferStream
            ...
            ' create a mixer outout stream
            _mixer1 = BassMix.BASS_MIXER_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT)
            Bass.BASS_ChannelPlay(_mixer1, False)
            _mixer2 = BassMix.BASS_MIXER_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT)
            Bass.BASS_ChannelPlay(_mixer2, False)
            ' create a source stream and add it to the mixer1
            _stream = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_SAMPLE_FLOAT Or 
                                                                  BASSFlag.BASS_STREAM_DECODE)
            BassMix.BASS_Mixer_StreamAddChannel(_mixer1, _stream, BASSFlag.BASS_DEFAULT)
            ...
            ' create a clone of the source stream to add it to mixer2
            _bufferStream = New DSP_BufferStream()
            _bufferStream.ChannelHandle = _stream ' the stream to copy
            _bufferStream.DSPPriority = - 4000
            _bufferStream.Start()
            BassMix.BASS_Mixer_StreamAddChannel(_mixer1, _bufferStream.BufferStream, BASSFlag.BASS_DEFAULT)
            </code>
            Create a buffered stream copy to sync a FFT or GetLevel call:
            <code>
            private DSP_BufferStream _bufferStream;
            ...
            // create a mixer outout stream
            _mixer = BassMix.BASS_MIXER_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT);
            Bass.BASS_ChannelPlay(BASSFlag.BASS_DEFAULT, false);
            // create a source stream and add it to the mixer
            _stream = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_SAMPLE_FLOAT | 
                                                                  BASSFlag.BASS_STREAM_DECODE);
            BassMix.BASS_Mixer_StreamAddChannel(_mixer, _stream, BASSFlag.BASS_DEFAULT);
            ...
            // create a buffer of the source stream for level and/or FFT data retrival in sync with the mixer output
            _bufferStream = new DSP_BufferStream();
            _bufferStream.ChannelHandle = _stream; // the stream to copy
            _bufferStream.OutputHandle = _mixer; // the stream to sync with (what's being heard)
            _bufferStream.DSPPriority = -4000;
            _bufferStream.Start();
            ...
            float[] fft = new float[2048];
            Bass.BASS_ChannelGetData(_bufferStream.BufferStream, fft, (int)BASSData.BASS_DATA_FFT4096);
            </code>
            <code lang="vbnet">
            Private _bufferStream As DSP_BufferStream
            ...
            ' create a mixer outout stream
            _mixer = BassMix.BASS_MIXER_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT)
            Bass.BASS_ChannelPlay(BASSFlag.BASS_DEFAULT, False)
            ' create a source stream and add it to the mixer
            _stream = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_SAMPLE_FLOAT Or 
                                                                  BASSFlag.BASS_STREAM_DECODE)
            BassMix.BASS_Mixer_StreamAddChannel(_mixer, _stream, BASSFlag.BASS_DEFAULT)
            ...
            ' create a buffer of the source stream for level and/or FFT data retrival in sync with the mixer output
            _bufferStream = New DSP_BufferStream()
            _bufferStream.ChannelHandle = _stream ' the stream to copy
            _bufferStream.OutputHandle = _mixer ' the stream to sync with (what's being heard)
            _bufferStream.DSPPriority = - 4000
            _bufferStream.Start()
            ...
            Dim fft(2048) As Single
            Bass.BASS_ChannelGetData(_bufferStream.BufferStream, fft, CInt(BASSData.BASS_DATA_FFT4096))
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.#ctor">
            <summary>
            Creates a new instance of the Stream Buffer DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Stream Buffer DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.ClearBuffer">
            <summary>
            Clears the internal buffer (zeros all elements) and resets the buffer pointer.
            </summary>
            <remarks>
            Use this method e.g. when you paused/stoped the original <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.OnChannelChanged">
            <summary>
            Occures when the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> has been changed. 
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.OnBypassChanged">
            <summary>
            Occures when the <see cref="M:Un4seen.Bass.Misc.BaseDSP.SetBypass(System.Boolean)"/> method was called.
            Actually clears the internal copy buffer.
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.OnStarted">
            <summary>
            Occures when the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> method was called.
            Actually creates the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> custom stream here.
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.OnStopped">
            <summary>
            Occures when the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> method was called.
            Actually frees the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> custom stream here.
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the stream copy operation. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream">
            <summary>
            Gets the buffered BASS stream (the created custom stream).
            </summary>
            <remarks>You might use this stream channel handle to call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/> in order to retrive the FFT or level data.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStreamFlags">
            <summary>
            Gets the channel flags of the <seealso cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> being used.
            </summary>
            <remarks>The channel flags are actually being the same as from the original <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>, but if you have FLOATDSP enabled the FLOAT flag will be added automatically.
            In addition <seealso cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> will always be a decoding stream!</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.OutputHandle">
            <summary>
            Gets or Sets a buffered output BASS stream to synchronize the position with (0 = use a non-synchronized direct buffer).
            </summary>
            <remarks>When not setting this property (or setting to 0) the internal buffer position will not be synchronized, which means the buffer reflects the immediate sample data as received in the DSP.
            This is perfect, if you want to create an exact shadow copy (clone) of the decoding <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>. In this case use the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> member to e.g. feed it to another
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.IsOutputBuffered">
            <summary>
            Gets or Sets, if the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> should be buffered or not (default is TRUE).
            </summary>
            <remarks>If set to TRUE, the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> position will be buffered. This option is useful, if you want to use it with a buffered output stream.
            If set to FALSE the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> will not be buffered, which is usefull when used with unbuffered outputs (e.g. ASIO).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.ConfigBuffer">
            <summary>
            Gets or Sets the buffer length in milliseconds to be used (between 1 and 5000).
            </summary>
            <remarks>The buffer length needs to be as big as the BASS_CONFIG_BUFFER setting used to create the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>.
            <para>Normally there is no need set this value, since it will be calculated accordingly to the current BASS_CONFIG_BUFFER setting.
            But this implies, that you haven't changed the BASS_CONFIG_BUFFER between the creation of the stream an using this DSP.
            So if you have changed the BASS_CONFIG_BUFFER setting in the meantime, you must provide the new BASS_CONFIG_BUFFER size.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.ConfigBufferLength">
            <summary>
            Gets the buffer length in bytes which is being used.
            </summary>
            <remarks>
            This is the translated <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.ConfigBuffer"/> value.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferPosition">
            <summary>
            Gets or Sets the current buffer position in bytes.
            </summary>
            <remarks>This member is maintained automatically depending on the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.IsOutputBuffered"/> property and the current buffer state.
            So normally there is no need to modify this value. However if you have a real need you might do so.
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Wv.BassWv">
            <summary>
            BASS.NET API wrapper for BASSWV.DLL
            <para>Requires: basswv.dll - WavPack Audio Format (WV) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSWV is an extension to the BASS audio library, enabling the playback of WavPack files.</para>
            <para>WavPack is a completely open audio compression format providing lossless, high quality lossy, and an unique hybrid compression mode.
            In the default lossless mode WavPack acts just like a WinZip® compressor for audio files. Unlike MP3 or WMA encoding which can affect the sound quality,
            not a single bit of the original information is lost. The hybrid mode provides all the advantages of lossless compression with an additional bonus: instead of creating a single file, this mode creates both a
            relatively small, high quality lossy file that can be used all by itself, and a correction file that, when combined with the lossy file, provides full lossless restoration.</para>
            <para>The WavPack format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> / User functions.</para>
            <para>More information can be found on <a href="http://www.wavpack.com">www.wavpack.com</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a WavPack file.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a WavPack memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a WavPack file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wv.BassWv.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the basswv.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wv.BassWv.SupportedStreamName">
            <summary>
            Supported file format name of the basswv.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Wv.BassWv.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Wv.BassWv.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vis.BassVis">
            <summary>
            BASS.NET API wrapper for BASS_VIS.DLL
            <para>Requires: bass_vis.dll - Winamp and Sonique Visualization plugins support Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BassVis is an extention to the BASS audio library, providing a set of functions for rendering Sonique Visualization plugins into any canvas, as long as you provide an hDC, Winamp visualization plugins are also handled.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_Init(Un4seen.Bass.AddOn.Vis.BASSVISPlugin,System.IntPtr,System.IntPtr)">
            <summary>
            Initialize a Plugin (and BassVis), and sets the default values.
            </summary>
            <param name="kind">Kind of Plugin you want (one of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISPlugin"/> values).</param>
            <param name="appHandle">Your application instance handle (you might use the <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.GetWindowLongPtr(System.IntPtr,System.Int32)"/> helper method with the <see cref="F:Un4seen.Bass.AddOn.Vis.GWLIndex.GWL_HINSTANCE"/> index here - or simply call: Process.GetCurrentProcess().Handle).</param>
            <param name="winHandle">Your main form handle.</param>
            <returns>If an error occurred then FALSE is returned, else TRUE is returned.</returns>
            <remarks>Call this method prior to showing your main form window and make sure to call it before any other BASS_VIS methods.
            <para>You might set both parameter values to the same main windows form instance handle.</para>
            <para>Call <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_Quit(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)"/> to free all resourcesand end the thread started by <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_Init(Un4seen.Bass.AddOn.Vis.BASSVISPlugin,System.IntPtr,System.IntPtr)"/>.</para>
            </remarks>
            <example>
            <code>
            BassVis.BASS_VIS_Init(BASSVISPlugin.BASSVISKIND_WINAMP, BassVis.GetWindowLongPtr(this.Handle, (int)GWLIndex.GWL_HINSTANCE), this.Handle);
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_FindPlugins(Un4seen.Bass.AddOn.Vis.BASSVISPlugin,System.String,Un4seen.Bass.AddOn.Vis.BASSVISPFindPlugin,System.Byte)">
            <summary>
            
            </summary>
            <param name="kind"></param>
            <param name="pluginPath"></param>
            <param name="searchFlags"></param>
            <param name="delemiter"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_FindPlugins(Un4seen.Bass.AddOn.Vis.BASSVISPlugin,System.String,System.Boolean)">
            <summary>
            Searches for plugins of a given kind in a given path. The result is an array of strings, with the available plugins.
            </summary>
            <param name="kind">Kind of Plugin you want (one of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISPlugin"/> values).</param>
            <param name="pluginPath">Path where to search for the plugins.</param>
            <param name="recursive">TRUE, if to also search all sub-directories recursively - else FALSE.</param>
            <returns>Returns an array of strings with the available plugins or NULL.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetPluginHandle(Un4seen.Bass.AddOn.Vis.BASSVISPlugin,System.String)">
            <summary>
            Determine the handle of an initialzed plugin.
            </summary>
            <param name="kind">Kind of Plugin you want (one of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISPlugin"/> values).</param>
            <param name="pluginPath">Path and filename of the plugin.</param>
            <returns>Returns the handle of the plugin, which must be used as the <see cref="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM.VisHandle"/> member.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetPluginParam(Un4seen.Bass.AddOn.Vis.BASSVISPlugin,System.String)">
            <summary>
            Determine the handle of an initialzed plugin.
            </summary>
            <param name="kind">Kind of Plugin you want (one of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISPlugin"/> values).</param>
            <param name="pluginPath">Path and filename of the plugin.</param>
            <returns>A new instance of <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/> containing the plugin's handle values.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_ExecutePlugin(Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC,Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)">
            <summary>
            Starts a plugin.
            </summary>
            <param name="exec">Parameter structure with plugin data (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC"/>).</param>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>). Make sure to set the kind property accordingly.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_RenderChannel(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.Int32)">
            <summary>
            Starts the visualization of the plugin for a given channel.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="channel">The channel to render, can be a HSTREAM or HMUSIC handle.</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_StartRecord(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.Int32,System.Int32)">
            <summary>
            Starts visualization of the selected device (using the recording functions of BASS). To select the device used in the <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> call.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="samplerate">The recording samplerate in Hz (e.g. 44100).</param>
            <param name="channels">The number of recording channels (e.g. 2 for stereo).</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_StartRecord(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.Int32)">
            <summary>
            Starts visualization of the selected device (using the recording functions of BASS). To select the device used in the <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> call.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="samplerate">The recording samplerate in Hz (e.g. 44100).</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
            <remarks>This overload uses the default of 2 number of channels.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_StartRecord(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)">
            <summary>
            Starts visualization of the selected device (using the recording functions of BASS). To select the device used in the <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> call.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
            <remarks>This overload uses the default of 2 number of channels and a samplerate of 44100.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_Config(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.Int32)">
            <summary>
            Invokes the integrated configuration dialog of a plugin, if one is available.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="module">The module index for which the configuration dialog should be invoked (0 = first).</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SetInfo(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO)">
            <summary>
            Hands over informations about the current track to the plugin.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="info">Parameter data about the track to set (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO"/>).</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_Resize(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Repositions or resizes the visualization of the plugin (if the container was resized).
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="left">Left position to set (upperleft corner).</param>
            <param name="top">Top position to set (upperleft corner).</param>
            <param name="width">Width to set.</param>
            <param name="height">Height to set.</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SetFullscreen(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Toggles the fullscreen mode for the plugin.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="sourceHandle">Handle of the current container.</param>
            <param name="destinHandle">Application handle or handle of the control containing the container.</param>
            <param name="sourceLeft">Left position within the container.</param>
            <param name="sourceTop">Top position within the container.</param>
            <param name="sourceWidth">Width of the container.</param>
            <param name="sourceHeight">Height of the container.</param>
            <param name="fullScreen">TRUE = fullscreen, FALSE = normal mode.</param>
            <param name="screenWidth">Screen resolution (width).</param>
            <param name="screenHeight">Screen resolution (height).</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
            <remarks>The given screen resolution should have always have an aspect ratio of 4:3 in order to correctly display the visualization.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASSVIS_SetModulePreset(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.Int32)">
            <summary>
            Activates a selected preset (WMP special).
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="index">Selected module preset, only for Windows Media Player plugins.</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetModulePresetCount(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.String)">
            <summary>
            Determines the number of modules contained in a plugin.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="pluginPath">Path and filename of the plugin.</param>
            <returns>Number of available modules within the plugin.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetModulePresetNamePtr(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="param"></param>
            <param name="module"></param>
            <param name="pluginPath"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetModulePresetName(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.Int32,System.String)">
            <summary>
            Determines the name of a module of a plugin.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="module">The module index for which to get the name (0 = first).</param>
            <param name="pluginPath">Path and filename of the plugin.</param>
            <returns>Returns a string with the name of the module - or NULL if not found.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetModulePresetNameListPtr(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.String)">
            <summary>
            
            </summary>
            <param name="param"></param>
            <param name="pluginPath"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetModulePresetNameList(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.String)">
            <summary>
            Determines the available list of module names of a plugin.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="pluginPath">Path and filename of the plugin.</param>
            <returns>Returns an array of strings with the available module names of a plugin or NULL.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetOption(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,Un4seen.Bass.AddOn.Vis.BASSVISConfig)">
            <summary>
            Determines the value of a configuration option for a plugin.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="option">Option to determine (one of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISConfig"/> values).</param>
            <returns>The current value of the given option.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SetOption(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,Un4seen.Bass.AddOn.Vis.BASSVISConfig,System.Int32)">
            <summary>
            Sets a configuration options value.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="option">Option to set a new value to (one of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISConfig"/> values).</param>
            <param name="value">The new value to set.</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SetPlayState(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,Un4seen.Bass.AddOn.Vis.BASSVISPlayState,System.Int32,System.String)">
            <summary>
            Gets or Sets the current play state of a plugin.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="state">The state to get or set (one of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISPlayState"/> values).</param>
            <param name="value">The value of the state to set.</param>
            <param name="title">The optional title to set (used with <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.SetPlaylistTitle"/>).</param>
            <returns>Returns the state of the plugin (see remarks for more information).</returns>
            <remarks>Sonique plugins are ignored by this function.
            <para>If state parameter is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Play"/>, <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Stop"/> or <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Pause"/> the appropriated play state is set.
            If the state was successfully set the return value is the same as the state parameter - otherwise the return value is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Error"/>.</para>
            <para>If state parameter is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.GetPlaylistTitlePos"/> or <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.GetSelectedTitlePos"/> the current position of the playlist is returned - otherwise the return value is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Error"/>.</para>
            <para>If state parameter is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.SetPlaylistPos"/> the position of the playlist is set to the value parameter. On success the return value is the same as the state parameter, otherwise the return value is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Error"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SetPlayState(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,Un4seen.Bass.AddOn.Vis.BASSVISPlayState,System.Int32)">
            <summary>
            Gets or Sets the current play state of a plugin.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="state">The state to get or set (one of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISPlayState"/> values).</param>
            <param name="value">The value of the state to set.</param>
            <returns>Returns the state of the plugin (see remarks for more information).</returns>
            <remarks>Sonique plugins are ignored by this function.
            <para>If state parameter is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Play"/>, <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Stop"/> or <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Pause"/> the appropriated play state is set.
            If the state was successfully set the return value is the same as the state parameter - otherwise the return value is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Error"/>.</para>
            <para>If state parameter is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.GetPlaylistTitlePos"/> or <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.GetSelectedTitlePos"/> the current position of the playlist is returned - otherwise the return value is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Error"/>.</para>
            <para>If state parameter is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.SetPlaylistPos"/> the position of the playlist is set to the value parameter. On success the return value is the same as the state parameter, otherwise the return value is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Error"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SetPlayState(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,Un4seen.Bass.AddOn.Vis.BASSVISPlayState)">
            <summary>
            Gets or Sets the current play state of a plugin.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="state">The state to get or set (one of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISPlayState"/> values).</param>
            <returns>Returns the state of the plugin (see remarks for more information).</returns>
            <remarks>Sonique plugins are ignored by this function.
            <para>If state parameter is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Play"/>, <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Stop"/> or <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Pause"/> the appropriated play state is set.
            If the state was successfully set the return value is the same as the state parameter - otherwise the return value is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Error"/>.</para>
            <para>If state parameter is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.GetPlaylistTitlePos"/> or <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.GetSelectedTitlePos"/> the current position of the playlist is returned - otherwise the return value is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Error"/>.</para>
            <para>If state parameter is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.SetPlaylistPos"/> the position of the playlist is set to the value parameter. On success the return value is the same as the state parameter, otherwise the return value is set to <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Error"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SetVisPort(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the container of the visualization as well as the position and size of it.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <param name="windowHandle">The VisGenWindow field of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/> structure.</param>
            <param name="containerHandle">Handle of the container in which the visualization should be shown.</param>
            <param name="x">Left position on the container (upperleft corner).</param>
            <param name="y">Top position on the container (upperleft corner).</param>
            <param name="width">Width of the visualization within the container.</param>
            <param name="height">Height of the visualization within the container.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetPluginNamePtr(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)">
            <summary>
            
            </summary>
            <param name="param"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetPluginName(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)">
            <summary>
            Determines the name of a plugin.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <returns>The name of the plugin or NULL if an error occured..</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_IsFree(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)">
            <summary>
            Checks if the thread of the last started plugin was correctly freed (after <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_Free(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)"/> has been called).
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <returns>TRUE, if the thread was successfully freed - else FALSE.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_Free(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)">
            <summary>
            Frees the handle of a plugin and removes it from memory.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
            <returns>TRUE, if the thread was successfully freed - else FALSE.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetVersion">
            <summary>
            Determines the version number of the bass_vis.dll.
            </summary>
            <returns>Returns a string with the version number of the library.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_Quit(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)">
            <summary>
            Ends up the last active thread and frees the plugin which was created by <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_ExecutePlugin(Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC,Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)"/>.
            </summary>
            <param name="param">Parameter structure with plugin handles (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SONIQUEClicked(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Shows the configuration for Sonique and Ultraplayer plugins within the visualization.
            </summary>
            <param name="handle">The VisHandle field of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/> structure.</param>
            <param name="x">The x position where the click should occure.</param>
            <param name="y">The y position where the click should occure.</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SONIQUERenderToDC(Un4seen.Bass.AddOn.Vis.BASSVISPlugin,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Renders a visualization on a device contex from a BASS channel handle.
            </summary>
            <param name="kind">Use BASSVISKIND_SONIQUE only.</param>
            <param name="handle">The VisHandle field of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/> structure.</param>
            <param name="channel">Channel of the currently playing song (HSTREAM or HMUSIC handle).</param>
            <param name="hDC">A device context handle where the visualization will be rendered.</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SONIQUERenderToDC(Un4seen.Bass.AddOn.Vis.BASSVISPlugin,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Renders a visualization on a device contex from the given data buffer.
            </summary>
            <param name="kind">Use BASSVISKIND_SONIQUE only.</param>
            <param name="handle">The VisHandle field of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM"/> structure.</param>
            <param name="data">Pointer to a buffer of sample data. This buffer MUST be of 512 samples, no more and no less. The data can be in floating-point, 16-bit and 8-bit, and stereo or mono. Be sure to specify the type of data, see the <paramref name="flags"/> parameter.</param>
            <param name="fft">Pointer to a buffer of FFT data. This buffer MUST be of 512 samples, no more and no less. The FFT data is made up of floating-point values ranging from 0 to 1.</param>
            <param name="hDC">A device context handle where the visualization will be rendered.</param>
            <param name="flags">Any combination of these flags <see cref="T:Un4seen.Bass.BASSFlag"/>:
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the buffer data is assumed to be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. If neither this or the BASS_SAMPLE_8BITS flags are specified, then the buffer data is assumed to be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Buffer data is in mono, else the buffer data is assumed to be stereo.</description></item>
            </list>
            </param>
            <param name="pos">Current position in Milliseconds. This value might not be relevant to some plugins, but it might be to others. Use it carefully.</param>
            <returns>Returns TRUE on success - else FALSE is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_WINAMPSetStateCallback(Un4seen.Bass.AddOn.Vis.BASSVISSTATE)">
            <summary>
            Set's a callback delegate for handling play state changes on the plugin (Winamp special).
            </summary>
            <param name="proc">The callback delegate to invoke when theplay state changes.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_WINAMPRemoveCallback">
            <summary>
            Removes the callback delegate, that was set with <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_WINAMPSetStateCallback(Un4seen.Bass.AddOn.Vis.BASSVISSTATE)"/> (Winamp special).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.LoadMe"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BassVis.GetWindowLongPtr(System.IntPtr,System.Int32)">
            <summary>
            The GetWindowLongPtr function retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra window memory.
            </summary>
            <param name="hwnd">Handle to the window and, indirectly, the class to which the window belongs (for a windows form use this.Handle).</param>
            <param name="index">Specifies the zero-based offset to the value to be retrieved (use one of the <see cref="T:Un4seen.Bass.AddOn.Vis.GWLIndex"/> values).</param>
            <returns></returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vis.BASSVISPlayState">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SetPlayState(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,Un4seen.Bass.AddOn.Vis.BASSVISPlayState,System.Int32,System.String)"/> to retrieve or set the current playstate of a plugin.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Error">
            <summary>
            An error occured.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Stop">
            <summary>
            Stops the playback (playback should be stopped).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Play">
            <summary>
            Starts playback (playback should be started).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.IsPlaying">
            <summary>
            A song is currently being played.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.Pause">
            <summary>
            Pause/Resume playback (playback should be paused/resumed).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.PrevTitle">
            <summary>
            Sets the current playlist position to the previous title.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.NextTitle">
            <summary>
            Sets the current playlist position to the next title.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.SetPlaylistTitle">
            <summary>
            Sets the current playlist title.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.GetPlaylistTitlePos">
            <summary>
            Gets the playlist position of the title.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.SetPlaylistPos">
            <summary>
            Sets the current playlist position.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlayState.GetSelectedTitlePos">
            <summary>
            Gets the playlist position of the selected title.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vis.BASSVISPlugin">
            <summary>
            Flag which identifies the type/kind of the visual plugin.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlugin.BASSVISKIND_NONE">
            <summary>
            No kind or undefined
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlugin.BASSVISKIND_WINAMP">
            <summary>
            Winamp visual plugin.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlugin.BASSVISKIND_SONIQUE">
            <summary>
            Sonique visual plugin.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlugin.BASSVISKIND_WMP">
            <summary>
            Windows Media Player visual plugin.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPlugin.BASSVISKIND_BASSBOX">
            <summary>
            BassBox visual plugin.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vis.BASSVISFlags">
            <summary>
            Sonique and BassBox execute flags for use with <see cref="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.SON_Flags"/> or <see cref="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.BB_Flags"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISFlags.BASS_VIS_DEFAULT">
            <summary>
            Create the vis and initialize it.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISFlags.BASS_VIS_NOINIT">
            <summary>
            Create the vis but do not initialize it. Mainly used to read the plugin name, and test whether it is a Sonique/UltraPlayer or Winamp plugin.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vis.BASSVISConfig">
            <summary>
            Flags to be used with <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetOption(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,Un4seen.Bass.AddOn.Vis.BASSVISConfig)"/> and <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SetOption(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,Un4seen.Bass.AddOn.Vis.BASSVISConfig,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISConfig.BASS_SONIQUEVIS_CONFIG_DEFAULT">
            <summary>
            No Vis option.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISConfig.BASS_SONIQUEVIS_CONFIG_FFTAMP">
            <summary>
            The amplification of the FFT values towards the plugins. One of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISFFTAmp"/> constants should be used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISConfig.BASS_WINAMPVIS_CONFIG_FFTAMP">
            <summary>
            FFT Spectrum sensitivity (defines the zoom spectrum data from 32 >8192 Sample). Allowed value range is 0..256.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISConfig.BASS_SONIQUEVIS_CONFIG_FFT_SKIPCOUNT">
            <summary>
            Amount of samples to skip when providing the plugin with sample data (kind of zoom out). Allowed value range is 0..3.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISConfig.BASS_SONIQUEVIS_CONFIG_WAVE_SKIPCOUNT">
            <summary>
            Amount of samples to skip when providing the plugin with sample data (kind of zoom out). Allowed value range is 0..N.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISConfig.BASS_SONIQUEVIS_CONFIG_SLOWFADE">
            <summary>
            Whether to dim light colors to less than half, then slowly fade them out. If set to zero, the fade out is steady, at a single rate. Allowed value range is 0..80.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISConfig.BASS_WMPVIS_CONFIG_FFTAMP">
            <summary>
            The amplification of the FFT values towards the plugins.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vis.BASSVISFFTAmp">
            <summary>
            FFT amplification flags to be used with the <see cref="F:Un4seen.Bass.AddOn.Vis.BASSVISConfig.BASS_SONIQUEVIS_CONFIG_FFTAMP"/> option for <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetOption(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,Un4seen.Bass.AddOn.Vis.BASSVISConfig)"/> and <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SetOption(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,Un4seen.Bass.AddOn.Vis.BASSVISConfig,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISFFTAmp.BASS_VIS_FFTAMP_NORMAL">
            <summary>
            Normal amplification.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISFFTAmp.BASS_VIS_FFTAMP_HIGH">
            <summary>
            High amplification.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISFFTAmp.BASS_VIS_FFTAMP_HIGHER">
            <summary>
            Higher amplification.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISFFTAmp.BASS_VIS_FFTAMP_HIGHEST">
            <summary>
            Highest amplification.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vis.BASSVISPFindPlugin">
            <summary>
            Flags to be used with <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_FindPlugins(Un4seen.Bass.AddOn.Vis.BASSVISPlugin,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPFindPlugin.BASS_VIS_FIND_DEFAULT">
            <summary>
            No search option.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASSVISPFindPlugin.BASS_VIS_FIND_RECURSIVE">
            <summary>
            Recursively loop through all sub-directories as well.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vis.GWLIndex">
            <summary>
            Flags to be used with <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_FindPlugins(Un4seen.Bass.AddOn.Vis.BASSVISPlugin,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.GWLIndex.GWL_USERDATA">
            <summary>
            Retrieves the user data associated with the window. This data is intended for use by the application that created the window. Its value is initially zero.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.GWLIndex.GWL_EXSTYLE">
            <summary>
            Retrieves the extended window styles.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.GWLIndex.GWL_STYLE">
            <summary>
            Retrieves the window styles.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.GWLIndex.GWL_ID">
            <summary>
            Retrieves the identifier of the window.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.GWLIndex.GWL_HWNDPARENT">
            <summary>
            Retrieves a handle to the parent window, if there is one.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.GWLIndex.GWL_HINSTANCE">
            <summary>
            Retrieves a handle to the application instance.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.GWLIndex.GWL_WNDPROC">
            <summary>
            Retrieves the pointer to the window procedure, or a handle representing the pointer to the window procedure. You must use the CallWindowProc function to call the window procedure.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM">
            <summary>
            Main parameter structure used in many methods to identify the plugin and it's window handles.
            </summary>
            <remarks>See <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_ExecutePlugin(Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC,Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)"/> for more info.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM.VisHandle">
            <summary>
            Handle of the plugin. This is set by calling <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_ExecutePlugin(Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC,Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM.VisWinHandle">
            <summary>
            Handle of the window for visualization.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM.VisGenWinHandle">
            <summary>
            Handle of the window for visualization (set if a Winamp5 plugin was started).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM.Kind">
            <summary>
            Type of the plugin (one of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISPlugin"/> values).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM.#ctor(Un4seen.Bass.AddOn.Vis.BASSVISPlugin)">
            <summary>
            Creates a new instance of this structure and specifies the kind of plugin it should be used for.
            </summary>
            <param name="kind">The kind/type of plugin this instance should be used with (one of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISPlugin"/> values).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM.#ctor(Un4seen.Bass.AddOn.Vis.BASSVISPlugin,System.Int32)">
            <summary>
            Creates a new instance of this structure and specifies the kind of plugin it should be used for.
            </summary>
            <param name="kind">The kind/type of plugin this instance should be used with (one of the <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISPlugin"/> values).</param>
            <param name="visHandle">The plugin handle as returned by <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_GetPluginHandle(Un4seen.Bass.AddOn.Vis.BASSVISPlugin,System.String)"/>.</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC">
            <summary>
            Parameter structure used with <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_ExecutePlugin(Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC,Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.PluginFile">
            <summary>
            Path and filename of the Winamp, Sonique or BassBox plugin.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.AMP_UseOwnW1">
            <summary>
            Flag to view Winamp5 plugins in a container (ownHDC).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.AMP_UseOwnW2">
            <summary>
            Flag to view Winamp2 plugins in a container (ownHDCW2).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.AMP_ModuleIndex">
            <summary>
            Modulenumber of the module within a plugin that should be used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.SON_PaintHandle">
            <summary>
            Handle of the container, where to view the plugin.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.SON_ConfigFile">
            <summary>
            Path and filename of the Sonique configuration file.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.SON_Flags">
            <summary>
            Flags for Sonique plugins (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISFlags"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.WMP_PluginIndex">
            <summary>
            WMP plugin index that should be used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.WMP_PresetIndex">
            <summary>
            WMP preset number of the plugin that should be used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.WMP_SrcVisHandle">
            <summary>
            WMP handle of the container, where to view the plugin.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.BB_ParentHandle">
            <summary>
            BassBox handle of the container, where to view the plugin.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.BB_Flags">
            <summary>
            Flags for BassBox plugins (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISFlags"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.BB_ShowFPS">
            <summary>
            Show the frames per seconds in the VisWindow.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.BB_ShowPrgBar">
            <summary>
            Show the progress bar in the VisWindow.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.Width">
            <summary>
            The with of the window, where the plugins should be viewed.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.Height">
            <summary>
            The height of the window, where the plugin should be viewed.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.Left">
            <summary>
            The left position, where the plugin should be viewed in the window.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.Top">
            <summary>
            The top position, where the plugin should be viewed in the window.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BASS_VIS_EXEC.#ctor(System.String)">
            <summary>
            Creates a new instance of this structure and specifies the path and of the plugin to be executed.
            </summary>
            <param name="filename">Path and filename of the plugin to be executed.</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO">
            <summary>
            Structure containing information for the plugin (see <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_SetInfo(Un4seen.Bass.AddOn.Vis.BASS_VIS_PARAM,Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO)"/> for details).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO.SongTitle">
            <summary>
            Title of the song.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO.SongFile">
            <summary>
            Path and filename of the song.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO.Position">
            <summary>
            Position within the stream (in milliseconds).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO.Length">
            <summary>
            Length of the stream (in milliseconds).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO.PlaylistPos">
            <summary>
            Position (index) of the current song in the playlist (first entry has the index 1).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO.PlaylistLen">
            <summary>
            Number of songs in the playlist.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO.SampleRate">
            <summary>
            Samplerate of the current song (default: 44100).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO.BitRate">
            <summary>
            Bitrate of the current song (default: 256).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO.Duration">
            <summary>
            Playtime of the song (in total seconds, use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO.Channels">
            <summary>
            Available channels of the song (default: 2 for stereo).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Vis.BASS_VIS_INFO.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of this structure and specifies the title and filename of the song.
            </summary>
            <param name="songtitle">Title of the song.</param>
            <param name="filename">Path and filename of the song.</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Vis.BASSVISSTATE">
            <summary>
            Winamp callback delegate (to be used with <see cref="M:Un4seen.Bass.AddOn.Vis.BassVis.BASS_VIS_WINAMPSetStateCallback(Un4seen.Bass.AddOn.Vis.BASSVISSTATE)"/>).
            </summary>
            <param name="state">The current play state (see <see cref="T:Un4seen.Bass.AddOn.Vis.BASSVISPlayState"/> for possible values).</param>
        </member>
        <member name="T:Un4seen.Bass.Misc.BPMCounter">
            <summary>
            Provides general methods to detect beats live in an audio signal and to calculate the resulting Beats Per Minute (BPM).
            <para>Requires: bass.dll - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>The BPMCounter class is an internal implementation of the BASS.NET API and does not require any additional extension or add-on to the BASS audio library, meaning only bass.dll is required.</para>
            <para>However, <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> must have been called before using any method within this class!</para>
            <para>NOTE: When using the BPMCounter class with an already existing decoding channel (created with the BASS_STREAM_DECODE flag) the data will be retrieved from that channel, meaning the data will be 'stolen'.
            So it is NOT recommended to use this class with any decoding streams.</para>
            <para>Internally the algo is based on human ear simulation - meaning an average energy history of 1 second is used, since this is what the human ear can keep - so the BPM results might change and vary more often as with systems scanning the whole file or bigger parts of it. 
            The advantage is therefore that this system might be used with live data and has a fast reaction time of about 1 second only - like our human ear.</para>
            <para>The typical use of this class is as followed:</para>
            <para>a) create an instance of this class (e.g. at the beginning of your application)</para>
            <para>b) use a timer callback (e.g. every 20ms or every 25ms) to process the audio signal (the timer frequency must be specified when creating the class instance).</para>
            <para>c) in the timer callback call <see cref="M:Un4seen.Bass.Misc.BPMCounter.ProcessAudio(System.Int32,System.Boolean)"/> to detect a beat.</para>
            <para>d) retrieve the <see cref="P:Un4seen.Bass.Misc.BPMCounter.BPM"/> propertiy to get the calculated Beats Per Minute value.</para>
            <para>You should call the <see cref="M:Un4seen.Bass.Misc.BPMCounter.Reset(System.Int32)"/> method whenever you play another stream or if the returned BPM looks completely wrong.</para>
            <para>There are also methods to calculate the BPM manually using a TAP click button. E.g. call <see cref="M:Un4seen.Bass.Misc.BPMCounter.TapBeat"/> on a mouse click event to tap (set) a beat manually and call <see cref="P:Un4seen.Bass.Misc.BPMCounter.TappedBPM"/> to retrieve the manually tapped BPM value.</para>
            <para>Beat detection is a very very complex task and it is almost impossible to implement it matching for any kind of audio signal. So please note, that it might NOT work with all tracks in the same way - with some tracks it might return really bad results.
            This implementation is a 'simple' one (not needing too much CPU power). It is based on instant energy calculation on 128 frequency bands and comparing them with it's average engery for that band.
            The variation of the energy of each frequency band is used as a dynamic sensitivity factor. The peak detector uses an attack time of 0ms and there is a dynamic release envelop for the release time - plus we have a Schmitt triggers and a rising edge detectors implemented for each frequency band.
            The low pass frequency has a fixed value of 350Hz (for detecting bass drums) and the mid range frequency is set to be between 1500Hz and 4000Hz (to detect e.g. snare drums). This to calculate an overall trigger value for all frequency bands.
            Finally there is a Schmitt trigger again to detect the final beat for each call to the audio signal processing.</para>
            <para>You might notice, that often more beats are detected as you would recognize them with your ear (when doing manual tapping). These are intermediate beats or simply lound noise in the signal (which the algo did not filter good enough).
            So the BPM calculation uses a time spotting approximation to determine when a beat is a good beat to count. 'No-good' beats are simply not counted. So it sometimes might take some time until the live BPM value reaches a good value!</para>
            <para>The default BPM value range is between 60 and 180 BPM. But this might be changed using the <see cref="P:Un4seen.Bass.Misc.BPMCounter.MinBPM"/> or <see cref="P:Un4seen.Bass.Misc.BPMCounter.MaxBPM"/> properties.</para>
            <para>Note: 1 BPM is worth about 5ms (at 120BMP) - or in other words: if your time intervall differs in 5ms the resulting BPM might have a difference of about 1 BPM.
            Therefor we use a BPM history buffer which we interleave and calculate the average to equalize this effect.</para>
            <para>The BPM results are not equally good for all music tracks and genres. However, beat detection and BPM calculation is mostly needed for DJ applications with music having mostly clear and distinct beats and for this kind of music the class produces very good results.
            Also keep in mind, that when working with highly compressed or equalized tracks (e.g. badly encoded MP3 tracks) the quality might also suffer - so for best results use good audio material.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BPMCounter.#ctor(System.Int32,System.Int32)">
            <summary>
            The contructor of the beat detection class.
            </summary>
            <param name="timerfreq">The frequency of your timer callback in milliseconds (how often you will call <see cref="M:Un4seen.Bass.Misc.BPMCounter.ProcessAudio(System.Int32,System.Boolean)"/>), e.g. 20ms.</param>
            <param name="samplerate">The samplerate of the audio signal to process. You might also change this with calling <see cref="M:Un4seen.Bass.Misc.BPMCounter.Reset(System.Int32)"/> at any time later.</param>
        </member>
        <member name="M:Un4seen.Bass.Misc.BPMCounter.TapBeat">
            <summary>
            Call this to set (tap) a beat manually (e.g. on a mouse click event).
            The resulting (tapped) BPM value is available at <see cref="P:Un4seen.Bass.Misc.BPMCounter.TappedBPM"/>.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.BPMCounter.Reset(System.Int32)">
            <summary>
            Call this to reset all internal buffers and/or to change the current samplerate of the audio signal to be processed.
            </summary>
            <param name="samplerate">The new samplerate (specify -1 to leave the current one).</param>
            <remarks>You should at best call this method every time you play a new track.
            But you might also call this method if the calculated BPM is wrong and you wanted to give it a fresh try.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BPMCounter.SetSamperate(System.Int32)">
            <summary>
            Call this method to change the current samplerate of the audio signal to be processed.
            </summary>
            <param name="samplerate">The new samplerate which should be used when processing audio sample.</param>
        </member>
        <member name="M:Un4seen.Bass.Misc.BPMCounter.ProcessAudio(System.Int32,System.Boolean)">
            <summary>
            Processes the audio data (gets instant FFT samples) and calculates the live BPM. 
            </summary>
            <param name="channel">The channel who's audio signal should be processed to detect a beat.</param>
            <param name="bpmBeatsOnly">Set this to TRUE, if you want the method to return only the counted BPM beats. If set to FALSE each detected beat will be returned.</param>
            <returns>TRUE, if a beat was detected or FALSE, if no beat was detected.</returns>
            <remarks>This is the main method doing the beat detection and live BPM calculation. Call this method in your timer callback as frequently as possibly (e.g. every 20ms is a good value, but every 50ms should also be okay).
            <para>Note: it is important, that you call this method in fixed time intervalls! The more often you call this method (the smaller your timer intervall is) the more exact will be the resulting BPM value.
            You must also call this method in the same interval as specified when you created the class instance.</para>
            <para>Since beat detection is very complex this method might return incorrect values when using it with audio signals containing a lot of noise.</para>
            <para>The method internally uses some history buffers, which needs first to be filled. So it will take around 1 second (or around 50 calls at 20ms) before you receive first results!
            Also note, that the internal buffer is flushed at certain intervals, so give the method some time to result newer and even 'better' values, especially, if the audio signal starts with different beats at the track beginning or has intermediate parts with no or different beats.</para>
            <para>You might also use this method to detect a given beat (e.g. to perform automatic mixing) and so to determine a good mixer start point (cue point).</para>
            <para>Note: This method might return 'intermediate' detected beats - so the detected beats might not always reflect your listening experiance like when using manual tapped beats. So with very slow jams (e.g. at 70 or 80bpm) the resulting BPM might sometimes be twice at high.</para>
            <para>The method itself takes less than 1ms to perform it's task. Internally the algo is based on human ear simulation - meaning an average energy history of 1 second is used, since this is what the human ear can keep - so the BPM results might change and vary more often as with systems scanning the whole file or bigger parts of it. 
            The advantage is therefore that this system might be used with live data and has a fast reaction time of about 1 second only - like our human ear.</para>
            <para>Note: 1 BPM is worth about 5ms (at 120BMP) - or in other words: if your time intervall differs in 5ms the resulting BPM might have a difference of about 1 BPM.
            Therefor we use a BPM history buffer which we interleave and calculate the average to equalize this effect.</para>
            </remarks>
            <example>
            <code>
            private int _stream;
            // create a BPMCounter instance, the timer will be fired every 20ms
            private BPMCounter _bpm = new BPMCounter(20, 44100);
            ...
            // create a stream
            _stream = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_DEFAULT);
            // get the samplerate of that stream
            BASS_CHANNELINFO info = new BASS_CHANNELINFO();
            Bass.BASS_ChannelGetInfo(_stream, info);
            // and start playing the and also start the BPM counter
            if (_stream != 0 &amp;&amp; Bass.BASS_ChannelPlay(_stream, false) )
            {
              //playing...
              _bpm.Reset(info.freq);
              // start our bpm timer callback
              this.timerBPM.Start();
            }
            
            private void timerBPM_Tick(object sender, System.EventArgs e)
            {
              if ( _stream == 0 || Bass.BASS_ChannelIsActive(_stream) != BASSActive.BASS_ACTIVE_PLAYING)
              {
                this.timerBPM.Stop();
                return;
              }
              bool beat = _bpm.ProcessAudio(_stream, true);
              if (beat)
              {
                // display the live calculated BPM value
                this.labelBPM.Text = _bpm.BPM.ToString( "#00.0" );
              }
            }
            </code>
            <code lang="vbnet">
            Private _stream As Integer
            ' create a BPMCounter instance, the timer will be fired every 20ms
            Private _bpm As New BPMCounter(20, 44100)
            ...
            ' create a stream
            _stream = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_DEFAULT)
            ' get the samplerate of that stream
            Dim info As New BASS_CHANNELINFO()
            Bass.BASS_ChannelGetInfo(_stream, info)
            ' and start playing the and also start the BPM counter
            If _stream &lt;&gt; 0 AndAlso Bass.BASS_ChannelPlay(_stream, False) Then
              'playing...
              _bpm.Reset(info.freq)
              ' start our bpm timer callback
              Me.timerBPM.Start()
            End If
            
            Private Sub timerBPM_Tick(sender As Object, e As System.EventArgs)
              If _stream = 0 OrElse Bass.BASS_ChannelIsActive(_stream) &lt;&gt; BASSActive.BASS_ACTIVE_PLAYING Then
                Me.timerBPM.Stop()
                Return
              End If
              Dim beat As Boolean = _bpm.ProcessAudio(_stream, True)
              If beat Then
                ' display the live calculated BPM value
                Me.labelBPM.Text = _bpm.BPM.ToString("#00.0")
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="P:Un4seen.Bass.Misc.BPMCounter.BPMHistorySize">
            <summary>
            Gets or Sets the BPM history buffer size (Minimum=2, Maximum=50, Default=10).
            </summary>
            <remarks>The BPM history buffer is used to keep the last detected BPM values. The resulting <see cref="P:Un4seen.Bass.Misc.BPMCounter.BPM"/> final value is calculated as the average value of the history.
            <para>Setting a new BPM history buffer size value will also reset the last calculated BPM values. Setting the BPM history buffer size to an even number is a good idea.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BPMCounter.MinBPM">
            <summary>
            Gets or sets the minimum BPM value (default is 60, minimum is 30).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BPMCounter.MaxBPM">
            <summary>
            Gets or sets the maximum BPM value (default is 180, maximum is 250).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BPMCounter.BPM">
            <summary>
            Gets or sets the currently detected live BPM value (detected via <see cref="M:Un4seen.Bass.Misc.BPMCounter.ProcessAudio(System.Int32,System.Boolean)"/>).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BPMCounter.TappedBPM">
            <summary>
            Gets or sets the manually tapped BPM value (detected via <see cref="M:Un4seen.Bass.Misc.BPMCounter.TapBeat"/>).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.HiPerfTimer">
            <summary>
            Provides a Win32 high performance counter.
            </summary>
            <remarks>
            This class is very simple to use. Just create an instance of <see cref="T:Un4seen.Bass.Misc.HiPerfTimer"/>, call <see cref="M:Un4seen.Bass.Misc.HiPerfTimer.Start"/> to start timing and call <see cref="M:Un4seen.Bass.Misc.HiPerfTimer.Stop"/> to stop timing. 
            To retrieve the elapsed time, just call the <see cref="P:Un4seen.Bass.Misc.HiPerfTimer.Duration"/> method and you will get the elapsed time in seconds.
            </remarks>
            <example>
            <code>
            // create a new HiPerfTimer object
            HiPerfTimer pt = new HiPerfTimer();
            pt.Start();                             // start the timer
            // the code to be timed
            Console.WriteLine("Test");
            pt.Stop();                              // stop the timer
            // print the duration of the timed code
            Console.WriteLine("Duration: {0} sec", pt.Duration);
            </code>
            <code lang="vbnet">
            ' create a new HiPerfTimer object
            Dim pt As New HiPerfTimer()
            pt.Start() ' start the timer
            Console.WriteLine("Test") ' the code to be timed
            pt.Stop() ' stop the timer
            ' print the duration of the timed code
            Console.WriteLine("Duration: {0} sec", pt.Duration)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.HiPerfTimer.#ctor">
            <summary>
            Default constructor to create a high performance counter.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">The HiPerfTimer is not supported on this platform.</exception>
        </member>
        <member name="M:Un4seen.Bass.Misc.HiPerfTimer.Start">
            <summary>
            Start the timer.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.HiPerfTimer.Stop">
            <summary>
            Stop the timer.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.HiPerfTimer.Duration">
            <summary>
            Returns the duration of the timer (in seconds).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Flac.BassFlac">
            <summary>
            BASS.NET API wrapper for BASSFLAC.DLL
            <para>Requires: bassflac.dll - Free Lossless Audio Codec (FLAC) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSFLAC is an extension to the BASS audio library, enabling the playing of FLAC (Free Lossless Audio Codec) encoded files.</para>
            <para>The FLAC format is used in very much the same way as any of the built-in BASS stream formats - simply call the FLAC stream creation function instead of the BASS built-in functions. The BASS plugin system (see <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>) is also supported.</para>
            <para>More information can be found on <a href="http://flac.sourceforge.net">flac.sourceforge.net</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a FLAC file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a FLAC memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a FLAC file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from a FLAC file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
             <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="proc">Callback function to receive the file as it is downloaded... NULL = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Flac.BassFlac.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bassflac.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Flac.BassFlac.SupportedStreamName">
            <summary>
            Supported file format name of the bassflac.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Flac.BassFlac.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Flac.BassFlac.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.WaveWriter">
            <summary>
            Provides general methods to save an audio stream to a file in the WAVE file format.
            <para>Supported bit resolutions are 8-bit, 16-bit, 24-bit and 32-bit.
            Supported sample rates are 8000, 11025, 22050, 44100, 48000 or 96000 Hz.
            Multi channel wave files are also supported. Use 1=mono, 2=stereo...</para>
            </summary>
            <remarks>
            <para>The WaveWriter class is an internal implementation of the BASS.NET API and does not require any additional extension or add-on to the BASS audio library.</para>
            <para>The typical use of this class is as followed:</para>
            <para>a) Create an instance of the class and define the frequency, channels and bitrate.</para>
            <para>b) Call the <see cref="M:Un4seen.Bass.Misc.WaveWriter.Write(System.IntPtr,System.Int32)"/> method subsequently to write sample data to the wave file.</para>
            <para>c) Finally call <see cref="M:Un4seen.Bass.Misc.WaveWriter.Close"/> to close and finish the wave file.</para>
            <para>Note: Not all media players support playback of all formats, especially multi-channel (more than stereo) or high-resolution (greater 16-bit) wave files.</para>
            <para>The following speaker assignment is used for multi-channel wave files (as defined/recommended by Microsoft):
            <list type="table">
            <listheader><term>#Chans</term><description>Speaker Assignment</description></listheader>
            <item><term>1</term><description>Mono: SPEAKER_FRONT_LEFT</description></item>
            <item><term>2</term><description>Stereo: SPEAKER_FRONT_LEFT, SPEAKER_FRONT_RIGHT</description></item>
            <item><term>3</term><description>2.1: SPEAKER_FRONT_LEFT, SPEAKER_FRONT_RIGHT, SPEAKER_FRONT_CENTER</description></item>
            <item><term>4</term><description>2.2: SPEAKER_FRONT_LEFT, SPEAKER_FRONT_RIGHT, SPEAKER_BACK_LEFT, SPEAKER_BACK_RIGHT</description></item>
            <item><term>5</term><description>2.2.1: SPEAKER_FRONT_LEFT, SPEAKER_FRONT_RIGHT, SPEAKER_FRONT_CENTER, SPEAKER_BACK_LEFT, SPEAKER_BACK_RIGHT</description></item>
            <item><term>6</term><description>5.1: SPEAKER_FRONT_LEFT, SPEAKER_FRONT_RIGHT, SPEAKER_FRONT_CENTER, SPEAKER_LOW_FREQUENCY, SPEAKER_BACK_LEFT, SPEAKER_BACK_RIGHT</description></item>
            <item><term>7</term><description>5.1.1: SPEAKER_FRONT_LEFT, SPEAKER_FRONT_RIGHT, SPEAKER_FRONT_CENTER, SPEAKER_LOW_FREQUENCY, SPEAKER_BACK_LEFT, SPEAKER_BACK_RIGHT, SPEAKER_BACK_CENTER</description></item>
            <item><term>8</term><description>7.1: SPEAKER_FRONT_LEFT, SPEAKER_FRONT_RIGHT, SPEAKER_FRONT_CENTER, SPEAKER_LOW_FREQUENCY, SPEAKER_BACK_LEFT, SPEAKER_BACK_RIGHT, SPEAKER_FRONT_LEFT_OF_CENTER, SPEAKER_FRONT_RIGHT_OF_CENTER</description></item>
            <item><term>9</term><description>7.1.1: SPEAKER_FRONT_LEFT, SPEAKER_FRONT_RIGHT, SPEAKER_FRONT_CENTER, SPEAKER_LOW_FREQUENCY, SPEAKER_BACK_LEFT, SPEAKER_BACK_RIGHT, SPEAKER_FRONT_LEFT_OF_CENTER, SPEAKER_FRONT_RIGHT_OF_CENTER, SPEAKER_BACK_CENTER</description></item>
            <item><term>&gt; 9</term><description>Undefined: SPEAKER_ALL</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Writing a MP3 file to WAV:
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE);
            WaveWriter WW = new WaveWriter("test.wav", stream, true);
            short[] data = new short[32768];
            while (Bass.BASS_ChannelIsActive(stream) == BASSActive.BASS_ACTIVE_PLAYING)
            {
              int length = Bass.BASS_ChannelGetData(stream, data, 32768);
              if (length &gt; 0)
                WW.Write(data, length);
            }
            // finilize the wave file!
            WW.Close();
            Bass.BASS_StreamFree(stream);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE)
            Dim WW As New WaveWriter("test.wav", stream, True)
            Dim data(32768) As Short
            While Bass.BASS_ChannelIsActive(stream) = BASSActive.BASS_ACTIVE_PLAYING
              Dim length As Integer = Bass.BASS_ChannelGetData(stream, data, 32768)
              If length &gt; 0 Then
                WW.Write(data, length)
              End If
            End While
            ' finilize the wave file!
            WW.Close()
            Bass.BASS_StreamFree(stream)
            </code>
            Using a WaveWriter in a RECORDPROC to record 24-bit at 44.1kHz, stereo:
            <code>
            private WaveWriter _waveWriter = null; // make it global, so that the GC can not remove it
            private RECORDPROC _myRecProc;
            private int _recHandle = 0;
            ...
            // start recording
            _myRecProc = new RECORDPROC(MyRecording);
            _recHandle = Bass.BASS_RecordStart(44100, 2, 
                              BASSFlag.BASS_RECORD_PAUSE | BASSFlag.BASS_SAMPLE_FLOAT, _myRecProc, IntPtr.Zero);
            // create a WaveWriter using the _recHandle to set the freq. and channels, but write the wave at 24-bit
            _waveWriter = new WaveWriter( "test.wav", _recHandle, 24, true);
            Bass.BASS_ChannelPlay(_recHandle, false);
            ...
            // when finished recording call this!
            if (_waveWriter != null)
            {
              // finilize the wave file!
              _waveWriter.Close();
            }
            ...
            // the recording callback
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              // we will get float sample data here
              // so make sure the _waveWriter.OrigResolution property is set to 32
              // this was automatically done, since we started recording with BASSFlag.BASS_SAMPLE_FLOAT
              _waveWriter.Write( buffer, length );
              return true; // always continue recording
            }
            </code>
            <code lang="vbnet">
            Private _waveWriter As WaveWriter = Nothing ' make it global, so that the GC can not remove it
            Private _myRecProc As RECORDPROC
            Private _recHandle As Integer = 0
            ...
            ' start recording
            _myRecProc = New RECORDPROC(AddressOf MyRecording)
            _recHandle = Bass.BASS_RecordStart(44100, 2, 
                              BASSFlag.BASS_RECORD_PAUSE Or BASSFlag.BASS_SAMPLE_FLOAT, _myRecProc, IntPtr.Zero)
            ' create a WaveWriter using the _recHandle to set the freq. and channels, but write the wave at 24-bit
            _waveWriter = New WaveWriter("test.wav", _recHandle, 24, True)
            Bass.BASS_ChannelPlay(_recHandle, False)
            ...
            ' when finished recording call this!
            If Not (_waveWriter Is Nothing) Then
              ' finilize the wave file!
              _waveWriter.Close()
            End If
            ...
            ' the recording callback
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              ' we will get float sample data here
              ' so make sure the _waveWriter.OrigResolution property is set to 32
              ' this was automatically done, since we started recording with BASSFlag.BASS_SAMPLE_FLOAT
              _waveWriter.Write(buffer, length)
              Return True ' always continue recording
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveWriter.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
            Create a WaveWrite instance from a given BASS stream channel.
            </summary>
            <param name="fileName">Fully referenced path and file name of the Wave file to create.</param>
            <param name="stream">A BASS stream channel (HMUSIC, HSTREAM, HRECORD) for which to create a WaveWriter.</param>
            <param name="rewrite">Specifies, if an existing <paramref name="fileName"/> should be overwritten (TRUE=overwrite, FALSE=do not overwrite).</param>
            <remarks>The sample data provided when calling the <see cref="M:Un4seen.Bass.Misc.WaveWriter.Write(System.IntPtr,System.Int32)"/> method must conform the stream info settings. No resampling will be applied here.
            <para>This overload already sets the <see cref="P:Un4seen.Bass.Misc.WaveWriter.NumChannels"/>, <see cref="P:Un4seen.Bass.Misc.WaveWriter.SampleRate"/> and <see cref="P:Un4seen.Bass.Misc.WaveWriter.BitsPerSample"/> properties according to the given <paramref name="channel"/> stream.</para>
            <para>When you have created the stream with the <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT"/> flag the Wave file will be written in 32-bit float format (WAVE_FORMAT_IEEE_FLOAT).
            When you have created the stream with the <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_8BITS"/> flag the Wave file will be written in 8-bit unsigned format (WAVE_FORMAT_PCM).
            In all other cases the the Wave file will be written in 16-bit signed format (WAVE_FORMAT_PCM).</para>
            <para>Note: 24-bit resolutions are not supported with this overload.</para>
            <para>If the stream contains more than 2 channels (e.g. multi-channel) the Wave file will be written in the WAVE_FORMAT_EXTENSIBLE format.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">The channel information could not be retrieved for the <paramref name="stream"/>.</exception>
            <exception cref="T:System.IO.IOException">The file already exists (only raised if the <paramref name="rewrite"/> has not been used). Or the Wave Header could not be written.</exception>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveWriter.#ctor(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a WaveWrite instance from a given BASS stream channel.
            </summary>
            <param name="fileName">Fully referenced path and file name of the Wave file to create.</param>
            <param name="stream">A BASS stream channel (HMUSIC, HSTREAM, HRECORD) for which to create a WaveWriter.</param>
            <param name="bitsPerSample">Bits per sample of the wave file (must be either 8, 16, 24 or 32). This overrides the actual stream resolution and the bit rate will be converted automatically (however quality might be effected but never increased).</param>
            <param name="rewrite">Specifies, if an existing <paramref name="fileName"/> should be overwritten (TRUE=overwrite, FALSE=do not overwrite).</param>
            <remarks>The sample data provided when calling the <see cref="M:Un4seen.Bass.Misc.WaveWriter.Write(System.IntPtr,System.Int32)"/> method must conform the stream info settings. No resampling will be applied here.
            <para>This overload already sets the <see cref="P:Un4seen.Bass.Misc.WaveWriter.NumChannels"/> and <see cref="P:Un4seen.Bass.Misc.WaveWriter.SampleRate"/> properties according to the given <paramref name="channel"/> stream. The <see cref="P:Un4seen.Bass.Misc.WaveWriter.BitsPerSample"/> will be overwritten.</para>
            <para>When you have specified a 32-bit resolution the Wave file will be written in 32-bit float format (WAVE_FORMAT_IEEE_FLOAT).
            When you have specified an 8-bit resolution the Wave file will be written in 8-bit unsigned format (WAVE_FORMAT_PCM).
            In all other cases the the Wave file will be written in 16-bit or 24-bit signed format (WAVE_FORMAT_PCM).</para>
            <para>If the stream contains more than 2 channels (e.g. multi-channel) the Wave file will be written in the WAVE_FORMAT_EXTENSIBLE format.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">The channel information could not be retrieved for the <paramref name="stream"/>.</exception>
            <exception cref="T:System.IO.IOException">The file already exists (only raised if the <paramref name="rewrite"/> has not been used). Or the Wave Header could not be written.</exception>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveWriter.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a WaveWrite instance to save sample data to be processed to a wave file.
            </summary>
            <param name="fileName">Fully referenced path and file name of the Wave file to create.</param>
            <param name="numChannels">Number of channels of the wave file (1=mono, 2=stereo...).</param>
            <param name="sampleRate">Sample rate of the wave file (e.g. 8000, 11025, 22050, 44100, 48000, 96000) in Hz.</param>
            <param name="bitsPerSample">Bits per sample of the wave file (must be either 8, 16, 24 or 32).</param>
            <param name="rewrite">Specifies, if an existing <paramref name="fileName"/> should be overwritten (TRUE=overwrite, FALSE=do not overwrite).</param>
            <remarks>The sample data provided when calling the <see cref="M:Un4seen.Bass.Misc.WaveWriter.Write(System.IntPtr,System.Int32)"/> method must conform these settings (ie. <see cref="P:Un4seen.Bass.Misc.WaveWriter.NumChannels"/>, <see cref="P:Un4seen.Bass.Misc.WaveWriter.SampleRate"/> and <see cref="P:Un4seen.Bass.Misc.WaveWriter.BitsPerSample"/>)! No resampling will be applied here.
            <para>When you have specified 24 <paramref name="bitsPerSample"/> the sample data must be provided as float values when using the <see cref="M:Un4seen.Bass.Misc.WaveWriter.Write(System.IntPtr,System.Int32)"/> method (the float sample will actually be converted to 24-bit samples)!</para>
            <para>If the stream contains more than 2 channels (e.g. multi-channel) or is defined with 24-bit resolution the Wave file will be written in the WAVE_FORMAT_EXTENSIBLE format.</para>
            </remarks>
            <exception cref="T:System.IO.IOException">The file already exists (only raised if the <paramref name="rewrite"/> has not been used). Or the Wave Header could not be written.</exception>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveWriter.Initialize(System.Boolean)">
            <summary>
            Internal constructor only.
            </summary>
            <param name="rewrite">Overwrite flag.</param>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveWriter.Dispose">
            <summary>
            Disposes the current instance of the WaveWriter and all it's resources and tries to delete the associated <see cref="P:Un4seen.Bass.Misc.WaveWriter.FileName"/>.
            </summary>
            <remarks>Only call this method, if you want to discard the <see cref="P:Un4seen.Bass.Misc.WaveWriter.FileName"/> created and physically delete it.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveWriter.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the <see cref="M:Un4seen.Bass.Misc.WaveWriter.Dispose"/> method does not get called.
            It will automatically <see cref="M:Un4seen.Bass.Misc.WaveWriter.Close"/> the <see cref="P:Un4seen.Bass.Misc.WaveWriter.FileName"/> and flush all the data so far written.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveWriter.WriteWaveHeader">
            <summary>
            Writes the Wave Header structure to the BinaryWriter _bw.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveWriter.Write(System.IntPtr,System.Int32)">
            <summary>
            Use this method to provide the sample data to the WaveWriter and write these samples to the wave file.
            </summary>
            <param name="buffer">The IntPtr containing the sample data.</param>
            <param name="length">The number of BYTEs in the buffer.</param>
            <remarks>This method is best used in <see cref="T:Un4seen.Bass.DSPPROC"/>, <see cref="T:Un4seen.Bass.DOWNLOADPROC"/> or <see cref="T:Un4seen.Bass.RECORDPROC"/> callback delegates.
            <para>Please note, that the sample data provided in the <paramref name="buffer"/> must conform the <see cref="P:Un4seen.Bass.Misc.WaveWriter.OrigResolution"/> property!
            Meaning if the <see cref="P:Un4seen.Bass.Misc.WaveWriter.OrigResolution"/>=32 float sample data is expected, if <see cref="P:Un4seen.Bass.Misc.WaveWriter.OrigResolution"/>=16 short sample data is expected and if <see cref="P:Un4seen.Bass.Misc.WaveWriter.OrigResolution"/>=8 byte samples are expected!</para>
            <para>However, the data written to the wave file will be in <see cref="P:Un4seen.Bass.Misc.WaveWriter.BitsPerSample"/> resolution (as specified in the constructor). If the <see cref="P:Un4seen.Bass.Misc.WaveWriter.OrigResolution"/> is different from this one an automatic bit resolution conversion will take place.</para>
            <para>When using a decoding stream other overloads might be more conviniant.</para>
            </remarks>
            <example>
            Using a WaveWriter in a RECORDPROC to record 24-bit at 44.1kHz, stereo:
            <code>
            private WaveWriter _waveWriter = null; // make it global, so that the GC can not remove it
            private RECORDPROC _myRecProc;
            private int _recHandle = 0;
            ...
            // start recording
            _myRecProc = new RECORDPROC(MyRecording);
            _recHandle = Bass.BASS_RecordStart(44100, 2, 
                              BASSFlag.BASS_RECORD_PAUSE | BASSFlag.BASS_SAMPLE_FLOAT, _myRecProc, IntPtr.Zero);
            // create a WaveWriter using the _recHandle to set the freq. and channels, but write the wave at 24-bit
            _waveWriter = new WaveWriter( "test.wav", _recHandle, 24, true);
            Bass.BASS_ChannelPlay(_recHandle, false);
            ...
            // when finished recording call this!
            if (_waveWriter != null)
            {
              // finilize the wave file!
              _waveWriter.Close();
            }
            ...
            // the recording callback
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              // we will get float sample data here
              // so make sure the _waveWriter.OrigResolution property is set to 32
              // this was automatically done, since we started recording with BASSFlag.BASS_SAMPLE_FLOAT
              _waveWriter.Write( buffer, length );
              return true; // always continue recording
            }
            </code>
            <code lang="vbnet">
            Private _waveWriter As WaveWriter = Nothing ' make it global, so that the GC can not remove it
            Private _myRecProc As RECORDPROC
            Private _recHandle As Integer = 0
            ...
            ' start recording
            _myRecProc = New RECORDPROC(AddressOf MyRecording)
            _recHandle = Bass.BASS_RecordStart(44100, 2, 
                              BASSFlag.BASS_RECORD_PAUSE Or BASSFlag.BASS_SAMPLE_FLOAT, _myRecProc, IntPtr.Zero)
            ' create a WaveWriter using the _recHandle to set the freq. and channels, but write the wave at 24-bit
            _waveWriter = New WaveWriter("test.wav", _recHandle, 24, True)
            Bass.BASS_ChannelPlay(_recHandle, False)
            ...
            ' when finished recording call this!
            If Not (_waveWriter Is Nothing) Then
              ' finilize the wave file!
              _waveWriter.Close()
            End If
            ...
            ' the recording callback
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              ' we will get float sample data here
              ' so make sure the _waveWriter.OrigResolution property is set to 32
              ' this was automatically done, since we started recording with BASSFlag.BASS_SAMPLE_FLOAT
              _waveWriter.Write(buffer, length)
              Return True ' always continue recording
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveWriter.Write(System.Single[],System.Int32)">
            <summary>
            Use this method to provide 32-bit sample data to the WaveWriter and write these samples to the wave file.
            </summary>
            <param name="buffer">An array of float values to write to the wave file.</param>
            <param name="length">The number of BYTEs in the buffer.</param>
            <remarks>This method is best used with e.g. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and e.g. decoding channels.
            <para>The data written to the wave file will be in <see cref="P:Un4seen.Bass.Misc.WaveWriter.BitsPerSample"/> resolution (as specified in the constructor). 
            If this is not 32 (float) an automatic bit resolution conversion will take place.</para>
            </remarks>
            <example>
            Converting an OGG file to WAV (32-bit quality):
            <code>
            // create a stream with the float option
            int stream = Bass.BASS_StreamCreateFile("test.ogg", 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            // set the target bit resolution to 32
            WaveWriter WW = new WaveWriter("test.wav", stream, 32, true);
            float[] data = new float[32768];
            while (Bass.BASS_ChannelIsActive(stream) == BASSActive.BASS_ACTIVE_PLAYING)
            {
              // get the sample data as float values as well
              int length = Bass.BASS_ChannelGetData(stream, data, 32768);
              // and write the data to the wave file
              if (length &gt; 0)
                WW.Write(data, length);
            }
            // finilize the wave file!
            WW.Close();
            Bass.BASS_StreamFree(stream);
            </code>
            <code lang="vbnet">
            ' create a stream with the float option
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.ogg", 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            ' set the target bit resolution to 32
            Dim WW As New WaveWriter("test.wav", stream, 32, True)
            Dim data(32768) As Single
            While Bass.BASS_ChannelIsActive(stream) = BASSActive.BASS_ACTIVE_PLAYING
              ' get the sample data as float values as well
              Dim length As Integer = Bass.BASS_ChannelGetData(stream, data, 32768)
              ' and write the data to the wave file
              If length &gt; 0 Then
                WW.Write(data, length)
              End If
            End While
            ' finilize the wave file!
            WW.Close()
            Bass.BASS_StreamFree(stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveWriter.Write(System.Int16[],System.Int32)">
            <summary>
            Use this method to provide 16-bit sample data to the WaveWriter and write these samples to the wave file.
            </summary>
            <param name="buffer">An array of short values to write to the wave file.</param>
            <param name="length">The number of BYTEs in the buffer.</param>
            <remarks>This method is best used with e.g. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and e.g. decoding channels.
            <para>However, the data written to the wave file will be in <see cref="P:Un4seen.Bass.Misc.WaveWriter.BitsPerSample"/> resolution (as specified in the constructor). 
            If this is not 16 (short) an automatic bit resolution conversion will take place.</para>
            </remarks>
            <example>
            Writing a MP3 file to WAV:
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE);
            WaveWriter WW = new WaveWriter("test.wav", stream, true);
            short[] data = new short[32768];
            while (Bass.BASS_ChannelIsActive(stream) == BASSActive.BASS_ACTIVE_PLAYING)
            {
              int length = Bass.BASS_ChannelGetData(stream, data, 32768);
              if (length &gt; 0)
                WW.Write(data, length);
            }
            // finilize the wave file!
            WW.Close();
            Bass.BASS_StreamFree(stream);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE)
            Dim WW As New WaveWriter("test.wav", stream, True)
            Dim data(32768) As Short
            While Bass.BASS_ChannelIsActive(stream) = BASSActive.BASS_ACTIVE_PLAYING
              Dim length As Integer = Bass.BASS_ChannelGetData(stream, data, 32768)
              If length &gt; 0 Then
                WW.Write(data, length)
              End If
            End While
            ' finilize the wave file!
            WW.Close()
            Bass.BASS_StreamFree(stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveWriter.Write(System.Byte[],System.Int32)">
            <summary>
            Use this method to provide 8-bit sample data to the WaveWriter and write these samples to the wave file.
            </summary>
            <param name="buffer">An array of byte values to write to the wave file.</param>
            <param name="length">The number of BYTEs in the buffer.</param>
            <remarks>This method is best used with e.g. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and e.g. decoding channels.
            <para>However, the data written to the wave file will be in <see cref="P:Un4seen.Bass.Misc.WaveWriter.BitsPerSample"/> resolution (as specified in the constructor). 
            If this is not 8 (byte) an automatic bit resolution conversion will take place.</para>
            </remarks>
            <example>
            Writing an OGG file to WAV (8-bit quality):
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.ogg", 0, 0, BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_8BITS);
            WaveWriter WW = new WaveWriter("test.wav", stream, true);
            byte[] data = new byte[32768];
            while (Bass.BASS_ChannelIsActive(stream) == BASSActive.BASS_ACTIVE_PLAYING)
            {
              int length = Bass.BASS_ChannelGetData(stream, data, 32768);
              if (length &gt; 0)
                WW.Write(data, length);
            }
            // finilize the wave file!
            WW.Close();
            Bass.BASS_StreamFree(stream);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.ogg", 0, 0, BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_8BITS)
            Dim WW As New WaveWriter("test.wav", stream, True)
            Dim data(32768) As Byte
            While Bass.BASS_ChannelIsActive(stream) = BASSActive.BASS_ACTIVE_PLAYING
              Dim length As Integer = Bass.BASS_ChannelGetData(stream, data, 32768)
              If length &gt; 0 Then
                WW.Write(data, length)
              End If
            End While
            ' finilize the wave file!
            WW.Close()
            Bass.BASS_StreamFree(stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveWriter.Close">
            <summary>
            Closes the WaveWriter and underlying wave file and updates the wave header accordingly.
            </summary>
            <remarks>After calling this method you might use the created wave file.
            <para>Not closing the WaveWriter will result in a broken wave file, since only at this point the wave header will be updated with the corrent sample size written.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveWriter.FileName">
            <summary>
            Gets or Sets the fully referenced path and file name of the wave file to write to data to.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveWriter.NumChannels">
            <summary>
            Gets the number of channels of the Wave file being created (values between 1 and 9 should be fine).
            <para>E.g. 1=mono, 2=stereo...</para>
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveWriter.SampleRate">
            <summary>
            Gets the sample rate of the Wave file being created.
            <para>e.g. 44100 for 44.1kHz. Typically one of the following: 11025, 22050, 44100, 48000, 96000.</para>
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveWriter.BitsPerSample">
            <summary>
            Gets or Sets the target resolution (number of bits per sample) of the Wave file being created.
            <para>This will be either 8, 16, 24 or 32.</para>
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveWriter.OrigResolution">
            <summary>
            Gets or Sets the original resolution (number of bits per sample) of the stream channel resp. sample data to process.
            <para>This should be either 8, 16 or 32.</para>
            <para>This value is used in the <see cref="M:Un4seen.Bass.Misc.WaveWriter.Write(System.IntPtr,System.Int32)"/> methods to automatically convert the bit resolution according to the target <see cref="P:Un4seen.Bass.Misc.WaveWriter.BitsPerSample"/> value.
            E.g. set this value to 32, if you receive 32-bit float sample data in a DSP callback and if you want to call the <see cref="M:Un4seen.Bass.Misc.WaveWriter.Write(System.IntPtr,System.Int32)"/> method there directly, but have specified a target resolution of 8, 16 or 24 bit.</para>
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.WaveWriter.WaveFormat">
            <summary>
            Defines the possible wave formats (only a few and common are listed here). For a complete listing see the mmreg.h header file.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveWriter.WaveFormat.WAVE_FORMAT_UNKNOWN">
            <summary>
            Unknown Format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveWriter.WaveFormat.WAVE_FORMAT_PCM">
            <summary>
            PCM format (8 or 16 bit)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveWriter.WaveFormat.WAVE_FORMAT_IEEE_FLOAT">
            <summary>
            Float format (32 bit)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveWriter.WaveFormat.WAVE_FORMAT_EXTENSIBLE">
            <summary>
            Extensible Format (user defined)
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.WaveWriter.WaveSpeakers">
            <summary>
            Wave speaker assignments for the WAVE_FORMAT_EXTENSIBLE format and multi-channel files.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.WaDsp.BassWaDsp">
            <summary>
            BASS.NET API wrapper for BASS_WADSP.DLL
            <para>Requires: bass_wadsp.dll - Winamp DSP plugin support Add-On - shipped with the BASS.NET API.</para>
            </summary>
            <remarks>
            <para>BassWaDsp is an BASS.NET API extention to the BASS audio library, providing a set of functions for calling Winamp DSP plugins.</para>
            <para>All Winamp DSPs are supported out of the box which do return as much data as provided - meaning not modifying the samplerate, tempo, pitch etc.!</para>
            <para>If you want to use Winamp plugins which do not return the same amount of bytes as provided, you need to add a lot functionality by yourself, e.g. implementing an intermediate ring-buffer between BASS and BASS_WADSP and/or sending ModifiedSamples only in a fixed packet size of 1152 samples etc. This might be a lot of work, but is actually possible.
            However, there is no guarantee, that all Winmap DSPs might really work - just try them out.</para>
            <para>Here is a list of Winamp DSP plugins, which should work fine:
            <code>
            - OctiMax  (dsp_omxw.dll)
            - Enhancer (dsp_enh.dll)
            - RockSteady (DSP_RockSteady.dll)
            - Nullsoft Signal Processing Studio (dsp_sps.dll)
            - SHOUTcast Source DSP (dsp_sc.dll - needs lamedll.dll in your startup directory)
            - SAM Encoders (dsp_encoders.dll)
            - Sound Solution (dsp_ss.dll - needs the ssN.dat files in your startup directory)
            - VST PlugIn Wrapper (dsp_vst.dll)
            - EQ by Nevi (dsp_eqfir.dll)
            </code>
            </para>
            <para>These plugins for example will only work, if you implement an intermediate ring-buffer between BASS and BASS_WADSP by yourself:
            <code>
            - Reverb3 (dsp_reverb3.dll - working with fixed Packets of 1152 samples only)
            - TomSteady (dsp_tom.dll - working with fixed Packets of 1152 samples only)
            - PaceMaker (dsp_pacemaker.dll)
            </code>
            </para>
            <para>Any window that remains in foreground should optimally pass unusedkeystrokes to the parent (winamp's) window, so that the user can still control it. 
            As for storing configuration, configuration data should be stored in [startup path]\plugin.ini.</para>
            <para>To use the BASS_WADSP add-on you need to perform the following steps:
            <list type="table">
            <item><term>1.</term><description>Call <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Init(System.IntPtr)"/> at the beginning of your application after you have initialized Bass with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.</description></item>
            <item><term>2.</term><description>Call <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/> - to load a Winamp DSP plugin.</description></item>
            <item><term>3.</term><description>Call <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Start(System.Int32,System.Int32,System.Int32)"/> - to start the loaded Winamp DSP plugin.</description></item>
            <item><term>4.</term><description>Create a Bass stream...e.g. with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>5.</term><description>Call <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ChannelSetDSP(System.Int32,System.Int32,System.Int32)"/> - to set the Winamp DSP to the created stream. This assigns a normal Bass DSP (like you would do with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/>) but now uses the Winamp DSP internally.
            <para>You might even assign multiple Winamp DSPs to the same stream. In this case the DSPs are just executed in the order to their priority - like in Bass.</para></description></item>
            <item><term>6.</term><description>Play the channel like normal...and at the end call <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ChannelRemoveDSP(System.Int32)"/> (if BASS_STREAM_AUTOFREE was specified at stream creation or if you call <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/> this will be done automatically and removing the DSP(s) is not even needed).</description></item>
            <item><term>7.</term><description>You might repeat with 4.</description></item>
            <item><term>8.</term><description>When a Winamp DSP is not needed anymore, call <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Stop(System.Int32)"/> - to stop the Winamp DSP plugin and call <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Start(System.Int32,System.Int32,System.Int32)"/> to start it again.
            <para>If you don't want the DSP anymore at all, you might also need to call <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ChannelRemoveDSP(System.Int32)"/> in addition, if you have assigned multiple DSPs to the stream in parallel.</para></description></item>
            <item><term>9.</term><description>Call <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_FreeDSP(System.Int32)"/> - to unload a Winamp DSP plugin and free all resources (this also stops the DSP and removes it out of memory).</description></item>
            <item><term>10.</term><description>At the end of your application make sure to call <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Free"/> - to free all resources.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASSWADSPVERSION">
            <summary>
            Current BASS_WADSP version (without minor revision).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetVersion">
            <summary>
            Retrieves the version number of the BASS_WADSP.DLL that is loaded.
            </summary>
            <returns>The BASS_WADSP version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASS_WADSP supports all the BASS_WADSP functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASSWADSPVERSION"/> to check the major revision.</para>
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(BassWaDsp.BASS_WADSP_GetVersion()) != BassWaDsp.BASSWADSPVERSION )
            {
              MessageBox.Show(this, "Wrong BassWaDsp Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(BassWaDsp.BASS_WADSP_GetVersion()) &lt;&gt; BassWaDsp.BASSWADSPVERSION Then
              MessageBox.Show(Me, "Wrong BassWaDsp Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (BassWaDsp.BASS_WADSP_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong BassWaDsp Version!");
            }
            </code>
            <code lang="vbnet">
            If BassWaDsp.BASS_WADSP_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong BassWaDsp Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASS_WADSP.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASS_FX version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASS_WADSP supports all the BASS_WADSP functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (BassWaDsp.BASS_WADSP_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong BassWaDsp Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If BassWaDsp.BASS_WADSP_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong BassWaDsp Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Init(System.IntPtr)">
            <summary>
            Initializes BASS_WADSP, call this right after you have called <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>.
            </summary>
            <param name="win">The main window handle of your application (e.g. <c>this.Handle</c>) - or IntPtr.Zero for console applications.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Free">
            <summary>
            Frees all resources of BASS_WADSP - call this method at the and of your application.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_FreeDSP(System.Int32)">
            <summary>
            Frees and unloads a Winamp DSP library from memory which has been loaded with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/> before.
            </summary>
            <param name="plugin">The plugin handle to unload (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <remarks>The Winamp DSP will automatically be stopped, if it was started before.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetFakeWinampWnd(System.Int32)">
            <summary>
            Gets the window handle of the fake Winamp window which has been created internally when a Winamp DSP was loaded with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>.
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <returns>An IntPtr representing the window handle of the fake Winamp window or IntPtr.Zero if an error occured.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_SetSongTitle(System.Int32,System.String)">
            <summary>
            Set the song title for a loaded Winamp DSP plugin.
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="title">The song title to set.</param>
            <remarks>Some Winamp DSPs require or simply display a current song title. Use this method to set this song title. It will then be used in the internal Window message handler for the related fake Winamp window.
            In most cases it is not required to set any song title at all - however streaming DSP might use this for updating it's metadata.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_SetFileName(System.Int32,System.String)">
            <summary>
            Set the file name for a loaded Winamp DSP plugin.
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="file">The file name to set.</param>
            <remarks>Some Winamp DSPs require or simply display a current playing file name. Use this method to set this file name. It will then be used in the internal Window message handler for the related fake Winamp windows.
            In most cases it is not required to set any file name at all.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)">
            <summary>
            Loads a Winamp DSP library.
            </summary>
            <param name="dspfile">The fully qualified path and name of the Winamp DSP library you want to load (e.g. "C:\\Program Files\\Winamp\\Plugins\\dsp_ss.dll").
            Both Unicode as well as Ansi filenames are supported, whereas Unicode is tried first.</param>
            <param name="x">The X-coordinate of the fake Winamp window to create.</param>
            <param name="y">The Y-coordinate of the fake Winamp window to create.</param>
            <param name="width">The width of the fake Winamp window to create.</param>
            <param name="height">The height of the fake Winamp window to create.</param>
            <param name="proc">An optional <see cref="T:Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC"/> which should be used instead of the internal window process message handler. Or NULL, if you want BASS_WADSP to handle it by default.</param>
            <returns>The handle of the loaded plugin, which is needed in all further method calls.</returns>
            <remarks>Most Winamp DSP plugins do save their location and visibility state in an own .ini file. So the parameters specifying the location and size are in most cases only uses for the first time a plugin is used. So don't worry, if they do not take effect.
            <para>In most cases the internal Windows message process handler should be fine and sufficient - however, if you encounter problems you might implement your own.</para>
            <para>Make sure to call <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_FreeDSP(System.Int32)"/> when the Winamp DSP is not needed anymore and should be unloaded and removed from memory.</para>
            <para>Winamp DSPs are designed to run only for one stream. So if you have multiple streams or multiple players in your application and you want to use the same Winamp DSP you need to create temporary copies of the library files (e.g. copy "dsp_ss.dll" to "dsp_ss2.dll", "dsp_ss3.dll" etc.).
            Then you should load each individual library copy with this function. This will enable you to load multiple instances of the same Winamp DSP. Each loaded instance can then be used for individual streams.</para>
            </remarks>
            <example>
            <code>
            int dspPluginA = BassWaDsp.BASS_WADSP_Load("dsp_test.dll", 5, 5, 100, 100, null);
            if (dspPluginA != 0)
            {
              BassWaDsp.BASS_WADSP_Start(dspPluginA, 0, 0);
            }
            </code>
            <code lang="vbnet">
            Dim dspPluginA As Integer = BassWaDsp.BASS_WADSP_Load("dsp_test.dll", 5, 5, 100, 100, Nothing)
            If dspPluginA &lt;&gt; 0 Then
              BassWaDsp.BASS_WADSP_Start(dspPluginA, 0, 0)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Config(System.Int32,System.Int32)">
            <summary>
            Invokes the config dialog of a loaded Winamp DSP.
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="module">The module number to use.</param>
            <remarks>Winamp DSPs might provide multiple independent modules. You might get the number of available modules with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetModule(System.Int32)"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Start(System.Int32,System.Int32,System.Int32)">
            <summary>
            Starts a Winamp DSP.
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="module">The module number to start (the first module is 0).</param>
            <param name="handle">The BASS channel handle (HSTREAM, HMUSIC, or HRECORD) for which to start the Winamp DSP. Or 0 if not applicable.</param>
            <remarks>Winamp DSPs might provide multiple independent modules. You might get the number of available modules with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetModuleCount(System.Int32)"/> or the name of a certain module with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetModule(System.Int32)"/>. 
            However, you can only start one module at a time for a certain Winamp DSP.
            The stream channel is only needed here because some Winamp DSPs might already request some information, which can be provided in this case. However, if you don't have created a stream so far, just leave the value to 0 and all is fine.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Stop(System.Int32)">
            <summary>
            Stops a Winamp DSP.
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <remarks>If the Winamp DSP was already assigned to a channel using <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ChannelSetDSP(System.Int32,System.Int32,System.Int32)"/> the DSP will be removed automatically from the channel when it is stopped.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_SetChannel(System.Int32,System.Int32)">
            <summary>
            Assigns a channel to a Winamp DSP.
            <para>You only need this method, if you do NOT use the default <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ChannelSetDSP(System.Int32,System.Int32,System.Int32)"/> method, but use your own DSP callback (see <see cref="T:Un4seen.Bass.DSPPROC"/>).</para>
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="handle">The BASS channel handle (HSTREAM, HMUSIC, or HRECORD) which to assign to the Winamp DSP.</param>
            <remarks>You must use this method when implementing your own <see cref="T:Un4seen.Bass.DSPPROC"/> callback before starting to play the channel.</remarks>
            <example>
            <code>
            private int _streamA = 0;
            private int _dspPluginA = 0;
            private DSPPROC _myDSPAddr;
            ...
            _dspPluginA = BassWaDsp.BASS_WADSP_Load("dsp_test.dll", 5, 5, 100, 100, null);
            BassWaDsp.BASS_WADSP_Start(_dspPluginA, 0, 0);
            ...
            _streamA = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                            BASSFlag.BASS_DEFAULT | BASSFlag.BASS_STREAM_AUTOFREE);
            // play the stream
            if (_streamA != 0 )
            {
              _myDSPAddr = new DSPPROC(MyWinampDSP);
              Bass.BASS_ChannelSetDSP(_streamA, _myDSPAddr, new IntPtr(_dspPluginA), -500);
              BassWaDsp.BASS_WADSP_SetChannel(_dspPluginA, _streamA);
              Bass.BASS_ChannelPlay(_streamA, false);
            }
            ...
            private void MyWinampDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              if (length == 0 || buffer == IntPtr.Zero)
                return;
              BassWaDsp.BASS_WADSP_ModifySamplesDSP(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _streamA As Integer = 0
            Private _dspPluginA As Integer = 0
            Private _myDSPAddr As DSPPROC
            ...
            _dspPluginA = BassWaDsp.BASS_WADSP_Load("dsp_test.dll", 5, 5, 100, 100, Nothing)
            BassWaDsp.BASS_WADSP_Start(_dspPluginA, 0, 0)
            ...
            _streamA = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                            BASSFlag.BASS_DEFAULT Or BASSFlag.BASS_STREAM_AUTOFREE)
            ' play the stream
            If _streamA &lt;&gt; 0 Then
              _myDSPAddr = New DSPPROC(AddressOf MyWinampDSP)
              Bass.BASS_ChannelSetDSP(_streamA, _myDSPAddr, New IntPtr(_dspPluginA), - 500)
              BassWaDsp.BASS_WADSP_SetChannel(_dspPluginA, _streamA)
              Bass.BASS_ChannelPlay(_streamA, False)
            End If
            ...
            Private Sub MyWinampDSP(handle As Integer, channel As Integer, 
                                    buffer As IntPtr, length As Integer, user As IntPtr)
              If length = 0 OrElse buffer = IntPtr.Zero Then
                Return
              End If
              BassWaDsp.BASS_WADSP_ModifySamplesDSP(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetModule(System.Int32)">
            <summary>
            Returns the currently selected plugin module of a Winamp DSP.
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <returns>The selected module number (first = 0), or -1, if an error occured.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ChannelSetDSP(System.Int32,System.Int32,System.Int32)">
            <summary>
            Assigns a loaded Winamp DSP to a standard BASS channel as a new DSP.
            <para>This method is pretty close to the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/> method (which is in fact internally used) but instead of setting up a user DSP method the Winamp DSP will be set up.</para>
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="handle">The BASS channel handle (HSTREAM, HMUSIC, or HRECORD) which to assign to the Winamp DSP.</param>
            <param name="priority">The priority of the new DSP, which determines it's position in the Bass DSP chain - DSPs with higher priority are called before those with lower.</param>
            <returns>If succesful, then the new DSP's handle (HDSP) is returned, else 0 is returned.</returns>
            <remarks>This method can and should only be used with those Winamp DSPs which return exactly as much samples as provided - meaning not modifying the samplerate, tempo, pitch etc.!
            <para>The Winamp DSP and this method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
            <example>
            <code>
            private int _streamA = 0;
            private int _dspPluginA = 0;
            ...
            _dspPluginA = BassWaDsp.BASS_WADSP_Load("dsp_test.dll", 5, 5, 100, 100, null);
            BassWaDsp.BASS_WADSP_Start(_dspPluginA, 0, 0);
            ...
            // create the stream
            _streamA = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                            BASSFlag.BASS_DEFAULT | BASSFlag.BASS_STREAM_AUTOFREE);
            // play the stream
            if (_streamA != 0 )
            {
            	// the next will setup a DSP on the playing channel to the selected Winamp DSP
            	int hDsp = BassWaDsp.BASS_WADSP_ChannelSetDSP(this._dspPluginA, _streamA, 1);
            	// and finally play it
            	Bass.BASS_ChannelPlay(_streamA, false);
            }
            </code>
            <code lang="vbnet">
            Private _streamA As Integer = 0
            Private _dspPluginA As Integer = 0
            ...
            _dspPluginA = BassWaDsp.BASS_WADSP_Load("dsp_test.dll", 5, 5, 100, 100, Nothing)
            BassWaDsp.BASS_WADSP_Start(_dspPluginA, 0, 0)
            ...
            ' create the stream
            _streamA = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                            BASSFlag.BASS_DEFAULT Or BASSFlag.BASS_STREAM_AUTOFREE)
            ' play the stream
            If _streamA &lt;&gt; 0 Then
              ' the next will setup a DSP on the playing channel to the selected Winamp DSP
              Dim hDsp As Integer = BassWaDsp.BASS_WADSP_ChannelSetDSP(Me._dspPluginA, _streamA, 1)
              ' and finally play it
              Bass.BASS_ChannelPlay(_streamA, False)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ChannelRemoveDSP(System.Int32)">
            <summary>
            Removes a Winamp DSP from the Bass DSP chain which had been set up with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ChannelSetDSP(System.Int32,System.Int32,System.Int32)"/> before.
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <returns>TRUE, if successfully removed, else FALSE.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ModifySamplesDSP(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:Un4seen.Bass.DSPPROC"/> callbacks).
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="buffer">The IntPtr to the memory block containing the sample data to modify.</param>
            <param name="length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which should always be the number of bytes specified when calling this method. Or 0, if an error occured.</returns>
            <remarks>This method can and should only be used with those Winamp DSPs which return exactly as much samples as provided - meaning not modifying the samplerate, tempo, pitch etc.!
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
            <example>
            <code>
            private int _streamA = 0;
            private int _dspPluginA = 0;
            private DSPPROC _myDSPAddr;
            ...
            _dspPluginA = BassWaDsp.BASS_WADSP_Load("dsp_test.dll", 5, 5, 100, 100, null);
            BassWaDsp.BASS_WADSP_Start(_dspPluginA, 0, 0);
            ...
            _streamA = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                            BASSFlag.BASS_DEFAULT | BASSFlag.BASS_STREAM_AUTOFREE);
            // play the stream
            if (_streamA != 0 )
            {
              _myDSPAddr = new DSPPROC(MyWinampDSP);
              Bass.BASS_ChannelSetDSP(_streamA, _myDSPAddr, new IntPtr(_dspPluginA), -500);
              BassWaDsp.BASS_WADSP_SetChannel(_dspPluginA, _streamA);
              Bass.BASS_ChannelPlay(_streamA, false);
            }
            ...
            private void MyWinampDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              if (length == 0 || buffer == IntPtr.Zero)
                return;
              BassWaDsp.BASS_WADSP_ModifySamplesDSP(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _streamA As Integer = 0
            Private _dspPluginA As Integer = 0
            Private _myDSPAddr As DSPPROC
            ...
            _dspPluginA = BassWaDsp.BASS_WADSP_Load("dsp_test.dll", 5, 5, 100, 100, Nothing)
            BassWaDsp.BASS_WADSP_Start(_dspPluginA, 0, 0)
            ...
            _streamA = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                            BASSFlag.BASS_DEFAULT Or BASSFlag.BASS_STREAM_AUTOFREE)
            ' play the stream
            If _streamA &lt;&gt; 0 Then
              _myDSPAddr = New DSPPROC(AddressOf MyWinampDSP)
              Bass.BASS_ChannelSetDSP(_streamA, _myDSPAddr, New IntPtr(_dspPluginA), - 500)
              BassWaDsp.BASS_WADSP_SetChannel(_dspPluginA, _streamA)
              Bass.BASS_ChannelPlay(_streamA, False)
            End If
            ...
            Private Sub MyWinampDSP(handle As Integer, channel As Integer, 
                                    buffer As IntPtr, length As Integer, user As IntPtr)
              If length = 0 OrElse buffer = IntPtr.Zero Then
                Return
              End If
              BassWaDsp.BASS_WADSP_ModifySamplesDSP(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ModifySamplesDSP(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:Un4seen.Bass.DSPPROC"/> callbacks).
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="buffer">The array of byte values containing the sample data to modify.</param>
            <param name="length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which should always be the number of bytes specified when calling this method. Or 0, if an error occured.</returns>
            <remarks>This method can and should only be used with those Winamp DSPs which return exactly as much samples as provided - meaning not modifying the samplerate, tempo, pitch etc.!
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ModifySamplesDSP(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:Un4seen.Bass.DSPPROC"/> callbacks).
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="buffer">The array of Int16 values containing the sample data to modify.</param>
            <param name="length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which should always be the number of bytes specified when calling this method. Or 0, if an error occured.</returns>
            <remarks>This method can and should only be used with those Winamp DSPs which return exactly as much samples as provided - meaning not modifying the samplerate, tempo, pitch etc.!
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ModifySamplesDSP(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:Un4seen.Bass.DSPPROC"/> callbacks).
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="buffer">The array of Int32 values containing the sample data to modify.</param>
            <param name="length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which should always be the number of bytes specified when calling this method. Or 0, if an error occured.</returns>
            <remarks>This method can and should only be used with those Winamp DSPs which return exactly as much samples as provided - meaning not modifying the samplerate, tempo, pitch etc.!
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ModifySamplesDSP(System.Int32,System.Single[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:Un4seen.Bass.DSPPROC"/> callbacks).
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="buffer">The array of float values containing the sample data to modify.</param>
            <param name="length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which should always be the number of bytes specified when calling this method. Or 0, if an error occured.</returns>
            <remarks>This method can and should only be used with those Winamp DSPs which return exactly as much samples as provided - meaning not modifying the samplerate, tempo, pitch etc.!
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ModifySamplesSTREAM(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:Un4seen.Bass.DSPPROC"/> callbacks or in a user defined <see cref="T:Un4seen.Bass.STREAMPROC"/>).
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="buffer">The pointer to the memory block containing the sample data to modify.</param>
            <param name="length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which might be different from the number of bytes given. 
            A Winamp DSP might return at max. twice the number of bytes but not less than half the number of bytes.</returns>
            <remarks>This method can be used to support Winamp DSPs which modify the samplerate, pitch etc. - meaning modifying the number of bytes given.
            However, this is not a simple task to do so, since Bass does not expect this. In order to handle a modified number of bytes you might need to implement a complex intermediate 'ring-buffer' in between Bass and the Winamp DSP.
            Note: Some Winamp DSPs work with a fixed number of 1152 samples only (meaning 1152 * chans * 2 bytes!) - this might also bring in some additional complexity.
            Implementing and correctly handling this intermediate 'buffer' is up to you and not handled by BASS_WADSP - however, this method is the right method to use for such a case, since it returns exactly what the Winamp DSP returned.
            <para>So make sure, that the buffer is at least twice as big as the samples it contains when you call this method, so that the Winamp DSP might have enough space to store it's returned samples into it.</para>
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ModifySamplesSTREAM(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:Un4seen.Bass.DSPPROC"/> callbacks or in a user defined <see cref="T:Un4seen.Bass.STREAMPROC"/>).
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="buffer">The array of byte values containing the sample data to modify.</param>
            <param name="length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which might be different from the number of bytes given. 
            A Winamp DSP might return at max. twice the number of bytes but not less than half the number of bytes.</returns>
            <remarks>This method can be used to support Winamp DSPs which modify the samplerate, pitch etc. - meaning modifying the number of bytes given.
            However, this is not a simple task to do so, since Bass does not expect this. In order to handle a modified number of bytes you might need to implement a complex intermediate 'ring-buffer' in between Bass and the Winamp DSP.
            Note: Some Winamp DSPs work with a fixed number of 1152 samples only (meaning 1152 * chans * 2 bytes!) - this might also bring in some additional complexity.
            Implementing and correctly handling this intermediate 'buffer' is up to you and not handled by BASS_WADSP - however, this method is the right method to use for such a case, since it returns exactly what the Winamp DSP returned.
            <para>So make sure, that the buffer is at least twice as big as the samples it contains when you call this method, so that the Winamp DSP might have enough space to store it's returned samples into it.</para>
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ModifySamplesSTREAM(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:Un4seen.Bass.DSPPROC"/> callbacks or in a user defined <see cref="T:Un4seen.Bass.STREAMPROC"/>).
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="buffer">The array of Int16 values containing the sample data to modify.</param>
            <param name="length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which might be different from the number of bytes given. 
            A Winamp DSP might return at max. twice the number of bytes but not less than half the number of bytes.</returns>
            <remarks>This method can be used to support Winamp DSPs which modify the samplerate, pitch etc. - meaning modifying the number of bytes given.
            However, this is not a simple task to do so, since Bass does not expect this. In order to handle a modified number of bytes you might need to implement a complex intermediate 'ring-buffer' in between Bass and the Winamp DSP.
            Note: Some Winamp DSPs work with a fixed number of 1152 samples only (meaning 1152 * chans * 2 bytes!) - this might also bring in some additional complexity.
            Implementing and correctly handling this intermediate 'buffer' is up to you and not handled by BASS_WADSP - however, this method is the right method to use for such a case, since it returns exactly what the Winamp DSP returned.
            <para>So make sure, that the buffer is at least twice as big as the samples it contains when you call this method, so that the Winamp DSP might have enough space to store it's returned samples into it.</para>
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ModifySamplesSTREAM(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:Un4seen.Bass.DSPPROC"/> callbacks or in a user defined <see cref="T:Un4seen.Bass.STREAMPROC"/>).
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="buffer">The array of Int32 values containing the sample data to modify.</param>
            <param name="length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which might be different from the number of bytes given. 
            A Winamp DSP might return at max. twice the number of bytes but not less than half the number of bytes.</returns>
            <remarks>This method can be used to support Winamp DSPs which modify the samplerate, pitch etc. - meaning modifying the number of bytes given.
            However, this is not a simple task to do so, since Bass does not expect this. In order to handle a modified number of bytes you might need to implement a complex intermediate 'ring-buffer' in between Bass and the Winamp DSP.
            Note: Some Winamp DSPs work with a fixed number of 1152 samples only (meaning 1152 * chans * 2 bytes!) - this might also bring in some additional complexity.
            Implementing and correctly handling this intermediate 'buffer' is up to you and not handled by BASS_WADSP - however, this method is the right method to use for such a case, since it returns exactly what the Winamp DSP returned.
            <para>So make sure, that the buffer is at least twice as big as the samples it contains when you call this method, so that the Winamp DSP might have enough space to store it's returned samples into it.</para>
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_ModifySamplesSTREAM(System.Int32,System.Single[],System.Int32)">
            <summary>
            Invokes the internal 'ModifySamples' method of the Winamp DSP directly (which is only needed for user defined <see cref="T:Un4seen.Bass.DSPPROC"/> callbacks or in a user defined <see cref="T:Un4seen.Bass.STREAMPROC"/>).
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="buffer">The array of float values containing the sample data to modify.</param>
            <param name="length">The number of bytes contained in the buffer.</param>
            <returns>The number of bytes modified, which might be different from the number of bytes given. 
            A Winamp DSP might return at max. twice the number of bytes but not less than half the number of bytes.</returns>
            <remarks>This method can be used to support Winamp DSPs which modify the samplerate, pitch etc. - meaning modifying the number of bytes given.
            However, this is not a simple task to do so, since Bass does not expect this. In order to handle a modified number of bytes you might need to implement a complex intermediate 'ring-buffer' in between Bass and the Winamp DSP.
            Note: Some Winamp DSPs work with a fixed number of 1152 samples only (meaning 1152 * chans * 2 bytes!) - this might also bring in some additional complexity.
            Implementing and correctly handling this intermediate 'buffer' is up to you and not handled by BASS_WADSP - however, this method is the right method to use for such a case, since it returns exactly what the Winamp DSP returned.
            <para>So make sure, that the buffer is at least twice as big as the samples it contains when you call this method, so that the Winamp DSP might have enough space to store it's returned samples into it.</para>
            <para>This method can be used with 8-bit, 16-bit or float channels. Since all Winamp DSPs will internally only work with 16-bit channels an automatic internal conversion from 8-bit resp. float to 16-bit and back will take place.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetNamePtr(System.Int32)">
            <summary>
            
            </summary>
            <param name="plugin"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetName(System.Int32)">
            <summary>
            Returns the name of the loaded Winamp DSP plugin.
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <returns>The name of the plugin on success or NULL on error.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetModuleCount(System.Int32)">
            <summary>
            Returns the number of modules contained in the loaded Winamp DSP.
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <returns>The number of available modules or -1 if an error occured.</returns>
            <remarks>Winamp DSPs might implement multiple different modules within the same DSP plugin.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetModuleNamePtr(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="plugin"></param>
            <param name="module"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetModuleName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a certain module of a loaded Winamp DSP.
            </summary>
            <param name="plugin">The plugin handle (returned by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).</param>
            <param name="module">The module number to get the name from (the first module is 0).</param>
            <returns>The name of the module on success or NULL on error (or if no module with that number exists).</returns>
            <remarks>Winamp DSPs might provide multiple independent modules. You might get the number of available modules with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_GetModuleCount(System.Int32)"/>.
            However, you can only start one module at a time for a certain Winamp DSP.
            <para>You can use this method in a setup dialog to list all the available modules of a Winamp DSP.</para>
            </remarks>
            <example>
            <code>
            string name;
            for (int n=0; (name = BassWaDsp.BASS_WADSP_GetModuleName(n)) != null; n++)
            {
              Console.WriteLine(name);
            }
            </code>
            <code lang="vbnet">
            Dim n As Integer = 0
            Dim name As String = ""
            While Not (name Is Nothing)
              name = BassWaDsp.BASS_WADSP_GetModuleName(n)
              n += 1
              If Not (name Is Nothing) Then
                Console.WriteLine(name)
              End If
            End While
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_PluginInfoFree">
            <summary>
            Free the temporary plugin info resources.
            </summary>
            <remarks>Should and must be called after <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_PluginInfoLoad(System.String)"/> when the plugin info is not needed.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_PluginInfoLoad(System.String)">
            <summary>
            Loads a Winamp DSP library into the temporary plugin info workspace.
            </summary>
            <param name="dspfile">The fully qualified path and name of the Winamp DSP library you want to load (e.g. "C:\\Program Files\\Winamp\\Plugins\\dsp_ss.dll").
            Both Unicode as well as Ansi filenames are supported, whereas Unicode is tried first.</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>The temporary plugin info workspace can be used to retrieve general information about a Winamp DSP without starting it.
            <para>This method will be used in the same way <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/> is used.</para>
            <para>The BASS.NET API offers an additional helper class <see cref="T:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP"/> to be used with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_FindPlugins(System.String)"/> which internally uses the temporary plugin info workspace and makes it obsolete to use these methods directly.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_PluginInfoGetNamePtr">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_PluginInfoGetName">
            <summary>
            Returns the name of the Winamp DSP plugin which has been loaded into the temporary plugin info workspace.
            </summary>
            <returns>The name of the plugin on success or NULL on error.</returns>
            <remarks>The BASS.NET API offers an additional helper class <see cref="T:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP"/> to be used with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_FindPlugins(System.String)"/> which internally uses the temporary plugin info workspace and makes it obsolete to use these methods directly.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_PluginInfoGetModuleCount">
            <summary>
            Returns the number of modules contained in the Winamp DSP which has been loaded into the temporary plugin info workspace.
            </summary>
            <returns>The number of available modules or -1 if an error occured.</returns>
            <remarks>Winamp DSPs might implement multiple different modules within the same DSP plugin.
            <para>The BASS.NET API offers an additional helper class <see cref="T:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP"/> to be used with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_FindPlugins(System.String)"/> which internally uses the temporary plugin info workspace and makes it obsolete to use these methods directly.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_PluginInfoGetModuleNamePtr(System.Int32)">
            <summary>
            
            </summary>
            <param name="module"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_PluginInfoGetModuleName(System.Int32)">
            <summary>
            Returns the name of a certain module of a Winamp DSP which has been loaded into the temporary plugin info workspace.
            </summary>
            <param name="module">The module number to get the name from (the first module is 0).</param>
            <returns>The name of the module on success or NULL on error (or if no module with that number exists).</returns>
            <remarks>Winamp DSPs might provide multiple independent modules. You might get the number of available modules with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_PluginInfoGetModuleCount"/>.
            <para>You can use this method in a setup dialog to list all the available modules of a Winamp DSP.</para>
            <para>The BASS.NET API offers an additional helper class <see cref="T:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP"/> to be used with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_FindPlugins(System.String)"/> which internally uses the temporary plugin info workspace and makes it obsolete to use these methods directly.</para>
            </remarks>
            <example>
            <code>
            string name;
            for (int n=0; (name = BassWaDsp.BASS_WADSP_PluginInfoGetModuleName(n)) != null; n++)
            {
              Console.WriteLine(name);
            }
            </code>
            <code lang="vbnet">
            Dim n As Integer = 0
            Dim name As String = ""
            While Not (name Is Nothing)
              name = BassWaDsp.BASS_WADSP_PluginInfoGetModuleName(n)
              n += 1
              If Not (name Is Nothing) Then
                Console.WriteLine(name)
              End If
            End While
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_PluginInfoGetModuleNames">
            <summary>
            Returns an array of strings containing all module names of a Winamp DSP which has been loaded into the temporary plugin info workspace.
            </summary>
            <returns>All names of all modules contained in the Winamp DSP.</returns>
            <remarks>You can use this method in a setup dialog to list all the available modules of a Winamp DSP.
            <para>The BASS.NET API offers an additional helper class <see cref="T:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP"/> to be used with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_FindPlugins(System.String)"/> which internally uses the temporary plugin info workspace and makes it obsolete to use these methods directly.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_FindPlugins(System.String)">
            <summary>
            Finds all Winamp DSP plugins contained in a given directory and stores all related information in a <see cref="T:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP"/> array.
            </summary>
            <param name="path">The directory in which to search for Winamp DSP plugins.</param>
            <returns>An array of <see cref="T:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP"/> instances where each element represents a found Winamp DSP.</returns>
            <example>
            <code>
            WINAMP_DSP[] dsps = BassWaDsp.BASS_WADSP_FindPlugins( "C:\\Program Files\\Winamp\\Plugins" );
            this.listBox1.Items.AddRange( dsps );
            ...
            // and display all modules out of a certain dsp...
            WINAMP_DSP dsp = (WINAMP_DSP)this.listBox1.SelectedItem;
            if (dsp.modulecount &gt; 0)
            {
              // display all modules
              this.comboBox1.Items.Clear();
              this.comboBox1.Items.AddRange( dsp.modulenames );
              this.comboBox1.SelectedIndex = 0;
            }
            </code>
            <code lang="vbnet">
            Dim dsps As WINAMP_DSP() = BassWaDsp.BASS_WADSP_FindPlugins("C:\Program Files\Winamp\Plugins")
            Me.listBox1.Items.AddRange(dsps)
            ...
            ' and display all modules out of a certain dsp...
            Dim dsp As WINAMP_DSP = CType(Me.listBox1.SelectedItem, WINAMP_DSP)
            If dsp.modulecount &gt; 0 Then
              ' display all modules
              Me.comboBox1.Items.Clear()
              Me.comboBox1.Items.AddRange(dsp.modulenames)
              Me.comboBox1.SelectedIndex = 0
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc">
            <summary>
            Communication to Winamp is done via the classic Win32 Message API. Most DSP plugins use this to ask for certain values.
            These definitions are the most commonly used messages, which might be handled by the fake winamp window which we create.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc.BASS_WADSP_IPC_GETOUTPUTTIME">
            <summary>
            IPC_GETOUTPUTTIME returns the position in milliseconds of the current song (mode = 0), 
            or the song length, in seconds (mode = 1).Returns -1 if not playing or error.
            <para>int res = SendMessage(hwnd_winamp,WM_WA_IPC,mode,IPC_GETOUTPUTTIME);</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc.BASS_WADSP_IPC_ISPLAYING">
            <summary>
            IPC_ISPLAYING returns the status of playback.
            If it returns 1, it is playing. if it returns 3, it is paused, if it returns 0, it is not playing.
            <para>int res = SendMessage(hwnd_winamp,WM_WA_IPC,0,IPC_ISPLAYING);</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc.BASS_WADSP_IPC_GETVERSION">
            <summary>
            Version will be 0x20yx for winamp 2.yx. 
            Versions previous to Winamp 2.0 typically use 0x1zyx for 1.zx versions. Weird, I know.
            <para>int version = SendMessage(hwnd_winamp,WM_WA_IPC,0,IPC_GETVERSION);</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc.BASS_WADSP_IPC_STARTPLAY">
            <summary>
            Using IPC_STARTPLAY is like hitting 'Play' in Winamp, mostly.
            <para>SendMessage(hwnd_winamp,WM_WA_IPC,0,IPC_STARTPLAY);</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc.BASS_WADSP_IPC_GETINFO">
            <summary>
            IPC_GETINFO returns info about the current playing song. The value it returns depends on the value of 'mode' (wParam):
            <list type="table">
            <listheader><term>Mode</term><description>Meaning</description></listheader>
            <item><term>0</term><description>Samplerate (i.e. 44100)</description></item>
            <item><term>1</term><description>Bitrate  (i.e. 128)</description></item>
            <item><term>2</term><description>Channels (i.e. 2)</description></item>
            </list>
            <para>int inf=SendMessage(hwnd_winamp,WM_WA_IPC,mode,IPC_GETINFO);</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc.BASS_WADSP_IPC_GETLISTLENGTH">
            <summary>
            IPC_GETLISTLENGTH returns the length of the current playlist, in tracks.
            <para>int length = SendMessage(hwnd_winamp,WM_WA_IPC,0,IPC_GETLISTLENGTH);</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc.BASS_WADSP_IPC_GETLISTPOS">
            <summary>
            IPC_GETLISTPOS returns the playlist position [index].
            <para>int pos=SendMessage(hwnd_winamp,WM_WA_IPC,0,IPC_GETLISTPOS);</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc.BASS_WADSP_IPC_GETPLAYLISTFILE">
            <summary>
            IPC_GETPLAYLISTFILE gets the filename of the playlist entry [index]. Returns a pointer to it. Returns NULL on error.
            <para>char *name=SendMessage(hwnd_winamp,WM_WA_IPC,index,IPC_GETPLAYLISTFILE);</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc.BASS_WADSP_IPC_GETPLAYLISTTITLE">
            <summary>
            IPC_GETPLAYLISTTITLE gets the title of the playlist entry [index]. Returns a pointer to it. Returns NULL on error.
            <para>char *name=SendMessage(hwnd_winamp,WM_WA_IPC,index,IPC_GETPLAYLISTTITLE);</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc.BASS_WADSP_IPC">
            <summary>
            Is defined as Win32's WM_USER an. When a message of this value arrives, we know, that we might handle it by ourself.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP">
            <summary>
            General helper class to retrieve information about a Winamp DSP. To be used by <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_FindPlugins(System.String)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.file">
            <summary>
            The fully qualified path and name of the Winamp DSP file.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.description">
            <summary>
            The description of the Winamp DSP.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.modulecount">
            <summary>
            Number of Modules contained in this Winamp DSP.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.modulenames">
            <summary>
            Array of Module names.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.iswinampdsp">
            <summary>
            TRUE, if this file is a Winamp DSP plugin.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.#ctor(System.String)">
            <summary>
            Default constructor initialising and retrieving information about a Winamp DSP.
            </summary>
            <param name="FileName">The path and name of the file to be constructed.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.Load">
            <summary>
            Loads the Winamp DSP plugin.
            </summary>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>Make sure to call <see cref="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.Unload"/> when you don't need it anymore in order to unload and free the plugin.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.Unload">
            <summary>
            Unloads the Winamp DSP plugin.
            </summary>
            <remarks>This must be called once you are done with the DSP to free all resources.
            If the DSP is already started it will also be stopped.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.Start(System.Int32,System.Int32,System.Int32)">
            <summary>
            Starts a certain module of a Wianmp DSP plugin and assignes it to a channel as a new DSP.
            </summary>
            <param name="module">The module index to start (must be between 0 and <see cref="F:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.modulecount"/>).</param>
            <param name="channel">The BASS stream channel handle to assign it to.</param>
            <param name="prio">The DSP priority to use when assigning the DSP.</param>
            <returns>The DSP handle on success - else 0 is returned.</returns>
            <remarks>The Winamp DSP must have been loaded with <see cref="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.Load"/> before you can use this method!
            Call <see cref="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.Stop"/> if you don't need this module anymore and to remove the DSP from the channel.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.Stop">
            <summary>
            Stops the currently started Winamp DSP plugin module.
            </summary>
            <remarks>Make sure to call this method once you <see cref="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.Start(System.Int32,System.Int32,System.Int32)"/>ed it.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.SetSongTitle(System.String)">
            <summary>
            Sets a global song title for the loaded and started Winamp DSP.
            </summary>
            <param name="title">The song title to set.</param>
            <remarks>
            Some Winamp DSPs require or simply display a current song title. Use this method to set this song title. 
            It will then be used in the internal Window message handler for all fake Winamp windows.
            In most cases it is not required to set any song title at all.
            For streaming DSPs (e.g. SHOUTcast Source DSP) use this function to set the title metadata.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.SetFilename(System.String)">
            <summary>
            Sets a global song title for the loaded and started Winamp DSP.
            </summary>
            <param name="filename">The song title to set.</param>
            <remarks>
            Some Winamp DSPs require or simply display a current playing file name. Use this method to set this file name. 
            It will then be used in the internal Window message handler for all fake Winamp windows.
            In most cases it is not required to set any file name at all.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.ShowEditor">
            <summary>
            Shows the Winamp DSP config dialog.
            </summary>
            <remarks>The Winamp DSP must have been loaded and started.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.ToString">
            <summary>
            A description of the Winamp DSP info object (description - filename).
            </summary>
            <returns></returns>
        </member>
        <member name="P:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.IsLoaded">
            <summary>
            Is the Winamp DSP plugin already loaded?
            </summary>
        </member>
        <member name="P:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.IsStarted">
            <summary>
            Is the Winamp DSP plugin already started and assigned to a channel?
            </summary>
        </member>
        <member name="P:Un4seen.Bass.AddOn.WaDsp.WINAMP_DSP.StartedModule">
            <summary>
            Returns the currently selected and started module index - or -1 if no module is started.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC">
            <summary>
            User defined Window Message Process Handler (to be used with <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/>).
            <para>Normally this is not needed, since BASS_WADSP implements a default handler which emulates most functions needed by Winamp DSPs.
            However, some very special Winamp DSPs might require something special. So you might implement your own windows message handler here.</para>
            </summary>
            <param name="hwnd">The Window handle we are dealing with - which is the hidden fake window which BASS_WADSP has created during <see cref="M:Un4seen.Bass.AddOn.WaDsp.BassWaDsp.BASS_WADSP_Load(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.WaDsp.WINAMPWINPROC)"/> and which emulates a Winamp 1.x class.</param>
            <param name="msg">The window message send. You typically might only react on WM_USER messages (also defined as <see cref="F:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc.BASS_WADSP_IPC"/>).</param>
            <param name="wParam">The wParam message parameter see the Winamp SDK for further details.</param>
            <param name="lParam">The lParam message parameter see the Winamp SDK for further details.</param>
            <returns>See the Winamp SDK documentation for information.</returns>
            <remarks>
            <para>The <see cref="T:Un4seen.Bass.AddOn.WaDsp.BASSWADSPIpc"/> enumeration defines all lParam values which you should typically handle. See the Winamp SDK for further details.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.WaveForm">
            <summary>
            Provides general methods to generate a stereo or mono channel waveform graphic for an audio file or a decoding stream handle.
            <para>The WaveForm will be drawn as two independent stereo envelopes, a combined dual mono envelope or a mono envelope.</para>
            <para>Requires: bass.dll - available @ www.un4seen.com</para>
            </summary>
            <remarks>
            <para>The WaveForm class is an internal implementation of the BASS.NET API and does not require any additional extension or add-on to the BASS audio library, meaning only bass.dll is required.</para>
            <para>However, <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> must have been called before using any method within this class!</para>
            <para>NOTE: When using the WaveForm class with an already existing decoding channel (created with the BASS_STREAM_DECODE flag) the data will be retrieved from that channel, meaning the data will be 'stolen'.
            In such a case you must reset the position to the beginning of the stream afterwards, e.g. use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> before rendering the WaveForm and call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> when rendering of the WaveForm has been completed.</para>
            <para>The typical use of this class is as followed:</para>
            <para>a) create an instance of this class (e.g. together with the filename)</para>
            <para>b) call <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/> to scan all peak levels</para>
            <para>c) call <see cref="M:Un4seen.Bass.Misc.WaveForm.CreateBitmap(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)"/> to generate a wave form image</para>
            <para>You might also use <see cref="M:Un4seen.Bass.Misc.WaveForm.WaveFormSaveToFile(System.String)"/> and <see cref="M:Un4seen.Bass.Misc.WaveForm.WaveFormLoadFromFile(System.String)"/> to save or load a rendered wave form.</para>
            <para>The methods <see cref="M:Un4seen.Bass.Misc.WaveForm.AddMarker(System.String,System.Int64)"/> and <see cref="M:Un4seen.Bass.Misc.WaveForm.RemoveMarker(System.String)"/> lets you manage named position markers within the WaveForm to be displayed, use the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawMarker"/> property to specify how and if markers should be displayed.</para>
            <para>When the image of the rendered wave form or a zoomed window of it is created via <see cref="M:Un4seen.Bass.Misc.WaveForm.CreateBitmap(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)"/> the global properties <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorBackground"/>, <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorRight"/> and <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorLeft"/> as well as <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorMarker"/>are used.</para>
            <para>You might also access the scanned peak levels directly via the <see cref="P:Un4seen.Bass.Misc.WaveForm.Wave"/> property.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.#ctor">
            <summary>
            Default constructor creating a new instance of the WaveForm class.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.#ctor(System.String)">
            <summary>
            Creates a new instance of the WaveForm class, initializing the file name.
            </summary>
            <param name="fileName">The file name to render.</param>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.#ctor(System.String,Un4seen.Bass.Misc.WAVEFORMPROC,System.Windows.Forms.Control)">
            <summary>
            Creates a new instance of the WaveForm class, initializing the file name and a notification handler.
            </summary>
            <param name="fileName">The file name to render.</param>
            <param name="proc">A <see cref="T:Un4seen.Bass.Misc.WAVEFORMPROC"/> callback delegate to be invoked during the rendering progress.</param>
            <param name="win">An optional window control which will be used to invoke the <see cref="T:Un4seen.Bass.Misc.WAVEFORMPROC"/> (if set), so that the callback will be executed in the 'correct' GUI thread.</param>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.Reset">
            <summary>
            Resets the wave form.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)">
            <summary>
            Start the rendering process for the specified decoding stream (peak levels will be scanned).
            </summary>
            <param name="decodingStream">A prepared decoding channel to use for rendering.</param>
            <param name="background">TRUE, if rendering should be performed in an independent background thread. FALSE, if rendering should be executed synchronious.</param>
            <returns>TRUE, if rendering was started successfully, else FALSE.</returns>
            <remarks>This overload uses the specified decoding channel. It's position will be set to 0 first. The channel can not and should not be used by your application in the meantime until rendering has been finished!
            <para>The decoding channel will be freed automatically by this method after rendering has been finished!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean,System.Threading.ThreadPriority)">
            <summary>
            Start the rendering process for the specified decoding stream (peak levels will be scanned).
            </summary>
            <param name="decodingStream">A prepared decoding channel to use for rendering.</param>
            <param name="background">TRUE, if rendering should be performed in an independent background thread. FALSE, if rendering should be executed synchronious.</param>
            <param name="prio">The thread priority to be used with the background thread (default is BelowNormal).</param>
            <returns>TRUE, if rendering was started successfully, else FALSE.</returns>
            <remarks>This overload uses the specified decoding channel. It's position will be set to 0 first. The channel can not and should not be used by your application in the meantime until rendering has been finished!
            <para>The decoding channel will be freed automatically by this method after rendering has been finished!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Boolean,Un4seen.Bass.BASSFlag)">
            <summary>
            Start the rendering process for the <see cref="P:Un4seen.Bass.Misc.WaveForm.FileName"/> given (peak levels will be scanned).
            </summary>
            <param name="background">TRUE, if rendering should be performed in an independent background thread. FALSE, if rendering should be executed synchronious.</param>
            <param name="flags">A combination of the <see cref="T:Un4seen.Bass.BASSFlag"/> flags on how to create the decoding stream. The <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_DECODE"/> and <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_PRESCAN"/> flags will be added automatically here, if not already set!</param>
            <returns>TRUE, if rendering was started successfully, else FALSE.</returns>
            <remarks>This overload creates an internal decoding channel allowing to render the peak levels independently.
            <para>If you intend to use this overload to render the wave form in parallel while already playing out the file, it is recommended to specify the same flags as for your playing stream.
            This is because <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelBytes2Seconds(System.Int32,System.Int64)"/> etc. would return different values if you specified different resolutions for your playing stream and your rendering stream (eg. a stream with BASS_SAMPLE_FLOAT would return twice as much bytes as a stream created with the default 16-bit resolution).</para>
            <para>If your playing stream and this call uses different flags, you might use the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method, so that the members <see cref="M:Un4seen.Bass.Misc.WaveForm.Position2Frames(System.Int64)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.Frame2Bytes(System.Int32)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.GetBytePositionFromX(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            will return converted values according to your playing stream.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Boolean,System.Threading.ThreadPriority,Un4seen.Bass.BASSFlag)">
            <summary>
            Start the rendering process for the <see cref="P:Un4seen.Bass.Misc.WaveForm.FileName"/> given (peak levels will be scanned).
            </summary>
            <param name="background">TRUE, if rendering should be performed in an independent background thread. FALSE, if rendering should be executed synchronious.</param>
            <param name="prio">The thread priority to be used with the background thread (default is BelowNormal).</param>
            <param name="flags">A combination of the <see cref="T:Un4seen.Bass.BASSFlag"/> flags on how to create the decoding stream. The <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_DECODE"/> and <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_PRESCAN"/> flags will be added automatically here, if not already set!</param>
            <returns>TRUE, if rendering was started successfully, else FALSE.</returns>
            <remarks>This overload creates an internal decoding channel allowing to render the peak levels independently.
            <para>If you intend to use this overload to render the wave form in parallel while already playing out the file, it is recommended to specify the same flags as for your playing stream.
            This is because <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelBytes2Seconds(System.Int32,System.Int64)"/> etc. would return different values if you specified different resolutions for your playing stream and your rendering stream (eg. a stream with BASS_SAMPLE_FLOAT would return twice as much bytes as a stream created with the default 16-bit resolution).</para>
            <para>If your playing stream and this call uses different flags, you might use the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method, so that the members <see cref="M:Un4seen.Bass.Misc.WaveForm.Position2Frames(System.Int64)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.Frame2Bytes(System.Int32)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.GetBytePositionFromX(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            will return converted values according to your playing stream.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RenderStop">
            <summary>
            Stops a currently running rendering process.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RenderStartRecording(System.Int32,System.Int32,System.Int32)">
            <summary>
            Start a live recording rendering process for the specified non-decoding handle (peak levels will not be scanned at this point).
            </summary>
            <param name="recordingStream">The HRECORD or HSTREAM stream for which to render the WaveForm (e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>).</param>
            <param name="initLength">The initial rendering buffer length in seconds (e.g. 10sec. - minimum is 1sec.).</param>
            <param name="nextLength">The next block in seconds when the recording buffer length needs to be increased (e.g. 5sec. - minimum is 1sec. or specify 0 to define a cycle buffer).</param>
            <returns>TRUE, if live recording rendering was started successfully, else FALSE.</returns>
            <remarks>The <paramref name="recordingStream"/> handle might be any stream channel. Just make sure, that you DO NOT use the <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderRecording"/> method overload (which takes no parameters) with a decoding stream.
            <para>When rendering a WaveForm for live recording the total length of the recording is unknown. 
            Therefore a dynamic buffer is used internally which is initialized with a length of <paramref name="initLength"/> seconds. 
            When the buffer needs to be extended (e.g. the recording exceeds the initial length) it is incremented <paramref name="nextLength"/> seconds.
            When you finally stop the live rendering recording with <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStopRecording"/> the total buffer size is at least <paramref name="initLength"/> seconds big or a multiple of <paramref name="nextLength"/> seconds.</para>
            <para>Make sure you started recording via <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/> before calling any live rendering recording method.</para>
            <para>After live rendering recorded has been started you might call <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderRecording"/> to actual render the recorded sample data.</para>
            <para>When you specify 0 (zero) for the <paramref name="nextLength"/> parameter a cycle buffer is created. Meaning the rendered WaveForm buffer size will only be <paramref name="initLength"/> long.
            When the buffer is filled, it starts at the beginning again (position 0)- overwriting the oldest rendered data.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RenderStartRecording(System.Int32,System.Single,System.Single)">
            <summary>
            Start a live recording rendering process for the specified stream handle (peak levels will not be scanned at this point).
            </summary>
            <param name="recordingStream">The HRECORD or HSTREAM stream for which to render the WaveForm (e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>).</param>
            <param name="initLength">The initial rendering buffer length in seconds (e.g. 10sec. - minimum is 1sec.).</param>
            <param name="nextLength">The next block in seconds when the recording buffer length needs to be increased (e.g. 5sec. - minimum is 1sec. or specify 0 to define a cycle buffer).</param>
            <returns>TRUE, if live recording rendering was started successfully, else FALSE.</returns>
            <remarks>The <paramref name="recordingStream"/> handle might be any stream channel. Just make sure, that you DO NOT use the <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderRecording"/> method overload (which takes no parameters) with a decoding stream.
            <para>When rendering a WaveForm for live recording the total length of the recording is unknown. 
            Therefore a dynamic buffer is used internally which is initialized with a length of <paramref name="initLength"/> seconds. 
            When the buffer needs to be extended (e.g. the recording exceeds the initial length) it is incremented <paramref name="nextLength"/> seconds.
            When you finally stop the live rendering recording with <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStopRecording"/> the total buffer size is at least <paramref name="initLength"/> seconds big or a multiple of <paramref name="nextLength"/> seconds.</para>
            <para>Make sure you started recording via <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/> before calling any live rendering recording method.</para>
            <para>After live rendering recorded has been started you might call <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderRecording"/> to actual render the recorded sample data.</para>
            <para>When you specify 0 (zero) for the <paramref name="nextLength"/> parameter a cycle buffer is created. Meaning the rendered WaveForm buffer size will only be <paramref name="initLength"/> long.
            When the buffer is filled, it starts at the beginning again (position 0)- overwriting the oldest rendered data.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RenderStopRecording">
            <summary>
            Stops live recording rendering.
            </summary>
            <remarks>This just stops the live recording rendering of the WaveForm, but it does not stop the actual recording itself.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RenderRecording">
            <summary>
            Renders live recorded data and generates the WaveForm data for it.
            </summary>
            <remarks>Call this method subsequently and often enough to get the actual recording data and perform the rendering of that data.
            <para>You must have started live rendering recording with <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStartRecording(System.Int32,System.Int32,System.Int32)"/> before calling this method.</para>
            <para>You might use the method either within a <see cref="T:Un4seen.Bass.RECORDPROC"/> or via your own timer callback at any time when new sample data is available.
            This overload actually calls <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> internally, so it is not recommended to use this with a stream channel (but only with buffered recording channels), since it will steal sample from the stream.</para>
            <para>This overload only exists for backwards compatibility it is advised to use this overload only when needed, since the 'other' overload of this method might be faster and more accurate.</para>
            <para>Calling this method after you have stopped live recording rendering with <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStopRecording"/> has no effect anymore.</para>
            </remarks>
            <example>
            <code>
            private WaveForm WF = null;
            private RECORDPROC _myRecProc; // make it global, so that the GC can not remove it
            private int _recHandle = 0;
            ...
            _myRecProc = new RECORDPROC(MyRecording);
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero);
            // create a live recording WaveForm
            WF = new WaveForm();
            WF.FrameResolution = 0.01f; // 10ms are nice
            // start a live recording waveform with 10sec. init size and 5sec. next size
            WF.RenderStartRecording(_recHandle, 10, 5);
            // really start recording
            Bass.BASS_ChannelPlay(_recHandle, false);
            ...
            // stops recording
            Bass.BASS_ChannelStop(_recHandle);
            // stop the live recording waveform
            if (WF != null)
            {
              WF.RenderStopRecording();
              DrawWave();
            }
            ...
            // the recording callback in which we will render the WaveForm
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              if (length &gt; 0 &amp;&amp; buffer != IntPtr.Zero)
              {
                // get and draw our live recording waveform
                WF.RenderRecording(buffer, length);
                DrawWave();
              }
              return true; // always continue recording
            }
            ...
            // draws a rendered WaveForm to a PictureBox
            private void DrawWave()
            {
              if (WF != null)
                this.pictureBoxLiveWave.BackgroundImage = WF.CreateBitmap(this.pictureBoxLiveWave.Width, 
                                                                          this.pictureBoxLiveWave.Height, 
                                                                          -1, -1, false);
              else
                this.pictureBoxLiveWave.BackgroundImage = null;
            }
            </code>
            <code lang="vbnet">
            Private WF As WaveForm = Nothing
            Private _myRecProc As RECORDPROC ' make it global, so that the GC can not remove it
            Private _recHandle As Integer = 0
            ...
            _myRecProc = New RECORDPROC(AddressOf MyRecording)
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero)
            ' create a live recording WaveForm
            WF = New WaveForm()
            WF.FrameResolution = 0.01F ' 10ms are nice
            ' start a live recording waveform with 10sec. init size and 5sec. next size
            WF.RenderStartRecording(_recHandle, 10, 5)
            ' really start recording
            Bass.BASS_ChannelPlay(_recHandle, False)
            ...
            ' stops recording
            Bass.BASS_ChannelStop(_recHandle)
            ' stop the live recording waveform
            If Not (WF Is Nothing) Then
              WF.RenderStopRecording()
              DrawWave()
            End If
            ...
            ' the recording callback in which we will render the WaveForm
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              If length &gt; 0 AndAlso buffer &lt;&gt; IntPtr.Zero Then
                ' get and draw our live recording waveform
                WF.RenderRecording(buffer, length)
                DrawWave()
              End If
              Return True ' always continue recording
            End Function
            
            ' draws a rendered WaveForm to a PictureBox
            Private Sub DrawWave()
              If Not (WF Is Nothing) Then
                Me.pictureBoxLiveWave.BackgroundImage = WF.CreateBitmap(Me.pictureBoxLiveWave.Width, 
                                                                        Me.pictureBoxLiveWave.Height, 
                                                                        -1, -1, False)
              Else
                Me.pictureBoxLiveWave.BackgroundImage = Nothing
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RenderRecording(System.IntPtr,System.Int32)">
            <summary>
            Renders live recorded data and generates the WaveForm data for it.
            </summary>
            <param name="buffer">The pointer to the sample data to render (e.g. as received within a <see cref="T:Un4seen.Bass.RECORDPROC"/>).</param>
            <param name="length">The length of the data with the buffer.</param>
            <remarks>Call this method subsequently and often enough to get the actual recording data and perform the rendering of that data - typically with a <see cref="T:Un4seen.Bass.RECORDPROC"/>.
            <para>You must have started live rendering recording with <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStartRecording(System.Int32,System.Int32,System.Int32)"/> before calling this method.</para>
            <para>You might use the method either within a <see cref="T:Un4seen.Bass.RECORDPROC"/> or any other BASS callback in which you receive sample data (a <see cref="T:Un4seen.Bass.DSPPROC"/> for example).</para>
            <para>Use this overload, if you want to render live sample data even from a decoding stream!</para>
            <para>Calling this method after you have stopped live recording rendering with <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStopRecording"/> has no effect anymore.</para>
            </remarks>
            <example>
            <code>
            private WaveForm WF = null;
            private RECORDPROC _myRecProc; // make it global, so that the GC can not remove it
            private int _recHandle = 0;
            ...
            _myRecProc = new RECORDPROC(MyRecording);
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero);
            // create a live recording WaveForm
            WF = new WaveForm();
            WF.FrameResolution = 0.01f; // 10ms are nice
            // start a live recording waveform with 10sec. init size and 5sec. next size
            WF.RenderStartRecording(_recHandle, 10, 5);
            // really start recording
            Bass.BASS_ChannelPlay(_recHandle, false);
            ...
            // stops recording
            Bass.BASS_ChannelStop(_recHandle);
            // stop the live recording waveform
            if (WF != null)
            {
              WF.RenderStopRecording();
              DrawWave();
            }
            ...
            // the recording callback in which we will render the WaveForm
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              if (length &gt; 0 &amp;&amp; buffer != IntPtr.Zero)
              {
                // get and draw our live recording waveform
                WF.RenderRecording(buffer, length);
                DrawWave();
              }
              return true; // always continue recording
            }
            
            // draws a rendered WaveForm to a PictureBox
            private void DrawWave()
            {
              if (WF != null)
                this.pictureBoxLiveWave.BackgroundImage = WF.CreateBitmap(this.pictureBoxLiveWave.Width, 
                                                                          this.pictureBoxLiveWave.Height, 
                                                                          -1, -1, false);
              else
                this.pictureBoxLiveWave.BackgroundImage = null;
            }
            </code>
            <code lang="vbnet">
            Private WF As WaveForm = Nothing
            Private _myRecProc As RECORDPROC ' make it global, so that the GC can not remove it
            Private _recHandle As Integer = 0
            ...
            _myRecProc = New RECORDPROC(AddressOf MyRecording)
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero)
            ' create a live recording WaveForm
            WF = New WaveForm()
            WF.FrameResolution = 0.01F ' 10ms are nice
            ' start a live recording waveform with 10sec. init size and 5sec. next size
            WF.RenderStartRecording(_recHandle, 10, 5)
            ' really start recording
            Bass.BASS_ChannelPlay(_recHandle, False)
            ...
            ' stops recording
            Bass.BASS_ChannelStop(_recHandle)
            ' stop the live recording waveform
            If Not (WF Is Nothing) Then
              WF.RenderStopRecording()
              DrawWave()
            End If
            ...
            ' the recording callback in which we will render the WaveForm
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              If length &gt; 0 AndAlso buffer &lt;&gt; IntPtr.Zero Then
                ' get and draw our live recording waveform
                WF.RenderRecording(buffer, length)
                DrawWave()
              End If
              Return True ' always continue recording
            End Function
            
            ' draws a rendered WaveForm to a PictureBox
            Private Sub DrawWave()
              If Not (WF Is Nothing) Then
                Me.pictureBoxLiveWave.BackgroundImage = WF.CreateBitmap(Me.pictureBoxLiveWave.Width, 
                                                                        Me.pictureBoxLiveWave.Height, 
                                                                        -1, -1, False)
              Else
                Me.pictureBoxLiveWave.BackgroundImage = Nothing
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)">
            <summary>
            Sets a playback channel to synchronize the wave form positions.
            </summary>
            <param name="channel">The playback channel which should be used to synchronize the WaveForm position members.</param>
            <returns>TRUE on success - else FALSE (e.g. channel is an invalid stream) will be returned.</returns>
            <remarks>
            <para>If you intend to use the wave form in parallel while already playing out a stream, it is recommended to specify the same flags as for your playing stream (see e.g. <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>).
            This is because <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelBytes2Seconds(System.Int32,System.Int64)"/> etc. would return different values if you specified different resolutions for your playing stream and your rendering stream (eg. a stream with BASS_SAMPLE_FLOAT would return twice as much bytes as a stream created with the default 16-bit resolution).</para>
            <para>If your playing stream and and the rendering process uses different flags, you might use this method, so that the members <see cref="M:Un4seen.Bass.Misc.WaveForm.Position2Frames(System.Int64)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.Frame2Bytes(System.Int32)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.GetBytePositionFromX(System.Int32,System.Int32,System.Int32,System.Int32)"/> <see cref="M:Un4seen.Bass.Misc.WaveForm.AddMarker(System.String,System.Int64)"/> and <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarker(System.String)"/>
            will return converted values according to your playing stream.</para>
            <para>Note: The <see cref="P:Un4seen.Bass.Misc.WaveForm.TempoFactor"/> will be reset to 0% when calling this method!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.Position2Rendering(System.Int64)">
            <summary>
            Converts a given playback position to the rendering position according to the <see cref="P:Un4seen.Bass.Misc.WaveForm.SyncFactor"/>.
            </summary>
            <param name="bytes">The playback position (in bytes) to convert.</param>
            <returns>The converted rendering position.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.Position2Rendering(System.Double)">
            <summary>
            Converts a given playback position to the rendering position according to the <see cref="P:Un4seen.Bass.Misc.WaveForm.SyncFactor"/>.
            </summary>
            <param name="seconds">The playback position (in seconds) to convert.</param>
            <returns>The converted rendering position or -1 on error.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.Position2Playback(System.Int64)">
            <summary>
            Converts a given rendering position to the playback position according to the <see cref="P:Un4seen.Bass.Misc.WaveForm.SyncFactor"/>.
            </summary>
            <param name="bytes">The rendering position (in bytes) to convert.</param>
            <returns>The converted playback position.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.Position2Playback(System.Double)">
            <summary>
            Converts a given rendering position to the playback position according to the <see cref="P:Un4seen.Bass.Misc.WaveForm.SyncFactor"/>.
            </summary>
            <param name="seconds">The rendering position (in seconds) to convert.</param>
            <returns>The converted playback position or -1 on error.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.Position2Frames(System.Int64)">
            <summary>
            Converts a given position (in bytes) to the frame number.
            </summary>
            <param name="bytes">The position (in bytes) which should be translated to a frame number.</param>
            <returns>The frame number which represents the position. Or -1, if an error occured or the wave form has not been rendered yet.</returns>
            <remarks>The wave form must have been rendered already before you can use this method.
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            this method would return the frame according to the rendering process, meaning the position would reflect a different value.</para>
            <para>You might use the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method to ensure, that the position will automatically be converted accordingly.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.Position2Frames(System.Double)">
            <summary>
            Converts a given position (in seconds) to the frame number.
            </summary>
            <param name="seconds">The position (in seconds) which should be translated to a frame number.</param>
            <returns>The frame number which represents the position. Or -1, if an error occured or the wave form has not been rendered yet.</returns>
            <remarks>The wave form must have been rendered already before you can use this method.
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            this method would return the frame according to the rendering process, meaning the position would reflect a different value.</para>
            <para>You might use the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method to ensure, that the position will automatically be converted accordingly.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.Frame2Bytes(System.Int32)">
            <summary>
            Converts a given frame to the position (in bytes).
            </summary>
            <param name="frame">The frame number which should be converted.</param>
            <returns>The position (in bytes) or -1, if an error occured or the wave form has not been rendered yet.</returns>
            <remarks>The wave form must have been rendered already before you can use this method.
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            this method would return the frame according to the rendering process, meaning the position would reflect a different value.</para>
            <para>You might use the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method to ensure, that the position will automatically be converted accordingly.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.Frame2Seconds(System.Int32)">
            <summary>
            Converts a given frame to the position (in seconds).
            </summary>
            <param name="frame">The frame number which should be converted.</param>
            <returns>The position (in seconds) or -1, if an error occured or the wave form has not been rendered yet.</returns>
            <remarks>The wave form must have been rendered already before you can use this method.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.AddMarker(System.String,System.Int64)">
            <summary>
            Add or replace a marker to the WaveForm.
            </summary>
            <param name="name">The name of the marker to add or replace.</param>
            <param name="position">The position (in bytes) of the marker (e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>).</param>
            <returns>TRUE, if the marker was added or replaced successfully, else FALSE.</returns>
            <remarks>Markers might be used to highlight certain positions within a WaveForm, e.g. Cue-, Ramp-, Fade- or Mix-Points.
            <para>Use the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawMarker"/> property to define if and how markers should be drawn within the WaveForm. The <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorMarker"/> property will be used as the the drawing color.</para>
            <para>In order to remove a marker use the <see cref="M:Un4seen.Bass.Misc.WaveForm.RemoveMarker(System.String)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllMarker"/> methods.</para>
            <para>Before adding markers the <see cref="P:Un4seen.Bass.Misc.WaveForm.Wave"/> buffer must have been created. So make sure this method is only called after <see cref="M:Un4seen.Bass.Misc.WaveForm.WaveFormLoadFromFile(System.String)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStartRecording(System.Int32,System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>.</para>
            <para>Use the <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarker(System.String)"/> method to retrive a certain marker position. To obtain a list of all markers you might use the <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarkers"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarkerCount"/> methods.</para>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            adding markers might result in a different position, meaning the position would reflect a different value during playback.
            In such case call the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method to ensure, that the position will be converted accordingly.</para>
            <para>Note: The byte position will be converted to the original rendering resolution according the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/>.
            So if your playback stream has a different resolution never add marker positions without first calling <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/>.</para>
            </remarks>
            <example>
            <code>
            private Un4seen.Bass.Misc.WaveForm WF = null;
            ...
            // render a wave form
            WF = new WaveForm(_fileName, new WAVEFORMPROC(MyWaveFormCallback), this);
            WF.FrameResolution = 0.01f; // 10ms are nice
            WF.CallbackFrequency = 500; // every 5 seconds rendered (500*10ms=5sec)
            WF.DrawMarker = WaveForm.MARKERDRAWTYPE.Line | 
                            WaveForm.MARKERDRAWTYPE.Name | 
                            WaveForm.MARKERDRAWTYPE.NamePositionAlternate;
            // it is important to use the same resolution flags as for the playing stream!
            // our already playing stream is 32-bit float - so this one will also need to be...
            WF.RenderStart( false, BASSFlag.BASS_SAMPLE_FLOAT );
            // from here on we might add markers...just examples here...
            WF.AddMarker( "CueIn", Bass.BASS_ChannelSeconds2Bytes(_stream, 2.0) );
            WF.AddMarker( "RampUp", Bass.BASS_ChannelSeconds2Bytes(_stream, 17.5));
            WF.AddMarker( "Outro", Bass.BASS_ChannelSeconds2Bytes(_stream, 100.7));
            WF.AddMarker( "Mix", Bass.BASS_ChannelSeconds2Bytes(_stream, 130.3));
            WF.AddMarker( "End", Bass.BASS_ChannelSeconds2Bytes(_stream, 136.9));
            ...
            // this will replace the 'RampUp' marker
            WF.AddMarker( "RampUp", Bass.BASS_ChannelSeconds2Bytes(_stream, 19.2));
            </code>
            <code lang="vbnet">
            Private WF As Un4seen.Bass.Misc.WaveForm = Nothing
            ...
            ' render a wave form
            WF = New WaveForm(_fileName, New WAVEFORMPROC(MyWaveFormCallback), Me)
            WF.FrameResolution = 0.01F ' 10ms are nice
            WF.CallbackFrequency = 500 ' every 5 seconds rendered (500*10ms=5sec)
            WF.DrawMarker = WaveForm.MARKERDRAWTYPE.Line Or 
                            WaveForm.MARKERDRAWTYPE.Name Or 
                            WaveForm.MARKERDRAWTYPE.NamePositionAlternate
            ' it is important to use the same resolution flags as for the playing stream!
            ' our already playing stream is 32-bit float - so this one will also need to be...
            WF.RenderStart(False, BASSFlag.BASS_SAMPLE_FLOAT)
            ' from here on we might add markers...just examples here...
            WF.AddMarker("CueIn", Bass.BASS_ChannelSeconds2Bytes(_stream, 2.0))
            WF.AddMarker("RampUp", Bass.BASS_ChannelSeconds2Bytes(_stream, 17.5))
            WF.AddMarker("Outro", Bass.BASS_ChannelSeconds2Bytes(_stream, 100.7))
            WF.AddMarker("Mix", Bass.BASS_ChannelSeconds2Bytes(_stream, 130.3))
            WF.AddMarker("End", Bass.BASS_ChannelSeconds2Bytes(_stream, 136.9))
            ...
            ' this will replace the 'RampUp' marker
            WF.AddMarker("RampUp", Bass.BASS_ChannelSeconds2Bytes(_stream, 19.2))
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.AddMarker(System.String,System.Double)">
            <summary>
            Add or replace a marker to the WaveForm.
            </summary>
            <param name="name">The name of the marker to add or replace.</param>
            <param name="position">The position (in seconds) of the marker (e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>).</param>
            <returns>TRUE, if the marker was added or replaced successfully, else FALSE.</returns>
            <remarks>Markers might be used to highlight certain positions within a WaveForm, e.g. Cue-, Ramp-, Fade- or Mix-Points.
            <para>Use the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawMarker"/> property to define if and how markers should be drawn within the WaveForm. The <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorMarker"/> property will be used as the the drawing color.</para>
            <para>In order to remove a marker use the <see cref="M:Un4seen.Bass.Misc.WaveForm.RemoveMarker(System.String)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllMarker"/> methods.</para>
            <para>Before adding markers the <see cref="P:Un4seen.Bass.Misc.WaveForm.Wave"/> buffer must have been created. So make sure this method is only called after <see cref="M:Un4seen.Bass.Misc.WaveForm.WaveFormLoadFromFile(System.String)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStartRecording(System.Int32,System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>.</para>
            <para>Use the <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarker(System.String)"/> method to retrive a certain marker position. To obtain a list of all markers you might use the <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarkers"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarkerCount"/> methods.</para>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            adding markers might result in a different position, meaning the position would reflect a different value during playback.
            In such case call the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method to ensure, that the position will be converted accordingly.</para>
            <para>Note: The seconds position will be converted to the original rendering resolution according the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/>.
            So if your playback stream has a different resolution never add marker positions without first calling <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/>.</para>
            </remarks>
            <example>
            <code>
            private Un4seen.Bass.Misc.WaveForm WF = null;
            ...
            // render a wave form
            WF = new WaveForm(_fileName, new WAVEFORMPROC(MyWaveFormCallback), this);
            WF.FrameResolution = 0.01f; // 10ms are nice
            WF.CallbackFrequency = 500; // every 5 seconds rendered (500*10ms=5sec)
            WF.DrawMarker = WaveForm.MARKERDRAWTYPE.Line | 
                            WaveForm.MARKERDRAWTYPE.Name | 
                            WaveForm.MARKERDRAWTYPE.NamePositionAlternate;
            // it is important to use the same resolution flags as for the playing stream!
            // our already playing stream is 32-bit float - so this one will also need to be...
            WF.RenderStart( false, BASSFlag.BASS_SAMPLE_FLOAT );
            // from here on we might add markers...just examples here...
            WF.AddMarker( "CueIn", 2.0 );
            WF.AddMarker( "RampUp", 17.5);
            WF.AddMarker( "Outro", 100.7);
            WF.AddMarker( "Mix", 130.3);
            WF.AddMarker( "End", 136.9);
            ...
            // this will replace the 'RampUp' marker
            WF.AddMarker( "RampUp", 19.2);
            </code>
            <code lang="vbnet">
            Private WF As Un4seen.Bass.Misc.WaveForm = Nothing
            ...
            ' render a wave form
            WF = New WaveForm(_fileName, New WAVEFORMPROC(MyWaveFormCallback), Me)
            WF.FrameResolution = 0.01F ' 10ms are nice
            WF.CallbackFrequency = 500 ' every 5 seconds rendered (500*10ms=5sec)
            WF.DrawMarker = WaveForm.MARKERDRAWTYPE.Line Or 
                            WaveForm.MARKERDRAWTYPE.Name Or 
                            WaveForm.MARKERDRAWTYPE.NamePositionAlternate
            ' it is important to use the same resolution flags as for the playing stream!
            ' our already playing stream is 32-bit float - so this one will also need to be...
            WF.RenderStart(False, BASSFlag.BASS_SAMPLE_FLOAT)
            ' from here on we might add markers...just examples here...
            WF.AddMarker("CueIn", 2.0)
            WF.AddMarker("RampUp", 17.5)
            WF.AddMarker("Outro", 100.7)
            WF.AddMarker("Mix", 130.3)
            WF.AddMarker("End", 136.9)
            ...
            ' this will replace the 'RampUp' marker
            WF.AddMarker("RampUp", 19.2)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetMarker(System.String)">
            <summary>
            Returns a given marker position.
            </summary>
            <param name="name">The name of the marker to get.</param>
            <returns>The marker position in bytes or -1 if the marker name does not exist.</returns>
            <remarks>This is the complementary method of <see cref="M:Un4seen.Bass.Misc.WaveForm.AddMarker(System.String,System.Int64)"/>.
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            this method would return the position according to the rendering process, meaning the position would reflect a different value.
            In this case make sure to call <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> before getting any markers. This will ensure that the position will be converted accordingly to the playback.</para>
            </remarks>
            <example>
            <code>
            private Un4seen.Bass.Misc.WaveForm WF = null;
            ...
            // render a wave form
            WF = new WaveForm(_fileName, new WAVEFORMPROC(MyWaveFormCallback), this);
            WF.FrameResolution = 0.01f; // 10ms are nice
            WF.CallbackFrequency = 500; // every 5 seconds rendered (500*10ms=5sec)
            WF.DrawMarker = WaveForm.MARKERDRAWTYPE.Line | 
                            WaveForm.MARKERDRAWTYPE.Name | 
                            WaveForm.MARKERDRAWTYPE.NamePositionAlternate;
            WF.RenderStart( false, BASSFlag.BASS_SAMPLE_FLOAT );
            // from here on we might add markers...just examples here...
            WF.AddMarker( "CueIn", Bass.BASS_ChannelSeconds2Bytes(_stream, 2.0) );
            ...
            // this will get the 'CueIn' marker
            long position = WF.GetMarker( "CueIn" );
            </code>
            <code lang="vbnet">
            Private WF As Un4seen.Bass.Misc.WaveForm = Nothing
            ...
             ' render a wave form
             WF = New WaveForm(_fileName, New WAVEFORMPROC(MyWaveFormCallback), Me)
             WF.FrameResolution = 0.01F ' 10ms are nice
             WF.CallbackFrequency = 500 ' every 5 seconds rendered (500*10ms=5sec)
             WF.DrawMarker = WaveForm.MARKERDRAWTYPE.Line Or 
                             WaveForm.MARKERDRAWTYPE.Name Or 
                             WaveForm.MARKERDRAWTYPE.NamePositionAlternate
             WF.RenderStart(False, BASSFlag.BASS_SAMPLE_FLOAT)
             ' from here on we might add markers...just examples here...
             WF.AddMarker("CueIn", Bass.BASS_ChannelSeconds2Bytes(_stream, 2.0))
             ...
             ' this will get the 'CueIn' marker
             Dim position As Long = WF.GetMarker("CueIn")
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetMarkerSec(System.String)">
            <summary>
            Returns a given marker position.
            </summary>
            <param name="name">The name of the marker to get.</param>
            <returns>The marker position in seconds or -1 if the marker name does not exist.</returns>
            <remarks>This is the complementary method of <see cref="M:Un4seen.Bass.Misc.WaveForm.AddMarker(System.String,System.Int64)"/>.
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            this method would return the position according to the rendering process, meaning the position would reflect a different value.
            In this case make sure to call <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> before getting any markers. This will ensure that the position will be converted accordingly to the playback.</para>
            </remarks>
            <example>
            <code>
            private Un4seen.Bass.Misc.WaveForm WF = null;
            ...
            // render a wave form
            WF = new WaveForm(_fileName, new WAVEFORMPROC(MyWaveFormCallback), this);
            WF.FrameResolution = 0.01f; // 10ms are nice
            WF.CallbackFrequency = 500; // every 5 seconds rendered (500*10ms=5sec)
            WF.DrawMarker = WaveForm.MARKERDRAWTYPE.Line | 
                            WaveForm.MARKERDRAWTYPE.Name | 
                            WaveForm.MARKERDRAWTYPE.NamePositionAlternate;
            WF.RenderStart( false, BASSFlag.BASS_SAMPLE_FLOAT );
            // from here on we might add markers...just examples here...
            WF.AddMarker( "CueIn", 2.0 );
            ...
            // this will get the 'CueIn' marker
            double position = WF.GetMarkerSec( "CueIn" );
            </code>
            <code lang="vbnet">
            Private WF As Un4seen.Bass.Misc.WaveForm = Nothing
            ...
             ' render a wave form
             WF = New WaveForm(_fileName, New WAVEFORMPROC(MyWaveFormCallback), Me)
             WF.FrameResolution = 0.01F ' 10ms are nice
             WF.CallbackFrequency = 500 ' every 5 seconds rendered (500*10ms=5sec)
             WF.DrawMarker = WaveForm.MARKERDRAWTYPE.Line Or 
                             WaveForm.MARKERDRAWTYPE.Name Or 
                             WaveForm.MARKERDRAWTYPE.NamePositionAlternate
             WF.RenderStart(False, BASSFlag.BASS_SAMPLE_FLOAT)
             ' from here on we might add markers...just examples here...
             WF.AddMarker("CueIn", 2.0)
             ...
             ' this will get the 'CueIn' marker
             Dim position As Double = WF.GetMarkerSec("CueIn")
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetMarkerCount">
            <summary>
            Returns the number of markers within the wave form.
            </summary>
            <returns>The number of markers present.</returns>
            <remarks>You might add new markers with <see cref="M:Un4seen.Bass.Misc.WaveForm.AddMarker(System.String,System.Int64)"/> and get existing markers with <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarker(System.String)"/>.
            <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarkers"/> will provide you with a list of marker names. <see cref="M:Un4seen.Bass.Misc.WaveForm.RemoveMarker(System.String)"/> will remove a certain marker from the list and <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllMarker"/> will remove all markers.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetMarkers">
            <summary>
            Returns an array of strings containing all marker names.
            </summary>
            <returns>A string array with all marker names or an empty array if no markers are present.</returns>
            <remarks>You might add new markers with <see cref="M:Un4seen.Bass.Misc.WaveForm.AddMarker(System.String,System.Int64)"/> and get existing markers with <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarker(System.String)"/>.
            <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarkerCount"/> will provide you with the total number of markers present. <see cref="M:Un4seen.Bass.Misc.WaveForm.RemoveMarker(System.String)"/> will remove a certain marker from the list and <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllMarker"/> will remove all markers.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RemoveMarker(System.String)">
            <summary>
            Removes an existing marker from the WaveForm.
            </summary>
            <param name="name">The name of the marker to remove.</param>
            <returns>TRUE, if the marker was removed successfully, else FALSE.</returns>
            <remarks>Markers might be used to highlight certain positions within a WaveForm, e.g. Cue-, Ramp-, Fade- or Mix-Points.
            <para>Use the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawMarker"/> property to define if and how markers should be drawn within the WaveForm. The <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorMarker"/> property will be used as the the drawing color.</para>
            <para>In order to remove all markers use the <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllMarker"/> method. If you need to add new markers or replace an existing marker use the <see cref="M:Un4seen.Bass.Misc.WaveForm.AddMarker(System.String,System.Int64)"/> method.</para>
            <para>Before removing markers the <see cref="P:Un4seen.Bass.Misc.WaveForm.Wave"/> buffer must have been created. So make sure this method is only called after <see cref="M:Un4seen.Bass.Misc.WaveForm.WaveFormLoadFromFile(System.String)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStartRecording(System.Int32,System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>.</para>
            <para>To obtain a list of all markers you might use the <see cref="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.marker"/> dictionary member (Key=name, Value=position) of the <see cref="P:Un4seen.Bass.Misc.WaveForm.Wave"/> property.</para>
            </remarks>
            <example>
            <code>
            private Un4seen.Bass.Misc.WaveForm WF = null;
            ...
            // render a wave form
            WF = new WaveForm(this._fileName, new WAVEFORMPROC(MyWaveFormCallback), this);
            WF.DrawMarker = WaveForm.MARKERDRAWTYPE.Line;
            WF.RenderStart( true, BASSFlag.BASS_SAMPLE_FLOAT );
            // from here on we might add markers...just examples here...
            WF.AddMarker( "CueIn", Bass.BASS_ChannelSeconds2Bytes(_stream, 2.0) );
            WF.AddMarker( "RampUp", Bass.BASS_ChannelSeconds2Bytes(_stream, 17.5));
            WF.AddMarker( "Outro", Bass.BASS_ChannelSeconds2Bytes(_stream, 100.7));
            WF.AddMarker( "Mix", Bass.BASS_ChannelSeconds2Bytes(_stream, 130.3));
            WF.AddMarker( "End", Bass.BASS_ChannelSeconds2Bytes(_stream, 136.9));
            ...
            // this will remove the 'CueIn' marker
            WF.RemoveMarker( "CueIn" );
            </code>
            <code lang="vbnet">
            Private WF As Un4seen.Bass.Misc.WaveForm = Nothing
            ...
            ' render a wave form
            WF = New WaveForm(Me._fileName, New WAVEFORMPROC(MyWaveFormCallback), Me)
            WF.DrawMarker = WaveForm.MARKERDRAWTYPE.Line
            WF.RenderStart(True, BASSFlag.BASS_SAMPLE_FLOAT)
            ' from here on we might add markers...just examples here...
            WF.AddMarker("CueIn", Bass.BASS_ChannelSeconds2Bytes(_stream, 2.0))
            WF.AddMarker("RampUp", Bass.BASS_ChannelSeconds2Bytes(_stream, 17.5))
            WF.AddMarker("Outro", Bass.BASS_ChannelSeconds2Bytes(_stream, 100.7))
            WF.AddMarker("Mix", Bass.BASS_ChannelSeconds2Bytes(_stream, 130.3))
            WF.AddMarker("End", Bass.BASS_ChannelSeconds2Bytes(_stream, 136.9))
            ...
            ' this will remove the 'CueIn' marker
            WF.RemoveMarker("CueIn")
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.ClearAllMarker">
            <summary>
            Removes all markers from the WaveForm.
            </summary>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>Markers might be used to highlight certain positions within a WaveForm, e.g. Cue-, Ramp-, Fade- or Mix-Points.
            <para>Use the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawMarker"/> property to define if and how markers should be drawn within the WaveForm. The <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorMarker"/> property will be used as the the drawing color.</para>
            <para>In order to remove all markers use the <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllMarker"/> method. If you need to add new markers or replace an existing marker use the <see cref="M:Un4seen.Bass.Misc.WaveForm.AddMarker(System.String,System.Int64)"/> method.</para>
            <para>Before removing markers the <see cref="P:Un4seen.Bass.Misc.WaveForm.Wave"/> buffer must have been created. So make sure this method is only called after <see cref="M:Un4seen.Bass.Misc.WaveForm.WaveFormLoadFromFile(System.String)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStartRecording(System.Int32,System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>.</para>
            <para>To obtain a list of all markers you might use the <see cref="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.marker"/> dictionary member (Key=name, Value=position) of the <see cref="P:Un4seen.Bass.Misc.WaveForm.Wave"/> property.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.SearchVolumePoint(System.Int64)">
            <summary>
            Searches for a certain volume point.
            </summary>
            <param name="position">The position (in bytes) of the volume point to search.</param>
            <returns>If the position is present the zero-based index will be returned; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than value or, if there is no larger element, the bitwise complement of Count.</returns>
            <example>
            // return the exact or next volume point
            int startIdx = wf.SearchVolumePoint(pos);
            if (startIdx &lt; 0)
                startIdx = ~startIdx;
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.SearchVolumePoint(System.Double)">
            <summary>
            Searches for a certain volume point.
            </summary>
            <param name="position">The position (in seconds) of the volume point to search.</param>
            <returns>If the position is present the zero-based index will be returned; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than value or, if there is no larger element, the bitwise complement of Count.</returns>
            <example>
            // return the exact or next volume point
            int startIdx = wf.SearchVolumePoint(pos);
            if (startIdx &lt; 0)
                startIdx = ~startIdx;
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.SearchVolumePoint(System.Int64,Un4seen.Bass.Misc.WaveForm.VolumePoint@,Un4seen.Bass.Misc.WaveForm.VolumePoint@)">
            <summary>
            Searches for a certain volume point.
            </summary>
            <param name="position">The position (in bytes) of the volume point to search.</param>
            <param name="prev">The previous or exact VolumePoint at the requested position.</param>
            <param name="next">The next VolumePoint at the requested position or NULL, if no next point exists.</param>
            <returns>If the position is present the zero-based index will be returned; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than value or, if there is no larger element, the bitwise complement of Count.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.SearchVolumePoint(System.Double,Un4seen.Bass.Misc.WaveForm.VolumePoint@,Un4seen.Bass.Misc.WaveForm.VolumePoint@)">
            <summary>
            Searches for a certain volume point.
            </summary>
            <param name="position">The position (in seconds) of the volume point to search.</param>
            <param name="prev">The previous or exact VolumePoint at the requested position.</param>
            <param name="next">The next VolumePoint at the requested position or NULL, if no next point exists.</param>
            <returns>If the position is present the zero-based index will be returned; otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than value or, if there is no larger element, the bitwise complement of Count.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.AddVolumePoint(System.Int64,System.Single)">
            <summary>
            Add or replace a volume point to the WaveForm.
            </summary>
            <param name="position">The position (in bytes) of the volume point (e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>).</param>
            <param name="level">The volume level of the point to add or replace (0=silent, 1.0=maximum=0dB).</param>
            <returns>TRUE, if the volume point was added or replaced successfully, else FALSE.</returns>
            <remarks>Volume points might be used to draw a volume curve within a WaveForm.
            <para>Use the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawVolume"/> property to define if and how the volume curve should be drawn within the WaveForm. The <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorVolume"/> property will be used as the the drawing color.</para>
            <para>In order to remove a volume point use the <see cref="M:Un4seen.Bass.Misc.WaveForm.RemoveVolumePoint(System.Int64)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllVolumePoints"/> methods.</para>
            <para>Before adding a volume point the <see cref="P:Un4seen.Bass.Misc.WaveForm.Wave"/> buffer must have been created. So make sure this method is only called after <see cref="M:Un4seen.Bass.Misc.WaveForm.WaveFormLoadFromFile(System.String)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStartRecording(System.Int32,System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>.</para>
            <para>Use the <see cref="M:Un4seen.Bass.Misc.WaveForm.GetVolumePoint(System.Int64)"/> method to retrive a certain volume point. Via <see cref="M:Un4seen.Bass.Misc.WaveForm.GetVolumeLevel(System.Int64,System.Boolean,System.Int64@,System.Single@)"/> you might retrieve the volume level of the curve at any point.</para>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            adding volume points might result in a different position, meaning the position would reflect a different value during playback.
            In such case call the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method to ensure, that the position will be converted accordingly.</para>
            <para>Note: The byte position will be converted to the original rendering resolution according the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/>.
            So if your playback stream has a different resolution never add volume points without first calling <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.AddVolumePoint(System.Double,System.Single)">
            <summary>
            Add or replace a volume point to the WaveForm.
            </summary>
            <param name="position">The position (in seconds) of the volume point (e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> converted to seconds).</param>
            <param name="level">The volume level of the point to add or replace (0=silent, 1.0=maximum=0dB).</param>
            <returns>TRUE, if the volume point was added or replaced successfully, else FALSE.</returns>
            <remarks>Volume points might be used to draw a volume curve within a WaveForm.
            <para>Use the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawVolume"/> property to define if and how the volume curve should be drawn within the WaveForm. The <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorVolume"/> property will be used as the the drawing color.</para>
            <para>In order to remove a volume point use the <see cref="M:Un4seen.Bass.Misc.WaveForm.RemoveVolumePoint(System.Int64)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllVolumePoints"/> methods.</para>
            <para>Before adding a volume point the <see cref="P:Un4seen.Bass.Misc.WaveForm.Wave"/> buffer must have been created. So make sure this method is only called after <see cref="M:Un4seen.Bass.Misc.WaveForm.WaveFormLoadFromFile(System.String)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStartRecording(System.Int32,System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>.</para>
            <para>Use the <see cref="M:Un4seen.Bass.Misc.WaveForm.GetVolumePoint(System.Int64)"/> method to retrive a certain volume point. Via <see cref="M:Un4seen.Bass.Misc.WaveForm.GetVolumeLevel(System.Int64,System.Boolean,System.Int64@,System.Single@)"/> you might retrieve the volume level of the curve at any point.</para>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            adding volume points might result in a different position, meaning the position would reflect a different value during playback.
            In such case call the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method to ensure, that the position will be converted accordingly.</para>
            <para>Note: The byte position will be converted to the original rendering resolution according the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/>.
            So if your playback stream has a different resolution never add volume points without first calling <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetVolumePoint(System.Int64)">
            <summary>
            Returns the level of a given volume point.
            </summary>
            <param name="position">The position (in bytes) of the volume point to get.</param>
            <returns>The level of the volume point (0=silent, 1.0=maximum=0dB) or -1 if the volume points does not exist.</returns>
            <remarks>This is the complementary method of <see cref="M:Un4seen.Bass.Misc.WaveForm.AddVolumePoint(System.Int64,System.Single)"/>.
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            this method would return the position according to the rendering process, meaning the position would reflect a different value.
            In this case make sure to call <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> before getting any markers. This will ensure that the position will be converted accordingly.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetVolumePoint(System.Double)">
            <summary>
            Returns the level of a given volume point.
            </summary>
            <param name="position">The position (in seconds) of the volume point to get.</param>
            <returns>The level of the volume point (0=silent, 1.0=maximum=0dB) or -1 if the volume points does not exist.</returns>
            <remarks>This is the complementary method of <see cref="M:Un4seen.Bass.Misc.WaveForm.AddVolumePoint(System.Int64,System.Single)"/>.
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            this method would return the position according to the rendering process, meaning the position would reflect a different value.
            In this case make sure to call <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> before getting any markers. This will ensure that the position will be converted accordingly.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetVolumePoint(System.Int32)">
            <summary>
            Returns a certain volume point at the given index.
            </summary>
            <param name="index">The index of the volume point to get.</param>
            <returns>The volume point at the given index - or NULL if the index is not present.</returns>
            <remarks>Use <see cref="M:Un4seen.Bass.Misc.WaveForm.GetVolumePointCount"/> to get the total number of volume points present.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetVolumeLevel(System.Int64,System.Boolean,System.Int64@,System.Single@)">
            <summary>
            Returns the volume level at the given position of the volume curve.
            </summary>
            <param name="position">The position (in bytes) of the volume point to get.</param>
            <param name="reverse">TRUE, if to search in reverse direction - else FALSE.</param>
            <param name="duration">Returns the duration (in bytes) to the next volume point in bytes.</param>
            <param name="nextLevel">Returns the volume level at the next volume point.</param>
            <returns>The volume level (0=silent, 1.0=maximum=0dB) at the given position.</returns>
            <remarks>Note: This method always returns a volume level, even if the position does not reflect a volume point. In such case the volume level of the volume curve at this position will be returned.
            If no volume points have been defined at all this method will return 1.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetVolumeLevel(System.Double,System.Boolean,System.Double@,System.Single@)">
            <summary>
            Returns the volume level at the given position of the volume curve.
            </summary>
            <param name="position">The position (in seconds) of the volume point to get.</param>
            <param name="reverse">TRUE, if to search in reverse direction - else FALSE.</param>
            <param name="duration">Returns the duration (in seconds) to the next volume point in bytes.</param>
            <param name="nextLevel">Returns the volume level at the next volume point.</param>
            <returns>The volume level (0=silent, 1.0=maximum=0dB) at the given position.</returns>
            <remarks>Note: This method always returns a volume level, even if the position does not reflect a volume point. In such case the volume level of the volume curve at this position will be returned.
            If no volume points have been defined at all this method will return 1.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetVolumePointCount">
            <summary>
            Returns the number of volume points within the wave form.
            </summary>
            <returns>The number of volume points present.</returns>
            <remarks>You might add new volume points with <see cref="M:Un4seen.Bass.Misc.WaveForm.AddVolumePoint(System.Int64,System.Single)"/> and get existing volume points with <see cref="M:Un4seen.Bass.Misc.WaveForm.GetVolumePoint(System.Int64)"/> or return the volume level at any point via <see cref="M:Un4seen.Bass.Misc.WaveForm.GetVolumeLevel(System.Int64,System.Boolean,System.Int64@,System.Single@)"/>.
            <see cref="M:Un4seen.Bass.Misc.WaveForm.GetVolumePoint(System.Int64)"/> will provide you with a list of volume points. <see cref="M:Un4seen.Bass.Misc.WaveForm.RemoveVolumePoint(System.Int64)"/> will remove a certain volume point from the list and <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllVolumePoints"/> will remove all volume points.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RemoveVolumePoint(System.Int64)">
            <summary>
            Removes an existing volume point from the WaveForm.
            </summary>
            <param name="position">The position (in bytes) of the volume point to remove.</param>
            <returns>TRUE, if the volume point was removed successfully, else FALSE.</returns>
            <remarks>Volume points might be used to draw a volume curve within a WaveForm.
            <para>Use the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawVolume"/> property to define if and how the volume curve should be drawn within the WaveForm. The <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorVolume"/> property will be used as the the drawing color.</para>
            <para>In order to remove a volume point use the <see cref="M:Un4seen.Bass.Misc.WaveForm.RemoveVolumePoint(System.Int64)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllVolumePoints"/> methods.</para>
            <para>Before adding a volume point the <see cref="P:Un4seen.Bass.Misc.WaveForm.Wave"/> buffer must have been created. So make sure this method is only called after <see cref="M:Un4seen.Bass.Misc.WaveForm.WaveFormLoadFromFile(System.String)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStartRecording(System.Int32,System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>.</para>
            <para>Use the <see cref="M:Un4seen.Bass.Misc.WaveForm.GetVolumePoint(System.Int64)"/> method to retrive a certain volume point. To get the volume level at any given position of the volume curve use the <see cref="M:Un4seen.Bass.Misc.WaveForm.GetVolumeLevel(System.Int64,System.Boolean,System.Int64@,System.Single@)"/> method.</para>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            adding volume points might result in a different position, meaning the position would reflect a different value during playback.
            In such case call the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method to ensure, that the position will be converted accordingly.</para>
            <para>Note: The byte position will be converted to the original rendering resolution according the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/>.
            So if your playback stream has a different resolution never add volume points without first calling <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RemoveVolumePoint(System.Double)">
            <summary>
            Removes an existing volume point from the WaveForm.
            </summary>
            <param name="position">The position (in seconds) of the volume point to remove.</param>
            <returns>TRUE, if the volume point was removed successfully, else FALSE.</returns>
            <remarks>Volume points might be used to draw a volume curve within a WaveForm.
            <para>Use the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawVolume"/> property to define if and how the volume curve should be drawn within the WaveForm. The <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorVolume"/> property will be used as the the drawing color.</para>
            <para>In order to remove a volume point use the <see cref="M:Un4seen.Bass.Misc.WaveForm.RemoveVolumePoint(System.Int64)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllVolumePoints"/> methods.</para>
            <para>Before adding a volume point the <see cref="P:Un4seen.Bass.Misc.WaveForm.Wave"/> buffer must have been created. So make sure this method is only called after <see cref="M:Un4seen.Bass.Misc.WaveForm.WaveFormLoadFromFile(System.String)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStartRecording(System.Int32,System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>.</para>
            <para>Use the <see cref="M:Un4seen.Bass.Misc.WaveForm.GetVolumePoint(System.Int64)"/> method to retrive a certain volume point. To get the volume level at any given position of the volume curve use the <see cref="M:Un4seen.Bass.Misc.WaveForm.GetVolumeLevel(System.Int64,System.Boolean,System.Int64@,System.Single@)"/> method.</para>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            adding volume points might result in a different position, meaning the position would reflect a different value during playback.
            In such case call the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method to ensure, that the position will be converted accordingly.</para>
            <para>Note: The byte position will be converted to the original rendering resolution according the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/>.
            So if your playback stream has a different resolution never add volume points without first calling <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RemoveVolumePointsBetween(System.Int64,System.Int64)">
            <summary>
            Removes all volume points between the two given points exclusive.
            </summary>
            <param name="from">The volume point position (in bytes) from which to remove (exclusive, this point is not removed).</param>
            <param name="to">The volume point position (in bytes) to which to remove (exclusive, this point is not removed).</param>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.RemoveVolumePointsBetween(System.Double,System.Double)">
            <summary>
            Removes all volume points between the two given points exclusive.
            </summary>
            <param name="from">The volume point position (in seconds) from which to remove (exclusive, this point is not removed).</param>
            <param name="to">The volume point position (in seconds) to which to remove (exclusive, this point is not removed).</param>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.ClearAllVolumePoints">
            <summary>
            Removes all volume points from the WaveForm.
            </summary>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>Volume points might be used to draw a volume curve within a WaveForm.
            <para>Use the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawVolume"/> property to define if and how volume points should be drawn within the WaveForm. The <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorVolume"/> property will be used as the the drawing color.</para>
            <para>In order to remove all volume points use the <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllVolumePoints"/> method. If you need to add new volume points or replace an existing volume point use the <see cref="M:Un4seen.Bass.Misc.WaveForm.AddVolumePoint(System.Int64,System.Single)"/> method.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.CreateBitmap(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a bitmap from a rendered wave form.
            </summary>
            <param name="width">The width (in pixel) of the image to create.</param>
            <param name="height">The height (in pixel) of the image to create.</param>
            <param name="frameStart">The rendered frame from where to start creating the image (specify 0 or -1 to start from the beginning).</param>
            <param name="frameEnd">The rendered frame til where to creating the image (specify -1 to create til the end). This value must be greater than frameStart.</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>The created bitmap image representing the wave form.</returns>
            <example>
            <code>
            private Un4seen.Bass.Misc.WaveForm WF = null;
            
            private void GetWaveForm()
            {
              // render a wave form
              WF = new Un4seen.Bass.Misc.WaveForm("test.mp3", 
                                    new Un4seen.Bass.Misc.WAVEFORMPROC(MyWaveFormCallback), this);
              WF.CallbackFrequency = 500; // every 10 seconds rendered
              WF.ColorBackground = Color.Black;
              WF.ColorBase = Color.Lime;
              WF.ColorPeak = Color.Red;
              // it is important to use the same resolution flags as for the playing stream
              // e.g. if an already playing stream is 32-bit float, so this should also be
              // or use 'SyncPlayback' as shown below
              WF.RenderStart(true, BASSFlag.BASS_DEFAULT);
            }
            
            private void MyWaveFormCallback(int framesDone, int framesTotal, TimeSpan elapsedTime, bool finished)
            {
              // will be called during rendering...
              DrawWave();
              if (finished)
              {
                Console.WriteLine("Finished rendering in {0}sec.", elapsedTime);
                Console.WriteLine("FramesRendered={0} of {1}", WF.FramesRendered, WF.FramesToRender);
                // if your playback stream uses a different resolution than the WF
                // use this to sync them
                WF.SyncPlayback(_stream);
              }
            }
            
            private void DrawWave()
            {
              if (WF != null)
                this.pictureBox1.BackgroundImage = WF.CreateBitmap(this.pictureBox1.Width, 
                                                                   this.pictureBox1.Height, 
                                                                   -1, -1, false);
              else
                this.pictureBox1.BackgroundImage = null;
            }
            </code>
            <code lang="vbnet">
            Private WF As Un4seen.Bass.Misc.WaveForm = Nothing
            ...
            Private Sub GetWaveForm()
              ' render a wave form
              WF = New Un4seen.Bass.Misc.WaveForm("test.mp3", New Un4seen.Bass.Misc.WAVEFORMPROC(MyWaveFormCallback), Me)
              WF.CallbackFrequency = 500 ' every 10 seconds rendered
              WF.ColorBackground = Color.Black
              WF.ColorBase = Color.Lime
              WF.ColorPeak = Color.Red
              ' it is important to use the same resolution flags as for the playing stream
              ' e.g. if an already playing stream is 32-bit float, so this should also be
              ' or use 'SyncPlayback' as shown below
              WF.RenderStart(True, BASSFlag.BASS_SAMPLE_FLOAT)
            End Sub
            
            Private Sub MyWaveFormCallback(framesDone As Integer, framesTotal As Integer, 
                                           elapsedTime As TimeSpan, finished As Boolean)
              ' will be called during rendering...
              DrawWave()
              If finished Then
                Console.WriteLine("Finished rendering in {0}sec.", elapsedTime)
                Console.WriteLine("FramesRendered={0} of {1}", WF.FramesRendered, WF.FramesToRender)
                ' if your playback stream uses a different resolution than the WF
                ' use this to sync them
                WF.SyncPlayback(_stream)
              End If
            End Sub
            
            Private Sub DrawWave()
              If Not (WF Is Nothing) Then
                Me.pictureBox1.BackgroundImage = WF.CreateBitmap(Me.pictureBox1.Width, 
                                                                 Me.pictureBox1.Height, 
                                                                 -1, -1, False)
              Else
                Me.pictureBox1.BackgroundImage = Nothing
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.CreateBitmap(System.Drawing.Graphics,System.Drawing.Rectangle,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Draws the rendered wave form directly on the provided GDI+ graphics.
            </summary>
            <param name="g">The GDI+ graphics object where to draw the wave form (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="clipRectangle">The rectangle describing the size of the wave form to draw (ie. can be taken directly from a <see cref="T:System.Windows.Forms.PaintEventArgs"/>).</param>
            <param name="frameStart">The rendered frame from where to start creating the image (specify 0 or -1 to start from the beginning).</param>
            <param name="frameEnd">The rendered frame til where to creating the image (specify -1 to create til the end).</param>
            <param name="highQuality">TRUE, if anti alias should be used when drawing. FALSE will draw in high speed mode.</param>
            <returns>TRUE, if successfully painted, else FALSE.</returns>
            <remarks>This overload is most useful when you are developing your own custom control. You might use it directly within your paint overload implementation.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetBytePositionFromX(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Translates a X coordinate of a drawn WaveForm graphic to the related byte position within the rendered stream.
            </summary>
            <param name="x">The X coordinate from which to get the byte position (between 0 and graphicsWidth-1).</param>
            <param name="graphicsWidth">The total width of the drawn WaveForm graphic (e.g. use pictureBox.Width).</param>
            <param name="frameStart">The rendered frame which was used to start creating the image (specify 0 or -1 if the start was from the beginning).</param>
            <param name="frameEnd">The rendered frame which was used to end creating the image (specify -1 for the end of the WaveForm).</param>
            <returns>The converted byte position of the stream which relates to the given X coordinate, else -1.</returns>
            <remarks>This method might be used to translate a graphics coordinate to a byte position within a stream. The return value might for example be used by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> to set a new playback position.
            <para>Note: The byte position relates to the resolution you used with <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>!
            So if you for example used the BASS_SAMPLE_FLOAT with <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/> the byte position relates to 32-bit sample data.
            However, if your playing stream uses only a 16-bit resolution (e.g. you used BASS_DEFAULT with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>), the returned byte position will not match!
            So make sure when you are calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> with this return value, that your stream resolution is the same as the resolution used with <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>.
            Otherwise you must convert the returned byte position (e.g. from 32-bit to 16-bit: pos = returnvalue/2).
            Or for ease of use you might use the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method to ensure, that the return value of this method will already be converted accordingly for you!
            </para>
            </remarks>
            <example>
            Using a pictureBox and the MouseDown event handler:
            <code>
            // assuming the WaveForm is fully displayed in the pictureBox...
            private void DrawWave()
            {
              if (WF != null)
                this.pictureBox1.BackgroundImage = WF.CreateBitmap(this.pictureBox1.Width, 
                                                                   this.pictureBox1.Height, 
                                                                   -1, -1, false);
              else
                this.pictureBox1.BackgroundImage = null;
            }
            
            private void pictureBox1_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
            {
              if (WF == null)
                return;
              long pos = WF.GetBytePositionFromX(e.X, this.pictureBox1.Width, -1, -1);
              Console.WriteLine("Position = {0}, Seconds = {1}", pos, Bass.BASS_ChannelBytes2Seconds(_stream, pos));
              Bass.BASS_ChannelSetPosition(_stream, pos);
            }
            </code>
            <code lang="vbnet">
            ' assuming the WaveForm is fully displayed in the pictureBox...
            Private Sub DrawWave()
              If Not (WF Is Nothing) Then
                Me.pictureBox1.BackgroundImage = WF.CreateBitmap(Me.pictureBox1.Width, 
                                                                 Me.pictureBox1.Height, 
                                                                 -1, -1, False)
              Else
                Me.pictureBox1.BackgroundImage = Nothing
              End If
            End Sub
            
            Private Sub pictureBox1_MouseDown(sender As Object, e As System.Windows.Forms.MouseEventArgs)
              If WF Is Nothing Then
                Return
              End If
              Dim pos As Long = WF.GetBytePositionFromX(e.X, Me.pictureBox1.Width, - 1, - 1)
              Console.WriteLine("Position = {0}, Seconds = {1}", pos, Bass.BASS_ChannelBytes2Seconds(_stream, pos))
              Bass.BASS_ChannelSetPosition(_stream, pos)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Int64@,System.Int64@,System.Double)">
            <summary>
            Determines silence positions at the beginning and end of a rendered wave form.
            </summary>
            <param name="startpos">Returns the position in bytes where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in bytes where the sound ends (cue-out position).</param>
            <param name="threshold">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning and end of the track.</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            long startpos = 0;
            long endpos   = 0;
            WF.GetCuePoints(ref startpos, ref endpos, -30.0);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Long = 0
            Dim endpos As Long = 0
            WF.GetCuePoints(startpos, endpos, -30.0)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Int64@,System.Int64@,System.Double,System.Double)">
            <summary>
            Determines silence positions at the beginning and end of a rendered wave form.
            </summary>
            <param name="startpos">Returns the position in bytes where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in bytes where the sound ends (cue-out position).</param>
            <param name="thresholdIn">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning of the track.</param>
            <param name="thresholdOut">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the end of the track.</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            long startpos = 0;
            long endpos   = 0;
            WF.GetCuePoints(ref startpos, ref endpos, -30.0, -50.0);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Long = 0
            Dim endpos As Long = 0
            WF.GetCuePoints(startpos, endpos, -30.0, -50.0)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Int64@,System.Int64@,System.Double,System.Double,System.Boolean)">
            <summary>
            Determines silence positions of a rendered wave form within a given range.
            </summary>
            <param name="startpos">Returns the position in bytes where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in bytes where the sound ends (cue-out position).</param>
            <param name="thresholdIn">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning of the track.</param>
            <param name="thresholdOut">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the end of the track.</param>
            <param name="findZeroCrossing">If set to TRUE the cue points will be adjusted to the next resp. previous zero crossing in order to avoid clicks (if set to FALSE the cue points will be adjusted to a quiter sample only).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            long startpos = 0;
            long endpos   = 0;
            WF.GetCuePoints(ref startpos, ref endpos, -24.0, -42.0, true);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Long = 0
            Dim endpos As Long = 0
            WF.GetCuePoints(startpos, endpos, -24.0, -42.0, True)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Int64@,System.Int64@,System.Double,System.Int32,System.Int32)">
            <summary>
            Determines silence positions of a rendered wave form within a given range.
            </summary>
            <param name="startpos">Returns the position in bytes where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in bytes where the sound ends (cue-out position).</param>
            <param name="threshold">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning and end of the track.</param>
            <param name="frameStart">The frame position where to start the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan from the beginning).</param>
            <param name="frameEnd">The frame position til where to perform the silence detection  (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan til the end; must be bigger than frameStart).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            long startpos = 0;
            long endpos   = 0;
            WF.GetCuePoints(ref startpos, ref endpos, -40.0, -1, -1);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Long = 0
            Dim endpos As Long = 0
            WF.GetCuePoints(startpos, endpos, -40.0, -1, -1)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Int64@,System.Int64@,System.Double,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Determines silence positions of a rendered wave form within a given range.
            </summary>
            <param name="startpos">Returns the position in bytes where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in bytes where the sound ends (cue-out position).</param>
            <param name="threshold">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning and end of the track.</param>
            <param name="frameStart">The frame position where to start the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan from the beginning).</param>
            <param name="frameEnd">The frame position til where to perform the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan til the end; must be bigger than frameStart).</param>
            <param name="findZeroCrossing">If set to TRUE the cue points will be adjusted to the next resp. previous zero crossing in order to avoid clicks (if set to FALSE the cue points will be adjusted to a quiter sample only).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            long startpos = 0;
            long endpos   = 0;
            WF.GetCuePoints(ref startpos, ref endpos, -42.0, -1, -1, true);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Long = 0
            Dim endpos As Long = 0
            WF.GetCuePoints(startpos, endpos, -42.0, -1, -1, True)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Int64@,System.Int64@,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Determines silence positions of a rendered wave form within a given range.
            </summary>
            <param name="startpos">Returns the position in bytes where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in bytes where the sound ends (cue-out position).</param>
            <param name="thresholdIn">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning of the track.</param>
            <param name="thresholdOut">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the end of the track.</param>
            <param name="frameStart">The frame position where to start the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan from the beginning).</param>
            <param name="frameEnd">The frame position til where to perform the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan til the end; must be bigger than frameStart).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            long startpos = 0;
            long endpos   = 0;
            WF.GetCuePoints(ref startpos, ref endpos, -24.0, -50.0, -1, -1);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Int64@,System.Int64@,System.Double,System.Double,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Determines silence positions of a rendered wave form within a given range.
            </summary>
            <param name="startpos">Returns the position in bytes where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in bytes where the sound ends (cue-out position).</param>
            <param name="thresholdIn">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning of the track.</param>
            <param name="thresholdOut">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the end of the track.</param>
            <param name="frameStart">The frame position where to start the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan from the beginning).</param>
            <param name="frameEnd">The frame position til where to perform the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan til the end; must be bigger than frameStart).</param>
            <param name="findZeroCrossing">If set to TRUE the cue points will be adjusted to the next resp. previous zero crossing in order to avoid clicks (if set to FALSE the cue points will be adjusted to a quiter sample only).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            long startpos = 0;
            long endpos   = 0;
            WF.GetCuePoints(ref startpos, ref endpos, -30.0, -50.0, -1, -1, true);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Long = 0
            Dim endpos As Long = 0
            WF.GetCuePoints(startpos, endpos, -30.0, -50.0, -1, -1, True)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Double@,System.Double@,System.Double)">
            <summary>
            Determines silence positions at the beginning and end of a rendered wave form.
            </summary>
            <param name="startpos">Returns the position in seconds where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in seconds where the sound ends (cue-out position).</param>
            <param name="threshold">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning and end of the track.</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            double startpos = 0.0;
            double endpos   = 0.0;
            WF.GetCuePoints(ref startpos, ref endpos, -30.0);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Double = 0.0
            Dim endpos As Double = 0.0
            WF.GetCuePoints(startpos, endpos, -30.0)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Double@,System.Double@,System.Double,System.Double)">
            <summary>
            Determines silence positions at the beginning and end of a rendered wave form.
            </summary>
            <param name="startpos">Returns the position in seconds where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in seconds where the sound ends (cue-out position).</param>
            <param name="thresholdIn">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning of the track.</param>
            <param name="thresholdOut">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the end of the track.</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            double startpos = 0.0;
            double endpos   = 0.0;
            WF.GetCuePoints(ref startpos, ref endpos, -30.0, -50.0);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Double = 0.0
            Dim endpos As Double = 0.0
            WF.GetCuePoints(startpos, endpos, -30.0, -50.0)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Double@,System.Double@,System.Double,System.Double,System.Boolean)">
            <summary>
            Determines silence positions of a rendered wave form within a given range.
            </summary>
            <param name="startpos">Returns the position in seconds where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in seconds where the sound ends (cue-out position).</param>
            <param name="thresholdIn">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning of the track.</param>
            <param name="thresholdOut">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the end of the track.</param>
            <param name="findZeroCrossing">If set to TRUE the cue points will be adjusted to the next resp. previous zero crossing in order to avoid clicks (if set to FALSE the cue points will be adjusted to a quiter sample only).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            double startpos = 0.0;
            double endpos   = 0.0;
            WF.GetCuePoints(ref startpos, ref endpos, -24.0, -42.0, true);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Double = 0.0
            Dim endpos As Double = 0.0
            WF.GetCuePoints(startpos, endpos, -24.0, -42.0, True)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Double@,System.Double@,System.Double,System.Int32,System.Int32)">
            <summary>
            Determines silence positions of a rendered wave form within a given range.
            </summary>
            <param name="startpos">Returns the position in seconds where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in seconds where the sound ends (cue-out position).</param>
            <param name="threshold">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning and end of the track.</param>
            <param name="frameStart">The frame position where to start the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan from the beginning).</param>
            <param name="frameEnd">The frame position til where to perform the silence detection  (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan til the end; must be bigger than frameStart).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            double startpos = 0.0;
            double endpos   = 0.0;
            WF.GetCuePoints(ref startpos, ref endpos, -40.0, -1, -1);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Double = 0.0
            Dim endpos As Double = 0.0
            WF.GetCuePoints(startpos, endpos, -40.0, -1, -1)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Double@,System.Double@,System.Double,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Determines silence positions of a rendered wave form within a given range.
            </summary>
            <param name="startpos">Returns the position in seconds where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in seconds where the sound ends (cue-out position).</param>
            <param name="threshold">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning and end of the track.</param>
            <param name="frameStart">The frame position where to start the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan from the beginning).</param>
            <param name="frameEnd">The frame position til where to perform the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan til the end; must be bigger than frameStart).</param>
            <param name="findZeroCrossing">If set to TRUE the cue points will be adjusted to the next resp. previous zero crossing in order to avoid clicks (if set to FALSE the cue points will be adjusted to a quiter sample only).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            double startpos = 0.0;
            double endpos   = 0.0;
            WF.GetCuePoints(ref startpos, ref endpos, -42.0, -1, -1, true);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Double = 0.0
            Dim endpos As Double = 0.0
            WF.GetCuePoints(startpos, endpos, -42.0, -1, -1, True)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Double@,System.Double@,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Determines silence positions of a rendered wave form within a given range.
            </summary>
            <param name="startpos">Returns the position in seconds where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in seconds where the sound ends (cue-out position).</param>
            <param name="thresholdIn">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning of the track.</param>
            <param name="thresholdOut">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the end of the track.</param>
            <param name="frameStart">The frame position where to start the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan from the beginning).</param>
            <param name="frameEnd">The frame position til where to perform the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan til the end; must be bigger than frameStart).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>
            <para>If your rendering method and your playback stream used different flags during creation (e.g. rendering was done using the BASS_DEFAULT flag whereas your playback stream uses BASS_SAMPLE_FLOAT)
            getting the cue points might result in different positions, meaning the positions would reflect a different value during playback.
            But if you called the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> method this will ensure, that the position will be converted accordingly.</para>
            </remarks>
            <example>
            <code>
            double startpos = 0.0;
            double endpos   = 0.0;
            WF.GetCuePoints(ref startpos, ref endpos, -24.0, -50.0, -1, -1);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Double = 0.0
            Dim endpos As Double = 0.0
            WF.GetCuePoints(startpos, endpos, -24.0, -50.0, -1, -1)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetCuePoints(System.Double@,System.Double@,System.Double,System.Double,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Determines silence positions of a rendered wave form within a given range.
            </summary>
            <param name="startpos">Returns the position in seconds where the sound begins (cue-in position).</param>
            <param name="endpos">Returns the position in seconds where the sound ends (cue-out position).</param>
            <param name="thresholdIn">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the beginning of the track.</param>
            <param name="thresholdOut">The threshold in dB (e.g. -24.0dB) which should be used to detect silence resp. sound at the end of the track.</param>
            <param name="frameStart">The frame position where to start the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan from the beginning).</param>
            <param name="frameEnd">The frame position til where to perform the silence detection (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan til the end; must be bigger than frameStart).</param>
            <param name="findZeroCrossing">If set to TRUE the cue points will be adjusted to the next resp. previous zero crossing in order to avoid clicks (if set to FALSE the cue points will be adjusted to a quiter sample only).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <example>
            <code>
            double startpos = 0.0;
            double endpos   = 0.0;
            WF.GetCuePoints(ref startpos, ref endpos, -30.0, -50.0, -1, -1, true);
            WF.AddMarker( "CUE", startpos );
            WF.AddMarker( "END", endpos );
            ...
            </code>
            <code lang="vbnet">
            Dim startpos As Double = 0.0
            Dim endpos As Double = 0.0
            WF.GetCuePoints(startpos, endpos, -30.0, -50.0, -1, -1, True)
            WF.AddMarker("CUE", startpos)
            WF.AddMarker("END", endpos)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.GetNormalizationGain(System.Int32,System.Int32)">
            <summary>
            Determines a gain factor (normalization), so that the maximum peak level of the sample data will be at 0 dB.
            </summary>
            <param name="frameStart">The frame position where to start the calculation (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan from the beginning).</param>
            <param name="frameEnd">The frame position til where to perform the calculation (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>, or -1 to scan til the end; must be bigger than frameStart).</param>
            <returns>The gain factor as a float value.</returns>
            <remarks>
            You might use the gain factor as a multiplier to the sample data to apply a volume adjustment, so that the maximum peak level of the audio samples is at 0 dB.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.DetectNextLevel(System.Int64,System.Double,System.Boolean,System.Boolean)">
            <summary>
            Finds the next position with a certain volume level.
            </summary>
            <param name="startpos">The position in bytes where to start the search.</param>
            <param name="threshold">The threshold in dB (e.g. -12.0dB) which should be searched.</param>
            <param name="reverse">Search forward (FALSE) or backward (TRUE).</param>
            <param name="findZeroCrossing">If set to TRUE the returned position will be adjusted to the next resp. previous zero crossing in order to avoid clicks.</param>
            <returns>The position with the respective volume level (if the level could not be detected, then startpos will be returned).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.DetectNextLevel(System.Double,System.Double,System.Boolean,System.Boolean)">
            <summary>
            Finds the next position with a certain volume level.
            </summary>
            <param name="startpos">The position in seconds where to start the search.</param>
            <param name="threshold">The threshold in dB (e.g. -12.0dB) which should be searched.</param>
            <param name="reverse">Search forward (FALSE) or backward (TRUE).</param>
            <param name="findZeroCrossing">If set to TRUE the returned position will be adjusted to the next resp. previous zero crossing in order to avoid clicks.</param>
            <returns>The position with the respective volume level (if the level could not be detected, then startpos will be returned).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.FindPreviousZeroCrossing(System.Int64)">
            <summary>
            Finds the previous zero crossing position related to the given position (backward seeking).
            </summary>
            <param name="position">The position where to start the search.</param>
            <returns>The previous zero crossing position.</returns>
            <remarks>If the given position already denotes a zero-crossing position the same position will be returned.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.FindNextZeroCrossing(System.Int64)">
            <summary>
            Finds the next zero crossing position related to the given position (forward seeking).
            </summary>
            <param name="position">The position where to start the search.</param>
            <returns>The next zero crossing position.</returns>
            /// <remarks>If the given position already denotes a zero-crossing position the same position will be returned.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.PeakLevelOfFrame(System.Int32)">
            <summary>
            Returns the peak level (between 0 and 32767) of a given frame position.
            </summary>
            <param name="pos">The frame position (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>) to get the peak level from.</param>
            <returns>The peak level between 0 and 32767 of the given position.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.IsZeroCrossingFrame(System.Int32,System.Int32)">
            <summary>
            Detects, if the two given positions reflect a zero crossing.
            </summary>
            <param name="pos1">The frame position1 (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>) to check for zero crossing.</param>
            <param name="pos2">The frame position2 (between 0 and <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesRendered"/>) to check for zero crossing.</param>
            <returns>TRUE, if the given positions denote a crossing of a zero level of either the left or right channel - else FALSE.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.Render(System.Boolean,System.Threading.ThreadPriority,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Performs the actual rendering.
            </summary>
            <param name="background">TRUE = in background thread.</param>
            <param name="prio">The thread priority to be used with the background thread (default is BelowNormal).</param>
            <param name="flags">The stream create flags.</param>
            <param name="chans">The number of channels (1=mono, 2=stereo, etc.)</param>
            <returns>TRUE = successfully started/executed.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.ScanPeaks">
            <summary>
            Does the actual scanning of the peak levels
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.InvokeCallback(System.Boolean)">
            <summary>
            Calls the notification handler.
            </summary>
            <param name="finished">TRUE, if the render process has finished.</param>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.DrawBitmap(System.Drawing.Graphics,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.Pen,System.Drawing.Pen,System.Drawing.Pen,System.Drawing.Pen,System.Drawing.Pen,System.Drawing.Pen,System.Drawing.Pen)">
            <summary>
            Internal method to draw the actual wave form.
            </summary>
            <param name="g">The graphics object where to draw.</param>
            <param name="width">width to draw</param>
            <param name="height">height to draw</param>
            <param name="frameStart">starting frame</param>
            <param name="frameEnd">ending frame</param>
            <param name="pLeft">pen left</param>
            <param name="pLeftEnv">pen left</param>
            <param name="pRight">pen right</param>
            <param name="pRightEnv">pen right</param>
            <param name="pMarker">pen marker</param>
            <param name="pBeat">pen beat</param>
            <param name="pVolume">pen volume</param>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.WaveFormSaveToFile(System.String)">
            <summary>
            Saves a rendered WaveForm to a file.
            </summary>
            <param name="fileName">The file name to save the rendered data to.</param>
            <returns>TRUE on success, else FALSE.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.WaveFormSaveToMemory">
            <summary>
            Saves a rendered WaveForm to a byte array.
            </summary>
            <returns>The byte array containing the serialized data of the wave form.</returns>
            <example>
            <code>
            private byte[] waveformSave;
            ...
            // save the wave form to a byte array
            waveformSave = WF.WaveFormSaveToMemory();
            ..
            // load the wave form to a byte array
            WF = new Un4seen.Bass.Misc.WaveForm();
            WF.WaveFormLoadFromMemory( waveformSave );
            WF.DrawMarker = WaveForm.MARKERDRAWTYPE.Line | WaveForm.MARKERDRAWTYPE.Name | WaveForm.MARKERDRAWTYPE.NamePositionAlternate;
            this.pictureBox1.BackgroundImage = WF.CreateBitmap( this.pictureBox1.Width, this.pictureBox1.Height, -1, -1, true);
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.WaveFormLoadFromFile(System.String)">
            <summary>
            Loads a rendered WaveForm from a file.
            </summary>
            <param name="fileName">The file name to load the rendered data from.</param>
            <returns>TRUE on success, else FALSE.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.WaveFormLoadFromMemory(System.Byte[])">
            <summary>
            Loads a rendered WaveForm from a byte array.
            </summary>
            <param name="data">The byte array to load the rendered data from (e.g. created with <see cref="M:Un4seen.Bass.Misc.WaveForm.WaveFormSaveToMemory"/>).</param>
            <returns>TRUE on success, else FALSE.</returns>
            <example>
            <code>
            private byte[] waveformSave;
            ...
            // save the wave form to a byte array
            waveformSave = WF.WaveFormSaveToMemory();
            ..
            // load the wave form to a byte array
            WF = new Un4seen.Bass.Misc.WaveForm();
            WF.WaveFormLoadFromMemory( waveformSave );
            WF.DrawMarker = WaveForm.MARKERDRAWTYPE.Line | WaveForm.MARKERDRAWTYPE.Name | WaveForm.MARKERDRAWTYPE.NamePositionAlternate;
            this.pictureBox1.BackgroundImage = WF.CreateBitmap( this.pictureBox1.Width, this.pictureBox1.Height, -1, -1, true);
            </code>
            </example>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.FileName">
            <summary>
            Gets or Sets the file name to render. Needs to be set before calling the RenderFile method.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.FrameResolution">
            <summary>
            Gets or Sets the rendering resolution in milliseconds. The resolution defines the length of one frame which is the smallest unit to display.
            <para>The minimum is 0.001 (1ms) and the maximum is 5.0 (5000ms, 5sec.).
            Default is 0.02 = 20ms.</para>
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.CallbackFrequency">
            <summary>
            Gets or Sets the frequency in <see cref="P:Un4seen.Bass.Misc.WaveForm.FrameResolution"/> frames - how often the <see cref="T:Un4seen.Bass.Misc.WAVEFORMPROC"/> callback should be invoked (default=250, every 5sec. - if the FrameResolution is set to 20ms).
            <para>Specify 0, if you want to invoke the callback only at the end of the rendering process.</para>
            <para>Example: Specify 50, if you want the callback to be called for every second of the deconding stream (slow - if the FrameResolution is set to 20ms).
            Or specify 500 to invoke the callback for every 10 seconds (if the FrameResolution is set to 20ms) rendered.
            Default is 250 = every 5sec. (if the FrameResolution is set to 20ms default).</para>
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.NotifyHandler">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.Misc.WAVEFORMPROC"/> callback delegete which should be invoked during the rendering progress started with <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.WinControl">
            <summary>
            Gets or Sets the application window control (use null for console applications).
            <para>This window control will be used to invoke the <see cref="T:Un4seen.Bass.Misc.WAVEFORMPROC"/> (if set), so that the callback will be executed in the 'correct' GUI thread, if the background option was set during <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/>.</para>
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.IsRendered">
            <summary>
            Gets, if the wave form has already been rendered.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.IsRenderingInProgress">
            <summary>
            Gets, if the wave form rendering process is still in progress.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.FramesToRender">
            <summary>
            Gets how many frames have to be rendered in total (one frame = <see cref="P:Un4seen.Bass.Misc.WaveForm.FrameResolution"/> ms).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.FramesRendered">
            <summary>
            Gets how many frames have been rendered (one frame = <see cref="P:Un4seen.Bass.Misc.WaveForm.FrameResolution"/> ms).
            <para>When rendering has finished this should be equal to <see cref="P:Un4seen.Bass.Misc.WaveForm.FramesToRender"/>.</para>
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.DetectBeats">
            <summary>
            Gets or Sets, if the beat positions should also be detected during the rendering process.
            </summary>
            <remarks>Note: If enabled BASS_FX is required!
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.TempoFactor">
            <summary>
            Gets or Sets the tempo adjustment factor in percent (e.g. 0.05 for +5% or -0.1 for -10%, default is 0).
            </summary>
            <remarks>Make sure to set this property after you have called <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> (when this is needed), since <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> will reset the tempo factor to 0.
            <para>Adjusting the tempo factor might be desired, if you want to display a zoomed wave form according to the current playback speed/tempo, if that was changes e.g. by a BASS_FX tempo stream.
            Normally this is only needed, if you display two or more partial (zoomed) wave forms in parallel.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.SyncFactor">
            <summary>
            Gets the current sync factor between rendering and playback.
            </summary>
            <remarks>The factor will reflect the difference between the resolution used during rendering and playback (e.g. because different stream flags have been used during rendering and during playback - for example rendering is done in 16-bit whereas the playback stream is using 32-bit float).
            In addition the sync factor also reflects the <see cref="P:Un4seen.Bass.Misc.WaveForm.TempoFactor"/> (as the rendering is always done in the original speed whereas playback might be done at a different speed).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.GainFactor">
            <summary>
            Gets or Sets a gain factor which should be used when creating the WaveForm image to amplify the amplitude (default is 1.0 = no amplification).
            </summary>
            <remarks>The gain factor amplifies the entire WaveForm amplitude.
            Values below 1.0 will lower the signal amplitude in the image, values above 1.0 will raise the signal amplitude in the image.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.Wave">
            <summary>
            Gets or Sets the rendered wave buffer instance, ie. lets you access the peak levels scanned.
            </summary>
            <remarks>Setting this property is not recommended, but possible e.g. if you want to create a reference copy of an already rendered WaveForm.
            Note, that when assigning a <see cref="T:Un4seen.Bass.Misc.WaveForm.WaveBuffer"/> from another instance a reference is create (not a full copy).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.ColorBackground">
            <summary>
            Gets or Sets the background color to be used when drawing the wave form image (Default = SystemColors.Control).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.ColorLeft">
            <summary>
            Gets or Sets the base color (left channel) to be used when drawing the wave form image (Default = Color.Gainsboro).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.ColorLeft2">
            <summary>
            Gets or Sets the gradient color (left channel) to be used when drawing the wave form image (Default = Color.Gainsboro).
            </summary>
            <remarks>This property is only used if <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawGradient"/> is set to TRUE.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.ColorLeftEnvelope">
            <summary>
            Gets or Sets the envelope color (left channel) to be used when drawing the wave form image (Default = Color.Gray).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.DrawEnvelope">
            <summary>
            Gets or Sets a flag if the envelope should be drawn in the wave form image (Default = TRUE).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.DrawGradient">
            <summary>
            Gets or Sets a flag if the wave form should be drawn in gradient mode (Default = FALSE).
            </summary>
            <remarks>If set to TRUE the <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorLeft"/> and <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorLeftEnvelope"/> resp. the <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorRight"/> and <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorRightEnvelope"/></remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.ColorRight">
            <summary>
            Gets or Sets the base color (right channel) to be used when drawing the wave form image (Default = Color.LightGray).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.ColorRight2">
            <summary>
            Gets or Sets the gradient color (right channel) to be used when drawing the wave form image (Default = Color.White).
            </summary>
            <remarks>This property is only used if <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawGradient"/> is set to TRUE.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.ColorRightEnvelope">
            <summary>
            Gets or Sets the envelope color (right channel) to be used when drawing the wave form image (Default = Color.DimGray).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.ColorVolume">
            <summary>
            Gets or Sets the color to be used when drawing volume curve (Default = Color.IndianRed).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.DrawVolume">
            <summary>
            Gets or Sets if and how a volume curve should be drawn in the WaveForm (Default = None).
            </summary>
            <remarks>
            Volume Curve Drawing Type: Defines how the volume curve should be drawn with the WaveForm:
            <list type="table">
            <item><term>None</term><description>No volume curve will be drawn at all.</description></item>
            <item><term>Solid</term><description>A solid volume curve will be drawn over the WaveForm.</description></item>
            <item><term>Dotted</term><description>A dotted volume curve will be drawn over the WaveForm.</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.VolumeCurveZeroLevel">
            <summary>
            Gets or Sets if the initial level when drawing a volume curve should be silent (default is FALSE).
            </summary>
            <remarks>If TRUE the initial level at the beginning and end of the wave form is 0 (silent) - else it is at maximum (0dB).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.ColorBeat">
            <summary>
            Gets or Sets the color to be used when drawing beat position marker (Default = Color.CornflowerBlue).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.DrawBeat">
            <summary>
            Gets or Sets if and how beat position should be drawn in the WaveForm (Default = None).
            </summary>
            <remarks>
            Beat Drawing Type: use one of the  <see cref="T:Un4seen.Bass.Misc.WaveForm.BEATDRAWTYPE"/> flags:
            <list type="table">
            <item><term>None</term><description>No beat positions will be drawn at all.</description></item>
            <item><term>Top</term><description>The beat position lines will be drawn at the top of the WaveForm.</description></item>
            <item><term>Bottom</term><description>The beat position lines will be drawn at the bottom of the WaveForm.</description></item>
            <item><term>Middle</term><description>The beat position lines will be drawn in the middle of the WaveForm.</description></item>
            <item><term>TopBottom</term><description>The beat position lines will be drawn at the top and bottom of the WaveForm.</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.BeatLength">
            <summary>
            Gets or Sets the length of the beat position line to be drawn in percentage of the total height (default is 0.05 = 5%).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.BeatWidth">
            <summary>
            Gets or Sets the width in pixel of the beat position line to be drawn (default is 1px).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.ColorMarker">
            <summary>
            Gets or Sets the color to be used when drawing a marker (Default = Color.DarkBlue).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.DrawMarker">
            <summary>
            Gets or Sets if and how markers should be drawn in the WaveForm (Default = None).
            </summary>
            <remarks>
            Marker Drawing Type: use any combination of the <see cref="T:Un4seen.Bass.Misc.WaveForm.MARKERDRAWTYPE"/> flags:
            <list type="table">
            <item><term>None</term><description>No markers will be drawn at all.</description></item>
            <item><term>Line</term><description>The markers lines will be drawn.</description></item>
            <item><term>Name</term><description>The name of the markers will be drawn.</description></item>
            <item><term>NamePositionAlternate</term><description>When marker names are drawn, they are drawn in an alternate way (top, bottom, top, bottom, ...).</description></item>
            <item><term>NamePositionTop</term><description>When marker names are drawn, they are drawn on top of the marker lines.</description></item>
            <item><term>NamePositionBottom</term><description>When marker names are drawn, they are drawn on top of the marker lines.</description></item>
            <item><term>NamePositionMiddle</term><description>When marker names are drawn, they are drawn in the middle of the marker lines.</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.MarkerLength">
            <summary>
            Gets or Sets the length of the marker line to be drawn in percentage of the total height (default is 0.1 = 10%).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.DrawWaveForm">
            <summary>
            Gets or Sets how the wave form should be drawn (Default = Stereo).
            </summary>
            <remarks>
            WaveForm Drawing Type: use one of the following <see cref="T:Un4seen.Bass.Misc.WaveForm.WAVEFORMDRAWTYPE"/>:
            <list type="table">
            <item><term>Stereo</term><description>Two independent wave forms will be drawn (upper=left channel, lower=right channel).</description></item>
            <item><term>Mono</term><description>One combined mono wave form will be drawn.</description></item>
            <item><term>DualMono</term><description>Two overloaded mono wave forms (left, right) will be drawn.</description></item>
            <item><term>HalfMono</term><description>One combined mirrored half mono wave form will be drawn.</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.WaveForm.MARKERDRAWTYPE">
            <summary>
            Marker Drawing Type: Defines how markers should be drawn with the WaveForm - any combination of the following flags:
            <list type="table">
            <item><term>None</term><description>No markers will be drawn at all.</description></item>
            <item><term>Line</term><description>The markers lines will be drawn.</description></item>
            <item><term>Name</term><description>The name of the markers will be drawn.</description></item>
            <item><term>NamePositionAlternate</term><description>When marker names are drawn, they are drawn in an alternate way (top, bottom, top, bottom, ...) - default.</description></item>
            <item><term>NamePositionTop</term><description>When marker names are drawn, they are drawn on top of the marker lines.</description></item>
            <item><term>NamePositionBottom</term><description>When marker names are drawn, they are drawn on top of the marker lines.</description></item>
            <item><term>NamePositionMiddle</term><description>When marker names are drawn, they are drawn in the middle of the marker lines.</description></item>
            </list>
            </summary>
            <remarks>Used in the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawMarker"/> property.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.MARKERDRAWTYPE.None">
            <summary>
            No markers will be drawn at all.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.MARKERDRAWTYPE.Line">
            <summary>
            The markers lines will be drawn.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.MARKERDRAWTYPE.Name">
            <summary>
            The name of the markers will be drawn.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.MARKERDRAWTYPE.NamePositionAlternate">
            <summary>
            When marker names are drawn, they are drawn in an alternate way (top, bottom, top, bottom, ...) - default.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.MARKERDRAWTYPE.NamePositionTop">
            <summary>
            When marker names are drawn, they are drawn on top of the marker lines.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.MARKERDRAWTYPE.NamePositionBottom">
            <summary>
            When marker names are drawn, they are drawn on top of the marker lines.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.MARKERDRAWTYPE.NamePositionMiddle">
            <summary>
            When marker names are drawn, they are drawn in the middle of the marker lines.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.WaveForm.VOLUMEDRAWTYPE">
            <summary>
            Volume Curve Drawing Type: Defines how the volume curve should be drawn with the WaveForm:
            <list type="table">
            <item><term>None</term><description>No volume curve will be drawn at all.</description></item>
            <item><term>Solid</term><description>A solid volume curve will be drawn over the WaveForm.</description></item>
            <item><term>Dotted</term><description>A dotted volume curve will be drawn over the WaveForm.</description></item>
            </list>
            </summary>
            <remarks>Used in the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawVolume"/> property.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.VOLUMEDRAWTYPE.None">
            <summary>
            No volume curve will be drawn at all.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.VOLUMEDRAWTYPE.Solid">
            <summary>
            A solid volume curve will be drawn over the WaveForm.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.VOLUMEDRAWTYPE.Dotted">
            <summary>
            A dotted volume curve will be drawn over the WaveForm.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.WaveForm.BEATDRAWTYPE">
            <summary>
            Beat Drawing Type: Defines how beat positions should be drawn with the WaveForm:
            <list type="table">
            <item><term>None</term><description>No beat positions will be drawn at all.</description></item>
            <item><term>Top</term><description>The beat position lines will be drawn at the top of the WaveForm.</description></item>
            <item><term>Bottom</term><description>The beat position lines will be drawn at the bottom of the WaveForm.</description></item>
            <item><term>Middle</term><description>The beat position lines will be drawn in the middle of the WaveForm.</description></item>
            <item><term>TopBottom</term><description>The beat position lines will be drawn at the top and bottom of the WaveForm.</description></item>
            </list>
            </summary>
            <remarks>Used in the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawBeat"/> property.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.BEATDRAWTYPE.None">
            <summary>
            No beat position will be drawn at all.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.BEATDRAWTYPE.Top">
            <summary>
            The beat position lines will be drawn at the top of the WaveForm.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.BEATDRAWTYPE.Bottom">
            <summary>
            The beat position lines will be drawn at the bottom of the WaveForm.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.BEATDRAWTYPE.Middle">
            <summary>
            The beat position lines will be drawn in the middle of the WaveForm.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.BEATDRAWTYPE.TopBottom">
            <summary>
            The beat position lines will be drawn at the top and bottom of the WaveForm.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.WaveForm.WAVEFORMDRAWTYPE">
            <summary>
            WaveForm Drawing Type: Defines how the wave form should be drawn:
            <list type="table">
            <item><term>Stereo</term><description>Two independent wave forms will be drawn (upper=left channel, lower=right channel).</description></item>
            <item><term>Mono</term><description>One combined mono wave form will be drawn.</description></item>
            <item><term>DualMono</term><description>Two overloaded mono wave forms (left, right) will be drawn.</description></item>
            <item><term>HalfMono</term><description>One combined mirrored half mono wave form will be drawn.</description></item>
            </list>
            </summary>
            <remarks>Used in the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawMarker"/> property.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WAVEFORMDRAWTYPE.Stereo">
            <summary>
            Two independent wave forms will be drawn (upper=left channel, lower=right channel).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WAVEFORMDRAWTYPE.Mono">
            <summary>
            One combined mono wave form will be drawn (using <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorLeft"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WAVEFORMDRAWTYPE.DualMono">
            <summary>
            Two overloaded mono wave forms (left, right both centered) will be drawn.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WAVEFORMDRAWTYPE.HalfMono">
            <summary>
            One combined mirrored half mono wave form will be drawn (using <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorLeft"/>).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.WaveForm.WaveBuffer">
            <summary>
            The internal class containing the rended wave buffer data (in frames).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.WaveBuffer.#ctor">
            <summary>
            Internal Constructor.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.fileName">
            <summary>
            Will keep the related stream file name (if set). Only used internally for serialization.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.flags">
            <summary>
            Will keep the stream create flags (as an int), see <see cref="T:Un4seen.Bass.BASSFlag"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.chans">
            <summary>
            Number of channels (1=mono, 2=stereo, ...).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.bpf">
            <summary>
            Bytes per frame (one frame is a window with the length defined in <see cref="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.resolution"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.resolution">
            <summary>
            Frame resolution in milliseconds
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.data">
            <summary>
            Data buffer containing the rendered peak levels of the right and left channel (one element represents the data of one frame).
            <para>The <see cref="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.Level.left"/> and <see cref="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.Level.right"/> values represent each the absolute signed maximum value of the left resp. right channel' sample data within the rendered frame (e.g. -10000 would be kept instead of +8000).
            If the channel is mono, then the left and right value of the <see cref="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.data"/> would contain the same value.</para>
            <para>Structure of one <see cref="T:Un4seen.Bass.Misc.WaveForm.WaveBuffer.Level"/> element:
            <code>
            |       32-bit      |
            |   left  |  right  |
            </code>
            </para>
            <para>Each level ranges linearly from -32768 to 0 (silent) to +32767.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.marker">
            <summary>
            List of optional markers within the WaveForm (or NULL, if no markers are defined).
            <para>Key (string) = Name of the marker, Value (long) = Position of the marker (in bytes of the rendering resolution).</para>
            </summary>
            <remarks>Markers might be used to highlight certain positions within a WaveForm, e.g. Cue-, Ramp-, Fade- or Mix-Points.
            <para>Use the <see cref="P:Un4seen.Bass.Misc.WaveForm.DrawMarker"/> property to define if and how markers should be drawn within the WaveForm. The <see cref="P:Un4seen.Bass.Misc.WaveForm.ColorMarker"/> property will be used as the the drawing color.</para>
            <para>Markers can be get, set or removed by using the <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarker(System.String)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.AddMarker(System.String,System.Int64)"/>, <see cref="M:Un4seen.Bass.Misc.WaveForm.RemoveMarker(System.String)"/> or <see cref="M:Un4seen.Bass.Misc.WaveForm.ClearAllMarker"/> methods.</para>
            <para>Note: When using the <see cref="M:Un4seen.Bass.Misc.WaveForm.AddMarker(System.String,System.Int64)"/> method the position (in byte) will be converted to the original rendering resolution.
            And when using the <see cref="M:Un4seen.Bass.Misc.WaveForm.GetMarker(System.String)"/> method the position will automatically be converted according to the <see cref="M:Un4seen.Bass.Misc.WaveForm.SyncPlayback(System.Int32)"/> stream.
            However, if you try to access this member directly keep in mind, that marker positions should be according to it's original rendering resolution!</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.beats">
            <summary>
            List of optional beat positions within the WaveForm (or NULL, if no beat positions have been detected).
            <para>Each Element reflects one beat position (long value, in bytes of the original rendering resolution).</para>
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.WaveForm.WaveBuffer.bps">
            <summary>
            Returns the bytes per sample (16-bit samples will return 2, 32-bit samples will return 4 and 8-bit samples will return 1).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.WaveForm.WaveBuffer.Level">
            <summary>
            This structure represents one element of a <see cref="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.data"/> array.
            It consists of a <see cref="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.Level.left"/> and <see cref="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.Level.right"/> value (both in the range of -32768 and +32767).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.Level.left">
            <summary>
            The signed maximum value of the left channel of the the wave buffer data at this point.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.WaveBuffer.Level.right">
            <summary>
            The signed maximum value of the right channel of the the wave buffer data at this point.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.WaveBuffer.Level.#ctor(System.Int16,System.Int16)">
            <summary>
            Creates a new instance of the Level structure taking the given values.
            </summary>
            <param name="levelL">The left level value.</param>
            <param name="levelR">The right level value.</param>
        </member>
        <member name="T:Un4seen.Bass.Misc.WaveForm.VolumePoint">
            <summary>
            The class represents a volume point to be used to draw a volume curve within the wave form.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.VolumePoint.Position">
            <summary>
            Original position of the volume point.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.WaveForm.VolumePoint.Level">
            <summary>
            0f=silent, 1f=0dB.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.VolumePoint.#ctor(System.Int64,System.Single)">
            <summary>
            Creates a new volume point instance.
            </summary>
            <param name="position">The byte position.</param>
            <param name="level">The volume level between 0f (silent) and 1f (max=0dB).</param>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.VolumePoint.ToString">
            <summary>
            Returns the string representation of a wave form volume point.
            </summary>
            <returns>The string of this instance representation.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.WaveForm.VolumePoint.CompareTo(System.Object)">
            <summary>
            Compares the current <see cref="T:Un4seen.Bass.Misc.WaveForm.VolumePoint"/> object to another object based on it's <see cref="F:Un4seen.Bass.Misc.WaveForm.VolumePoint.Position"/>.
            </summary>
            <param name="obj">The VolumePoint object to compare to.</param>
            <returns>If the two objects are of the type VolumePoint, the method behaves exactly like long.CompareTo, and the returned values are: -1 if the position value is greater than the position value of the current object. 
            0 if the two positions are identical. 1 if the position value is less than the position value of the current object.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is not a VolumePoint.</exception>
        </member>
        <member name="T:Un4seen.Bass.Misc.WAVEFORMPROC">
            <summary>
            Callback which will be invoked during <see cref="M:Un4seen.Bass.Misc.WaveForm.RenderStart(System.Int32,System.Boolean)"/> to give feedback about the current rendering progress.
            </summary>
            <param name="framesDone">The number of frames already rendered.</param>
            <param name="framesTotal">The total number of frames to render.</param>
            <param name="elapsedTime">The already elapsed rendering time.</param>
            <param name="finished">TRUE, when rendering has finished - else FALSE (still rendering).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Wma.BassWma">
            <summary>
            BASS.NET API wrapper for BASSWMA.DLL
            <para>Requires: basswma.dll - Windows Media Audio Format (WMA) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            <para>The Windows Media Format modules are also required to be installed on the user's system. They are installed with Windows Media Player, so will already be on most users' systems, but they can also be installed separately (WMFDIST.EXE).</para>
            </summary>
            <remarks>
            <para>BASSWMA is an extension to the BASS audio library, enabling the playback of WMA files and network streams. The audio tracks of WMV files can also be played. WMA file encoding and network broadcasting functions are also provided.</para>
            <para>The WMA format is used in very much the same way as any of the built-in BASS stream formats - simply call the WMA stream creation function instead of the BASS built-in functions. The BASS plugin system (see <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>) is also supported for local WMA files.</para>
            <para>More information can be found on <a href="http://www.microsoft.com/windows/windowsmedia">Microsoft Windows Media — Your Digital Entertainment Resource</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFileIStream(System.Int32,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="istream"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateIStream(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from an IStream object.
            </summary>
            <param name="istream">A pointer to an IStream object.</param>
            <param name="offset">Unused... set to 0.</param>
            <param name="length">Unused... set to 0.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The bitrate (amongst other things) can be retrieved through <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_WMA). When retrieving tags, a pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</para>
            <para>The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>. Until the whole file has been streamed, whatever length the file's header says is returned, which may or may not be exact.</para>
            <para>Although the Windows Media modules uses it's own internet streaming code (not BASS's), the BASS_CONFIG_NET_TIMEOUT (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) config option does have effect when opening WMA streams. None of the other NET config options apply.</para>
            <para>With local files, <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> works the same as with the BASS built-in stream formats. But when internet streaming, the Windows Media modules uses it's own streaming routines.
            The download progress of an internet streamed file can be retrieved with <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> (BASS_FILEPOS_DOWNLOAD). The file size (BASS_FILEPOS_END) can also be retrieved, but getting the size of internet streamed files requires Windows Media 9 to be installed. 
            The decode position (BASS_FILEPOS_CURRENT) is not available. When streaming a file from the internet, it is not possible to seek with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> until the whole file has been downloaded. A sync (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> with BASS_SYNC_DOWNLOAD) can be set to be notified when the file has been downloaded.</para>
            <para>When streaming a file from the internet, it's not possible to seek with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> until the whole file has been downloaded. A sync (BASS_SYNC_DOWNLOAD) can be set to be notified when the file has been downloaded.</para>
            <para>With Windows Media versions prior to 9 (and when streaming from the internet), WMA decoding is performed in a separate thread, so the CPU used to decode a file/stream during playback will not be included in the <see cref="M:Un4seen.Bass.Bass.BASS_GetCPU"/> return value.</para>
            <para>When using the BASS_STREAM_DECODE flag, it's not possible to play the stream. Because the decoded sample data is not outputted, "decoding channels" can still be used when there is no output device (using the "no sound" device with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>).</para>
            <para>The sample rate of local files can be altered with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. But the playback rate of internet streams should not be changed, because they are decoded at a fixed rate - the rate required to sustain playback at normal speed. So increasing the rate will result in playback stalling.</para>
            <para>Using VBR, lossless and multi-channel WMA files/streams requires Windows Media 9 to be installed.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One or more of the parameters are invalid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>There is no appropriate codec installed to decode the file. Try installing the latest Windows Media codecs.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_WMA_LICENSE</term><description>The WMA file can not be played because it is protected.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a WMA file.
            <para>This overload implements unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="file">Filename or URL for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from (Unused, set to 0).</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The bitrate (amongst other things) can be retrieved through <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_WMA). When retrieving tags, a pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</para>
            <para>The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>. Until the whole file has been streamed, whatever length the file's header says is returned, which may or may not be exact.</para>
            <para>Unless the BASS_CONFIG_WMA_BASSFILE config option is enabled, the Windows Media modules uses its own file reading routines, and the <paramref name="offset"/> and <paramref name="length"/> parameters are ignored, except that length is still the length when playing from memory. 
            Also, <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> isn't fully supported. The file size (BASS_FILEPOS_END) can be retrieved, but the decode position (BASS_FILEPOS_CURRENT) is not available. 
            The download progress of streamed files (BASS_FILEPOS_DOWNLOAD) can also be retrieved. The buffering progress (percentage) can be retrieved using the BASS_FILEPOS_WMA_BUFFER mode.</para>
            <para>When streaming a file from the internet, it's not possible to seek with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> until the whole file has been downloaded. A sync (BASS_SYNC_DOWNLOAD) can be set to be notified when the file has been downloaded.</para>
            <para>With Windows Media versions prior to 9 (and when streaming from the internet), WMA decoding is performed in a separate thread, so the CPU used to decode a file/stream during playback will not be included in the <see cref="M:Un4seen.Bass.Bass.BASS_GetCPU"/> return value.</para>
            <para>When using the BASS_STREAM_DECODE flag, it's not possible to play the stream. Because the decoded sample data is not outputted, "decoding channels" can still be used when there is no output device (using the "no sound" device with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>).</para>
            <para>The sample rate of local files can be altered with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. But the playback rate of internet streams should not be changed, because they are decoded at a fixed rate - the rate required to sustain playback at normal speed. So increasing the rate will result in playback stalling.</para>
            <para>Using VBR, lossless and multi-channel WMA files/streams requires Windows Media 9 to be installed.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One or more of the parameters are invalid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>There is no appropriate codec installed to decode the file. Try installing the latest Windows Media codecs.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_WMA_LICENSE</term><description>The WMA file can not be played because it is protected.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a WMA memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The bitrate (amongst other things) can be retrieved through <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_WMA). When retrieving tags, a pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</para>
            <para>The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>. Until the whole file has been streamed, whatever length the file's header says is returned, which may or may not be exact.</para>
            <para>Although the Windows Media modules uses it's own internet streaming code (not BASS's), the BASS_CONFIG_NET_TIMEOUT (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) config option does have effect when opening WMA streams. None of the other NET config options apply.</para>
            <para>With local files, <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> works the same as with the BASS built-in stream formats. But when internet streaming, the Windows Media modules uses it's own streaming routines.
            The download progress of an internet streamed file can be retrieved with <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> (BASS_FILEPOS_DOWNLOAD). The file size (BASS_FILEPOS_END) can also be retrieved, but getting the size of internet streamed files requires Windows Media 9 to be installed. 
            The decode position (BASS_FILEPOS_CURRENT) is not available. When streaming a file from the internet, it is not possible to seek with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> until the whole file has been downloaded. A sync (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> with BASS_SYNC_DOWNLOAD) can be set to be notified when the file has been downloaded.</para>
            <para>When streaming a file from the internet, it's not possible to seek with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> until the whole file has been downloaded. A sync (BASS_SYNC_DOWNLOAD) can be set to be notified when the file has been downloaded.</para>
            <para>With Windows Media versions prior to 9 (and when streaming from the internet), WMA decoding is performed in a separate thread, so the CPU used to decode a file/stream during playback will not be included in the <see cref="M:Un4seen.Bass.Bass.BASS_GetCPU"/> return value.</para>
            <para>When using the BASS_STREAM_DECODE flag, it's not possible to play the stream. Because the decoded sample data is not outputted, "decoding channels" can still be used when there is no output device (using the "no sound" device with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>).</para>
            <para>The sample rate of local files can be altered with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. But the playback rate of internet streams should not be changed, because they are decoded at a fixed rate - the rate required to sustain playback at normal speed. So increasing the rate will result in playback stalling.</para>
            <para>Using VBR, lossless and multi-channel WMA files/streams requires Windows Media 9 to be installed.</para>
            <para>Don't forget to pin your memory object when using this overload.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One or more of the parameters are invalid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>There is no appropriate codec installed to decode the file. Try installing the latest Windows Media codecs.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_WMA_LICENSE</term><description>The WMA file can not be played because it is protected.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFileAuthIStream(System.Int32,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="istream"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateIStreamAuth(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.String,System.String)">
            <summary>
            Creates a sample stream from an IStream object.
            <para>This overload implements UNICODE user name and password. The BASS_UNICODE flag will be added automatically, if not alreday set.</para>
            </summary>
            <param name="istream">A pointer to an IStream object.</param>
            <param name="offset">Unused... set to 0.</param>
            <param name="length">Unused... set to 0.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="user">Username to use in connecting to the server... if either this or pass is NULL, then no username/password is sent to the server.</param>
            <param name="pass">Password to use in connecting to the server</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function is identical to <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, but with the additional authentication options.
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The bitrate (amongst other things) can be retrieved through <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_WMA). When retrieving tags, a pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</para>
            <para>The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>. Until the whole file has been streamed, whatever length the file's header says is returned, which may or may not be exact.</para>
            <para>Although the Windows Media modules uses it's own internet streaming code (not BASS's), the BASS_CONFIG_NET_TIMEOUT (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) config option does have effect when opening WMA streams. None of the other NET config options apply.</para>
            <para>With local files, <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> works the same as with the BASS built-in stream formats. But when internet streaming, the Windows Media modules uses it's own streaming routines.
            The download progress of an internet streamed file can be retrieved with <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> (BASS_FILEPOS_DOWNLOAD). The file size (BASS_FILEPOS_END) can also be retrieved, but getting the size of internet streamed files requires Windows Media 9 to be installed. 
            The decode position (BASS_FILEPOS_CURRENT) is not available. When streaming a file from the internet, it is not possible to seek with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> until the whole file has been downloaded. A sync (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> with BASS_SYNC_DOWNLOAD) can be set to be notified when the file has been downloaded.</para>
            <para>When streaming a file from the internet, it's not possible to seek with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> until the whole file has been downloaded. A sync (BASS_SYNC_DOWNLOAD) can be set to be notified when the file has been downloaded.</para>
            <para>With Windows Media versions prior to 9 (and when streaming from the internet), WMA decoding is performed in a separate thread, so the CPU used to decode a file/stream during playback will not be included in the <see cref="M:Un4seen.Bass.Bass.BASS_GetCPU"/> return value.</para>
            <para>When using the BASS_STREAM_DECODE flag, it's not possible to play the stream. Because the decoded sample data is not outputted, "decoding channels" can still be used when there is no output device (using the "no sound" device with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>).</para>
            <para>The sample rate of local files can be altered with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. But the playback rate of internet streams should not be changed, because they are decoded at a fixed rate - the rate required to sustain playback at normal speed. So increasing the rate will result in playback stalling.</para>
            <para>Using VBR, lossless and multi-channel WMA files/streams requires Windows Media 9 to be installed.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One or more of the parameters are invalid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>There is no appropriate codec installed to decode the file. Try installing the latest Windows Media codecs.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_WMA_LICENSE</term><description>The WMA file can not be played because it is protected.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFileAuthUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFileAuth(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.String,System.String)">
            <summary>
            Creates a sample stream from a WMA file.
            <para>This overload implements Unicode filenames, username and password. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="file">Filename or URL for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from (Unused, set to 0).</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="user">Username to use in connecting to the server... if either this or pass is NULL, then no username/password is sent to the server.</param>
            <param name="pass">Password to use in connecting to the server</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function is identical to <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, but with the additional authentication options.
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The bitrate (amongst other things) can be retrieved through <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_WMA). When retrieving tags, a pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</para>
            <para>The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>. Until the whole file has been streamed, whatever length the file's header says is returned, which may or may not be exact.</para>
            <para>Although the Windows Media modules uses it's own internet streaming code (not BASS's), the BASS_CONFIG_NET_TIMEOUT (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) config option does have effect when opening WMA streams. None of the other NET config options apply.</para>
            <para>With local files, <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> works the same as with the BASS built-in stream formats. But when internet streaming, the Windows Media modules uses it's own streaming routines.
            The download progress of an internet streamed file can be retrieved with <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> (BASS_FILEPOS_DOWNLOAD). The file size (BASS_FILEPOS_END) can also be retrieved, but getting the size of internet streamed files requires Windows Media 9 to be installed. 
            The decode position (BASS_FILEPOS_CURRENT) is not available. When streaming a file from the internet, it is not possible to seek with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> until the whole file has been downloaded. A sync (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> with BASS_SYNC_DOWNLOAD) can be set to be notified when the file has been downloaded.</para>
            <para>When streaming a file from the internet, it's not possible to seek with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> until the whole file has been downloaded. A sync (BASS_SYNC_DOWNLOAD) can be set to be notified when the file has been downloaded.</para>
            <para>With Windows Media versions prior to 9 (and when streaming from the internet), WMA decoding is performed in a separate thread, so the CPU used to decode a file/stream during playback will not be included in the <see cref="M:Un4seen.Bass.Bass.BASS_GetCPU"/> return value.</para>
            <para>When using the BASS_STREAM_DECODE flag, it's not possible to play the stream. Because the decoded sample data is not outputted, "decoding channels" can still be used when there is no output device (using the "no sound" device with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>).</para>
            <para>The sample rate of local files can be altered with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. But the playback rate of internet streams should not be changed, because they are decoded at a fixed rate - the rate required to sustain playback at normal speed. So increasing the rate will result in playback stalling.</para>
            <para>Using VBR, lossless and multi-channel WMA files/streams requires Windows Media 9 to be installed.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One or more of the parameters are invalid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>There is no appropriate codec installed to decode the file. Try installing the latest Windows Media codecs.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_WMA_LICENSE</term><description>The WMA file can not be played because it is protected.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFileAuthMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFileAuth(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.String,System.String)">
            <summary>
            Creates a sample stream from a WMA memory IntPtr.
            <para>This overload implements streaming from memory. Username and Password are UNICODE, so the BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="user">Username to use in connecting to the server... if either this or pass is NULL, then no username/password is sent to the server.</param>
            <param name="pass">Password to use in connecting to the server</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function is identical to <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, but with the additional authentication options.
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The bitrate (amongst other things) can be retrieved through <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_WMA). When retrieving tags, a pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</para>
            <para>The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>. Until the whole file has been streamed, whatever length the file's header says is returned, which may or may not be exact.</para>
            <para>Although the Windows Media modules uses it's own internet streaming code (not BASS's), the BASS_CONFIG_NET_TIMEOUT (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) config option does have effect when opening WMA streams. None of the other NET config options apply.</para>
            <para>With local files, <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> works the same as with the BASS built-in stream formats. But when internet streaming, the Windows Media modules uses it's own streaming routines.
            The download progress of an internet streamed file can be retrieved with <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> (BASS_FILEPOS_DOWNLOAD). The file size (BASS_FILEPOS_END) can also be retrieved, but getting the size of internet streamed files requires Windows Media 9 to be installed. 
            The decode position (BASS_FILEPOS_CURRENT) is not available. When streaming a file from the internet, it is not possible to seek with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> until the whole file has been downloaded. A sync (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> with BASS_SYNC_DOWNLOAD) can be set to be notified when the file has been downloaded.</para>
            <para>When streaming a file from the internet, it's not possible to seek with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> until the whole file has been downloaded. A sync (BASS_SYNC_DOWNLOAD) can be set to be notified when the file has been downloaded.</para>
            <para>With Windows Media versions prior to 9 (and when streaming from the internet), WMA decoding is performed in a separate thread, so the CPU used to decode a file/stream during playback will not be included in the <see cref="M:Un4seen.Bass.Bass.BASS_GetCPU"/> return value.</para>
            <para>When using the BASS_STREAM_DECODE flag, it's not possible to play the stream. Because the decoded sample data is not outputted, "decoding channels" can still be used when there is no output device (using the "no sound" device with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>).</para>
            <para>The sample rate of local files can be altered with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. But the playback rate of internet streams should not be changed, because they are decoded at a fixed rate - the rate required to sustain playback at normal speed. So increasing the rate will result in playback stalling.</para>
            <para>Using VBR, lossless and multi-channel WMA files/streams requires Windows Media 9 to be installed.</para>
            <para>Don't forget to pin your memory object when using this overload.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One or more of the parameters are invalid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>There is no appropriate codec installed to decode the file. Try installing the latest Windows Media codecs.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_WMA_LICENSE</term><description>The WMA file can not be played because it is protected.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a WMA file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One or more of the parameters are invalid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>There is no appropriate codec installed to decode the file. Try installing the latest Windows Media codecs.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_WMA_LICENSE</term><description>The WMA file can not be played because it is protected.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_StreamCreateURL(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a URL.
            <para>This overload implements Unicode urls. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="url">URL for which a stream should be created.</param>
            <param name="offset">Unused... set to 0.</param>
            <param name="length">Unused... set to 0.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The bitrate (amongst other things) can be retrieved through <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_WMA). When retrieving tags, a pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</para>
            <para>The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>. Until the whole file has been streamed, whatever length the file's header says is returned, which may or may not be exact.</para>
            <para>When loading from a memory location (mem = TRUE), unlike <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, this function makes a copy of the data. So you can release the source memory immediately after calling this function.</para>
            <para>Although the Windows Media modules uses it's own internet streaming code (not BASS's), the BASS_CONFIG_NET_TIMEOUT (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) config option does have effect when opening WMA streams. None of the other NET config options apply.</para>
            <para>The download progress of an internet streamed file can be retrieved with <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> (BASS_FILEPOS_DOWNLOAD). The file size (BASS_FILEPOS_END) can also be retrieved, but getting the size of internet streamed files requires Windows Media 9 to be installed. 
            The decode position (BASS_FILEPOS_CURRENT) is not available. When streaming a file from the internet, it is not possible to seek with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> until the whole file has been downloaded. A sync (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> with BASS_SYNC_DOWNLOAD) can be set to be notified when the file has been downloaded.</para>
            <para>With Windows Media versions prior to 9 (and when streaming from the internet), WMA decoding is performed in a separate thread, so the CPU used to decode a file/stream during playback will not be included in the <see cref="M:Un4seen.Bass.Bass.BASS_GetCPU"/> return value.</para>
            <para>When using the BASS_STREAM_DECODE flag, it's not possible to play the stream. Because the decoded sample data is not outputted, "decoding channels" can still be used when there is no output device (using the "no sound" device with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>).</para>
            <para>The sample rate of local files can be altered with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. But the playback rate of internet streams should not be changed, because they are decoded at a fixed rate - the rate required to sustain playback at normal speed. So increasing the rate will result in playback stalling.</para>
            <para>Using VBR, lossless and multi-channel WMA files/streams requires Windows Media 9 to be installed.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One or more of the parameters are invalid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>There is no appropriate codec installed to decode the file. Try installing the latest Windows Media codecs.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_WMA_LICENSE</term><description>The WMA file can not be played because it is protected.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_GetWMObject(System.Int32)">
            <summary>
            Retrieves a pointer to the IWMReader interface of a WMA stream, or IWMWriter interface of a WMA encoder.
            </summary>
            <param name="handle">The WMA stream or encoder handle.</param>
            <returns>If succesful, then a pointer to the requested object is returned, otherwise NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function allows those that are familiar with the Windows Media Format SDK to access the internal object interface, for extra functionality. 
            If you create any objects through a retrieved interface, make sure you release the objects before calling <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/>.</para>
            <para>See the Windows Media Format SDK for information on the IWMReader and associated interfaces.</para>
            <para>When streaming local (not internet) files, this function may actually return an IWMSyncReader interface instead of an IWMReader interface. 
            The type of interface can be determined by querying other interfaces from it, e.g. IWMReaderAdvanced.</para>
            <para>See the Windows Media Format SDK for information on the IWMReader, IWMWriter and associated interfaces.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Example using the WMFSDK function wrapper and casting it to the IWMHeaderInfo3:
            <code>
            IntPtr pUnk = Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_GetWMObject(stream);
            IWMHeaderInfo3 headerInfo3 = (IWMHeaderInfo3)Marshal.GetObjectForIUnknown( pUnk );
            if (headerInfo3 != null)
            {
              ...
            }
            </code>
            <code lang="vbnet">
            Dim pUnk As IntPtr = Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_GetWMObject(stream)
            Dim headerInfo3 As IWMHeaderInfo3 = CType(Marshal.GetObjectForIUnknown(pUnk), IWMHeaderInfo3)
            If Not (headerInfo3 Is Nothing) Then
              ...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeGetRatesPtr(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode)">
            <summary>
            
            </summary>
            <param name="freq"></param>
            <param name="chans"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeGetRates(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode)">
            <summary>
            Retrieves the WMA encoding bitrates available for a specified sample format.
            </summary>
            <param name="freq">The sample rate in Hz.</param>
            <param name="chans">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Wma.BASSWMAEncode"/>):
            <list type="table">
            <item><term>BASS_WMA_ENCODE_RATES_VBR</term><description>Get available VBR (Variable BitRate) quality settings.</description></item>
            <item><term>BASS_WMA_ENCODE_RATES_CBR</term><description>Get available CBR (Constant BitRate) quality settings.</description></item>
            <item><term>BASS_WMA_ENCODE_STANDARD</term><description>Get only bitrates available for standard WMA encoding. If neither this or the BASS_WMA_ENCODE_PRO flag is specified, then the bitrates available for either codec are returned.</description></item>
            <item><term>BASS_WMA_ENCODE_PRO</term><description>Get only bitrates available for WMA Pro encoding.</description></item>
            <item><term>BASS_WMA_ENCODE_24BIT</term><description>Get available bitrates for 24-bit encoding, else 16-bit encoding rates.</description></item>
            </list>
            </param>
            <returns>If succesful, an array of the available bitrates is returned (int[], in bits per second), else NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>When requesting VBR rates, the rates returned are quality settings. For example, 10 = 10% quality, 25 = 25% quality, etc... 100% quality is lossless.</para>
            <para>The WMA codec expects 16-bit or 24-bit sample data depending on the BASS_WMA_ENCODE_24BIT flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format. Of course, it makes little sense to encode 8-bit or 16-bit data in 24-bit.</para>
            <para>The WMA codec currently supports the following sample rates: 8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200, 96000. And the following number of channels: 1, 2, 6, 8. But not all combinations of these are supported. To encode other sample formats, the data will first have to be resampled to a supported format.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>No codec could be found to support the specified sample format.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List the CBR bitrates available at 44100hz 16-bit stereo:
            <code>
            int[] bitrates = BassWma.BASS_WMA_EncodeGetRates(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_RATES_CBR );
            if (bitrates != null)
            {
              foreach (int bitrate in bitrates)
                Console.WriteLine( bitrate );
            }
            </code>
            <code lang="vbnet">
            Dim bitrates As Integer() = BassWma.BASS_WMA_EncodeGetRates(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_RATES_CBR)
            If Not (bitrates Is Nothing) Then
              Dim bitrate As Integer
              For Each bitrate In bitrates
                Console.WriteLine(bitrate)
              Next bitrate
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpen(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,Un4seen.Bass.AddOn.Wma.WMENCODEPROC,System.IntPtr)">
            <summary>
            Initializes WMA encoding to a user defined function.
            </summary>
            <param name="freq">The sample rate in Hz.</param>
            <param name="chans">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Wma.BASSWMAEncode"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>8-bit sample data. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then 16-bit data is expected.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>32-bit floating-point sample data.</description></item>
            <item><term>BASS_WMA_ENCODE_STANDARD</term><description>Use standard WMA encoding. If neither this or the BASS_WMA_ENCODE_PRO flag is specified, then either codec could be used (whichever supports the requested sample format and bitrate).</description></item>
            <item><term>BASS_WMA_ENCODE_PRO</term><description>Use WMA Professional encoding.</description></item>
            <item><term>BASS_WMA_ENCODE_24BIT</term><description>Encode in 24-bit, else 16-bit. 24-bit encoding requires WMA Pro.</description></item>
            <item><term>BASS_WMA_ENCODE_SCRIPT</term><description>Enable the specification of tags mid-stream (after encoding has begun).</description></item>
            </list>
            </param>
            <param name="bitrate">The encoding bitrate (in bits per second, e.g. 128000), or VBR quality (100 or less).</param>
            <param name="proc">The user defined function to receive the encoded data (see <see cref="T:Un4seen.Bass.AddOn.Wma.WMENCODEPROC"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If succesful, the new encoder's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Encoding to a user defined function allows any storage or delivery method to be used for the encoded WMA data. For example, encoding to memory.</para>
            <para>The WMA codec expects 16-bit or 24-bit sample data depending on the BASS_WMA_ENCODE_24BIT flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format. Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeGetRates(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode)"/> to retrieve a list of the encoding bitrates available for a specific sample format.</para>
            <para>Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetTag(System.Int32,System.IntPtr,System.IntPtr,Un4seen.Bass.AddOn.Wma.BASSWMATag)"/> for each tag you wish to set.</para>
            <para>Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.IntPtr,System.Int32)"/> to encode sample data, and <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeClose(System.Int32)"/> to finish encoding.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>No codec could be found to support the specified sample format and bitrate.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // the encoding callback
            private WMENCODEPROC _myEndoderProc;
            private FileStream _fs;
            private byte[] _encbuffer = new byte[1048510]; // 1MB buffer, should be enough
            ...
            // open a wma file
            _fs = File.OpenRead("test.wma");
            // create the encoder (44kHz, stereo at 64kbps, no tags)
            _myEndoderProc = new WMENCODEPROC(MyEncodingWriter);
            int encoder = BassWma.BASS_WMA_EncodeOpen(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 
                                  64000, _myEndoderProc, IntPtr.Zero); 
            ...
            private bool MyEncodingWriter(int handle, BASSWMAEncodeCallback type, IntPtr buffer, int length, IntPtr user)
            {
              if (type == BASSWMAEncodeCallback.BASS_WMA_ENCODE_HEAD)
              {
                // rewind to start of file to write the header	
                _fs.Position = 0L;
              }
            
              if (type == BASSWMAEncodeCallback.BASS_WMA_ENCODE_DONE)
              {
                // done encoding - close the file
                _fs.Flush();
                _fs.Close();
              }
              else
              {
                // copy the unmanaged buffer content to out managed buffer
                Marshal.Copy(buffer, _encbuffer, 0, length);
                // process the data in _encbuffer
                _fs.Write(_encbuffer, 0, length);
              }
            }
            </code>
            <code lang="vbnet">
            Private _myEndoderProc As WMENCODEPROC
            Private _fs As FileStream
            Private _encbuffer(1048510) As Byte ' 1MB buffer, should be enough
            ...
            ' open a wma file
            _fs = File.OpenRead("test.wma")
            ' create the encoder (44kHz, stereo at 64kbps, no tags)
            _myEndoderProc = New WMENCODEPROC(AddressOf MyEncodingWriter)
            Dim encoder As Integer = BassWma.BASS_WMA_EncodeOpen(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 
                                             64000, _myEndoderProc, IntPtr.Zero)
            ...
            Private Function MyEncodingWriter(handle As Integer, type As BASSWMAEncodeCallback, 
                                              buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              If type = BASSWMAEncodeCallback.BASS_WMA_ENCODE_HEAD Then
                ' rewind to start of file to write the header	
                _fs.Position = 0L.ToUInt32()
              End If
            
              If type = BASSWMAEncodeCallback.BASS_WMA_ENCODE_DONE Then
                ' done encoding - close the file
                _fs.Flush()
                _fs.Close()
              Else
                ' copy the unmanaged buffer content to out managed buffer
                Marshal.Copy(buffer, _encbuffer, 0, length)
                ' process the data in _encbuffer
                _fs.Write(_encbuffer, 0, length)
              End If
            End Function
            </code>
            NOTE: This is just an example. It's obviously simpler to use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenFile(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.String)"/> to encode to a file.
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenFileUnicode(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="freq"></param>
            <param name="chans"></param>
            <param name="flags"></param>
            <param name="bitrate"></param>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenFile(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.String)">
            <summary>
            Initializes WMA encoding to a file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="freq">The sample rate in Hz.</param>
            <param name="chans">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Wma.BASSWMAEncode"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>8-bit sample data. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then 16-bit data is expected.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>32-bit floating-point sample data.</description></item>
            <item><term>BASS_WMA_ENCODE_STANDARD</term><description>Use standard WMA encoding. If neither this or the BASS_WMA_ENCODE_PRO flag is specified, then either codec could be used (whichever supports the requested sample format and bitrate).</description></item>
            <item><term>BASS_WMA_ENCODE_PRO</term><description>Use WMA Professional encoding.</description></item>
            <item><term>BASS_WMA_ENCODE_24BIT</term><description>Encode in 24-bit, else 16-bit. 24-bit encoding requires WMA Pro.</description></item>
            <item><term>BASS_WMA_ENCODE_SCRIPT</term><description>Enable the specification of tags mid-stream (after encoding has begun).</description></item>
            <item><term>BASS_UNICODE</term><description>File is a Unicode (16-bit characters) filename.</description></item>
            </list>
            </param>
            <param name="bitrate">The encoding bitrate (in bits per second, e.g. 128000), or VBR quality (100 or less).</param>
            <param name="file">The filename to write.</param>
            <returns>If succesful, the new encoder's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The WMA codec expects 16-bit or 24-bit sample data depending on the BASS_WMA_ENCODE_24BIT flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format. Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeGetRates(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode)"/> to retrieve a list of the encoding bitrates available for a specific sample format.</para>
            <para>Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetTag(System.Int32,System.IntPtr,System.IntPtr,Un4seen.Bass.AddOn.Wma.BASSWMATag)"/> for each tag you wish to set.</para>
            <para>Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.IntPtr,System.Int32)"/> to encode sample data, and <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeClose(System.Int32)"/> to finish encoding and close the file.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>No codec could be found to support the specified sample format and bitrate.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>Could not create the file to write the WMA stream.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Initialize encoding 44100hz 16-bit stereo sample data at 128kb/s to a file called "output.wma":
            <code>
            int stream = Bass.BASS_StreamCreateFile("input.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE);
            if (stream != 0)
            {
              byte[] buffer = new byte[16384]; // 16KB decode buffer
              int enc = BassWma.BASS_WMA_EncodeOpenFile(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 
                                128000, "output.wma");
              while (Bass.BASS_ChannelIsActive(stream) == BASSActive.BASS_ACTIVE_PLAYING)
              {
                int len = Bass.BASS_ChannelGetData(stream, buffer, 16384);
                if (len &gt; 0)
                  BassWma.BASS_WMA_EncodeWrite(enc, buffer, len);
              }
              BassWma.BASS_WMA_EncodeClose(enc);
            }
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("input.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE)
            If stream &lt;&gt; 0 Then
              Dim buffer(16384) As Byte ' 16KB decode buffer
              Dim enc As Integer = BassWma.BASS_WMA_EncodeOpenFile(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 
                                           128000, "output.wma")
              While Bass.BASS_ChannelIsActive(stream) = BASSActive.BASS_ACTIVE_PLAYING
                Dim len As Integer = Bass.BASS_ChannelGetData(stream, buffer, 16384)
                If len &gt; 0 Then
                  BassWma.BASS_WMA_EncodeWrite(enc, buffer, len)
                End If
              End While
              BassWma.BASS_WMA_EncodeClose(enc)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenNetwork(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes WMA encoding to the network.
            </summary>
            <param name="freq">The sample rate in Hz.</param>
            <param name="chans">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Wma.BASSWMAEncode"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>8-bit sample data. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then 16-bit data is expected.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>32-bit floating-point sample data.</description></item>
            <item><term>BASS_WMA_ENCODE_STANDARD</term><description>Use standard WMA encoding. If neither this or the BASS_WMA_ENCODE_PRO flag is specified, then either codec could be used (whichever supports the requested sample format and bitrate).</description></item>
            <item><term>BASS_WMA_ENCODE_PRO</term><description>Use WMA Professional encoding.</description></item>
            <item><term>BASS_WMA_ENCODE_24BIT</term><description>Encode in 24-bit, else 16-bit. 24-bit encoding requires WMA Pro.</description></item>
            <item><term>BASS_WMA_ENCODE_SCRIPT</term><description>Enable the specification of tags mid-stream (after encoding has begun).</description></item>
            </list>
            </param>
            <param name="bitrate">The encoding bitrate (in bits per second, e.g. 128000), or VBR quality (100 or less).</param>
            <param name="port">The port number for clients to conenct to... 0 = let the system choose a port.</param>
            <param name="clients">The maximum number of clients (up to 50) that can be connected.</param>
            <returns>If succesful, the new encoder's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If you chose to let the system select a port, you can retrieve the port number using <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeGetPort(System.Int32)"/>.</para>
            <para>The WMA codec expects 16-bit or 24-bit sample data depending on the BASS_WMA_ENCODE_24BIT flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format. Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeGetRates(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode)"/> to retrieve a list of the encoding bitrates available for a specific sample format.
            VBR encoding is not recommended for network encoding.</para>
            <para>Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetTag(System.Int32,System.IntPtr,System.IntPtr,Un4seen.Bass.AddOn.Wma.BASSWMATag)"/> for each tag you wish to set.</para>
            <para>Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.IntPtr,System.Int32)"/> to encode sample data, and <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeClose(System.Int32)"/> to finish encoding and close the network port.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="clients"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>No codec could be found to support the specified sample format and bitrate.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>Stream what you are recording using a system-chosen port, and allowing up to 5 clients:
            <code>
            private RECORDPROC _myRecProc;
            ...
            if ( Bass.BASS_RecordInit(-1) )
            {
              int enc = BassWma.BASS_WMA_EncodeOpenNetwork(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 
                                128000, 0, 5);
              _myRecProc = new RECORDPROC(MyRecording);
              int recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, _myRecProc, new IntPtr(enc));
            }
            ...
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              if (length &gt; 0 &amp;&amp; buffer != IntPtr.Zero)
              {
                // write the recorded data to the encoder
                BassWma.BASS_WMA_EncodeWrite(user.ToInt32(), buffer, length);
              }
              return true;
            }
            </code>
            <code lang="vbnet">
            Private _myRecProc As RECORDPROC
            ...
            If Bass.BASS_RecordInit(-1) Then
              Dim enc As Integer = BassWma.BASS_WMA_EncodeOpenNetwork(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 
                                           128000, 0, 5)
              _myRecProc = New RECORDPROC(AddressOf MyRecording)
              Dim recHandle As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, _myRecProc, New IntPtr(enc))
            End If
            ...
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              If length &gt; 0 AndAlso buffer &lt;&gt; IntPtr.Zero Then
                ' write the recorded data to the encoder
                BassWma.BASS_WMA_EncodeWrite(user.ToInt32(), buffer, length)
              End If
              Return True
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenNetworkMulti(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Initializes WMA encoding to the network, using multiple bitrates.
            </summary>
            <param name="freq">The sample rate in Hz.</param>
            <param name="chans">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Wma.BASSWMAEncode"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>8-bit sample data. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then 16-bit data is expected.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>32-bit floating-point sample data.</description></item>
            <item><term>BASS_WMA_ENCODE_STANDARD</term><description>Use standard WMA encoding. If neither this or the BASS_WMA_ENCODE_PRO flag is specified, then either codec could be used (whichever supports the requested sample format and bitrate).</description></item>
            <item><term>BASS_WMA_ENCODE_PRO</term><description>Use WMA Professional encoding.</description></item>
            <item><term>BASS_WMA_ENCODE_24BIT</term><description>Encode in 24-bit, else 16-bit. 24-bit encoding requires WMA Pro.</description></item>
            <item><term>BASS_WMA_ENCODE_SCRIPT</term><description>Enable the specification of tags mid-stream (after encoding has begun).</description></item>
            </list>
            </param>
            <param name="bitrates">Array of encoding bitrates (in bits per second, e.g. 128000) to use, terminated with a 0 element (so the number of elements in the array must be one more than the effective bitrates used).</param>
            <param name="port">The port number for clients to conenct to... 0 = let the system choose a port.</param>
            <param name="clients">The maximum number of clients (up to 50) that can be connected.</param>
            <returns>If succesful, the new encoder's handle is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function is identical to <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenNetwork(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.Int32,System.Int32)"/>, but with the additional ability to specify multiple bitrates.
            <para>When encoding/broadcasting in multiple bitrates, the user will automatically get the best available bitrate for their bandwidth.</para>
            <para>The WMA codec expects 16-bit or 24-bit sample data depending on the BASS_WMA_ENCODE_24BIT flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format. Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeGetRates(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode)"/> to retrieve a list of the encoding bitrates available for a specific sample format.
            VBR encoding is not recommended for network encoding.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="clients"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>No codec could be found to support the specified sample format and bitrate.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Initialize encoding 44100hz 16-bit stereo sample data at 128kb/s and 64kb/s, using port 4711, and allowing up to 5 clients.
            <code>
            int[] bitrates = {128000, 64000, 0}; // the bitrates
            int encoder = BassWma.BASS_WMA_EncodeOpenNetworkMulti( 44100, 2, 
                                  BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, bitrates, 4711, 5);
            </code>
            <code lang="vbnet">
            Dim bitrates As Integer() = {128000, 64000, 0} ' the bitrates
            Dim encoder As Integer = BassWma.BASS_WMA_EncodeOpenNetworkMulti(44100, 2, 
                                             BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, bitrates, 4711, 5)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenPublishUnicode(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.String,System.String,System.String)">
            <summary>
            Unicode
            </summary>
            <param name="freq"></param>
            <param name="chans"></param>
            <param name="flags"></param>
            <param name="bitrate"></param>
            <param name="url"></param>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenPublish(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.String,System.String,System.String)">
            <summary>
            Initializes WMA encoding to a publishing point on a Windows Media server.
            <para>This overload implements the Unicode version for url, user and pass. BASS_UNICODE will automatically be added if not set.</para>
            </summary>
            <param name="freq">The sample rate in Hz.</param>
            <param name="chans">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Wma.BASSWMAEncode"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>8-bit sample data. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then 16-bit data is expected.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>32-bit floating-point sample data.</description></item>
            <item><term>BASS_WMA_ENCODE_STANDARD</term><description>Use standard WMA encoding. If neither this or the BASS_WMA_ENCODE_PRO flag is specified, then either codec could be used (whichever supports the requested sample format and bitrate).</description></item>
            <item><term>BASS_WMA_ENCODE_PRO</term><description>Use WMA Professional encoding.</description></item>
            <item><term>BASS_WMA_ENCODE_24BIT</term><description>Encode in 24-bit, else 16-bit. 24-bit encoding requires WMA Pro.</description></item>
            <item><term>BASS_WMA_ENCODE_SCRIPT</term><description>Enable the specification of tags mid-stream (after encoding has begun).</description></item>
            </list>
            </param>
            <param name="bitrate">The encoding bitrate (in bits per second, e.g. 128000), or VBR quality (100 or less).</param>
            <param name="url">URL of the publishing point on the Windows Media server.</param>
            <param name="user">Username to use in connecting to the server... if either this or pass is NULL, then no username/password is sent to the server.</param>
            <param name="pass">Password to use in connecting to the server.</param>
            <returns>If succesful, the new encoder's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The WMA codec expects 16-bit or 24-bit sample data depending on the BASS_WMA_ENCODE_24BIT flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format. Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeGetRates(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode)"/> to retrieve a list of the encoding bitrates available for a specific sample format.
            VBR encoding is not recommended for network encoding.</para>
            <para>Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetTag(System.Int32,System.IntPtr,System.IntPtr,Un4seen.Bass.AddOn.Wma.BASSWMATag)"/> for each tag you wish to set.</para>
            <para>Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.IntPtr,System.Int32)"/> to encode sample data, and <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeClose(System.Int32)"/> to finish encoding and close the network port.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>No codec could be found to support the requested sample format and bitrate.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>Could not connect to the server.</description></item>
            <item><term>BASS_ERROR_WMA_DENIED</term><description>Access was denied. Check the <paramref name="user"/> and <paramref name="pass"/>.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenPublishMultiUnicode(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32[],System.String,System.String,System.String)">
            <summary>
            Unicode
            </summary>
            <param name="freq"></param>
            <param name="chans"></param>
            <param name="flags"></param>
            <param name="bitrates"></param>
            <param name="url"></param>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenPublishMulti(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32[],System.String,System.String,System.String)">
            <summary>
            Initializes WMA encoding to a publishing point on a Windows Media server, using multiple bitrates.
            <para>This overload implements the Unicode version for url, user and pass. BASS_UNICODE will automatically be added if not set.</para>
            </summary>
            <param name="freq">The sample rate in Hz.</param>
            <param name="chans">The number of channels (1=mono, 2=stereo, etc.).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Wma.BASSWMAEncode"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>8-bit sample data. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then 16-bit data is expected.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>32-bit floating-point sample data.</description></item>
            <item><term>BASS_WMA_ENCODE_STANDARD</term><description>Use standard WMA encoding. If neither this or the BASS_WMA_ENCODE_PRO flag is specified, then either codec could be used (whichever supports the requested sample format and bitrate).</description></item>
            <item><term>BASS_WMA_ENCODE_PRO</term><description>Use WMA Professional encoding.</description></item>
            <item><term>BASS_WMA_ENCODE_24BIT</term><description>Encode in 24-bit, else 16-bit. 24-bit encoding requires WMA Pro.</description></item>
            <item><term>BASS_WMA_ENCODE_SCRIPT</term><description>Enable the specification of tags mid-stream (after encoding has begun).</description></item>
            </list>
            </param>
            <param name="bitrates">Array of encoding bitrates to use, terminated with a 0 (in bits per second, e.g. 128000).</param>
            <param name="url">URL of the publishing point on the Windows Media server.</param>
            <param name="user">Username to use in connecting to the server... if either this or pass is NULL, then no username/password is sent to the server.</param>
            <param name="pass">Password to use in connecting to the server.</param>
            <returns>If succesful, the new encoder's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function is identical to BASS_WMA_EncodeOpenPublish, but with the additional ability to specify multiple bitrates.
            <para>When encoding/broadcasting in multiple bitrates, the user will automatically get the best available bitrate for their bandwidth.</para>
            <para>The WMA codec expects 16-bit or 24-bit sample data depending on the BASS_WMA_ENCODE_24BIT flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format. Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeGetRates(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode)"/> to retrieve a list of the encoding bitrates available for a specific sample format.
            VBR encoding is not recommended for network encoding.</para>
            <para>Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetTag(System.Int32,System.IntPtr,System.IntPtr,Un4seen.Bass.AddOn.Wma.BASSWMATag)"/> for each tag you wish to set.</para>
            <para>Use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.IntPtr,System.Int32)"/> to encode sample data, and <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeClose(System.Int32)"/> to finish encoding and close the network port.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WMA</term><description>The Windows Media modules (v9 or above) are not installed.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>No codec could be found to support the requested sample format and bitrate.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>Could not connect to the server.</description></item>
            <item><term>BASS_ERROR_WMA_DENIED</term><description>Access was denied. Check the <paramref name="user"/> and <paramref name="pass"/>.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeGetPort(System.Int32)">
            <summary>
            Retrieves the network port for clients to connect to.
            </summary>
            <param name="handle">The encoder handle.</param>
            <returns>If succesful, the port number is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            If you have choosen to let the system select a port (e.g. in your <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenNetwork(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenNetworkMulti(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32[],System.Int32,System.Int32)"/>), 
            this is the function to retrieve the port actually being used.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The encoder is not a network encoder, so no port is being used.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetNotify(System.Int32,Un4seen.Bass.AddOn.Wma.CLIENTCONNECTPROC,System.IntPtr)">
            <summary>
            Sets a client connection notification callback on a network encoder.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="proc">User defined notification function... NULL = disable notifications.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>A previously set notification callback can be changed (or removed) at any time, by calling this function again.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The encoder is not a network encoder, so no port is being used.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            private CLIENTCONNECTPROC _myClientConnectProc;
            ...
            // set the notification callback
            _myClientConnectProc = new CLIENTCONNECTPROC(MyClientConnectNotify);
            BassWma.BASS_WMA_EncodeSetNotify(encoder, _myClientConnectProc, IntPtr.Zero);
            ...
            // the recording callback
            private void MyClientConnectNotify(int handle, bool connect, string ip, IntPtr user)
            {
              if (connect)
                Console.Writeln( "Connected: {0} at {1}", ip, DateTime.Now );
              else
                Console.Writeln( "Disconnected: {0} at {1}", ip, DateTime.Now );
            }
            </code>
            <code lang="vbnet">
            Private _myClientConnectProc As CLIENTCONNECTPROC
            ...
            ' set the notification callback
            _myClientConnectProc = New CLIENTCONNECTPROC(AddressOf MyClientConnectNotify)
            BassWma.BASS_WMA_EncodeSetNotify(encoder, _myClientConnectProc, IntPtr.Zero)
            ...
            ' the recording callback
            Private Sub MyClientConnectNotify(handle As Integer, connect As Boolean, ip As String, user As IntPtr)
              If connect Then
                Console.Writeln("Connected: {0} at {1}", ip, DateTime.Now)
              Else
                Console.Writeln("Disconnected: {0} at {1}", ip, DateTime.Now)
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeGetClients(System.Int32)">
            <summary>
            Retrieves the number of clients currently connected to the encoder.
            </summary>
            <param name="handle">The encoder handle.</param>
            <returns>If succesful, the number of clients is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The encoder was not created with <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenNetwork(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.Int32,System.Int32)"/>.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetTag(System.Int32,System.IntPtr,System.IntPtr,Un4seen.Bass.AddOn.Wma.BASSWMATag)">
            <summary>
            Sets a tag in a WMA encoding.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="tag">The pointer to the tag to set.</param>
            <param name="value">The pointer to the tag's text/data.</param>
            <param name="type">The format of the tag and value strings. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Wma.BASSWMATag"/>):
            <list type="table">
            <item><term>BASS_WMA_TAG_ANSI</term><description>ANSI strings.</description></item>
            <item><term>BASS_WMA_TAG_UNICODE</term><description>Unicode (UTF-16) strings.</description></item>
            <item><term>BASS_WMA_TAG_UTF8</term><description>UTF-8 strings.</description></item>
            </list>
            </param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Where the tags are located in the encoded stream depends on when this function is used. Calling this function before beginning encoding data puts the tags in the stream's header. Calling this function after encoding has begun puts the tags in the actual stream data, at the current encoding position.
            <para>Header tags must be set before encoding any data - no more header tags can be set once <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.IntPtr,System.Int32)"/> has been called.</para>
            <para>To set tags mid-stream (after encoding has begun), the BASS_WMA_ENCODE_SCRIPT flag needs to have been specified in the encoder's creation. A mid-stream tag typically used is "Caption", which get's displayed in Windows Media Player 9 and above (if the user has enabled captions).</para>
            <para>When using a network encoder, it should be noted that while all header tags are sent to newly connecting clients, prior mid-stream tags are not. So if, for example, you're using the "Caption" tag to indicate the current song title, it should be sent at fairly regular intervals (not only at the start of the song).</para>
            <para>On the playback side, mid-stream tags can be processed using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> (with BASS_TAG_WMA_META).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The encoder does not have mid-stream tags enabled, so tags can not be set once encoding has begun.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="tag"/> and/or <paramref name="value"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Initialize encoding 44100hz 16-bit stereo sample data at 128kbps to a file called "out.wma", 
            and set the header tag "Title" to "Something".
            <code>
            int encoder = BassWma.BASS_WMA_EncodeOpenFile(44100, 2, 
                                  BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 128000, "out.wma");
            // set the title tag
            BassWma.BASS_WMA_EncodeSetTag(encoder, "Title", "Something", BASSWMATag.BASS_WMA_TAG_UNICODE);
            </code>
            <code lang="vbnet">
            Dim encoder As Integer = BassWma.BASS_WMA_EncodeOpenFile(44100, 2, 
                                             BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 128000, "out.wma")
            ' set the title tag
            BassWma.BASS_WMA_EncodeSetTag(encoder, "Title", "Something", BASSWMATag.BASS_WMA_TAG_UNICODE)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetTagUnicode(System.Int32,System.String,System.String,Un4seen.Bass.AddOn.Wma.BASSWMATag)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="tag"></param>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetTag(System.Int32,System.String,System.String,Un4seen.Bass.AddOn.Wma.BASSWMATag)">
            <summary>
            Sets a tag in a WMA encoding.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="tag">The tag to set.
            <para>The standard WMA header tags are as follows:</para>
            <list type="table">
            <item><term>Title</term><description>Content title.</description></item>
            <item><term>Author</term><description>Name of the content author (Artist).</description></item>
            <item><term>Description</term><description>Description of the content.</description></item>
            <item><term>Rating</term><description>Content rating.</description></item>
            <item><term>Copyright</term><description>Content copyright message.</description></item>
            <item><term>WM/AlbumTitle</term><description>Album title.</description></item>
            <item><term>WM/PromotionURL</term><description>URL to an HTML page containing related information.</description></item>
            <item><term>WM/AlbumCoverURL</term><description>URL to an HTML page containing an image of the album cover.</description></item>
            <item><term>WM/Genre</term><description>Genre of the music.</description></item>
            <item><term>WM/Year</term><description>Year of publication of the music.</description></item>
            </list>
            </param>
            <param name="value">The tag's text/data.</param>
            <param name="type">The format of the tag and value strings. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Wma.BASSWMATag"/>):
            <list type="table">
            <item><term>BASS_WMA_TAG_ANSI</term><description>ANSI strings (actually not used and automatically converted to BASS_WMA_TAG_UNICODE).</description></item>
            <item><term>BASS_WMA_TAG_UNICODE</term><description>Unicode (UTF-16) strings (recommended for .Net).</description></item>
            <item><term>BASS_WMA_TAG_UTF8</term><description>UTF-8 strings.</description></item>
            </list>
            You don't actually need to set any flags here, since we automatically add the BASS_WMA_TAG_UNICODE flag, unless you explititly set the BASS_WMA_TAG_UTF8 flag.
            </param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Where the tags are located in the encoded stream depends on when this function is used. Calling this function before beginning encoding data puts the tags in the stream's header. Calling this function after encoding has begun puts the tags in the actual stream data, at the current encoding position.
            <para>Header tags must be set before encoding any data - no more header tags can be set once <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.IntPtr,System.Int32)"/> has been called.</para>
            <para>To set tags mid-stream (after encoding has begun), the BASS_WMA_ENCODE_SCRIPT flag needs to have been specified in the encoder's creation. A mid-stream tag typically used is "Caption", which get's displayed in Windows Media Player 9 and above (if the user has enabled captions).</para>
            <para>When using a network encoder, it should be noted that while all header tags are sent to newly connecting clients, prior mid-stream tags are not. So if, for example, you're using the "Caption" tag to indicate the current song title, it should be sent at fairly regular intervals (not only at the start of the song).</para>
            <para>On the playback side, mid-stream tags can be processed using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> (with BASS_SYNC_META).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The encoder does not have mid-stream tags enabled, so tags can not be set once encoding has begun.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="tag"/> and/or <paramref name="value"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Initialize encoding 44100hz 16-bit stereo sample data at 128kbps to a file called "out.wma", 
            and set the header tag "Title" to "Something" in UTF-8 format.
            <code>
            int encoder = BassWma.BASS_WMA_EncodeOpenFile(44100, 2, 
                                  BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 128000, "out.wma");
            // set the title tag
            BassWma.BASS_WMA_EncodeSetTag(encoder, "Title", "Something", BASSWMATag.BASS_WMA_TAG_UTF8);
            </code>
            <code lang="vbnet">
            Dim encoder As Integer = BassWma.BASS_WMA_EncodeOpenFile(44100, 2, 
                                             BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 128000, "out.wma")
            ' set the title tag
            BassWma.BASS_WMA_EncodeSetTag(encoder, "Title", "Something", BASSWMATag.BASS_WMA_TAG_UTF8)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetTag(System.Int32,System.String,System.String)">
            <summary>
            Sets a tag in a WMA encoding (Unicode version).
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="tag">The tag to set.
            <para>The standard WMA header tags are as follows:</para>
            <list type="table">
            <item><term>Title</term><description>Content title.</description></item>
            <item><term>Author</term><description>Name of the content author (Artist).</description></item>
            <item><term>Description</term><description>Description of the content.</description></item>
            <item><term>Rating</term><description>Content rating.</description></item>
            <item><term>Copyright</term><description>Content copyright message.</description></item>
            <item><term>WM/AlbumTitle</term><description>Album title.</description></item>
            <item><term>WM/PromotionURL</term><description>URL to an HTML page containing related information.</description></item>
            <item><term>WM/AlbumCoverURL</term><description>URL to an HTML page containing an image of the album cover.</description></item>
            <item><term>WM/Genre</term><description>Genre of the music.</description></item>
            <item><term>WM/Year</term><description>Year of publication of the music.</description></item>
            </list>
            </param>
            <param name="value">The tag's text/data.</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Where the tags are located in the encoded stream depends on when this function is used. Calling this function before beginning encoding data puts the tags in the stream's header. Calling this function after encoding has begun puts the tags in the actual stream data, at the current encoding position.
            <para>Header tags must be set before encoding any data - no more header tags can be set once <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.IntPtr,System.Int32)"/> has been called.</para>
            <para>To set tags mid-stream (after encoding has begun), the BASS_WMA_ENCODE_SCRIPT flag needs to have been specified in the encoder's creation. A mid-stream tag typically used is "Caption", which get's displayed in Windows Media Player 9 and above (if the user has enabled captions).</para>
            <para>When using a network encoder, it should be noted that while all header tags are sent to newly connecting clients, prior mid-stream tags are not. So if, for example, you're using the "Caption" tag to indicate the current song title, it should be sent at fairly regular intervals (not only at the start of the song).</para>
            <para>On the playback side, mid-stream tags can be processed using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> (with BASS_SYNC_META).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The encoder does not have mid-stream tags enabled, so tags can not be set once encoding has begun.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="tag"/> and/or <paramref name="value"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Initialize encoding 44100hz 16-bit stereo sample data at 128kbps to a file called "out.wma", 
            and set the header tag "Title" to "Something".
            <code>
            int encoder = BassWma.BASS_WMA_EncodeOpenFile(44100, 2, 
                                  BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 128000, "out.wma");
            // set the title tag
            BassWma.BASS_WMA_EncodeSetTag(encoder, "Title", "Something");
            </code>
            <code lang="vbnet">
            Dim encoder As Integer = BassWma.BASS_WMA_EncodeOpenFile(44100, 2, 
                                             BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 128000, "out.wma")
            ' set the title tag
            BassWma.BASS_WMA_EncodeSetTag(encoder, "Title", "Something")
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Encodes sample data, and writes it to the file or network.
            <para>This overload uses an IntPtr to point to the memory block containing the data.</para>
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="buffer">The buffer containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The WMA codec expects 16-bit or 24-bit sample data depending on the BASS_WMA_ENCODE_24BIT flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>Stream what you are recording using a system-chosen port, and allowing up to 5 clients:
            <code>
            private RECORDPROC _myRecProc;
            ...
            if ( Bass.BASS_RecordInit(-1) )
            {
              int enc = BassWma.BASS_WMA_EncodeOpenNetwork(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 
                                128000, 0, 5);
              _myRecProc = new RECORDPROC(MyRecording);
              int recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, _myRecProc, new IntPtr(enc));
            }
            ...
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              if (length &gt; 0 &amp;&amp; buffer != IntPtr.Zero)
              {
                // write the recorded data to the encoder
                BassWma.BASS_WMA_EncodeWrite(user.ToInt32(), buffer, length);
              }
              return true;
            }
            </code>
            <code lang="vbnet">
            Private _myRecProc As RECORDPROC
            ...
            If Bass.BASS_RecordInit(-1) Then
              Dim enc As Integer = BassWma.BASS_WMA_EncodeOpenNetwork(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 
                                           128000, 0, 5)
              _myRecProc = New RECORDPROC(AddressOf MyRecording)
              Dim recHandle As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, _myRecProc, New IntPtr(enc))
            End If
            ...
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              If length &gt; 0 AndAlso buffer &lt;&gt; IntPtr.Zero Then
                ' write the recorded data to the encoder
                BassWma.BASS_WMA_EncodeWrite(user.ToInt32(), buffer, length)
              End If
              Return True
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.Single[],System.Int32)">
            <summary>
            Encodes sample data, and writes it to the file or network.
            <para>This overload uses a managed float[] to handover sample data to the encoder.</para>
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="buffer">The buffer containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The WMA codec expects 16-bit or 24-bit sample data depending on the BASS_WMA_ENCODE_24BIT flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See the overload taking a byte array for an example.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Encodes sample data, and writes it to the file or network.
            <para>This overload uses a managed int[] to handover sample data to the encoder (Note: An int[] is 32-bit. When using 16-bit samples we can keep a stereo pair in here).</para>
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="buffer">The buffer containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The WMA codec expects 16-bit or 24-bit sample data depending on the BASS_WMA_ENCODE_24BIT flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See the overload taking a byte array for an example.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Encodes sample data, and writes it to the file or network.
            <para>This overload uses a managed short[] to handover sample data to the encoder (perfect for 16-bit samples).</para>
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="buffer">The buffer containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The WMA codec expects 16-bit or 24-bit sample data depending on the BASS_WMA_ENCODE_24BIT flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See the overload taking a byte array for an example.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeWrite(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encodes sample data, and writes it to the file or network.
            <para>This overload uses a managed byte[] to handover sample data to the encoder (perfect for 8-bit samples).</para>
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="buffer">The buffer containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The WMA codec expects 16-bit or 24-bit sample data depending on the BASS_WMA_ENCODE_24BIT flag, but BASSWMA will accept 8-bit, 16-bit or floating-point data, and convert it to the appropriate format.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Initialize encoding 44100hz 16-bit stereo sample data at 128kb/s to a file called "output.wma":
            <code>
            int stream = Bass.BASS_StreamCreateFile("input.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE);
            if (stream != 0)
            {
              byte[] buffer = new byte[16384]; // 16KB decode buffer
              int enc = BassWma.BASS_WMA_EncodeOpenFile(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 
                                128000, "output.wma");
              while (Bass.BASS_ChannelIsActive(stream) == BASSActive.BASS_ACTIVE_PLAYING)
              {
                int len = Bass.BASS_ChannelGetData(stream, buffer, 16384);
                if (len &gt; 0)
                  BassWma.BASS_WMA_EncodeWrite(enc, buffer, len);
              }
              BassWma.BASS_WMA_EncodeClose(enc);
            }
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("input.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE)
            If stream &lt;&gt; 0 Then
              Dim buffer(16384) As Byte ' 16KB decode buffer
              Dim enc As Integer = BassWma.BASS_WMA_EncodeOpenFile(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 
                                           128000, "output.wma")
              While Bass.BASS_ChannelIsActive(stream) = BASSActive.BASS_ACTIVE_PLAYING
                Dim len As Integer = Bass.BASS_ChannelGetData(stream, buffer, 16384)
                If len &gt; 0 Then
                  BassWma.BASS_WMA_EncodeWrite(enc, buffer, len)
                End If
              End While
              BassWma.BASS_WMA_EncodeClose(enc)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeClose(System.Int32)">
            <summary>
            Finishes encoding and closes the file or network port.
            </summary>
            <param name="handle">The encoder handle.</param>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>&gt;
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BassWma.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the basswma.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BassWma.SupportedStreamName">
            <summary>
            Supported file format name of the basswma.dll
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            <para>The disadvantage of this method is, that the standard plugin support for <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> is not working - so you would need to use the native add-on methods!</para>
            </remarks>
            <example>
            Load BASS and BASSWMA from the application's startup path:
            <code>
            Bass.LoadMe();
            BassWma.LoadMe();
            ...
            // when not used anymore...
            BassWma.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSWMA from a different directory:
            <code>
            Bass.LoadMe( @"C:\Development\BASS\_libs" );
            BassWma.LoadMe( @"C:\Development\BASS\_libs" );
            ...
            // when not used anymore...
            BassWma.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wma.BassWma.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.LoadMe"/>.</remarks>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_IsDRMVersion">
            <summary>
            Return TRUE, if this version is a WMA DRM version - else FALSE.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Wma.BASSWMAEncode">
            <summary>
            WMA encoding flags for use with <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpen(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,Un4seen.Bass.AddOn.Wma.WMENCODEPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenFile(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.String)"/>, <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenNetwork(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.Int32,System.Int32)"/>, <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenPublish(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.String,System.String,System.String)"/> or <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeGetRates(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT">
            <summary>
            Default encoding, no tags
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncode.BASS_SAMPLE_8BITS">
            <summary>
            8 bit sample data.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncode.BASS_SAMPLE_FLOAT">
            <summary>
            32-bit floating-point sample data.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncode.BASS_WMA_ENCODE_STANDARD">
            <summary>
            Standard WMA encoding
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncode.BASS_WMA_ENCODE_PRO">
            <summary>
            WMA Professional encoding
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncode.BASS_WMA_ENCODE_24BIT">
            <summary>
             Enable 24-bit encoding
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncode.BASS_WMA_ENCODE_SCRIPT">
            <summary>
            Enable the specification of tags mid-stream (after encoding has begun).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncode.BASS_WMA_ENCODE_RATES_VBR">
            <summary>
            GetRates: get available VBR quality settings
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncode.BASS_WMA_ENCODE_RATES_CBR">
            <summary>
            GetRates: get available CBR quality settings
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncode.BASS_UNICODE">
            <summary>
            file is a Unicode (16-bit characters) filename
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Wma.BASSWMAEncodeCallback">
            <summary>
            WMA encoding callback flags for use with <see cref="T:Un4seen.Bass.AddOn.Wma.WMENCODEPROC"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncodeCallback.BASS_WMA_ENCODE_HEAD">
            <summary>
            The data in the buffer is the header.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncodeCallback.BASS_WMA_ENCODE_DATA">
            <summary>
            The data in the buffer is encoded sample data
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMAEncodeCallback.BASS_WMA_ENCODE_DONE">
            <summary>
            The encoding has finished... buffer and length will both be IntPtr.Zero resp. 0.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Wma.BASSWMATag">
            <summary>
            The "type" of the tag and values strings for use with <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetTag(System.Int32,System.IntPtr,System.IntPtr,Un4seen.Bass.AddOn.Wma.BASSWMATag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMATag.BASS_WMA_TAG_ANSI">
            <summary>
            ANSI strings.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMATag.BASS_WMA_TAG_UNICODE">
            <summary>
            Unicode (UTF-16) strings (recommended to be used with .Net).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wma.BASSWMATag.BASS_WMA_TAG_UTF8">
            <summary>
            UTF-8 strings.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Wma.CLIENTCONNECTPROC">
            <summary>
            User defined client connection notification callback function.
            </summary>
            <param name="handle">The encoder handle (as returned by <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetNotify(System.Int32,Un4seen.Bass.AddOn.Wma.CLIENTCONNECTPROC,System.IntPtr)"/>).</param>
            <param name="ip">The client is connecting?</param>
            <param name="connect">The client's IP address... "xxx.xxx.xxx.xxx:port".</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeSetNotify(System.Int32,Un4seen.Bass.AddOn.Wma.CLIENTCONNECTPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>
            A client connection notification can be used to keep track of who's connected, where they're from, and for long they've been connected.
            </para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            <code>
            private CLIENTCONNECTPROC _myClientConnectProc;
            ...
            // set the notification callback
            _myClientConnectProc = new CLIENTCONNECTPROC(MyClientConnectNotify);
            BassWma.BASS_WMA_EncodeSetNotify(encoder, _myClientConnectProc, IntPtr.Zero);
            ...
            // the recording callback
            private void MyClientConnectNotify(int handle, bool connect, string ip, IntPtr user)
            {
              if (connect)
                Console.Writeln( "Connected: {0} at {1}", ip, DateTime.Now );
              else
                Console.Writeln( "Disconnected: {0} at {1}", ip, DateTime.Now );
            }
            </code>
            <code lang="vbnet">
            Private _myClientConnectProc As CLIENTCONNECTPROC
            ...
            ' set the notification callback
            _myClientConnectProc = New CLIENTCONNECTPROC(AddressOf MyClientConnectNotify)
            BassWma.BASS_WMA_EncodeSetNotify(encoder, _myClientConnectProc, IntPtr.Zero)
            ...
            ' the recording callback
            Private Sub MyClientConnectNotify(handle As Integer, connect As Boolean, ip As String, user As IntPtr)
              If connect Then
                Console.Writeln("Connected: {0} at {1}", ip, DateTime.Now)
              Else
                Console.Writeln("Disconnected: {0} at {1}", ip, DateTime.Now)
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Wma.WMENCODEPROC">
            <summary>
            Encoded data processing callback function.
            </summary>
            <param name="handle">The encoder handle (as returned by <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpen(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,Un4seen.Bass.AddOn.Wma.WMENCODEPROC,System.IntPtr)"/>).</param>
            <param name="type">The type of data to process, one of the following (see <see cref="T:Un4seen.Bass.AddOn.Wma.BASSWMAEncodeCallback"/>):
            <para>BASS_WMA_ENCODE_HEAD : The data in the buffer is the header.</para>
            <para>BASS_WMA_ENCODE_DATA : The data in the buffer is encoded sample data.</para>
            <para>BASS_WMA_ENCODE_DONE : The encoding has finished... buffer and length will both be intPtr.Zero resp. 0.</para>
            </param>
            <param name="buffer">The pointer to the data to process. The buffer can contain the sample data or the header (see above). The sample data is in standard Windows PCM format - 8-bit samples are unsigned, 16-bit samples are signed.</param>
            <param name="length">The number of bytes in the buffer.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpen(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,Un4seen.Bass.AddOn.Wma.WMENCODEPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>
            When encoding begins, an initial header is given. When encoding is completed, an updated header is given (with the duration info, etc.). 
            When encoding to a file (whether that's on disk or not), the initial header should be replaced by the updated one.
            </para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            <code>
            // the encoding callback
            private WMENCODEPROC _myEndoderProc;
            private FileStream _fs;
            private byte[] _encbuffer = new byte[1048510]; // 1MB buffer, should be enough
            ...
            // open a wma file
            _fs = File.OpenRead("test.wma");
            // create the encoder (44kHz, stereo at 64kbps, no tags)
            _myEndoderProc = new WMENCODEPROC(MyEncodingWriter);
            int encoder = BassWma.BASS_WMA_EncodeOpen(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 
                                  64000, _myEndoderProc, IntPtr.Zero); 
            ...
            private bool MyEncodingWriter(int handle, BASSWMAEncodeCallback type, IntPtr buffer, int length, IntPtr user)
            {
              if (type == BASSWMAEncodeCallback.BASS_WMA_ENCODE_HEAD)
              {
                // rewind to start of file to write the header	
                _fs.Position = 0L;
              }
            
              if (type == BASSWMAEncodeCallback.BASS_WMA_ENCODE_DONE)
              {
                // done encoding - close the file
                _fs.Flush();
                _fs.Close();
              }
              else
              {
                // copy the unmanaged buffer content to out managed buffer
                Marshal.Copy(buffer, _encbuffer, 0, length);
                // process the data in _encbuffer
                _fs.Write(_encbuffer, 0, length);
              }
            }
            </code>
            <code lang="vbnet">
            Private _myEndoderProc As WMENCODEPROC
            Private _fs As FileStream
            Private _encbuffer(1048510) As Byte ' 1MB buffer, should be enough
            ...
            ' open a wma file
            _fs = File.OpenRead("test.wma")
            ' create the encoder (44kHz, stereo at 64kbps, no tags)
            _myEndoderProc = New WMENCODEPROC(AddressOf MyEncodingWriter)
            Dim encoder As Integer = BassWma.BASS_WMA_EncodeOpen(44100, 2, BASSWMAEncode.BASS_WMA_ENCODE_DEFAULT, 
                                             64000, _myEndoderProc, IntPtr.Zero)
            ...
            Private Function MyEncodingWriter(handle As Integer, type As BASSWMAEncodeCallback, 
                                              buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              If type = BASSWMAEncodeCallback.BASS_WMA_ENCODE_HEAD Then
                ' rewind to start of file to write the header	
                _fs.Position = 0L.ToUInt32()
              End If
            
              If type = BASSWMAEncodeCallback.BASS_WMA_ENCODE_DONE Then
                ' done encoding - close the file
                _fs.Flush()
                _fs.Close()
              Else
                ' copy the unmanaged buffer content to out managed buffer
                Marshal.Copy(buffer, _encbuffer, 0, length)
                ' process the data in _encbuffer
                _fs.Write(_encbuffer, 0, length)
              End If
            End Function
            </code>
            NOTE: This is just an example. It's obviously simpler to use <see cref="M:Un4seen.Bass.AddOn.Wma.BassWma.BASS_WMA_EncodeOpenFile(System.Int32,System.Int32,Un4seen.Bass.AddOn.Wma.BASSWMAEncode,System.Int32,System.String)"/> to encode to a file.
            </example>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Mix.BassMix">
            <summary>
            BASS.NET API wrapper for BASSMIX.DLL
            <para>Requires: bassmix.dll - Mixing and resample channels (MIX) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            <para>A fairly common question is how to mix and/or resample channels. To make that task simple, here's the add-on that'll do it.</para>
            </summary>
            <remarks>
            <para>BASSMIX is an extension to the BASS audio library, enabling the mixing and resampling of streams and channels.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BassMix.BASSMIXVERSION">
            <summary>
            Current BASSmix version (without minor revision).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_GetVersion">
            <summary>
            Retrieves the version number of the BASSmix.DLL that is loaded.
            </summary>
            <returns>The BASSmix version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASSmix supports all the BASSmix functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.AddOn.Mix.BassMix.BASSMIXVERSION"/> to check the major revision.</para>
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(BassMix.BASS_Mixer_GetVersion()) != BassMix.BASSMIXVERSION )
            {
              MessageBox.Show(this, "Wrong BassMix Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(BassMix.BASS_Mixer_GetVersion()) &lt;&gt; BassFx.BASSMIXVERSION Then
              MessageBox.Show(Me, "Wrong BassMix Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (BassMix.BASS_Mixer_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong BassMix Version!");
            }
            </code>
            <code lang="vbnet">
            If BassMix.BASS_Mixer_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong BassMix Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASSmix.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASSmix version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASSmix supports all the BASSmix functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (BassMix.BASS_Mixer_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong BassMix Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If BassMix.BASS_Mixer_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong BassMix Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a mixer stream.
            </summary>
            <param name="freq">The sample rate of the mixer output (e.g. 44100).</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers (or the BASS_STREAM_DECODE flag) in Windows, and the SPEAKER flags are ignored.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Produce 8-bit output. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Produce 32-bit floating-point output. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See Floating-point channels for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing. Note this only applies to playback of the mixer's output - the mixing of the source channels is always performed by BASSmix.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/>. 3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the DX8 effect implementations section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_MIXER_END</term><description>End the stream when there are no active (including stalled) source channels, else it's never-ending.</description></item>
            <item><term>BASS_MIXER_NONSTOP</term><description>Don't stop producing output when there are no active source channels, else it will be stalled until there are active sources.</description></item>
            <item><term>BASS_MIXER_RESUME</term><description>When stalled, resume the mixer immediately upon a new or unpaused source, else it will be resumed at the next update cycle.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description>Speaker assignment flags.</description></item>
            </list>
            </param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Source channels are "plugged" into a mixer using the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> function, and "unplugged" using the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelRemove(System.Int32)"/> function.</para>
            <para>If the mixer output is being played with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> (it's not a decoding channel), then there will be some delay in the effect of adding/removing source channels or changing their attributes being heard. 
            This latency can be reduced by making use of the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_BUFFER</see> and <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_UPDATEPERIOD</see> config options.
            The playback buffer can be flushed by calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> (restart = TRUE) or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> (pos = 0).</para>
            <para>Unless the BASS_MIXER_END flag is specified, a mixer stream will never end. When there are no sources (or the sources have ended/stalled), it'll produce no output until there's an active source. 
            That's unless the BASS_MIXER_NONSTOP flag is used, in which case it will produce silent output while there are no active sources. The BASS_MIXER_END and BASS_MIXER_NONSTOP flags can be toggled at any time, using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</para>
            <para>Besides mixing channels, a mixer stream can be used as a resampler. In that case the freq parameter would be set the new sample rate, and the source channel's attributes would be left at their defaults. 
            A mixer stream can also be used to downmix, upmix and generally rearrange channels, using the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetMatrix(System.Int32,System.Single[0:,0:])">matrix mixing</see> features.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding streams (BASS_STREAM_DECODE) are allowed when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_FREQ</term><description>freq is out of range. See the minrate and maxrate members of the <see cref="T:Un4seen.Bass.BASS_INFO"/> structure.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported (ie. no WDM drivers).</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficent memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Couldn't initialize 3D support for the stream.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Create a new mixer stream at 44kHz, stereo using floats - out of two source streams:
            <code>
            // this will be the final mixer output stream being played
            int mixer = BassMix.BASS_Mixer_StreamCreate(44100, 2, BASSFlag.BASS_SAMPLE_FLOAT );
            // now we need some channels to plug them in...create two decoding sources
            int streamA = Bass.BASS_StreamCreateFile("testA.mp3", 0, 0, 
                               BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            int streamB = Bass.BASS_StreamCreateFile("testB.mp3", 0, 0, 
                               BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            // finally we plug them into the mixer (no downmix, since we assume the sources to be stereo)
            bool okA = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamA, BASSFlag.BASS_DEFAULT);
            bool okB = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamB, BASSFlag.BASS_DEFAULT);
            // and play it...
            Bass.BASS_ChannelPlay(mixer, false);
            </code>
            <code lang="vbnet">
            ' this will be the final mixer output stream being played
            Dim mixer As Integer = BassMix.BASS_Mixer_StreamCreate(44100, 2, BASSFlag.BASS_SAMPLE_FLOAT)
            ' now we need some channels to plug them in...create two decoding sources
            Dim streamA As Integer = Bass.BASS_StreamCreateFile("testA.mp3", 0, 0, 
                                          BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            Dim streamB As Integer = Bass.BASS_StreamCreateFile("testB.mp3", 0, 0, 
                                          BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            ' finally we plug them into the mixer (no downmix, since we assume the sources to be stereo)
            Dim okA As Boolean = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamA, BASSFlag.BASS_DEFAULT)
            Dim okB As Boolean = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamB, BASSFlag.BASS_DEFAULT)
            ' and play it...
            Bass.BASS_ChannelPlay(mixer, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Plugs a channel into a mixer.
            </summary>
            <param name="handle">The mixer handle (created with <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>).</param>
            <param name="channel">The handle of the channel to plug into the mixer... a HMUSIC, HSTREAM or HRECORD (e.g. created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_MIXER_MATRIX</term><description>Creates a channel matrix, allowing the source channels to be sent to any of the mixer output channels, at any levels. The matrix can be retrieved and modified via the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetMatrix(System.Int32,System.Single[0:,0:])"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetMatrix(System.Int32,System.Single[0:,0:])"/> functions. The matrix will initially contain a one-to-one mapping, eg. left out = left in, right out = right in, etc... </description></item>
            <item><term>BASS_MIXER_DOWNMIX</term><description>Downmix to stereo, or mono if the mixer output is mono.</description></item>
            <item><term>BASS_MIXER_BUFFER</term><description>Buffer the sample data, for use by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/>. This increases memory requirements, so should not be enabled needlessly. The size of the buffer can be controlled via the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option.</description></item>
            <item><term>BASS_MIXER_FILTER</term><description>Filter the sample data when resampling, to reduce aliasing. This improves the sound quality, particularly when resampling to or from a low sample rate, but requires more processing. The precision of the filtering can be controlled via the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_FILTER</see> config option.</description></item>
            <item><term>BASS_MIXER_NORAMPIN</term><description>Don't ramp-in the start, including after seeking (<see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>). This is useful for gap-less playback, where a source channel is intended to seamlessly follow another. This does not affect volume and pan changes, which are always ramped.</description></item>
            <item><term>BASS_MIXER_PAUSE</term><description>Don't process the source channel (add it in a paused mode). Use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/> in order to toggle processing of the source channel.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the source channel when it ends. This allows you to add a channel to a mixer and forget about it, as it will automatically be freed when it has reached the end, or when the source is removed from the mixer or when the mixer is freed.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description>Speaker assignment flags.</description></item>
            </list>
            </param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Source channels must be decoding channels, and they can only be plugged into one mixer at a time. Plugging into more than one mixer is not possible because the mixers would be taking data away from eachother. 
            An advantage of this is that there is no need for a mixer's handle to be used with the channel functions.</para>
            <para>Channels are "unplugged" using the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelRemove(System.Int32)"/> function. Channels are also automatically unplugged when they are freed.</para>
            <para>When mixing a channel, the mixer makes use of the channel's attributes (freq/volume/pan), as set with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSlideAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single,System.Int32)"/>. 
            The BASS_CONFIG_CURVE_VOL and BASS_CONFIG_CURVE_PAN config option settings are also used (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>).</para>
            <para>If a multi-channel stream has more channels than the mixer output, the extra channels will be discarded. For example, if a 5.1 stream is plugged into a stereo mixer, only the front-left/right channels will be retained. 
            That is unless matrix mixing is used or downmixing is enabled.</para>
            <para>The mixing is performed in floating-point, so it makes sense (for both quality and efficiency reasons) for the source channels to be floating-point too, though they don't have to be. 
            It's also more efficient if the source channels are the same sample rate as the mixer output as no resampling is required then. 
            When resampling is required, 8 point sinc interpolation is used, giving a good blend of sound quality and performance.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description><paramref name="channel"/> is not a decoding channel.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description><paramref name="channel"/> is already plugged into a mixer. It must be unplugged first.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The mixer does not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Create a new mixer stream at 44kHz, stereo using floats - out of two source streams:
            <code>
            // this will be the final mixer output stream being played
            int mixer = BassMix.BASS_Mixer_StreamCreate(44100, 2, BASSFlag.BASS_SAMPLE_FLOAT );
            // now we need some channels to plug them in...create two decoding sources
            int streamA = Bass.BASS_StreamCreateFile("testA.mp3", 0, 0, 
                               BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            int streamB = Bass.BASS_StreamCreateFile("testB.mp3", 0, 0, 
                               BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            // finally we plug them into the mixer (no downmix, since we assume the sources to be stereo)
            bool okA = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamA, BASSFlag.BASS_DEFAULT);
            bool okB = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamB, BASSFlag.BASS_DEFAULT);
            // and play it...
            Bass.BASS_ChannelPlay(mixer, false);
            </code>
            <code lang="vbnet">
            ' this will be the final mixer output stream being played
            Dim mixer As Integer = BassMix.BASS_Mixer_StreamCreate(44100, 2, BASSFlag.BASS_SAMPLE_FLOAT)
            ' now we need some channels to plug them in...create two decoding sources
            Dim streamA As Integer = Bass.BASS_StreamCreateFile("testA.mp3", 0, 0, 
                                          BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            Dim streamB As Integer = Bass.BASS_StreamCreateFile("testB.mp3", 0, 0, 
                                          BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            ' finally we plug them into the mixer (no downmix, since we assume the sources to be stereo)
            Dim okA As Boolean = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamA, BASSFlag.BASS_DEFAULT)
            Dim okB As Boolean = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamB, BASSFlag.BASS_DEFAULT)
            ' and play it...
            Bass.BASS_ChannelPlay(mixer, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)">
            <summary>
            Plugs a channel into a mixer, optionally delaying the start and limiting the length.
            </summary>
            <param name="handle">The mixer handle.</param>
            <param name="channel">The handle of the channel to plug into the mixer... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_MIXER_MATRIX</term><description>Creates a channel matrix, allowing the source channels to be sent to any of the mixer output channels, at any levels. The matrix can be retrieved and modified via the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetMatrix(System.Int32,System.Single[0:,0:])"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetMatrix(System.Int32,System.Single[0:,0:])"/> functions. The matrix will initially contain a one-to-one mapping, eg. left out = left in, right out = right in, etc... </description></item>
            <item><term>BASS_MIXER_DOWNMIX</term><description>Downmix to stereo, or mono if the mixer output is mono.</description></item>
            <item><term>BASS_MIXER_BUFFER</term><description>Buffer the sample data, for use by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/>. This increases memory requirements, so should not be enabled needlessly. The size of the buffer can be controlled via the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option.</description></item>
            <item><term>BASS_MIXER_FILTER</term><description>Filter the sample data when resampling, to reduce aliasing. This improves the sound quality, particularly when resampling to or from a low sample rate, but requires more processing. The precision of the filtering can be controlled via the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_FILTER</see> config option.</description></item>
            <item><term>BASS_MIXER_NORAMPIN</term><description>Don't ramp-in the start, including after seeking (<see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>). This is useful for gap-less playback, where a source channel is intended to seamlessly follow another. This does not affect volume and pan changes, which are always ramped.</description></item>
            <item><term>BASS_MIXER_PAUSE</term><description>Don't process the source channel (add it in a paused mode). Use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/> in order to toggle processing of the source channel.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the source channel when it ends. This allows you to add a channel to a mixer and forget about it, as it will automatically be freed when it has reached the end, or when the source is removed from the mixer or when the mixer is freed.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description>Speaker assignment flags.</description></item>
            </list>
            </param>
            <param name="start">Delay (in bytes) before the channel is mixed in.</param>
            <param name="length">The maximum amount of data (in bytes) to mix... 0 = no limit. Once this end point is reached, the channel will be removed from the mixer.</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function is identical to <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>, but with the additional ability to specify a delay and duration for the channel.
            <para>The <paramref name="start"/> and <paramref name="length"/> parameters relate to the mixer output. So when calculating these values, use the mixer stream's sample format rather than the source channel's. 
            The start parameter is automatically rounded-down to the nearest sample boundary, while the length parameter is rounded-up to the nearest sample boundary.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description><paramref name="channel"/> is not a decoding channel.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description><paramref name="channel"/> is already plugged into a mixer. It must be unplugged first.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The mixer does not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Add a channel to a mixer, delaying the start by 1 second and limiting the duration to 2 seconds:
            <code>
            long start = Bass.BASS_ChannelSeconds2Bytes(mixer, 1.0); // delay
            long length = Bass.BASS_ChannelSeconds2Bytes(mixer, 2.0); // duration
            // add the channel
            BassMix.BASS_Mixer_StreamAddChannelEx(mixer, channel, 0, start, length);
            </code>
            <code lang="vbnet">
            Dim start As Long = Bass.BASS_ChannelSeconds2Bytes(mixer, 1.0) ' delay
            Dim length As Long = Bass.BASS_ChannelSeconds2Bytes(mixer, 2.0) ' duration
            ' add the channel
            BassMix.BASS_Mixer_StreamAddChannelEx(mixer, channel, 0, start, length)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            This overload uses an IntPtr to reference the buffer data.
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="buffer">Location to write the data as an IntPtr (can be IntPtr.Zero when handle is a recording channel (HRECORD), to discard the requested amount of data from the recording buffer).
            <para>Use "Marshal.AllocCoTaskMem" to allocate a memory buffer, use "Marshal.Copy" to copy the buffer data from unmanaged BASS to your managed code and use "Marshal.FreeCoTaskMem" to free the memory buffer when not needed anymore.</para>
            <para>Or make use of a "GCHandle" to receive data to a pinned managed object.</para>
            </param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_FLOAT</term><description>Return floating-point sample data.</description></item>
            <item><term>BASS_DATA_FFT256</term><description>256 sample FFT (returns 128 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT512</term><description>512 sample FFT (returns 256 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT1024</term><description>1024 sample FFT (returns 512 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT2048</term><description>2048 sample FFT (returns 1024 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT4096</term><description>4096 sample FFT (returns 2048 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT8192</term><description>8192 sample FFT (returns 4096 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT_INDIVIDUAL</term><description>Use this flag to request separate FFT data for each channel. The size of the data returned (as listed above) is multiplied by the number channels.</description></item>
            <item><term>BASS_DATA_FFT_NOWINDOW</term><description>This flag can be used to prevent a hanning window being applied to the sample data when performing an FFT.</description></item>
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be NULL when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, but it gets the data from the channel's buffer instead of decoding it from the channel, 
            which means that the mixer doesn't miss out on any data. In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is a decoding channel, then the channel's most recent data will be returned. Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option can be used to set the buffer size.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            This overload uses a managed float[] to reference the buffer data as 32-bit!
            SHOULD ONLY BE USED, if the stream was created with BASS_SAMPLE_FLOAT!
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="buffer">The array (float[]) to receive the data, use BASS_SAMPLE_FLOAT when creating the channel stream!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_FLOAT</term><description>Return floating-point sample data.</description></item>
            <item><term>BASS_DATA_FFT256</term><description>256 sample FFT (returns 128 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT512</term><description>512 sample FFT (returns 256 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT1024</term><description>1024 sample FFT (returns 512 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT2048</term><description>2048 sample FFT (returns 1024 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT4096</term><description>4096 sample FFT (returns 2048 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT8192</term><description>8192 sample FFT (returns 4096 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT_INDIVIDUAL</term><description>Use this flag to request separate FFT data for each channel. The size of the data returned (as listed above) is multiplied by the number channels.</description></item>
            <item><term>BASS_DATA_FFT_NOWINDOW</term><description>This flag can be used to prevent a hanning window being applied to the sample data when performing an FFT.</description></item>
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be NULL when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, but it gets the data from the channel's buffer instead of decoding it from the channel, 
            which means that the mixer doesn't miss out on any data. In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is a decoding channel, then the channel's most recent data will be returned. Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option can be used to set the buffer size.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Retrieves the immediate sample data of a mixer source channel.
            This overload uses a managed short[] to reference the buffer data as 16-bit values - each element will represent one channel in this case!
            SHOULD ONLY BE USED, if the stream was created WITHOUT BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS!
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="buffer">The array (short[]) to receive the data, e.g. when creating the channel stream with default setting, meaning 16-bit samples!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be NULL when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, but it gets the data from the channel's buffer instead of decoding it from the channel, 
            which means that the mixer doesn't miss out on any data. In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is a decoding channel, then the channel's most recent data will be returned. Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option can be used to set the buffer size.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Retrieves the immediate sample data of a mixer source channel.
            This overload uses a managed int[] to reference the buffer data (Note: an int is 32-bit meaning if we expect to receive 16-bit data stereo a single int value will contain 2 x 16-bit, so a full stereo pair of data)!
            SHOULD ONLY BE USED, if the stream was created WITHOUT BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS!
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="buffer">The array (int[]) to receive the data, e.g. when creating the channel stream with default setting, meaning 16-bit samples, an int value contains 2 channels (left and right)!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be NULL when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, but it gets the data from the channel's buffer instead of decoding it from the channel, 
            which means that the mixer doesn't miss out on any data. In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is a decoding channel, then the channel's most recent data will be returned. Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option can be used to set the buffer size.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Retrieves the immediate sample data of a mixer source channel.
            This overload uses a managed byte[] to reference the buffer data!
            SHOULD ONLY BE USED, if the stream was created with BASS_SAMPLE_8BITS!
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="buffer">The array (byte[]) to receive the data, e.g. when creating the channel with BASS_SAMPLE_8BITS!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be NULL when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, but it gets the data from the channel's buffer instead of decoding it from the channel, 
            which means that the mixer doesn't miss out on any data. In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is a decoding channel, then the channel's most recent data will be returned. Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option can be used to set the buffer size.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)">
            <summary>
            Retrieves the level (peak amplitude) of a mixer source channel.
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            <para>If successful, the level of the left channel is returned in the low word (low 16-bits, use <see cref="M:Un4seen.Bass.Utils.LowWord32(System.Int32)"/>), and the level of the right channel is returned in the high word (high 16-bits, use <see cref="M:Un4seen.Bass.Utils.HighWord32(System.Int32)"/>). If the channel is mono, then the low word is duplicated in the high word. 
            The level ranges linearly from 0 (silent) to 32768 (max). 0 will be returned when a channel is stalled.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but it gets the level from the channel's buffer instead of decoding data from the channel, which means that the mixer doesn't miss out on any data. 
            In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is a decoding channel, then the channel's most recent data will be used to get the level. Otherwise, the level will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The BASS_CONFIG_MIXER_BUFFER config option can be used to set the buffer size.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            <item><term>BASS_ERROR_NOPLAY</term><description>The mixer is not playing.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the left and right levels of a stereo channel:
            <code>
            BassMix.BASS_Mixer_StreamAddChannel(mixer, channel, BASSFlag.BASS_MIXER_BUFFER);
            int level = BassMix.BASS_Mixer_ChannelGetLevel(channel);
            int left = Utils.LowWord32(level); // the left level
            int right = Utils.HighWord32(level); // the right level
            </code>
            <code lang="vbnet">
            BassMix.BASS_Mixer_StreamAddChannel(mixer, channel, BASSFlag.BASS_MIXER_BUFFER)
            Dim level As Integer = BassMix.BASS_Mixer_ChannelGetLevel(channel)
            Dim left As Integer = Utils.LowWord32(level) ' the left level
            Dim right As Integer = Utils.HighWord32(level) ' the right level
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32,System.Single[])">
            <summary>
            Retrieves the level (peak amplitude) of a mixer source channel.
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="level">The array which will receive the peak levels values. The size of the array must be set to the number of channels of the stream (e.g. 2 for stereo).</param>
            <returns>On success TRUE is returned - else FALSE, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            <para>If successful, the peak levels of the interleaved channel order is returned in the <paramref name="level"/> array.
            The level value ranges linearly from 0.0 (silent) to 1.0 (=0dB) or above.</para>
            </returns>
            <remarks>
            <para>This function is like the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but it gets the level from the channel's buffer instead of decoding data from the channel, which means that the mixer doesn't miss out on any data. 
            In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is a decoding channel, then the channel's most recent data will be used to get the level. Otherwise, the level will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The BASS_CONFIG_MIXER_BUFFER config option can be used to set the buffer size.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be NULL when using this flag.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the left and right levels of a stereo channel:
            <code>
            float[] level = new float[2]; // dealing with stereo
            if (BassMix.BASS_Mixer_ChannelGetLevel(channel, level))
            {
              float left  = level[0]; // the left level
              float right = level[1]; // the right level
            }
            </code>
            <code lang="vbnet">
            Dim level(2) As Single ' dealing with stereo
            If BassMix.BASS_Mixer_ChannelGetLevel(channel, level) Then
              Dim left As Single  = level(0) ' the left level
              Dim right As Single = level(1) ' the right level
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)">
            <summary>
            Modifies and/or retrieves a channel's mixer flags.
            </summary>
            <param name="handle">The handle of the mixer source channel to modify (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_MIXER_BUFFER</term><description>Buffer the sample data, for use by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/>.</description></item>
            <item><term>BASS_MIXER_NORAMPIN</term><description>Don't ramp-in the start, including after seeking (<see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>). This is useful for gap-less playback, where a source channel is intended to seamlessly follow another. This does not affect volume and pan changes, which are always ramped.</description></item>
            <item><term>BASS_MIXER_PAUSE</term><description>Don't process the source channel (paused mode).</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the source channel when it ends. This allows you to add a channel to a mixer and forget about it, as it will automatically be freed when it has reached the end, or when the source is removed from the mixer or when the mixer is freed.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description>Speaker assignment flags.</description></item>
            </list>
            </param>
            <param name="mask">The flags (as above) to modify. Flags that are not included in this are left as they are, so it can be set to 0 (<see cref="F:Un4seen.Bass.BASSFlag.BASS_DEFAULT"/>) in order to just retrieve the current flags. 
            To modify the speaker flags, any of the BASS_SPEAKER_xxx flags can be used in the mask (no need to include all of them).</param>
            <returns>If successful, the channel's updated flags are returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function only deals with the channel's mixer related flags. The channel's standard flags, for example looping (BASS_SAMPLE_LOOP), are unaffected - use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/> to modify them.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The mixer does not support the requested speaker(s), or the channel has matrix mixing enabled.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // Disable ramping-in of a channel:
            BassMix.BASS_Mixer_ChannelFlags(channel, BASSFlag.BASS_MIXER_NORAMPIN, BASSFlag.BASS_MIXER_NORAMPIN);
            
            // Enable ramping-in of a channel:
            BassMix.BASS_Mixer_ChannelFlags(channel, BASSFlag.BASS_DEFAULT, BASSFlag.BASS_MIXER_NORAMPIN);
            </code>
            <code lang="vbnet">
            ' Disable ramping-in of a channel:
            BassMix.BASS_Mixer_ChannelFlags(channel, BASSFlag.BASS_MIXER_NORAMPIN, BASSFlag.BASS_MIXER_NORAMPIN)
            
            ' Enable ramping-in of a channel:
            BassMix.BASS_Mixer_ChannelFlags(channel, BASSFlag.BASS_DEFAULT, BASSFlag.BASS_MIXER_NORAMPIN)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelPause(System.Int32)">
            <summary>
            Pauses a mixer source channel (don't process the source).
            </summary>
            <param name="handle">The handle of the mixer source channel to unplug (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Use this method to pause a mixer source channel currently playing (which stops the mixer from processing that source). 
            Use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelPlay(System.Int32)"/> to resume a paused mixer source channel.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The mixer does not support the requested speaker(s), or the channel has matrix mixing enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelPlay(System.Int32)">
            <summary>
            Starts (or resumes) playback of a mixer source channel (process the source).
            </summary>
            <param name="handle">The handle of the mixer source channel to unplug (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>If the mixer source channel is already playing this method has no effect - else it removes the <see cref="F:Un4seen.Bass.BASSFlag.BASS_MIXER_PAUSE"/> flag from the mixer source channel.
            Use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelPause(System.Int32)"/> to pause a mixer source channel.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The mixer does not support the requested speaker(s), or the channel has matrix mixing enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelIsActive(System.Int32)">
            <summary>
            Checks if a mixer source channel is active (playing) or paused.
            </summary>
            <param name="handle">The handle of the mixer source channel to check (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>The return value is one of the folowing (see <see cref="T:Un4seen.Bass.BASSActive"/>):
            <list type="table">
            <item><term>BASS_ACTIVE_STOPPED</term><description>The source is not active, or handle is not a valid mixer source channel.</description></item>
            <item><term>BASS_ACTIVE_PLAYING</term><description>The source is playing.</description></item>
            <item><term>BASS_ACTIVE_PAUSED</term><description>The source is paused.</description></item>
            </list>
            </returns>
            <remarks>
            <para>BASS_ACTIVE_STOPPED will not automatically be returned once the end of the source mixer channel has been reached (unless you have specified <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_AUTOFREE"/> with the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/> method).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The mixer does not support the requested speaker(s), or the channel has matrix mixing enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelRemove(System.Int32)">
            <summary>
            Unplugs a channel from a mixer.
            </summary>
            <param name="handle">The handle of the mixer source channel to unplug (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetMixer(System.Int32)">
            <summary>
            Retrieves the mixer that a channel is plugged into.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>If successful, the mixer stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)">
            <summary>
            Sets the playback position of a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="pos">The position, in bytes. With MOD musics, the <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>(order,row) method can be used to set the position in orders and rows instead of bytes.
            <param name="mode">
            <list type="table">
            <item><term>BASS_POS_BYTE</term><description>The position is in bytes, which will be rounded down to the nearest sample boundary.</description></item>
            <item><term>BASS_POS_MUSIC_ORDER</term><description>The position is in orders and rows... use <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>. (HMUSIC only).</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>Flag: Stop all notes. This flag is applied automatically if it has been set on the channel, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. (HMUSIC).</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>Flag: Stop all notes and reset bpm/etc. This flag is applied automatically if it has been set on the channel, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. (HMUSIC).</description></item>
            <item><term>BASS_MIXER_NORAMPIN</term><description>Flag: Don't ramp-in the start after seeking. This flag is applied automatically if it has been set on the channel, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. (HMUSIC).</description></item>
            </list>
            <i>Other modes and flags may be supported by add-ons, see the documentation.</i>
            </param>
            <para>The playback buffer of the mixer can be flushed by using pos = 0.</para>
            </param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function works exactly like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, except that it also resets things for the channel in the mixer,
            well as supporting the BASS_MIXER_NORAMPIN flag. See <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> for details.
            <para>For custom looping purposes (eg. in a mixtime SYNCPROC), the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> function should be used instead of this</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>The requested position is illegal.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The download has not yet reached the requested position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Sets the position of a source stream to 35seconds:
            <code>
            BassMix.BASS_Mixer_ChannelSetPosition(streamA, Bass.BASS_ChannelSeconds2Bytes(streamA, 35.0));
            </code>
            <code lang="vbnet">
            BassMix.BASS_Mixer_ChannelSetPosition(streamA, Bass.BASS_ChannelSeconds2Bytes(streamA, 35.0));
            </code>
            Reset the playback buffer of the mixer:
            <code>
            BassMix.BASS_Mixer_ChannelSetPosition(mixer, 0L);
            </code>
            <code lang="vbnet">
            BassMix.BASS_Mixer_ChannelSetPosition(mixer, 0L)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetPosition(System.Int32,System.Int64)">
            <summary>
            Sets the playback position in bytes of a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="pos">The position, in bytes. With MOD musics, the <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>(order,row) method can be used to set the position in orders and rows instead of bytes.
            <para>The playback buffer of the mixer can be flushed by using pos = 0.</para>
            </param>
            <returns>If successful, then TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function works exactly like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, except that it also resets things for the channel in the mixer,
            well as supporting the BASS_MIXER_NORAMPIN flag. See <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> for details.
            <para>For custom looping purposes (eg. in a mixtime SYNCPROC), the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> function should be used instead of this</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>The requested position is illegal.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The download has not yet reached the requested position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Sets the position of a source stream to 35seconds:
            <code>
            BassMix.BASS_Mixer_ChannelSetPosition(streamA, Bass.BASS_ChannelSeconds2Bytes(streamA, 35.0));
            </code>
            <code lang="vbnet">
            BassMix.BASS_Mixer_ChannelSetPosition(streamA, Bass.BASS_ChannelSeconds2Bytes(streamA, 35.0));
            </code>
            Reset the playback buffer of the mixer:
            <code>
            BassMix.BASS_Mixer_ChannelSetPosition(mixer, 0L);
            </code>
            <code lang="vbnet">
            BassMix.BASS_Mixer_ChannelSetPosition(mixer, 0L)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)">
            <summary>
            Retrieves the playback position of a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="mode">
            <list type="table">
            <item><term>BASS_POS_BYTE</term><description>Get the position in bytes.</description></item>
            <item><term>BASS_POS_MUSIC_ORDER</term><description>Get the position in orders and rows... LoWord = order, HiWord = row * scaler (<see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_PSCALER"/>). (HMUSIC only).</description></item>
            </list>
            <i>Other modes and flags may be supported by add-ons, see the documentation.</i>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            If successful, the position is returned.</returns>
            <remarks>
            This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>, but it compensates for the mixer's buffering to return the source channel position that is currently being heard.
            So when used with a decoding channel (eg. a mixer source channel), this method will return the current decoding position.
            But if the mixer output is being played, then there is a playback buffer involved. This function compensates for that, to return the position that is currently being heard. 
            If the mixer itself is a decoding channel, then this function is identical to using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested position is not available.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPosition(System.Int32)">
            <summary>
            Retrieves the playback position in bytes of a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            If successful, the position is returned.</returns>
            <remarks>
            This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>, but it compensates for the mixer's buffering to return the source channel position that is currently being heard.
            So when used with a decoding channel (eg. a mixer source channel), this method will return the current decoding position.
            But if the mixer output is being played, then there is a playback buffer involved. This function compensates for that, to return the position that is currently being heard. 
            If the mixer itself is a decoding channel, then this function is identical to using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested position is not available.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetMatrix(System.Int32,System.Single[0:,0:])">
            <summary>
            Sets a channel's mixing matrix, if it has one.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="matrix">The 2-dimensional array (float[,]) of the mixing matrix.</param>
            <returns>If successful, a TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Normally when mixing channels, the source channels are sent to the output in the same order - the left input is sent to the left output, and so on. Sometimes something a bit more complex than that is required. For example, if the source has more channels than the output, you may want to "downmix" the source so that all channels are present in the output. Equally, if the source has fewer channels than the output, you may want to "upmix" it so that all output channels have sound. Or you may just want to rearrange the channels. Matrix mixing allows all of these.</para>
            <para>A matrix mixer is created on a per-source basis (you can mix'n'match normal and matrix mixing), by using the <see cref="F:Un4seen.Bass.BASSFlag.BASS_MIXER_MATRIX"/> and/or <see cref="F:Un4seen.Bass.BASSFlag.BASS_MIXER_DOWNMIX"/> flag when calling <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>. 
            The matrix itself is a 2-dimensional array of floating-point mixing levels, with the source channels on one axis, and the output channels on the other. Some simple examples are shown below.</para>
            <para>The Matrix layout:
            <list type="table">
            <item><term>Horizontal</term><description>The Input channels (e.g. 1,0 = left-on,right-off).</description></item>
            <item><term>Vertical</term><description>The Output channels (e.g. 1,0 = left-on,right-off).</description></item>
            </list>
            <code>
                   ---------&gt; (Input)           ---------&gt; (Input)
                  |    L  R                    |    L  R
                  | L  1  0                    |LF  1  0
                  | R  0  1                    |RF  0  1
                  v                            |LR  1  0
            (Output)                           |RR  0  1
                                               v
                                          (Output)
            </code>
            </para>
            <para>When streaming multi-channel sample data, the channel order of each sample is as follows:
            <list type="table">
            <item><term>3 channels</term><description>left-front, right-front, center.</description></item>
            <item><term>4 channels</term><description>left-front, right-front, left-rear/side, right-rear/side.</description></item>
            <item><term>6 channels(5.1)</term><description>left-front, right-front, center, LFE, left-rear/side, right-rear/side.</description></item>
            <item><term>8 channels(7.1)</term><description>left-front, right-front, center, LFE, left-rear/side, right-rear/side, left-rear center, right-rear center.</description></item>
            </list></para>
            <para>When using matrix mixing, the source channel's volume attribute still has effect, but the pan attribute doesn't. Whenever necessary, panning changes can be achieved by modifying the matrix.</para>
            <para>Do NOT use .Net jagged arrays, but only two-dimensional C-style arrays - as shown in the examples below!</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel is not using matrix mixing.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example shows how to use Matrix mixing (stereo to quad matrix):
            <code>
            // the source stream
            int streamA = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_STREAM_DECODE);
            // create a 4-channel mixer stream
            BASS_CHANNELINFO i = Bass.BASS_ChannelGetInfo(streamA);
            int mixer = BassMix.BASS_Mixer_StreamCreate(i.freq, 4, BASSFlag.BASS_DEFAULT );
            // add the source stream to the mixer with the matrix option
            BassMix.BASS_Mixer_StreamAddChannel(mixer, streamA, BASSFlag.BASS_MIXER_MATRIX);
            // define a mixing matrix for the source stream
            float[,] matrix = { // stereo to quad matrix
            			{1, 0}, // left in = left front out
            			{0, 1}, // right in = right front out
            			{1, 0}, // left in = left rear out
            			{0, 1}  // right in = right rear out
            	       };
            // apply the matrix
            BassMix.BASS_Mixer_ChannelSetMatrix(streamA, matrix);
            // and play it
            Bass.BASS_ChannelPlay(mixer, false);
            </code>
            <code lang="vbnet">
            ' the source stream
            Dim streamA As Integer = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_STREAM_DECODE)
            ' create a 4-channel mixer stream
            Dim i As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(streamA)
            Dim mixer As Integer = BassMix.BASS_Mixer_StreamCreate(i.freq, 4, BASSFlag.BASS_DEFAULT)
            ' add the source stream to the mixer with the matrix option
            BassMix.BASS_Mixer_StreamAddChannel(mixer, streamA, BASSFlag.BASS_MIXER_MATRIX)
            ' define a mixing matrix for the source stream
            Dim matrix(,) As Single = { ' stereo to quad matrix
                                {1, 0}, ' left in = left front out
                                {0, 1}, ' right in = right front out
                                {1, 0}, ' left in = left rear out
                                {0, 1}  ' right in = right rear out
                               }
            BassMix.BASS_Mixer_ChannelSetMatrix(streamA, matrix)
            ' and play it
            Bass.BASS_ChannelPlay(mixer, False)
            </code>
            Here are some more matrix examples...
            <code lang="null">
            // In = stereo, Out = stereo
            float[,] matrix = { 
            		{1, 0}, // left out = left in
            		{0, 1}, // right out = right in
            	};
            
            // In = stereo, Out = swapped stereo
            float[,] matrix = { 
            		{0, 1}, // left out = right in
            		{1, 0}, // right out = left in
            	};
            
            // In = stereo, Out = mono
            float[,] matrix = { 
            		{0.5f, 0.5f} // mono out = half left + right in
            	};
            
            // In = stereo, Out = quadraphonic (4 channels)
            float[,] matrix = { // stereo to quad matrix
            			{1, 0}, // left-front out = left in
            			{0, 1}, // right-front out = right in
            			{1, 0}, // left rear out = left in
            			{0, 1}  // right rear out = right in
            	};
            
            // In = mono, Out = quadraphonic (4 channels)
            float[,] matrix = { // mono to quad matrix
              		       {1}, // left-front out = mono in
            			   {1}, // right-front out = mono in
            			   {1}, // left rear out = mono in
            			   {1}  // right rear out = mono in
            	};
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetMatrix(System.Int32,System.Single[0:,0:])">
            <summary>
            Retrieves a channel's mixing matrix, if it has one.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="matrix">The 2-dimentional array (float[,]) where to write the matrix.</param>
            <returns>If successful, a TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>For more details see <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetMatrix(System.Int32,System.Single[0:,0:])"/>. The array must be big enough to get the matrix.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel is not using matrix mixing.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the matrix of a stereo channel plugged into a quad mixer:
            <code>
            // you must initialize the array size correctly before getting the matrix!
            float[,] matrixGet = new float[4,2];
            BassMix.BASS_Mixer_ChannelGetMatrix(streamA, matrixGet);
            </code>
            <code lang="vbnet">
            ' you must initialize the array size correctly before getting the matrix!
            Dim matrixGet(4, 2) As Single
            BassMix.BASS_Mixer_ChannelGetMatrix(streamA, matrixGet)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Single@)">
            <summary>
            Retrieves the current position and value of an envelope on a channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The envelope to get the position/value of. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope"/>):
            <list type="table">
            <item><term>BASS_MIXER_ENV_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_MIXER_ENV_VOL</term><description>Volume.</description></item>
            <item><term>BASS_MIXER_ENV_PAN</term><description>Panning/balance.</description></item>
            </list>
            </param>
            <param name="value">A reference to a variable to receive the envelope value at the current position.</param>
            <returns>If successful, the current position of the envelope is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The envelope's current position is not necessarily what is currently being heard, due to buffering.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no envelope of the requested type on the channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            float val = 0f;
            int pos = BassMix.BASS_Mixer_ChannelGetEnvelope(source, 
                              BASSMIXEnvelope.BASS_MIXER_ENV_VOL, ref val);
            Console.WriteLine("Pos={0}, Val={1}", pos, val);
            </code>
            <code lang="vbnet">
            Dim val As Single = 0F
            Dim pos As Integer = BassMix.BASS_Mixer_ChannelGetEnvelope(source, 
                                         BASSMIXEnvelope.BASS_MIXER_ENV_VOL, val)
            Console.WriteLine("Pos={0}, Val={1}", pos, val)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Object)">
            <summary>
            Retrieves the current position and value of an envelope on a channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The envelope to get the position/value of. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope"/>):
            <list type="table">
            <item><term>BASS_MIXER_ENV_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_MIXER_ENV_VOL</term><description>Volume.</description></item>
            <item><term>BASS_MIXER_ENV_PAN</term><description>Panning/balance.</description></item>
            </list>
            </param>
            <param name="value">A reference to an object to receive the envelope value at the current position (NULL = don't retrieve it).</param>
            <returns>If successful, the current position of the envelope is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The envelope's current position is not necessarily what is currently being heard, due to buffering.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no envelope of the requested type on the channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int pos = BassMix.BASS_Mixer_ChannelGetEnvelope(source, 
                              BASSMIXEnvelope.BASS_MIXER_ENV_VOL, null);
            Console.WriteLine("Pos={0}", val);
            </code>
            <code lang="vbnet">
            Dim pos As Integer = BassMix.BASS_Mixer_ChannelGetEnvelope(source, 
                                         BASSMIXEnvelope.BASS_MIXER_ENV_VOL, Nothing)
            Console.WriteLine("Pos={0}", pos)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Int64)">
            <summary>
            Sets the current position of an envelope on a channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The envelope to set the position/value of. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope"/>):
            <list type="table">
            <item><term>BASS_MIXER_ENV_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_MIXER_ENV_VOL</term><description>Volume.</description></item>
            <item><term>BASS_MIXER_ENV_PAN</term><description>Panning/balance.</description></item>
            </list>
            </param>
            <param name="pos">The new envelope position, in bytes. If this is beyond the end of the envelope it will be capped or looped, depending on whether the envelope has looping enabled.</param>
            <returns>If successful, the current position of the envelope is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            During playback, the effect of changes are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_BUFFER</see> config option config option to reduce the buffer length.
            <para>Note: Envelopes deal in mixer positions, not sources!
            So when you are changing the source position (e.g. via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> the envelope's positions doesn't change with it.
            You might use this method to align the envelope position accorting to the new source position (see example below).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no envelope of the requested type on the channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Align the envelope position when seeking on the source:
            <code>
            // set a volume envelope on a source mixer channel (do this just once)
            BASS_MIXER_NODE[] nodes = 
              {
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 3d), 1f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 5d), 0f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 7d), 0f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 9d), 1f)
              };
            BassMix.BASS_Mixer_ChannelSetEnvelope(source, BASSMIXEnvelope.BASS_MIXER_ENV_VOL, nodes);
            ...
            
            // change the source position and align the envelope position to it
            // pause mixer
            Bass.BASS_ChannelLock(mixer, true);
            BassMix.BASS_Mixer_ChannelSetPosition(source, newPos);
            // convert source pos to mixer pos 
            long envPos = Bass.BASS_ChannelSeconds2Bytes(mixer, Bass.BASS_ChannelBytes2Seconds(source, newPos));
            BassMix.BASS_Mixer_ChannelSetEnvelopePos(source, BASSMIXEnvelope.BASS_MIXER_ENV_VOL, envPos);
            // resume mixer 
            Bass.BASS_ChannelLock(mixer, false);
            ...
            </code>
            <code lang="vbnet">
            Dim nodes As BASS_MIXER_NODE() =  
              {
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 3.0), 1F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 5.0), 0F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 7.0), 0F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 9.0), 1F)
              }
            BassMix.BASS_Mixer_ChannelSetEnvelope(source, BASSMIXEnvelope.BASS_MIXER_ENV_VOL, nodes)
            ...
            
            ' change the source position and align the envelope position to it
            ' pause mixer
            Bass.BASS_ChannelLock(mixer, True)
            BassMix.BASS_Mixer_ChannelSetPosition([source], newPos)
            ' convert source pos to mixer pos 
            Dim envPos As Long = Bass.BASS_ChannelSeconds2Bytes(mixer, Bass.BASS_ChannelBytes2Seconds([source], newPos))
            BassMix.BASS_Mixer_ChannelSetEnvelopePos([source], BASSMIXEnvelope.BASS_MIXER_ENV_VOL, envPos)
            ' resume mixer 
            Bass.BASS_ChannelLock(mixer, False)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelope(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE[],System.Int32)">
            <summary>
            Sets an envelope to modify the sample rate, volume or pan of a channel over a period of time.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The envelope to get the position/value of. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope"/>):
            <list type="table">
            <item><term>BASS_MIXER_ENV_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_MIXER_ENV_VOL</term><description>Volume.</description></item>
            <item><term>BASS_MIXER_ENV_PAN</term><description>Panning/balance.</description></item>
            <item><term>BASS_MIXER_ENV_LOOP</term><description>Loop the envelope. This is a flag and can be used in combination with any of the above.</description></item>
            </list>
            </param>
            <param name="nodes">The array of envelope nodes, which should have sequential positions.</param>
            <param name="count">The number of elements in the nodes array... 0 = no envelope.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            In the case of <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_FREQ</see> and <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_VOL</see>, 
            the final sample rate and volume is a product of the channel attribute and the envelope. 
            While in the <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_PAN</see> case, the final panning is a sum of the channel attribute and envelope.</para>
            <para><see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Single@)"/> can be used to get the current envelope position, 
            and a <see cref="T:Un4seen.Bass.BASSSync">BASS_SYNC_MIXER_ENVELOPE</see> sync can be set via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> to be informed of when an envelope ends. 
            The function can be called again from such a sync, in order to set a new envelope to follow the old one.</para>
            <para>Any previous envelope of the same type is replaced by the new envelope. A copy is made of the nodes array, so it does not need to persist beyond this function call.</para>
            <para>Note: Envelopes deal in mixer positions, not sources!
            You might use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Int64)"/> to adjust the envelope to a source channel position.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set an envelope to bounce the pan position between left and right every 4 seconds:
            <code>
            BASS_MIXER_NODE[] nodes = 
              {
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 0d), 0f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 1d), -1f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 3d), 1f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 4d), 0f)
              };
            BassMix.BASS_Mixer_ChannelSetEnvelope(_channel, BASSMIXEnvelope.BASS_MIXER_ENV_PAN | BASSMIXEnvelope.BASS_MIXER_ENV_LOOP, nodes, 4);
            </code>
            <code lang="vbnet">
            Dim nodes As BASS_MIXER_NODE() =  
              {
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 0.0), 0F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 1.0), -1F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 3.0), 1F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 4.0), 0F)
              }
            BassMix.BASS_Mixer_ChannelSetEnvelope(_channel, BASSMIXEnvelope.BASS_MIXER_ENV_PAN | BASSMIXEnvelope.BASS_MIXER_ENV_LOOP, nodes, 4)
            </code>
            Remove any still available envelope nodes:
            <code>
            BassMix.BASS_Mixer_ChannelSetEnvelope(_channel, BASSMIXEnvelope.BASS_MIXER_ENV_PAN, null, 0);
            </code>
            <code lang="vbnet">
            BassMix.BASS_Mixer_ChannelSetEnvelope(_channel, BASSMIXEnvelope.BASS_MIXER_ENV_PAN, Nothing, 0)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelope(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE[])">
            <summary>
            Sets an envelope to modify the sample rate, volume or pan of a channel over a period of time.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The envelope to get the position/value of. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope"/>):
            <list type="table">
            <item><term>BASS_MIXER_ENV_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_MIXER_ENV_VOL</term><description>Volume.</description></item>
            <item><term>BASS_MIXER_ENV_PAN</term><description>Panning/balance.</description></item>
            <item><term>BASS_MIXER_ENV_LOOP</term><description>Loop the envelope. This is a flag and can be used in combination with any of the above.</description></item>
            </list>
            </param>
            <param name="nodes">The array of envelope nodes, which should have sequential positions (NULL = no envelope).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            In the case of <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_FREQ</see> and <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_VOL</see>, 
            the final sample rate and volume is a product of the channel attribute and the envelope. 
            While in the <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_PAN</see> case, the final panning is a sum of the channel attribute and envelope.</para>
            <para><see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Single@)"/> can be used to get the current envelope position, 
            and a <see cref="T:Un4seen.Bass.BASSSync">BASS_SYNC_MIXER_ENVELOPE</see> sync can be set via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> to be informed of when an envelope ends. 
            The function can be called again from such a sync, in order to set a new envelope to follow the old one.</para>
            <para>Any previous envelope of the same type is replaced by the new envelope. A copy is made of the nodes array, so it does not need to persist beyond this function call.</para>
            <para>Note: Envelopes deal in mixer positions, not sources!
            You might use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Int64)"/> to adjust the envelope to a source channel position.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Volume curve envelope starting after 3 seconds, ending after 9 seconds:
            <code>
            BASS_MIXER_NODE[] nodes = 
              {
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 3d), 1f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 5d), 0.3f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 7d), 0.5f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 9d), 1f)
              };
            BassMix.BASS_Mixer_ChannelSetEnvelope(_channel, BASSMIXEnvelope.BASS_MIXER_ENV_VOL, nodes);
            </code>
            <code lang="vbnet">
            Dim nodes As BASS_MIXER_NODE() =  
              {
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 3.0), 1F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 5.0), 0.3F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 7.0), 0.5F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 9.0), 1F)
              }
            BassMix.BASS_Mixer_ChannelSetEnvelope(_channel, BASSMIXEnvelope.BASS_MIXER_ENV_VOL, nodes)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">
            <summary>
            Sets up a synchronizer on a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The type of sync (see <see cref="T:Un4seen.Bass.BASSSync"/> for details). This can be one of the standard sync types, as available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, or one of the mixer specific sync types listed below plus one of the following flags:
            <list type="table">
            <item><term>BASS_SYNC_ONETIME</term><description>Call the sync only once.</description></item>
            <item><term>BASS_SYNC_MIXTIME</term><description>Call the sync function when the sync occurs during decoding/mixing, instead of delaying the call until the sync is actually heard. This is automatically applied with decoding channels, as they can not be played/heard.</description></item>
            </list>
            </param>
            <param name="param">The sync parameters, depends on the sync type (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> or <see cref="T:Un4seen.Bass.BASSSync"/> for details).</param>
            <param name="proc">The callback function which should be invoked with the sync.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If succesful, then the new synchronizer's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Sync types, with param and <see cref="T:Un4seen.Bass.SYNCPROC"/> data definitions:
            <list type="table">
            <item><term>BASS_SYNC_MIXER_ENVELOPE</term><description>Sync when an envelope reaches the end.
            <para>param : not used.</para>
            <para>data : envelope type.</para>
            </description></item>
            <item><term>BASS_SYNC_STALL</term><description>This is like the standard BASS_SYNC_STALL sync, except it can be either mixtime or not.
            <para>param : not used.</para>
            <para>data : 0 = stalled, 1 = resumed.</para>
            </description></item>
            </list>
            <para>When used on a decoding channel (eg. a mixer source channel), syncs set with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> are automatically "mixtime", 
            which means that they will be triggered as soon as the sync event is encountered during decoding. 
            But if the mixer output is being played, then there is a playback buffer involved, which will delay the hearing of the sync event. 
            This function compensates for that, delaying the triggering of the sync until the event is actually heard. 
            If the mixer itself is a decoding channel, or the BASS_SYNC_MIXTIME flag is used, then there is effectively no real difference between this function and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>.
            One sync type that is slightly different is the BASS_SYNC_STALL sync, which can be either mixtime or not.</para>
            <para>Sync types that would automatically be mixtime when using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> are not so when using this function. 
            The BASS_SYNC_MIXTIME flag should be specified in those cases, or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> used instead.</para>
            <para>When a source is removed from a mixer, any syncs that have been set on it via this function are automatically removed. 
            If the channel is subsequently plugged back into a mixer, the previous syncs will not still be set on it. Syncs set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> are unaffected.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description>An illegal <paramref name="type"/> was specified.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal <paramref name="param"/> was specified.</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.SYNCPROC"/> for an example on how to use synchronizers.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.AddOn.Mix.SYNCPROCEX,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="type"></param>
            <param name="param"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSyncEx(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.AddOn.Mix.SYNCPROCEX,System.IntPtr)">
            <summary>
            Sets up an extended synchronizer on a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The type of sync (see <see cref="T:Un4seen.Bass.BASSSync"/> for details). This can be one of the standard sync types, as available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, or one of the mixer specific sync types listed below plus one of the following flags:
            <list type="table">
            <item><term>BASS_SYNC_ONETIME</term><description>Call the sync only once.</description></item>
            <item><term>BASS_SYNC_MIXTIME</term><description>Call the sync function when the sync occurs during decoding/mixing, instead of delaying the call until the sync is actually heard. This is automatically applied with decoding channels, as they can not be played/heard.</description></item>
            </list>
            </param>
            <param name="param">The sync parameters, depends on the sync type (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> or <see cref="T:Un4seen.Bass.BASSSync"/> for details).</param>
            <param name="proc">The callback function which should be invoked with the sync.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If succesful, then the new synchronizer's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Sync types, with param and <see cref="T:Un4seen.Bass.SYNCPROC"/> data definitions:
            <list type="table">
            <item><term>BASS_SYNC_MIXER_ENVELOPE</term><description>Sync when an envelope reaches the end.
            <para>param : not used.</para>
            <para>data : envelope type.</para>
            </description></item>
            <item><term>BASS_SYNC_STALL</term><description>This is like the standard BASS_SYNC_STALL sync, except it can be either mixtime or not.
            <para>param : not used.</para>
            <para>data : 0 = stalled, 1 = resumed.</para>
            </description></item>
            </list>
            <para>The main difference between this method and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> is, that this method invokes the <see cref="T:Un4seen.Bass.AddOn.Mix.SYNCPROCEX"/> callback.
            This callback contains an extra 'offeset' parameter, which defines the position of the sync occurrence within the current update cycle of the source converted to the mixer stream position.
            This offset might be used to calculate more accurate non-mixtime sync triggers (as with non-mixtime sync's a variable delay is to be expected, as the accuracy depends on the sync thread waking in time, and there is no guarantee when that will happen) - 
            as well as mixtime syncs are only accurate to the current update period, as they are triggered within such.
            So a mixtime sync is being triggered ahead of the actual mixer position being heard. The 'offset' parameter might be used to compensate for that.</para>
            <para>When used on a decoding channel (eg. a mixer source channel), syncs set with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> are automatically "mixtime", 
            which means that they will be triggered as soon as the sync event is encountered during decoding. 
            But if the mixer output is being played, then there is a playback buffer involved, which will delay the hearing of the sync event. 
            This function compensates for that, delaying the triggering of the sync until the event is actually heard. 
            If the mixer itself is a decoding channel, or the BASS_SYNC_MIXTIME flag is used, then there is effectively no real difference between this function and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>.
            One sync type that is slightly different is the BASS_SYNC_STALL sync, which can be either mixtime or not.</para>
            <para>Sync types that would automatically be mixtime when using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> are not so when using this function. 
            The BASS_SYNC_MIXTIME flag should be specified in those cases, or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> used instead.</para>
            <para>When a source is removed from a mixer, any syncs that have been set on it via this function are automatically removed. 
            If the channel is subsequently plugged back into a mixer, the previous syncs will not still be set on it. Syncs set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> are unaffected.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description>An illegal <paramref name="type"/> was specified.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal <paramref name="param"/> was specified.</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.AddOn.Mix.SYNCPROCEX"/> for an example on how to use the extended synchronizer.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelRemoveSync(System.Int32,System.Int32)">
            <summary>
            Removes a synchronizer from a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (as returned by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>).</param>
            <param name="sync">Handle of the synchronizer to remove (return value of a previous <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> call).</param>
            <returns>If succesful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function can only remove syncs that were set via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, not those that were set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="sync"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSmix from the application's startup path:
            <code>
            Bass.LoadMe();
            BassMix.LoadMe();
            ...
            // when not used anymore...
            BassMix.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSmix from a different directory:
            <code>
            Bass.LoadMe( @"C:\Development\BASS\_libs" );
            BassMix.LoadMe( @"C:\Development\BASS\_libs" );
            ...
            // when not used anymore...
            BassMix.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">
            <summary>
            Mixer envelope attribute types, used with <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelope(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE[],System.Int32)"/>, <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Single@)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Int64)"/> to set/retrieve an envelope on a mixer source channel.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope.BASS_MIXER_ENV_FREQ">
            <summary>
            Sample rate.
            </summary>
            <remarks>
            Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            The final sample rate is the product of the channel attribute and the envelope.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope.BASS_MIXER_ENV_VOL">
            <summary>
            Volume.
            </summary>
            <remarks>
            Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            The final volume is the product of the channel attribute and the envelope.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope.BASS_MIXER_ENV_PAN">
            <summary>
            Panning/balance.
            </summary>
            <remarks>
            Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            The final panning is a sum of the channel attribute and envelope.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope.BASS_MIXER_ENV_LOOP">
            <summary>
            Loop the envelope (flag).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelope(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE[],System.Int32)"/> to set an envelope on a mixer source channel.
            </summary>
            <remarks>
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            In the case of <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_FREQ</see> and <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_VOL</see>, 
            the final sample rate and volume is a product of the channel attribute and the envelope. 
            While in the <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_PAN</see> case, the final panning is a sum of the channel attribute and envelope.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE.pos">
            <summary>
            The postion of the node in bytes. This is based on the mixer's sample format, not the source channel's format!
            </summary>
            <remarks>Note: Envelopes deal with mixer positions, not sources!</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE.val">
            <summary>
            The envelope value at the position.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE.#ctor(System.Int64,System.Single)">
            <summary>
            Constructor to initialize the members.
            </summary>
            <param name="Pos">The postion of the node in bytes. This is based on the mixer's sample format, not the source channel's format.</param>
            <param name="Val">The envelope value at the position.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE.ToString">
            <summary>
            A description of the mixer envelope node (position, value).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Mix.SYNCPROCEX">
            <summary>
            User defined extended mixer synchronizer callback function (see <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSyncEx(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.AddOn.Mix.SYNCPROCEX,System.IntPtr)"/> for details).
            </summary>
            <param name="handle">The sync handle that has occured (as returned by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSyncEx(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.AddOn.Mix.SYNCPROCEX,System.IntPtr)"/>).</param>
            <param name="channel">The channel that the sync occured on (the mixer source channel).</param>
            <param name="data">Additional data associated with the sync's occurance.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> was called.</param>
            <param name="offset">The offset in bytes containing the position of the sync occurrence within the update cycle converted to the mixer stream.</param>
            <remarks>
            <para>A sync callback function should be very quick as other syncs can't be processed until it has finished. Attribute slides (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelSlideAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single,System.Int32)"/>) are also performed by the sync thread, so are also affected if a sync callback takes a long time.</para>
            <para>If the sync is a "mixtime" sync (BASS_SYNC_MIXTIME), then depending on the sync type, the callback will be executed in the update thread.
            The <paramref name="offset"/> specifies the position of the sync within the update buffer converted to the mixer stream position.
            Note that the <paramref name="offset"/> is based on the mixer's sample format, so you'll need to convert that to the source's format if using the sync to trigger things on the source.</para>
            <para>The usual restrictions on which BASS functions can be called that apply to stream callbacks (<see cref="T:Un4seen.Bass.STREAMPROC"/>) also apply here. 
            It is also unsafe to call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> on the same channel from a mixtime sync callback. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> can be used in a mixtime sync to implement custom looping, eg. set a BASS_SYNC_POS sync at the loop end position and seek to the loop start position in the callback.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BassEnc">
            <summary>
            BASS.NET API wrapper for BASSENC.DLL
            <para>Requires: bassenc.dll - Encoding support library - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSenc is an extension that allows BASS channels to be encoded using any command-line encoder that has STDIN support (LAME/OGGENC/etc).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASSENCVERSION">
            <summary>
            Current BASSenc version (without minor revision).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetVersion">
            <summary>
            Retrieves the version number of the BASSenc.DLL that is loaded.
            </summary>
            <returns>The BASSenc version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASSenc supports all the BASSenc functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASSENCVERSION"/> to check the major revision.</para>
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(BassEnc.BASS_Encode_GetVersion()) != BassEnc.BASSENCVERSION )
            {
              MessageBox.Show(this, "Wrong BassEnc Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(BassEnc.BASS_Encode_GetVersion()) &lt;&gt; BassEnc.BASSENCVERSION Then
              MessageBox.Show(Me, "Wrong BassEnc Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (BassEnc.BASS_Encode_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong BassEnc Version!");
            }
            </code>
            <code lang="vbnet">
            If BassEnc.BASS_Encode_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong BassEnc Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASSenc.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASSenc version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASSenc supports all the BASSenc functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (BassEnc.BASS_Encode_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong BassEnc Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If BassEnc.BASS_Encode_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong BassEnc Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="cmdline"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)">
            <summary>
            Starts encoding on a channel.
            <para>This overload implements UNICODE cmdlines. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="cmdline">The encoder command-line, including the executable filename and any options. Or the output filename if the BASS_ENCODE_PCM flag is specified.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_PCM</term><description>Write plain PCM sample data to a file, without an encoder. The output filename is given in the cmdline parameter.</description></item>
            <item><term>BASS_ENCODE_NOHEAD</term><description>Don't send a WAVE header to the encoder. If this flag is used then the sample format must be passed to the encoder some other way (eg. via the command-line).</description></item>
            <item><term>BASS_ENCODE_BIGEND</term><description>Send big-endian sample data to the encoder, else little-endian.</description></item>
            <item><term>BASS_ENCODE_FP_8BIT, BASS_ENCODE_FP_16BIT, BASS_ENCODE_FP_24BIT, BASS_ENCODE_FP_32BIT</term><description>When you want to encode a floating-point channel, but the encoder does not support 32-bit floating-point sample data, then you can use one of these flags to have the sample data converted to 8/16/24/32 bit integer data before it's passed on to the encoder. These flags are ignored if the channel's sample data isn't floating-point.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_UNICODE</term><description>cmdline is Unicode (16-bit characters) (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="proc">Optional callback function to receive the encoded data... NULL = no callback. To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>The encoder process handle is returned if the encoder is successfully started, else 0 is returned.</returns>
            <remarks>
            <para>The encoder must be told (via the command-line) to expect input from STDIN, rather than a file. The command-line should also tell the encoder what filename to write it's output to, unless you're using a callback function, in which case it should be told to write it's output to STDOUT.</para>
            <para>No user interaction with the encoder is possible, so anything that would cause the encoder to require the user to press any keys should be avoided. For example, if the encoder asks whether to overwrite files, the encoder should be instructed to always overwrite (via the command-line), or you should delete the existing file before starting the encoder.</para>
            <para>Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel. That means when you play the channel (or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            It also means that if you use the BASS_CONFIG_FLOATDSP option, then the sample data will be 32-bit floating-point, and you'll need to use one of the BASS_ENCODE_FP flags if the encoder does not support floating-point sample data. 
            The BASS_CONFIG_FLOATDSP setting should not be changed while encoding is in progress.</para>
            <para>The encoder DSP has a priority setting of -1000, so if you want to set DSP/FX on the channel and have them present in the encoding, set their priority above that.</para>
            <para>Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> function. Both methods can be used together, but in general, the "automatic" system ought be paused when using the "manual" system, by use of the BASS_ENCODE_PAUSE flag or the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)"/> function.</para>
            <para><see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/> can be used to check that the encoder is still running. When done encoding, use <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> to close the encoder.</para>
            <para>The returned process handle can be used to do things like change the encoder's priority and get it's exit code. See the System.Diagnostics namespace for details.</para>
            <para>Multiple encoders can be set on a channel. For simplicity, the encoder functions (ie. BASS_Encode_IsActive/SetPaused/Stop/Write) will accept either an encoder handle or a channel handle. When using a channel handle, the function is applied to all encoders that are set on that channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>Couldn't start the encoder. Check that the executable exists.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>The PCM file couldn't be created.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Start encoding a channel to an MP3 file (output.mp3) using LAME with the standard preset settings:
            <code>
            BassEnc.BASS_Encode_Start(channel, "lame --alt-preset standard - output.mp3", 
                    0, null, IntPtr.Zero);
            // start the channel playing &amp; encoding
            Bass.BASS_ChannelPlay(channel, false);
            </code>
            <code lang="vbnet">
            BassEnc.BASS_Encode_Start(channel, "lame --alt-preset standard - output.mp3", 
                    0, Nothing, IntPtr.Zero)
            ' start the channel playing &amp; encoding
            Bass.BASS_ChannelPlay(channel, False)
            </code>
            Start writing a channel to a WAV file (output.wav):
            <code>
            BassEnc.BASS_Encode_Start(channel, "output.wav", 
                    BASSEncode.BASS_ENCODE_PCM, null, IntPtr.Zero);
            // start the channel playing &amp; encoding
            Bass.BASS_ChannelPlay(channel, false);
            </code>
            <code lang="vbnet">
            BassEnc.BASS_Encode_Start(channel, "output.wav", 
                    BASSEncode.BASS_ENCODE_PCM, Nothing, IntPtr.Zero)
            ' start the channel playing &amp; encoding
            Bass.BASS_ChannelPlay(channel, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)">
            <summary>
            Checks if an encoder is running on a channel.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>The return value is one of the folowing (see <see cref="T:Un4seen.Bass.BASSActive"/>):
            <list type="table">
            <item><term>BASS_ACTIVE_STOPPED</term><description>No encoder is running on the channel.</description></item>
            <item><term>BASS_ACTIVE_PLAYING</term><description>There is an encoder running on the channel.</description></item>
            <item><term>BASS_ACTIVE_PAUSED</term><description>There is an encoder running on the channel, but it is paused.</description></item>
            </list>
            </returns>
            <remarks>
            <para>When checking if there's an encoder running on a channel, and there are multiple encoders on the channel, BASS_ACTIVE_PLAYING will be returned if any of them are active.</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
            <example>
            In a recording callback (see <see cref="T:Un4seen.Bass.RECORDPROC"/>) this might be used to check, if recording should be continued:
            <code>
            private bool RecordingCallback(int channel, IntPtr buffer, int length, IntPtr user)
            {
              // continue recording if encoder is alive
              return ( BassEnc.BASS_Encode_IsActive(channel) != BASSActive.BASS_ACTIVE_STOPPED );
            }
            </code>
            <code lang="vbnet">
            Private Function RecordingCallback(channel As Integer, buffer As IntPtr, 
                                               length As Integer, user As IntPtr) As Boolean
              ' continue recording if encoder is alive
              Return BassEnc.BASS_Encode_IsActive(channel) &lt;&gt; BASSActive.BASS_ACTIVE_STOPPED
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)">
            <summary>
            Stops encoding on a channel.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>If no encoder has been started on the channel, FALSE is returned, otherwise TRUE is returned.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)">
            <summary>
            Pauses or resumes encoding on a channel.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="paused">Paused?</param>
            <returns>If no encoder has been started on the channel, FALSE is returned, otherwise TRUE is returned.</returns>
            <remarks>When an encoder is paused, no sample data will be sent to the encoder.
            <para>When an encoder is paused, no sample data will be sent to the encoder "automatically". Data can still be sent to the encoder "manually" though, via the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> function.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sends sample data to the encoder.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="buffer">A pointer to the buffer containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder. But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the BASS_CONFIG_FLOATDSP (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) option is enabled.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The encoder has died.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.Single[],System.Int32)">
            <summary>
            Sends sample data to the encoder.
            <para>This overload uses a managed float[] to handover sample data to the encoder (typically not used, since most encoders expect 16-bit, so use the int[] or short[] overload).</para>
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="buffer">A reference to the first array element (float[0]) containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder. But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the BASS_CONFIG_FLOATDSP (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) option is enabled.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The encoder has died.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Sends sample data to the encoder.
            <para>This overload uses a managed int[] to handover sample data to the encoder (Note: An int[] is 32-bit. When using 16-bit samples we can keep a stereo pair in here).</para>
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="buffer">A reference to the first array element (int[0]) containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder. But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the BASS_CONFIG_FLOATDSP (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) option is enabled.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The encoder has died.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Sends sample data to the encoder.
            <para>This overload uses a managed short[] to handover sample data to the encoder (perfect for 16-bit samples).</para>
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="buffer">A reference to the first array element (short[0]) containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder. But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the BASS_CONFIG_FLOATDSP (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) option is enabled.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The encoder has died.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Sends sample data to the encoder.
            <para>This overload uses a managed byte[] to handover sample data to the encoder (perfect for 8-bit samples).</para>
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="buffer">A reference to the first array element (byte[0]) containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder. But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the BASS_CONFIG_FLOATDSP (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) option is enabled.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The encoder has died.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetCount(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeCount)">
            <summary>
            Retrieves the amount data sent to or received from an encoder, or sent to a cast server.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="count">The count to retrieve. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncodeCount"/>):
            <list type="table">
            <item><term>BASS_ENCODE_COUNT_IN</term><description>Data sent to the encoder.</description></item>
            <item><term>BASS_ENCODE_COUNT_OUT</term><description>Data received from the encoder. This only applies when the encoder outputs to STDOUT or it is an ACM encoder.</description></item>
            <item><term>BASS_ENCODE_COUNT_CAST</term><description>Data sent to a cast server.</description></item>
            </list>
            </param>
            <returns>If successful, the requested count (in bytes) is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The BASS_ENCODE_COUNT_IN count will be the same as the amount of data received from the source channel, unless it is floating-point, in which case it may not be if one of the BASS_ENCODE_FP flags is active, or the encoder is using an ACM codec (which take 16-bit data).
            <para>When the encoder output is being sent to a cast server, the BASS_ENCODE_COUNT_CAST count will match the BASS_ENCODE_COUNT_OUT count, unless there have been problems (eg. network timeout) that have caused data to be dropped.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="count"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormatUnicode(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="form"></param>
            <param name="fromlen"></param>
            <param name="title"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)">
            <summary>
            Presents the user with a list of available ACM (Audio Compression Manager) codec output formats to choose from.
            <para>The overload implements the Unicode version for the title, so the BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="form">Pointer to the format buffer.</param>
            <param name="fromlen">Size of the format buffer. If this is 0, then a suggested format buffer length is returned (which is the maximum length of all installed codecs), without displaying the codec selector.</param>
            <param name="title">Window title for the selector... NULL = "Choose the output format".</param>
            <param name="flags">A combination of these flags <see cref="T:Un4seen.Bass.AddOn.Enc.BASSACMFormat"/>:
            <list type="table">
            <item><term>BASS_ACM_DEFAULT</term><description>Use the format buffer (form) contents as the default choice in the codec selector.</description></item>
            <item><term>BASS_ACM_RATE</term><description>Only include formats with the same sample rate as the source.</description></item>
            <item><term>BASS_ACM_CHANS</term><description>Only include formats with the same number of channels (mono/stereo) as the source.</description></item>
            <item><term>BASS_ACM_SUGGEST</term><description>Suggest a format without letting the user choose. The wanted format tag (eg. WAVE_FORMAT_ADPCM) should be specified in the HIWORD.</description></item>
            </list>
            The HighWord - use <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>(flags,format) - can be used to restrict the choice to a particular format tag (eg. WAVE_FORMAT_ADPCM). This is required with BASS_ACM_SUGGEST, and is optional otherwise.
            See <see cref="T:Un4seen.Bass.AddOn.Enc.WAVEFormatTag"/> for a list of typical formats being used.
            </param>
            <returns>If successful, the user-selected codec format details are put in the provided buffer and the length of the format details is returned, else 0 is returned. 
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. If formlen is 0, then the suggested format buffer size is returned.</returns>
            <remarks>This function presents the user with a list of available ACM codecs to choose from, given the sample format of the channel. The details of the chosen codec's output are returned in the form buffer, 
            which can then be used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACM(System.Int32,Un4seen.Bass.AddOn.Enc.ACMFORMAT,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACMFile(System.Int32,System.IntPtr,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)"/> to begin encoding.
            <para>The <paramref name="form"/> buffer contents are actually a <see cref="T:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX"/> or <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> structure.
            If writing the encoder output to a WAVE file, the form buffer contents would be the format chunk ("fmt") of the file.</para>
            <para>To not let the user choose a codec, but automatically suggest a codec you might also use the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormatSuggest(System.Int32,Un4seen.Bass.AddOn.Enc.BASSACMFormat,Un4seen.Bass.AddOn.Enc.WAVEFormatTag)"/> method.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There are no codecs available that will accept the channel's format.</description></item>
            <item><term>BASS_ERROR_ACM_CANCEL</term><description>The user pressed the "cancel" button.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Let the user choose a codec, and setup an encoder on a channel using the chosen codec:
            <code>
            // get suggested (maximum) format buffer size
            int formlen = BassEnc.BASS_Encode_GetACMFormat(0, IntPtr.Zero, 0, null, BASSACMFormat.BASS_ACM_NONE);
            // create a buffer for the codec
            byte[] buffer = new byte[formlen];
            // now create a pinned handle, so that the Garbage Collector will not move this object
            GCHandle hGC = GCHandle.Alloc( buffer, GCHandleType.Pinned );
            // get the pointer to that pinned object
            IntPtr codec = hGC.AddrOfPinnedObject();
            // let the user choose a codec...
            if ( BassEnc.BASS_Encode_GetACMFormat( channel, codec, formlen, "Choose your format", BASSACMFormat.BASS_ACM_DEFAULT) &gt; 0 )
            {
              // get the generic codec information back
              ACMFORMAT acm = (ACMFORMAT)Marshal.PtrToStructure(codec, typeof(ACMFORMAT));
              // begin encoding using the codec
              BassEnc.BASS_Encode_StartACMFile( channel, codec, BASSEncode.BASS_ENCODE_DEFAULT, "acm.wav");
            }
            // free the codec format buffer (you might free it even if encoding is still running)
            hGC.Free();
            </code>
            <code lang="vbnet">
            ' get suggested (maximum) format buffer size
            Dim formlen As Integer = BassEnc.BASS_Encode_GetACMFormat(0, IntPtr.Zero, 0, Nothing, BASSACMFormat.BASS_ACM_NONE)
            ' create a buffer for the codec
            Dim buffer(formlen) As Byte
            ' now create a pinned handle, so that the Garbage Collector will not move this object
            Dim hGC As GCHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned)
            ' get the pointer to that pinned object
            Dim codec As IntPtr = hGC.AddrOfPinnedObject()
            ' let the user choose a codec...
            If BassEnc.BASS_Encode_GetACMFormat(channel, codec, formlen, "Choose your format", 
                       BASSACMFormat.BASS_ACM_DEFAULT) &gt; 0 Then
              ' get the generic codec information back
              Dim acm As ACMFORMAT = CType(Marshal.PtrToStructure(codec, GetType(ACMFORMAT)), ACMFORMAT)
              ' begin encoding using the codec
              BassEnc.BASS_Encode_StartACMFile(channel, codec, BASSEncode.BASS_ENCODE_DEFAULT, "acm.wav")
            End If
            ' free the codec format buffer (you might free it even if encoding is still running)
            hGC.Free()
            </code>
            If you are into C# using native pointers in an unsafe codeblock would be even faster:
            <code>
            // get suggested (maximum) format buffer size
            int formlen = BassEnc.BASS_Encode_GetACMFormat(0, IntPtr.Zero, 0, null, BASSACMFormat.BASS_ACM_NONE);
            // create a buffer for the codec
            byte[] buffer = new byte[formlen];
            unsafe
            {
              fixed (byte* p = buffer)
              {
                // let the user choose a codec...
                if ( BassEnc.BASS_Encode_GetACMFormat( channel, (IntPtr)p, formlen, "Choose your format", BASSACMFormat.BASS_ACM_DEFAULT) &gt; 0 )
                {
                  // get the generic codec information back
                  ACMFORMAT acm = (ACMFORMAT)Marshal.PtrToStructure((IntPtr)p, typeof(ACMFORMAT));
                  // begin encoding using the codec
                  BassEnc.BASS_Encode_StartACMFile( channel, acm, BASSEncode.BASS_ENCODE_DEFAULT, "acm.wav");
                }
              }
            }
            </code>
            For more convenience use the other overload of <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/>.
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat,Un4seen.Bass.AddOn.Enc.WAVEFormatTag)">
            <summary>
            Presents the user with a list of available ACM (Audio Compression Manager) codec output formats to choose from.
            <para>This overload returns the generic codec format <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> and handles all the rest already for you.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="title">Window title for the selector... NULL = "Choose the output format".</param>
            <param name="flags">A combination of these flags <see cref="T:Un4seen.Bass.AddOn.Enc.BASSACMFormat"/>:
            <list type="table">
            <item><term>BASS_ACM_DEFAULT</term><description>Use the format buffer (form) contents as the default choice in the codec selector.</description></item>
            <item><term>BASS_ACM_RATE</term><description>Only include formats with the same sample rate as the source.</description></item>
            <item><term>BASS_ACM_CHANS</term><description>Only include formats with the same number of channels (mono/stereo) as the source.</description></item>
            <item><term>BASS_ACM_SUGGEST</term><description>Suggest a format without letting the user choose. The wanted format tag (eg. WAVE_FORMAT_ADPCM) should be specified in the HIWORD.</description></item>
            </list>
            The HighWord - use <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>(flags,format) - can be used to restrict the choice to a particular format tag (eg. WAVE_FORMAT_ADPCM). This is required with BASS_ACM_SUGGEST, and is optional otherwise.
            See <see cref="T:Un4seen.Bass.AddOn.Enc.WAVEFormatTag"/> for a list of typical formats being used.
            </param>
            <param name="format">The wanted codec format (use one of the <see cref="T:Un4seen.Bass.AddOn.Enc.WAVEFormatTag"/> flags, or see the MMREG.H file for more).</param>
            <returns>If successful, an instance of the generic codec format <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> is returned, else NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function presents the user with a list of available ACM codecs to choose from, given the sample format of the channel. The details of the chosen codec's output are returned as a generic codec format <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/>,
            which can then be used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACM(System.Int32,Un4seen.Bass.AddOn.Enc.ACMFORMAT,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACMFile(System.Int32,System.IntPtr,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)"/> to begin encoding.
            <para>If writing the encoder output to a WAVE file, the codec format's <see cref="T:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX"/> contents would be the format chunk ("fmt") of the file.</para>
            <para>To not let the user choose a codec, but automatically suggest a codec you might also use the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormatSuggest(System.Int32,Un4seen.Bass.AddOn.Enc.BASSACMFormat,Un4seen.Bass.AddOn.Enc.WAVEFormatTag)"/> method.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There are no codecs available that will accept the channel's format.</description></item>
            <item><term>BASS_ERROR_ACM_CANCEL</term><description>The user pressed the "cancel" button.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Let the user choose a codec, and setup an encoder on a channel using the chosen codec:
            <code>
            ACMFORMAT codec = BassEnc.BASS_Encode_GetACMFormat(channel, "Select your encoder", 
                                      BASSACMFormat.BASS_ACM_DEFAULT, 
                                      WAVEFormatTag.WAVE_FORMAT_UNKNOWN);
            if ( codec != null )
            {
            	// begin encoding using the codec
            	BassEnc.BASS_Encode_StartACMFile( channel, codec, BASSEncode.BASS_ENCODE_DEFAULT, "acm.wav");
            }
            </code>
            <code lang="vbnet">
            Dim codec As ACMFORMAT = BassEnc.BASS_Encode_GetACMFormat(channel, "Select your encoder", 
                                             BASSACMFormat.BASS_ACM_DEFAULT, 
                                             WAVEFormatTag.WAVE_FORMAT_UNKNOWN)
            If Not (codec Is Nothing) Then
              ' begin encoding using the codec
              BassEnc.BASS_Encode_StartACMFile(channel, codec, BASSEncode.BASS_ENCODE_DEFAULT, "acm.wav")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormatSuggest(System.Int32,Un4seen.Bass.AddOn.Enc.BASSACMFormat,Un4seen.Bass.AddOn.Enc.WAVEFormatTag)">
            <summary>
            Returns a suggested ACM (Audio Compression Manager) codec output format without displaying a user dialog.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="flags">A combination of these flags <see cref="T:Un4seen.Bass.AddOn.Enc.BASSACMFormat"/>:
            <list type="table">
            <item><term>BASS_ACM_DEFAULT</term><description>Use the format buffer (form) contents as the default choice in the codec selector.</description></item>
            <item><term>BASS_ACM_RATE</term><description>Only include formats with the same sample rate as the source.</description></item>
            <item><term>BASS_ACM_CHANS</term><description>Only include formats with the same number of channels (mono/stereo) as the source.</description></item>
            <item><term>BASS_ACM_SUGGEST</term><description>This flag will be added automatically.</description></item>
            </list>
            </param>
            <param name="format">The wanted codec format (use one of the <see cref="T:Un4seen.Bass.AddOn.Enc.WAVEFormatTag"/> flags, or see the MMREG.H file for more).</param>
            <returns>If successful, an instance of the generic codec format <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> is returned, else NULL is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function does NOT presents the user with a list of available ACM codecs to choose from, instead an automatic suggested codec will be returned, which matches the given format. 
            The details of the chosen codec's output are returned as a generic codec format <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/>,
            which can then be used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACM(System.Int32,Un4seen.Bass.AddOn.Enc.ACMFORMAT,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACMFile(System.Int32,System.IntPtr,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)"/> to begin encoding.
            <para>If writing the encoder output to a WAVE file, the codec format's <see cref="T:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX"/> contents would be the format chunk ("fmt") of the file.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There are no codecs available that will accept the channel's format.</description></item>
            <item><term>BASS_ERROR_ACM_CANCEL</term><description>The user pressed the "cancel" button.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Without letting the user choose, setup an MP3 encoder on a channel:
            <code>
            ACMFORMAT codec = BassEnc.BASS_Encode_GetACMFormatSuggest(channel, 
                                      BASSACMFormat.BASS_ACM_CHANS | BASSACMFormat.BASS_ACM_RATE,
                                      WAVEFormatTag.WAVE_FORMAT_MPEGLAYER3);
            if ( codec != null )
            {
              // begin encoding using the codec
              BassEnc.BASS_Encode_StartACMFile( channel, codec, BASSEncode.BASS_ENCODE_DEFAULT, "acm.mp3");
            }
            </code>
            <code lang="vbnet">
            Dim codec As ACMFORMAT = BassEnc.BASS_Encode_GetACMFormatSuggest(channel, 
                                             BASSACMFormat.BASS_ACM_CHANS Or BASSACMFormat.BASS_ACM_RATE,
                                             WAVEFormatTag.WAVE_FORMAT_MPEGLAYER3)
            If Not (codec Is Nothing) Then
              ' begin encoding using the codec
              BassEnc.BASS_Encode_StartACMFile(channel, codec, BASSEncode.BASS_ENCODE_DEFAULT, "acm.mp3")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACM(System.Int32,Un4seen.Bass.AddOn.Enc.ACMFORMAT,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)">
            <summary>
            Sets up an encoder on a channel, using an ACM codec and sending the output to a user defined function.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="form">ACM codec output format (an <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> instance as returned by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/>).</param>
            <param name="flags">A combination of these flags <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>:
            <list type="table">
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            </list>
            </param>
            <param name="proc">Callback function to receive the encoded data.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The ACM encoder allows installed ACM (Audio Compression Manager) codecs to be used for encoding. The codec used is determined by the contents of the form parameter. 
            The <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/> function can be used to initialize that.
            <para>Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel. That means when you play the channel (or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            The encoding is performed in the DSP callback. There isn't a separate process doing the encoding, as when using an external encoder via <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>.</para>
            <para>By default, the encoder DSP has a priority setting of -1000, which determines where in the DSP chain the encoding is performed. That can be changed using the BASS_CONFIG_ENCODE_PRIORITY config option (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>).</para>
            <para>Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> function. Both methods can be used together, but in general, the "automatic" system ought be paused when using the "manual" system, by use of the BASS_ENCODE_PAUSE flag or the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)"/> function.</para>
            <para>When done encoding, use <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> to close the encoder.</para>
            <para>Multiple encoders can be set on a channel. For simplicity, the encoder functions will accept either an encoder handle or a channel handle. When using a channel handle, the function is applied to all encoders that are set on that channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The codec specified in <paramref name="form"/> couldn't be initialized.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Setup an ACM encoder with a callback to process the encoded data:
            <code>
            // the encoding callback
            private ENCODEPROC _myEncProc;
            private byte[] _encbuffer = null;
            ...
            ACMFORMAT codec = BassEnc.BASS_Encode_GetACMFormat(channel, "Select your encoder", 
                                      BASSACMFormat.BASS_ACM_DEFAULT, WAVEFormatTag.WAVE_FORMAT_UNKNOWN);
            if ( codec != null )
            {
              // create the delegate
              _myEncProc = new ENCODEPROC(MyEncoderProc);
              // begin encoding using the codec with the delegate callback
              int encHandle = BassEnc.BASS_Encode_StartACM( channel, codec, 
                                      BASSEncode.BASS_ENCODE_DEFAULT, _myEncProc, IntPtr.Zero);
            }
            ...
            private bool MyEncodingWriter(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              // dynamic buffer allocation
              if ( _encbuffer == null || _encbuffer.Length &lt; length )
                _encbuffer = new byte[length];
            	
              // copy from managed to unmanaged memory
              Marshal.Copy(buffer, _encbuffer, 0, length);
              // process the data in _encbuffer, e.g. write to disk or whatever
              ...
            }
            </code>
            <code lang="vbnet">
            Private _myEncProc As ENCODEPROC
            Private _encbuffer As Byte() = Nothing
            ...
            Dim codec As ACMFORMAT = BassEnc.BASS_Encode_GetACMFormat(channel, "Select your encoder", 
                                             BASSACMFormat.BASS_ACM_DEFAULT, WAVEFormatTag.WAVE_FORMAT_UNKNOWN)
            If Not (codec Is Nothing) Then
              ' create the delegate
              _myEncProc = New ENCODEPROC(AddressOf MyEncoderProc)
              ' begin encoding using the codec with the delegate callback
              Dim encHandle As Integer = BassEnc.BASS_Encode_StartACM(channel, codec, 
                                                 BASSEncode.BASS_ENCODE_DEFAULT, _myEncProc, IntPtr.Zero)
            End If
            ...
            Private Function MyEncodingWriter(handle As Integer, channel As Integer, 
                                              buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              ' dynamic buffer allocation
              If _encbuffer Is Nothing OrElse _encbuffer.Length &lt; length Then
                _encbuffer = New Byte(length) {}
              End If 
            
              ' copy from managed to unmanaged memory
              Marshal.Copy(buffer, _encbuffer, 0, length)
              ' process the data in _encbuffer, e.g. write to disk or whatever
              ...
            End Function
            </code>
            If you are into C# you might also use native pointer access in an unsafe codeblock:
            <code>
            private unsafe void MyEncoding(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              // here we receive the encoded data back.
              // the encoded data is a kind of raw byte buffer...
              byte *data = (byte*)buffer;
            
              for (int a=0; a&lt;length; a++)
              {
                // do whatever you want with the encoded data
                _stream.WriteByte( data[a] );
              }
            }
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACM(System.Int32,System.IntPtr,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)">
            <summary>
            Sets up an encoder on a channel, using an ACM codec and sending the output to a user defined function.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="form">ACM codec output format (buffer as returned by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/>).</param>
            <param name="flags">A combination of these flags <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>:
            <list type="table">
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            </list>
            </param>
            <param name="proc">Callback function to receive the encoded data.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The ACM encoder allows installed ACM (Audio Compression Manager) codecs to be used for encoding. The codec used is determined by the contents of the form parameter. 
            The <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/> function can be used to initialize that.
            <para>Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel. That means when you play the channel (or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            The encoding is performed in the DSP callback. There isn't a separate process doing the encoding, as when using an external encoder via <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>.</para>
            <para>By default, the encoder DSP has a priority setting of -1000, which determines where in the DSP chain the encoding is performed. That can be changed using the BASS_CONFIG_ENCODE_PRIORITY config option (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>).</para>
            <para>Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> function. Both methods can be used together, but in general, the "automatic" system ought be paused when using the "manual" system, by use of the BASS_ENCODE_PAUSE flag or the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)"/> function.</para>
            <para>When done encoding, use <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> to close the encoder.</para>
            <para>Multiple encoders can be set on a channel. For simplicity, the encoder functions will accept either an encoder handle or a channel handle. When using a channel handle, the function is applied to all encoders that are set on that channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The codec specified in <paramref name="form"/> couldn't be initialized.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Setup an ACM encoder with a callback to process the encoded data:
            <code>
            // get suggested (maximum) format buffer size
            int formlen = BassEnc.BASS_Encode_GetACMFormat(0, IntPtr.Zero, 0, null, BASSACMFormat.BASS_ACM_NONE);
            // create a buffer for the codec
            byte[] buffer = new byte[formlen];
            unsafe
            {
              fixed (byte* p = buffer)
              {
                // let the user choose a codec...
                if ( BassEnc.BASS_Encode_GetACMFormat( channel, (IntPtr)p, formlen, "Choose your format", 
                             BASSACMFormat.BASS_ACM_DEFAULT) &gt; 0 )
                {
                  // create the delegate
            	  _myEncProc = new ENCODEPROC(MyEncoderProc);
                  // begin encoding using the codec with the delegate callback
            	  int encHandle = BassEnc.BASS_Encode_StartACMFile(channel, (IntPtr)p, BASSEncode.BASS_ENCODE_DEFAULT, _myEncProc, IntPtr.Zero);
                }
              }
            }
            ...
            // the encoding callback
            private ENCODEPROC _myEncProc;  // keep the callback delegate in a global member
            private bool MyEncodingWriter(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              ...
            }
            </code>
            <code lang="vbnet">
            ' get suggested (maximum) format buffer size
            Dim formlen As Integer = BassEnc.BASS_Encode_GetACMFormat(0, IntPtr.Zero, 0, Nothing, BASSACMFormat.BASS_ACM_NONE)
            ' create a buffer for the codec
            Dim buffer(formlen) As Byte
            ' now create a pinned handle, so that the Garbage Collector will not move this object
            Dim hGC As GCHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned)
            ' get the pointer to that pinned object
            Dim codec As IntPtr = hGC.AddrOfPinnedObject()
            ' let the user choose a codec...
            If BassEnc.BASS_Encode_GetACMFormat(channel, codec, formlen, "Choose your format", 
                       BASSACMFormat.BASS_ACM_DEFAULT) &gt; 0 Then
              ' create the delegate
              _myEncProc = New ENCODEPROC(AddressOf MyEncoderProc)
              ' begin encoding using the codec with the delegate callback
              Dim encHandle As Integer = BassEnc.BASS_Encode_StartACMFile(channel, codec, 
                                                 BASSEncode.BASS_ENCODE_DEFAULT, _myEncProc, IntPtr.Zero)
            End If
            ' free the codec format buffer (you might free it even if encoding is still running)
            hGC.Free()
            ...
            Private _myEncProc As ENCODEPROC
            Private Function MyEncodingWriter(handle As Integer, channel As Integer, 
                                              buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              ...
            End Function
            </code>
            If you are into C# using native pointers in an unsafe codeblock would be even faster:
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACMFileUnicode(System.Int32,System.IntPtr,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="form"></param>
            <param name="flags"></param>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACMFileUnicode(System.Int32,Un4seen.Bass.AddOn.Enc.ACMFORMAT,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="form"></param>
            <param name="flags"></param>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACMFile(System.Int32,System.IntPtr,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)">
            <summary>
            Sets up an encoder on a channel, using an ACM codec and writing the output to a file.
            <para>This overload represents the Unicode version for the file name. The BASS_UNICODE flag will automatically be added if missing.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="form">ACM codec output format (buffer as returned by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/>).</param>
            <param name="flags">A combination of these flags <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>:
            <list type="table">
            <item><term>BASS_ENCODE_NOHEAD</term><description>Don't write a WAVE header to the file.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            </list>
            </param>
            <param name="file">The filename to write.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The ACM encoder allows installed ACM (Audio Compression Manager) codecs to be used for encoding. The codec used is determined by the contents of the form parameter. The <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/> function can be used to initialize that.
            <para>Unless the BASS_ENCODE_NOHEAD flag is specified, a WAVE header and the form contents will be written to the file. This is generally required for the file to be playable, but in some cases (eg. MP3) it's not.</para>
            <para>Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel. That means when you play the channel (or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            The encoding is performed in the DSP callback. There isn't a separate process doing the encoding, as when using an external encoder via <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>.</para>
            <para>By default, the encoder DSP has a priority setting of -1000, which determines where in the DSP chain the encoding is performed. That can be changed using the BASS_CONFIG_ENCODE_PRIORITY config option (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>).</para>
            <para>Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> function. Both methods can be used together, but in general, the "automatic" system ought be paused when using the "manual" system, by use of the BASS_ENCODE_PAUSE flag or the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)"/> function.</para>
            <para>When done encoding, use <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> to close the encoder.</para>
            <para>Multiple encoders can be set on a channel. For simplicity, the encoder functions will accept either an encoder handle or a channel handle. When using a channel handle, the function is applied to all encoders that are set on that channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The codec specified in <paramref name="form"/> couldn't be initialized.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>The file couldn't be created.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Setup an ACM encoder with a callback to process the encoded data:
            <code>
            // get suggested (maximum) format buffer size
            int formlen = BassEnc.BASS_Encode_GetACMFormat(0, IntPtr.Zero, 0, null, BASSACMFormat.BASS_ACM_NONE);
            // create a buffer for the codec
            byte[] form = new byte[formlen];
            unsafe
            {
              fixed (byte* p = form)
              {
                // automatically suggest an MP3 codec
                if (BassEnc.BASS_Encode_GetACMFormat(handle, (IntPtr)p, formlen, null, 
                            (BASSACMFormat)Utils.MakeLong((int)(BASSACMFormat.BASS_ACM_SUGGEST | BASSACMFormat.BASS_ACM_RATE | BASSACMFormat.BASS_ACM_CHANS), 
                                                          (int)WAVEFormatTag.WAVE_FORMAT_MPEGLAYER3)) &gt; 0)
                {
                  // begin encoding
                  int encHandle = BassEnc.BASS_Encode_StartACMFile(channel, (IntPtr)p, 
                                          BASSEncode.BASS_ENCODE_NOHEAD, "output.mp3" );
            }
            </code>
            <code lang="vbnet">
            ' get suggested (maximum) format buffer size
            Dim formlen As Integer = BassEnc.BASS_Encode_GetACMFormat(0, IntPtr.Zero, 0, Nothing, BASSACMFormat.BASS_ACM_NONE)
            ' create a buffer for the codec
            Dim buffer(formlen) As Byte
            ' now create a pinned handle, so that the Garbage Collector will not move this object
            Dim hGC As GCHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned)
            ' get the pointer to that pinned object
            Dim codec As IntPtr = hGC.AddrOfPinnedObject()
            ' automatically suggest an MP3 codec
            If BassEnc.BASS_Encode_GetACMFormat(handle, codec, formlen, Nothing, 
                       CType(Utils.MakeLong(CInt(BASSACMFormat.BASS_ACM_SUGGEST Or BASSACMFormat.BASS_ACM_RATE Or BASSACMFormat.BASS_ACM_CHANS), 
                                            CInt(WAVEFormatTag.WAVE_FORMAT_MPEGLAYER3)), BASSACMFormat)) &gt; 0 Then
              ' begin encoding
              Dim encHandle As Integer = BassEnc.BASS_Encode_StartACMFile(channel, codec, 
                                                 BASSEncode.BASS_ENCODE_NOHEAD, "output.mp3")
            End If
            ' free the codec format buffer (you might free it even if encoding is still running)
            hGC.Free()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACMFile(System.Int32,Un4seen.Bass.AddOn.Enc.ACMFORMAT,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)">
            <summary>
            Sets up an encoder on a channel, using an ACM codec and writing the output to a file.
            <para>This overload represents the Unicode version for the file name. The BASS_UNICODE flag will automatically be added if missing.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="form">ACM codec output format (buffer as returned by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/>).</param>
            <param name="flags">A combination of these flags <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>:
            <list type="table">
            <item><term>BASS_ENCODE_NOHEAD</term><description>Don't write a WAVE header to the file.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            </list>
            </param>
            <param name="file">The filename to write.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The ACM encoder allows installed ACM (Audio Compression Manager) codecs to be used for encoding. The codec used is determined by the contents of the form parameter. The <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/> function can be used to initialize that.
            <para>Unless the BASS_ENCODE_NOHEAD flag is specified, a WAVE header and the form contents will be written to the file. This is generally required for the file to be playable, but in some cases (eg. MP3) it's not.</para>
            <para>Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel. That means when you play the channel (or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            The encoding is performed in the DSP callback. There isn't a separate process doing the encoding, as when using an external encoder via <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>.</para>
            <para>By default, the encoder DSP has a priority setting of -1000, which determines where in the DSP chain the encoding is performed. That can be changed using the BASS_CONFIG_ENCODE_PRIORITY config option (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>).</para>
            <para>Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> function. Both methods can be used together, but in general, the "automatic" system ought be paused when using the "manual" system, by use of the BASS_ENCODE_PAUSE flag or the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)"/> function.</para>
            <para>When done encoding, use <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> to close the encoder.</para>
            <para>Multiple encoders can be set on a channel. For simplicity, the encoder functions will accept either an encoder handle or a channel handle. When using a channel handle, the function is applied to all encoders that are set on that channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The codec specified in <paramref name="form"/> couldn't be initialized.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>The file couldn't be created.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Setup an ACM encoder with a callback to process the encoded data:
            <code>
            ACMFORMAT codec = BassEnc.BASS_Encode_GetACMFormat(channel, "Select your encoder", 
                                      BASSACMFormat.BASS_ACM_DEFAULT, WAVEFormatTag.WAVE_FORMAT_UNKNOWN);
            if ( codec != null )
            {
              // begin encoding
              int encHandle = BassEnc.BASS_Encode_StartACMFile( channel, codec, 
                                      BASSEncode.BASS_ENCODE_DEFAULT, "output.wav" );
            }
            </code>
            <code lang="vbnet">
            Dim codec As ACMFORMAT = BassEnc.BASS_Encode_GetACMFormat(channel, "Select your encoder", 
                                             BASSACMFormat.BASS_ACM_DEFAULT, WAVEFormatTag.WAVE_FORMAT_UNKNOWN)
            If Not (codec Is Nothing) Then
              ' begin encoding
              Dim encHandle As Integer = BassEnc.BASS_Encode_StartACMFile(channel, codec, 
                                                 BASSEncode.BASS_ENCODE_DEFAULT, "output.wav")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)">
            <summary>
            Sets a callback function on an encoder (or all encoders on a channel) to receive notifications about its status.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="proc">Callback function to receive the notifications... NULL = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>When setting a notification callback on a channel, it only applies to the encoders that are currently set on the channel. Subsequent encoders will not automatically have the notification callback set on them, this function will have to be called again to set them up.</para>
            <para>An encoder can only have one notification callback set. Subsequent calls of this function can be used to change the callback function, or disable notifications (proc = NULL).</para>
            <para>The status of an encoder and its cast connection (if it has one) is checked when data is sent to the encoder or server, and by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/>. That means an encoder's death will not be detected automatically, and so no notification given, while no data is being encoded.</para>
            <para>If the encoder is already dead when setting up a notification callback, the callback will be triggered immediately.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Using the callback with a recording caster:
            <code>
            private ENCODENOTIFYPROC _myEndoderNotify;
            private int _encoder = 0;
            private int _recChan = 0;
            private bool _autoreconnect = true;
            ...
            _recChan = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, 20, null, IntPtr.Zero);
            Start();
            ...
            private void Start()
            {
              // start an encoder
              _encoder = BassEnc.BASS_Encode_Start(_recChan, "lame -r -x -s 44100 -b 128 -", 
                                 BASSEncode.BASS_ENCODE_NOHEAD, null, IntPtr.Zero);
              _myEndoderNotify = new ENCODENOTIFYPROC(EncoderNotify);
              // start a caster
              BassEnc.BASS_Encode_CastInit(_encoder, "server.com:8000", "password", 
                      BassEnc.BASS_ENCODE_TYPE_MP3, "name", "url", "genre", null, null, 128, true);
              // notify on dead encoder/connection 
              BassEnc.BASS_Encode_SetNotify(_encoder, _myEndoderNotify, IntPtr.Zero);
            }
            
            private void Stop()
            {
              if (_encoder != 0)
              {
                BassEnc.BASS_Encode_SetNotify(_encoder, null, IntPtr.Zero);
                BassEnc.BASS_Encode_Stop(_encoder);
                _encoder = 0;
              }
            }
            
            private void EncoderNotify(int handle, int status, IntPtr user)
            {
              // encoder/connection lost
              Stop();
              if (_autoreconnect)
              {
                // do auto-reconnect...
                Thread.Sleep(1000); // wait a sec
                Start();
              } 
            }
            </code>
            <code lang="vbnet">
            Private _myEndoderNotify As ENCODENOTIFYPROC
            Private _encoder As Integer = 0
            Private _recChan As Integer = 0
            Private _autoreconnect As Boolean = True
            ...
            _recChan = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, 20, Nothing, IntPtr.Zero)
            Start()
            ...
            Private Sub Start()
              ' start an encoder
              _encoder = BassEnc.BASS_Encode_Start(_recChan, "lame -r -x -s 44100 -b 128 -", 
                                 BASSEncode.BASS_ENCODE_NOHEAD, Nothing, IntPtr.Zero)
              _myEndoderNotify = New ENCODENOTIFYPROC(AddressOf EncoderNotify)
              ' start a caster
              BassEnc.BASS_Encode_CastInit(_encoder, "server.com:8000", "password", 
                      Bass.BASS_ENCODE_TYPE_MP3, "name", "url", "genre", Nothing, Nothing, 128, True)
              ' notify on dead encoder/connection 
              BassEnc.BASS_Encode_SetNotify(_encoder, _myEndoderNotify, IntPtr.Zero)
            End Sub
            
            Private Sub Stop()
              If _encoder &lt;&gt; 0 Then
                BassEnc.BASS_Encode_SetNotify(_encoder, Nothing, IntPtr.Zero)
                BassEnc.BASS_Encode_Stop(_encoder)
                _encoder = 0
              End If
            End Sub
            
            Private Sub EncoderNotify(handle As Integer, status As Integer, user As IntPtr)
              ' encoder/connection lost
              Stop()
              If _autoreconnect Then
                ' do auto-reconnect...
                Thread.Sleep(1000) ' wait a sec
                Start()
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetChannel(System.Int32,System.Int32)">
            <summary>
            Moves an encoder (or all encoders on a channel) to another channel.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="channel">The channel to move the encoder(s) to... a HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The new channel must have the same sample format (rate, channels, resolution) as the old channel, as that is what the encoder is expecting. 
            A channel's sample format is available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> or <paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The new channel's sample format is not the same as the old channel's.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetChannel(System.Int32)">
            <summary>
            Retrieves the channel that an encoder is set on.
            </summary>
            <param name="handle">The encoder to get the channel from.</param>
            <returns>If successful, the encoder's channel handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Initializes sending an encoder's output to a Shoutcast or Icecast server.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="server">The server to send to, in the form of "address:port" (Shoutcast) or "address:port/mount" (Icecast).</param>
            <param name="pass">The server password.</param>
            <param name="content">The MIME type of the encoder output. This can be one of the following:
            <para><see cref="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_ENCODE_TYPE_MP3"/>, <see cref="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_ENCODE_TYPE_OGG"/> or <see cref="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_ENCODE_TYPE_AAC"/>.</para>
            </param>
            <param name="name">The stream name... NULL = no name.</param>
            <param name="url">The URL, for example, of the radio station's webpage... NULL = no URL.</param>
            <param name="genre">The genre... NULL = no genre.</param>
            <param name="desc">Description... NULL = no description. This applies to Icecast only.</param>
            <param name="headers">Other headers to send to the server... NULL = none. Each header should end with a carriage return and line feed ("\r\n").</param>
            <param name="bitrate">The bitrate (in kbps) of the encoder output... 0 = undefined bitrate. In cases where the bitrate is a "quality" (rather than CBR) setting, the headers parameter can be used to communicate that instead, eg. "ice-bitrate: Quality 0\r\n".</param>
            <param name="pub">Public? If TRUE, the stream is added to the public directory of streams, at shoutcast.com or dir.xiph.org (or as defined in the server config).</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>BASSenc performs the role of source client, feeding stream data to a server, and is not itself a server that listeners can connect to. A Shoutcast/Icecast server is needed for BASSenc and the listeners to connect to. The Shoutcast and Icecast server software is available from www.shoutcast.com/download/serve.phtml and www.icecast.org/download.php, respectively.</para>
            <para>An encoder needs to be started (but with no data sent to it yet) before using this function to setup the sending of the encoder's output to a Shoutcast or Icecast server. 
            The encoder should be setup to write its output to STDOUT. Due to the length restrictions of WAVE headers/files, the encoder should also be started with the BASS_ENCODE_NOHEAD flag, and the sample format details sent via the command-line.</para>
            <para>BASSenc automatically restricts the rate that data is sent to the server, so it is safe to simply try to process data as quickly as possible, eg. when using decoding channels.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>There is already a cast set on the encoder.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="server"/> doesn't include a port number.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>Couldn't connect to the server.</description></item>
            <item><term>BASS_ERROR_CAST_DENIED</term><description><paramref name="pass"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Start encoding a stereo 44100hz channel to 128kb/s MP3, and send the output to a Shoutcast server:
            <code>
            // setup the encoder
            int encoder = BassEnc.BASS_Encode_Start(channel, "lame -r -x -s 44100 -b 128 -", 
                                  BASS_ENCODE_NOHEAD, null, 0);
            // setup the encoder
            BassEnc.BASS_Encode_CastInit(encoder, "server.com:8000", "password", BassEnc.BASS_ENCODE_TYPE_MP3, 
                                         "name", "url", "genre", null, null, 128, true);
            </code>
            <code lang="vbnet">
            ' setup the encoder
            Dim encoder As Integer = BassEnc.BASS_Encode_Start(channel, "lame -r -x -s 44100 -b 128 -", 
                                             BASS_ENCODE_NOHEAD, Nothing, 0)
            ' setup the encoder
            BassEnc.BASS_Encode_CastInit(encoder, "server.com:8000", "password", BassEnc.BASS_ENCODE_TYPE_MP3, 
                                         "name", "url", "genre", Nothing, Nothing, 128, True)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastSetTitle(System.Int32,System.String,System.String)">
            <summary>
            Sets the title of a cast stream.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="title">The title to set.</param>
            <param name="url">URL to go with the title... NULL = no URL. This applies to Shoutcast only.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            The encoder needs to have been setup to write its output to STDOUT. Due to the length restrictions of WAVE headers/files, the encoder should also have been started with the BASS_ENCODE_NOHEAD flag and the sample format details sent via the command-line.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There isn't a cast set on the encoder.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastGetStatsPtr(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeStats,System.String)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="type"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastGetStats(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeStats,System.String)">
            <summary>
            Retrieves stats from the Shoutcast or Icecast server.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="type">The type of stats to retrieve. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncodeStats"/>):
            <list type="table">
            <item><term>BASS_ENCODE_STATS_SHOUT</term><description>Shoutcast stats, including listener information and additional server information.</description></item>
            <item><term>BASS_ENCODE_STATS_ICE</term><description>Icecast mount-point listener information.</description></item>
            <item><term>BASS_ENCODE_STATS_ICESERV</term><description>Icecast server stats, including information on all mount points on the server.</description></item>
            </list>
            </param>
            <param name="pass">Password when retrieving Icecast server stats... NULL = use the password provided in the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/> call.</param>
            <returns>If successful, TRUE is returned, else FALSE is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The stats are returned in XML format.
            <para>Each encoder has a single stats buffer, which is reused by each call of this function for the encoder. 
            So if the data needs to be retained across multiple calls, it should be copied to another buffer.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There isn't a cast set on the encoder.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>Get the number of listeners for SHOUTcast:
            <code>
            string stats = BassEnc.BASS_Encode_CastGetStats(encoder, 
                                   BASSEncodeStats.BASS_ENCODE_STATS_SHOUT, password);
            if (stats != null)
            {
              int start = stats.IndexOf( "&lt;CURRENTLISTENERS&gt;" );
              int end = stats.IndexOf( "&lt;/CURRENTLISTENERS&gt;" );
              if (start &gt; 0 &amp;&amp; end &gt; 0)
              {
                start += 18;
                count = int.Parse( stats.Substring(start, end-start) );
              }
            }
            </code>
            <code lang="vbnet">
            Dim stats As String = BassEnc.BASS_Encode_CastGetStats(encoder, 
                                          BASSEncodeStats.BASS_ENCODE_STATS_SHOUT, password)
            If Not (stats Is Nothing) Then
              Dim start As Integer = stats.IndexOf("&lt;CURRENTLISTENERS&gt;")
              Dim [end] As Integer = stats.IndexOf("&lt;/CURRENTLISTENERS&gt;")
              If start &gt; 0 AndAlso end &gt; 0 Then
                start += 18
                count = Integer.Parse(stats.Substring(start, end - start))
              End If
            End If
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_ENCODE_TYPE_MP3">
            <summary>
            <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/> content MIME type for MP3
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_ENCODE_TYPE_OGG">
            <summary>
            <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/> content MIME type for OGG
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_ENCODE_TYPE_AAC">
            <summary>
            <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/> content MIME type for AAC
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.LoadMe">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSenc from the application's startup path:
            <code>
            Bass.LoadMe();
            BassEnc.LoadMe();
            ...
            // when not used anymore...
            BassEnc.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.LoadMe(System.String)">
            <summary>
            Loads this library into memory. The library will be search in the current application directory.
            </summary>
            <returns>TRUE, if the module could be loaded successfully, else FALSE.</returns>
            <remarks>This method can be used to make sure, that this specific library has been loaded.
            <para>Normally an external library will be loaded into memory when either of the declared methods will be called for the very first time.
            This results in the very first call to a library method being slower than all subsequent calls.</para>
            <para>Moreover some of the BASS libraries and add-ons will introduce new options to the main BASS lib, e.g. new parameters which can be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.
            But in order to enable BASS using these new options the respective library must have been already loaded. This method can be used to ensure this.</para>
            <para>This method can also be used as an alternative way to load a library instead of using the BASS way via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.
            The advantage of this is method here is, that you might locate all your bass dll's in a different directory.</para>
            </remarks>
            <example>
            Load BASS and BASSenc from a different directory:
            <code>
            Bass.LoadMe( @"C:\Development\BASS\_libs" );
            BassEnc.LoadMe( @"C:\Development\BASS\_libs" );
            ...
            // when not used anymore...
            BassEnc.FreeMe();
            Bass.FreeMe();
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.FreeMe">
            <summary>
            Unloads this library. This must be called when you have previously called <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.LoadMe"/>.
            </summary>
            <returns>TRUE, if the module has been unloaded successfully, else FALSE.</returns>
            <remarks>For more information see <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.LoadMe"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BASSEncode">
            <summary>
            BASS Encode Start flags for use with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_DEFAULT">
            <summary>
            default option, incl. wave header, little-endian and no FP conversion
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_NOHEAD">
            <summary>
            do NOT send a WAV header to the encoder
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_FP_8BIT">
            <summary>
            convert floating-point sample data to 8-bit integer
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_FP_16BIT">
            <summary>
            convert floating-point sample data to 16-bit integer
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_FP_24BIT">
            <summary>
            convert floating-point sample data to 24-bit integer
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_FP_32BIT">
            <summary>
            convert floating-point sample data to 32-bit integer
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_BIGEND">
            <summary>
            big-endian sample data
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_PAUSE">
            <summary>
            Start the encoder paused
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_PCM">
            <summary>
            write PCM sample data (no encoder)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_AUTOFREE">
            <summary>
            Free the encoder when the channel is freed
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_UNICODE">
            <summary>
            cmdline is a Unicode (16-bit characters)
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BASSACMFormat">
            <summary>
            ACM Format flags to be used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSACMFormat.BASS_ACM_NONE">
            <summary>
            No ACM.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSACMFormat.BASS_ACM_DEFAULT">
            <summary>
            Use the format as default selection.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSACMFormat.BASS_ACM_RATE">
            <summary>
            Only list formats with same sample rate as the source channel.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSACMFormat.BASS_ACM_CHANS">
            <summary>
            Only list formats with same number of channels (eg. mono/stereo).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSACMFormat.BASS_ACM_SUGGEST">
            <summary>
            Suggest a format (HIWORD=format tag - use one of the <see cref="T:Un4seen.Bass.AddOn.Enc.WAVEFormatTag"/> flags).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSACMFormat.BASS_UNICODE">
            <summary>
            Unicode (16-bit characters) option.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.WAVEFormatTag">
            <summary>
            Defines possible wave formats to be used with the <see cref="F:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX.wFormatTag"/> flag.
            </summary>
            <remarks>See the MMREG.H file for more codec numbers.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_UNKNOWN">
            <summary>
            Unknown Format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_PCM">
            <summary>
            PCM format (8 or 16 bit), Microsoft Corporation
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_ADPCM">
            <summary>
            AD PCM Format, Microsoft Corporation
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_IEEE_FLOAT">
            <summary>
            IEEE PCM Float format (32 bit)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_DOLBY_AC2">
            <summary>
            AC2, Dolby Laboratories
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_GSM610">
            <summary>
            GSM 6.10, Microsoft Corporation
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_MSNAUDIO">
            <summary>
            MSN Audio, Microsoft Corporation
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_MPEG">
            <summary>
            MPEG format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_MPEGLAYER3">
            <summary>
            ISO/MPEG Layer3 Format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_DOLBY_AC3_SPDIF">
            <summary>
            AC3 Digital, Sonic Foundry
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_WMA">
            <summary>
            Windows Media Audio. This format is valid for versions 2 through 9
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_WMA_PRO">
            <summary>
            Windows Media Audio 9 Professional
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_WMA_LOSSLESS">
            <summary>
            Windows Media Audio 9 Lossless
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFormatTag.WAVE_FORMAT_EXTENSIBLE">
            <summary>
            Extensible Format (user defined)
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify">
            <summary>
            To be used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/> to receive notifications on an encoder's status.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify.BASS_ENCODE_NOTIFY_ENCODER">
            <summary>
            Encoder died
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify.BASS_ENCODE_NOTIFY_CAST">
            <summary>
            Cast server connection died
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify.BASS_ENCODE_NOTIFY_CAST_TIMEOUT">
            <summary>
            Cast timeout
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BASSEncodeCount">
            <summary>
            To be used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetCount(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeCount)"/> to define the type of count you want to get.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeCount.BASS_ENCODE_COUNT_IN">
            <summary>
            Get the bytes sent to the encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeCount.BASS_ENCODE_COUNT_OUT">
            <summary>
            Get the bytes received from the encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeCount.BASS_ENCODE_COUNT_CAST">
            <summary>
            Get the bytes sent to the cast server.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BASSEncodeStats">
            <summary>
            To be used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastGetStats(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeStats,System.String)"/> to define the type of stats you want to get.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeStats.BASS_ENCODE_STATS_SHOUT">
            <summary>
            Shoutcast stats
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeStats.BASS_ENCODE_STATS_ICE">
            <summary>
            Icecast mount-point stats
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeStats.BASS_ENCODE_STATS_ICESERV">
            <summary>
            Icecast server stats
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX">
            <summary>
            The WAVEFORMATEX structure defines the format of waveform-audio data. 
            Only format information common to all waveform-audio data formats is included in this structure. 
            For formats that require additional information, this structure is included as the first member in another structure, along with the additional information.
            See <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> for details.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX.wFormatTag">
            <summary>
            Waveform-audio format type (see <see cref="T:Un4seen.Bass.AddOn.Enc.WAVEFormatTag"/>). Format tags are registered with Microsoft Corporation for many compression algorithms.
            A complete list of format tags can be found in the Mmreg.h header file. 
            For one- or two-channel PCM data, this value should be WAVE_FORMAT_PCM.
            <para>Default = 1 (WAVE_FORMAT_PCM)</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX.nChannels">
            <summary>
            Number of channels in the waveform-audio data. Monaural data uses one
            channel and stereo data uses two channels.
            <para>Default = 2</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX.nSamplesPerSec">
            <summary>
            Sample rate, in samples per second (hertz), that each channel should
            be played or recorded. If wFormatTag is WAVE_FORMAT_PCM, then common
            values for nSamplesPerSec are 8.0 kHz, 11.025 kHz, 22.05 kHz, and
            44.1 kHz. For non-PCM formats, this member must be computed according
            to the manufacturer's specification of the format tag.
            <para>Default = 44100</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX.nAvgBytesPerSec">
            <summary>
            In most cases, this member contains the required average data-transfer rate, 
            in bytes per second, for the format tag. If wFormatTag is WAVE_FORMAT_PCM, 
            nAvgBytesPerSec should be equal to the product of nSamplesPerSec and nBlockAlign. 
            For non-PCM formats, this member must be computed according to the manufacturer's 
            specification of the format tag. 
            When the Windows Media Audio 9 Codec is in quality-based variable-bit-rate mode, 
            the high-order bytes of this member are set to 0x7fffff and the low-order byte is set to a value 
            from one through 100 which indicates the quality level.
            <para>Typical Calculation: nSamplesPerSec * nBlockAlign</para>
            <para>Default = 176400</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX.nBlockAlign">
            <summary>
            Block alignment, in bytes. The block alignment is the minimum atomic unit
            of data for the wFormatTag format type. If wFormatTag is WAVE_FORMAT_PCM,
            nBlockAlign should be equal to the product of nChannels and wBitsPerSample
            divided by 8 (bits per byte). For non-PCM formats, this member must be
            computed according to the manufacturer's specification of the format tag. 
            Playback and record software must process a multiple of nBlockAlign bytes
            of data at a time. Data written and read from a device must always start
            at the beginning of a block. For example, it is illegal to start playback
            of PCM data in the middle of a sample (that is, on a non-block-aligned boundary).
            <para>Typical Calculation: nChannels * (wBitsPerSample / 8)</para>
            <para>Default = 4</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX.wBitsPerSample">
            <summary>
            Bits per sample for the wFormatTag format type. If wFormatTag is
            WAVE_FORMAT_PCM, then wBitsPerSample should be equal to 8, 16 or 32. For
            non-PCM formats, this member must be set according to the manufacturer's
            specification of the format tag. Some compression schemes cannot define
            a value for wBitsPerSample, so this member can be zero.
            <para>Default = 16</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX.cbSize">
            <summary>
            Size, in bytes, of extra format information appended to the end of the WAVEFORMATEX structure. 
            This information can be used by non-PCM formats to store extra attributes for the wFormatTag. 
            If no extra information is required by the wFormatTag, this member must be set to zero. 
            For WAVE_FORMAT_PCM formats (and only WAVE_FORMAT_PCM formats), this member is ignored.
            <para>Default = 0</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX.#ctor(Un4seen.Bass.AddOn.Enc.WAVEFormatTag,System.Int16,System.Int32,System.Int16,System.Int16)">
            <summary>
            Creates an instance setting the members to certain values.
            </summary>
            <param name="format">Waveform-audio format type (see <see cref="T:Un4seen.Bass.AddOn.Enc.WAVEFormatTag"/>).</param>
            <param name="channels">Number of channels in the waveform-audio data.</param>
            <param name="samplesPerSec">Sample rate, in samples per second (hertz), that each channel should be played or recorded.</param>
            <param name="bitsPerSample">Bits per sample for the wFormatTag format type (e.g. 8, 16 or 32).</param>
            <param name="exSize">Size, in bytes, of extra format information appended to the end of the WAVEFORMATEX structure.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX.ToString">
            <summary>
            Returns a description string for the instance members.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT">
            <summary>
            The ACMFORMAT is a specialized and generic format structure. It contains the WAVEFORMATEX structure and define the format of any ACM audio data. 
            Only format information common to all ACM audio data formats are included in this structure. 
            For formats that require additional information, this structure has an additional byte[] keeping the additional information.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.ACMFORMAT.waveformatex">
            <summary>
            The <see cref="T:Un4seen.Bass.AddOn.Enc.WAVEFORMATEX"/> structure that specifies the basic format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.ACMFORMAT.extension">
            <summary>
            Extra format information is appended to the end of the WAVEFORMATEX structure in this array. 
            This information can be used by non-PCM formats to store extra attributes for the wFormatTag. 
            If no extra information is required by the wFormatTag, this member should be set to zero. 
            For WAVE_FORMAT_PCM formats (and only WAVE_FORMAT_PCM formats), this member is ignored.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.ACMFORMAT.#ctor">
            <summary>
            Creates an instance of a generic audio codec format and automatically determines the suggested format buffer length.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.ACMFORMAT.#ctor(System.Int32)">
            <summary>
            Creates an instance of a generic audio codec format with a given total length.
            </summary>
            <param name="length">The total lenght of the format structure (e.g. as returned by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/> when using 0 for the formlen parameter).</param>
            <example>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.ACMFORMAT.#ctor(System.IntPtr)">
            <summary>
            Creates an instance of a generic audio codec format from the given format buffer pointer.
            </summary>
            <param name="codec">A pointer to an ACM codec format structure as returned by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/>.</param>
            <example>
            <code>
            ACMFORMAT codec = null;
            // get the maximum codec format length
            int formlen = BASS_Encode_GetACMFormatUnicode(0, IntPtr.Zero, 0, null, BASSACMFormat.BASS_ACM_NONE);
            byte[] buffer = new byte[formlen];
            GCHandle hGC = GCHandle.Alloc( buffer, GCHandleType.Pinned );
            try
            {
              IntPtr codecPtr = hGC.AddrOfPinnedObject();
              if ( BassEnc.BASS_Encode_GetACMFormat( handle, codecPtr, formlen, title, flags) &gt; 0 )
              {
                codec = new ACMFORMAT(codecPtr);
              }
            }
            catch { codec = null; }
            finally
            {
              hGC.Free();
            }
            </code>
            <code lang="vbnet">
            Dim codec As ACMFORMAT = Nothing
            ' get the maximum codec format length
            Dim formlen As Integer = BASS_Encode_GetACMFormatUnicode(0, IntPtr.Zero, 0, Nothing, BASSACMFormat.BASS_ACM_NONE)
            Dim buffer(formlen) As Byte
            Dim hGC As GCHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned)
            Try
              Dim codecPtr As IntPtr = hGC.AddrOfPinnedObject()
              If BassEnc.BASS_Encode_GetACMFormat(handle, codecPtr, formlen, title, flags) &gt; 0 Then
                codec = New ACMFORMAT(codecPtr)
              End If
            Catch
              codec = Nothing
            Finally
              hGC.Free()
            End Try
            </code>
            If you are into C# you might also use native pointers in an unsafe codeblock:
            <code>
            ACMFORMAT codec = null;
            // get the maximum codec format length
            int formlen = BASS_Encode_GetACMFormatUnicode(0, IntPtr.Zero, 0, null, BASSACMFormat.BASS_ACM_NONE);
            byte[] buffer = new byte[formlen];
            unsafe
            {
              fixed (byte* p = buffer)
              {
                if ( BassEnc.BASS_Encode_GetACMFormat( handle, (IntPtr)p, formlen, title, flags) &gt; 0 )
                {
                  codec = new ACMFORMAT((IntPtr)p);
                }
              }
            }
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.ACMFORMAT.ToString">
            <summary>
            Returns a description string for the instance members.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.ACMFORMAT.SaveToFile(Un4seen.Bass.AddOn.Enc.ACMFORMAT,System.String)">
            <summary>
            Saves <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> codec format data to a file name.
            </summary>
            <param name="form">The <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> as returned by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/>.</param>
            <param name="fileName">The file name to save the ACM codec format data to.</param>
            <returns>TRUE on success, else FALSE.</returns>
            <remarks>Use <see cref="M:Un4seen.Bass.AddOn.Enc.ACMFORMAT.LoadFromFile(System.String)"/> to (re)create an instance of an <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> codec format.
            <para>This method might be usefull together with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/>, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACM(System.Int32,Un4seen.Bass.AddOn.Enc.ACMFORMAT,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACMFile(System.Int32,System.IntPtr,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)"/>
            in order to load and save predefined codec'.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.ACMFORMAT.LoadFromFile(System.String)">
            <summary>
            Loads <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> codec format data from a file.
            </summary>
            <param name="fileName">The file name from where to load the ACM codec format data.</param>
            <returns>On success an instance of <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> is returned, else NULL is returned.</returns>
            <remarks>Use <see cref="M:Un4seen.Bass.AddOn.Enc.ACMFORMAT.SaveToFile(Un4seen.Bass.AddOn.Enc.ACMFORMAT,System.String)"/> to write the instance data of an <see cref="T:Un4seen.Bass.AddOn.Enc.ACMFORMAT"/> codec format to a file.
            <para>This method might be usefull together with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetACMFormat(System.Int32,System.IntPtr,System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSACMFormat)"/>, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACM(System.Int32,Un4seen.Bass.AddOn.Enc.ACMFORMAT,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartACMFile(System.Int32,System.IntPtr,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)"/>
            in order to load and save predefined codec's.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Enc.ACMFORMAT.FormatLength">
            <summary>
            Returns the total length of this instance.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC">
            <summary>
            User defined callback function to process (receive) encoded sample data.
            </summary>
            <param name="handle">The encoder that the data is from (as returned by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>).</param>
            <param name="channel">The channel that the data is from.</param>
            <param name="buffer">The pointer to the buffer containing the encoded data.</param>
            <param name="length">The number of bytes in the buffer.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>To have the encoded data received by this callback function, the encoder needs to be told to output to STDOUT (instead of a file).</para>
            <para>
            It is clever to NOT alloc any buffer data (e.g. a byte[]) everytime within the callback method, since ALL callbacks should be really fast!
            And if you would do a 'byte[] data = new byte[]' every time here...the GarbageCollector would never really clean up that memory.
            Sideeffects might occure, due to the fact, that BASS will call this callback too fast and too often...
            </para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            <code>
            // the encoding callback
            private ENCODEPROC _myEndoderProc;
            private byte[] _encbuffer = new byte[1048510]; // 1MB buffer
            ...
            _myEndoderProc = new ENCODEPROC(MyEncodingWriter);
            // create the encoder (with default setting for lame)
            BassEnc.BASS_Encode_Start(channel, "lame --alt-preset standard", 
                    BASSEncode.BASS_ENCODE_DEFAULT, _myEndoderProc, IntPtr.Zero);
            Bass.BASS_ChannelPlay(channel, false); // start the channel playing &amp; encoding 
            ...
            private bool MyEncodingWriter(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
            	// copy from managed to unmanaged memory
            	Marshal.Copy(buffer, _encbuffer, 0, length);
            	// process the data in _encbuffer, e.g. write to disk or whatever
            	...
            }
            </code>
            <code lang="vbnet">
            Private _myEndoderProc As ENCODEPROC
            Private _encbuffer(1048510) As Byte ' 1MB buffer
            ...
            _myEndoderProc = New ENCODEPROC(AddressOf MyEncodingWriter)
            ' create the encoder (with default setting for lame)
            BassEnc.BASS_Encode_Start(channel, "lame --alt-preset standard", 
                    BASSEncode.BASS_ENCODE_DEFAULT, _myEndoderProc, IntPtr.Zero)
            Bass.BASS_ChannelPlay(channel, False)
            ' start the channel playing &amp; encoding 
            Private Function MyEncodingWriter(handle As Integer, channel As Integer, 
                                              buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              ' copy from managed to unmanaged memory
              Marshal.Copy(buffer, _encbuffer, 0, length)
              ' process the data in _encbuffer, e.g. write to disk or whatever
              ...
            End Function
            </code>
            If you are into C# you might also use native pointer access in an unsafe code block:
            <code>
            // assuming you have created a: BinaryWriter bw = new BinaryWriter(_fs);
            private unsafe bool MyEncodingWriter(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
            	byte *data = (byte*)buffer;
            	// process the data in 'data', e.g. write to disk or whatever
            	for (int a=0; a&lt;length; a++)
                {
                  // write the received sample data to a local file
                  bw.Write( data[a] );
                }
            }
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC">
            <summary>
            User defined callback function to receive notifications on an encoder's status.
            </summary>
            <param name="handle">The encoder that the notification is from (as returned by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/>).</param>
            <param name="status">The encoder's status, one of the following (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify"/>):
            <para>BASS_ENCODE_NOTIFY_ENCODER : The encoder died.</para>
            <para>BASS_ENCODE_NOTIFY_CAST : Cast server connection died.</para>
            <para>BASS_ENCODE_NOTIFY_CAST_TIMEOUT : Cast data sending timeout. The connection is not dead at this point, it may just be a temporary problem.</para>
            </param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>When setting a notification callback on a channel, it only applies to the encoders that are currently set on the channel. Subsequent encoders will not automatically have the notification callback set on them, this function will have to be called again to set them up.</para>
            <para>An encoder can only have one notification callback set. Subsequent calls of this function can be used to change the callback function, or disable notifications (proc = NULL).</para>
            <para>If the encoder is already dead when setting up a notification callback, the callback will be triggered immediately.</para>
            <para>It is safe to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> to free an encoder from within a notification callback.</para>
            </remarks>
            <example>
            Using the callback with a recording caster:
            <code>
            private ENCODENOTIFYPROC _myEndoderNotify;
            private int _encoder = 0;
            private int _recChan = 0;
            private bool _autoreconnect = true;
            ...
            _recChan = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, 20, null, IntPtr.Zero);
            Start();
            ...
            private void Start()
            {
              // start an encoder
              _encoder = BassEnc.BASS_Encode_Start(_recChan, "lame -r -x -s 44100 -b 128 -", 
                                 BASSEncode.BASS_ENCODE_NOHEAD, null, IntPtr.Zero);
              _myEndoderNotify = new ENCODENOTIFYPROC(EncoderNotify);
              // start a caster
              BassEnc.BASS_Encode_CastInit(_encoder, "server.com:8000", "password", 
                      BassEnc.BASS_ENCODE_TYPE_MP3, "name", "url", "genre", null, null, 128, true);
              // notify on dead encoder/connection 
              BassEnc.BASS_Encode_SetNotify(_encoder, _myEndoderNotify, IntPtr.Zero);
            }
            
            private void Stop()
            {
              if (_encoder != 0)
              {
                BassEnc.BASS_Encode_SetNotify(_encoder, null, IntPtr.Zero);
                BassEnc.BASS_Encode_Stop(_encoder);
                _encoder = 0;
              }
            }
            
            private void EncoderNotify(int handle, BASSEncodeNotify status, IntPtr user)
            {
              // encoder/connection lost
              Stop();
              if (_autoreconnect)
              {
                // do auto-reconnect...
                Thread.Sleep(1000); // wait a sec
                Start();
              } 
            }
            </code>
            <code lang="vbnet">
            Private _myEndoderNotify As ENCODENOTIFYPROC
            Private _encoder As Integer = 0
            Private _recChan As Integer = 0
            Private _autoreconnect As Boolean = True
            ...
            _recChan = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, 20, Nothing, IntPtr.Zero)
            Start()
            ...
            Private Sub Start()
              ' start an encoder
              _encoder = BassEnc.BASS_Encode_Start(_recChan, "lame -r -x -s 44100 -b 128 -", 
                                 BASSEncode.BASS_ENCODE_NOHEAD, Nothing, IntPtr.Zero)
              _myEndoderNotify = New ENCODENOTIFYPROC(AddressOf EncoderNotify)
              ' start a caster
              BassEnc.BASS_Encode_CastInit(_encoder, "server.com:8000", "password", 
                      Bass.BASS_ENCODE_TYPE_MP3, "name", "url", "genre", Nothing, Nothing, 128, True)
              ' notify on dead encoder/connection 
              BassEnc.BASS_Encode_SetNotify(_encoder, _myEndoderNotify, IntPtr.Zero)
            End Sub
            
            Private Sub Stop()
              If _encoder &lt;&gt; 0 Then
                BassEnc.BASS_Encode_SetNotify(_encoder, Nothing, IntPtr.Zero)
                BassEnc.BASS_Encode_Stop(_encoder)
                _encoder = 0
              End If
            End Sub
            
            Private Sub EncoderNotify(handle As Integer, status As BASSEncodeNotify, user As IntPtr)
              ' encoder/connection lost
              Stop()
              If _autoreconnect Then
                ' do auto-reconnect...
                Thread.Sleep(1000) ' wait a sec
                Start()
              End If
            End Sub
            </code>
            </example>
        </member>
    </members>
</doc>
